import { secp256k1 as b, schnorr as Y } from "@noble/curves/secp256k1";
import { sha256 as K } from "@noble/hashes/sha2";
import { bytesToHex as q, randomBytes as Ot, hexToBytes as O, numberToBytesBE as Le } from "@noble/curves/utils";
import { utf8ToBytes as $e, hexToBytes as H, bytesToHex as J, randomBytes as Xt } from "@noble/hashes/utils";
import { HDKey as he } from "@scure/bip32";
import { hmac as We } from "@noble/hashes/hmac";
const ut = {
  UNPAID: "UNPAID",
  PENDING: "PENDING",
  PAID: "PAID"
}, Tt = {
  UNPAID: "UNPAID",
  PAID: "PAID",
  ISSUED: "ISSUED"
};
class ht extends Error {
  constructor(t, e) {
    super(t), this.status = e, this.name = "HttpResponseError", Object.setPrototypeOf(this, ht.prototype);
  }
}
class Kt extends Error {
  constructor(t) {
    super(t), this.name = "NetworkError", Object.setPrototypeOf(this, Kt.prototype);
  }
}
class Dt extends ht {
  constructor(t, e) {
    super(e || "Unknown mint operation error", 400), this.code = t, this.name = "MintOperationError", Object.setPrototypeOf(this, Dt.prototype);
  }
}
const L = {
  error() {
  },
  warn() {
  },
  info() {
  },
  debug() {
  },
  trace() {
  },
  log() {
  }
};
function bt(s, t = L, e) {
  throw t.error(s, e), new Error(s);
}
function le(s, t, e = L, n) {
  s && bt(t, e, n);
}
function de(s, t, e = L, n) {
  s == null && bt(t, e, n);
}
function lt(s, t, e = L, n) {
  if (s)
    try {
      const r = s(t);
      r && typeof r.then == "function" && r.catch((i) => {
        try {
          e.warn("callback failed", {
            ...n ?? {},
            error: i,
            cb: s.name ?? ""
          });
        } catch {
        }
      });
    } catch (r) {
      try {
        e.warn("callback failed", {
          ...n ?? {},
          error: r,
          cb: s.name ?? ""
        });
      } catch {
      }
    }
}
const Yt = {
  error: 0,
  warn: 1,
  info: 2,
  debug: 3,
  trace: 4
};
class gs {
  constructor(t = "info") {
    this.minLevel = t;
  }
  should(t) {
    return Yt[t] <= Yt[this.minLevel];
  }
  method(t) {
    switch (t) {
      case "error":
        return console.error;
      case "warn":
        return console.warn;
      case "info":
        return console.info;
      case "debug":
        return console.debug;
      case "trace":
        return console.trace;
      default:
        return console.log;
    }
  }
  header(t, e) {
    return `[${t.toUpperCase()}] ${e}`;
  }
  flattenContext(t) {
    if (!t) return;
    const e = {};
    for (const [n, r] of Object.entries(t))
      e[n] = r instanceof Error ? { message: r.message, stack: r.stack } : r;
    return e;
  }
  emit(t, e, n) {
    if (!this.should(t)) return;
    const r = this.header(t, e), i = this.flattenContext(n), o = this.method(t);
    i && Object.keys(i).length ? o(r, i) : o(r);
  }
  error(t, e) {
    this.emit("error", t, e);
  }
  warn(t, e) {
    this.emit("warn", t, e);
  }
  info(t, e) {
    this.emit("info", t, e);
  }
  debug(t, e) {
    this.emit("debug", t, e);
  }
  trace(t, e) {
    this.emit("trace", t, e);
  }
  log(t, e, n) {
    this.emit(t, e, n);
  }
}
function He() {
  const s = Date.now();
  return {
    elapsed: () => Date.now() - s
  };
}
let fe = {}, ge = L;
function ps(s) {
  fe = s;
}
function je(s) {
  ge = s;
}
async function Qe({
  endpoint: s,
  requestBody: t,
  headers: e,
  ...n
}) {
  const r = t ? JSON.stringify(t) : void 0, i = {
    Accept: "application/json, text/plain, */*",
    ...r ? { "Content-Type": "application/json" } : void 0,
    ...e
  };
  let o;
  try {
    o = await fetch(s, { body: r, headers: i, ...n });
  } catch (a) {
    throw new Kt(a instanceof Error ? a.message : "Network request failed");
  }
  if (!o.ok) {
    let a;
    try {
      a = await o.json();
    } catch {
      a = { error: "bad response" };
    }
    if (o.status === 400 && "code" in a && typeof a.code == "number" && "detail" in a && typeof a.detail == "string")
      throw new Dt(a.code, a.detail);
    let c = "HTTP request failed";
    throw "error" in a && typeof a.error == "string" ? c = a.error : "detail" in a && typeof a.detail == "string" && (c = a.detail), new ht(c, o.status);
  }
  try {
    return await o.json();
  } catch (a) {
    throw ge.error("Failed to parse HTTP response", { err: a }), new ht("bad response", o.status);
  }
}
async function pe(s) {
  return await Qe({ ...s, ...fe });
}
let pt;
typeof WebSocket < "u" && (pt = WebSocket);
function ms(s) {
  pt = s;
}
function ze() {
  if (pt === void 0)
    throw new Error("WebSocket implementation not initialized");
  return pt;
}
class _ {
  static fromHex(t) {
    if (t = t.trim(), t.length === 0)
      return new Uint8Array(0);
    if (t.length < 2 || t.length & 1)
      throw new Error("Invalid hex string: odd length.");
    if ((t.startsWith("0x") || t.startsWith("0X")) && (t = t.slice(2)), !t.match(/^[0-9a-fA-F]*$/))
      throw new Error("Invalid hex string: contains non-hex characters");
    const n = t.match(/.{1,2}/g);
    if (!n)
      throw new Error("Invalid hex string");
    return new Uint8Array(n.map((r) => parseInt(r, 16)));
  }
  static toHex(t) {
    return Array.from(t, (e) => e.toString(16).padStart(2, "0")).join("");
  }
  static fromString(t) {
    return t = t.trim(), new TextEncoder().encode(t);
  }
  static toString(t) {
    return new TextDecoder("utf-8").decode(t);
  }
  static concat(...t) {
    const e = t.reduce((i, o) => i + o.length, 0), n = new Uint8Array(e);
    let r = 0;
    for (const i of t)
      n.set(i, r), r += i.length;
    return n;
  }
  static alloc(t) {
    return new Uint8Array(t);
  }
  static writeBigUint64BE(t) {
    const e = new ArrayBuffer(8);
    return new DataView(e).setBigUint64(0, t, !1), new Uint8Array(e);
  }
  static toBase64(t) {
    if (typeof Buffer < "u")
      return Buffer.from(t).toString("base64");
    if (t.length > 32768) {
      let e = "";
      for (let n = 0; n < t.length; n += 32768) {
        const r = t.slice(n, n + 32768);
        e += btoa(String.fromCharCode(...r));
      }
      return e;
    }
    return btoa(String.fromCharCode(...t));
  }
  static fromBase64(t) {
    t = t.trim();
    let e = t.replace(/-/g, "+").replace(/_/g, "/");
    for (; e.length % 4; )
      e += "=";
    return typeof Buffer < "u" ? new Uint8Array(Buffer.from(e, "base64")) : new Uint8Array([...atob(e)].map((n) => n.charCodeAt(0)));
  }
  // NOTE: MUST remain a constant-time implementation (full byte check)
  // because callers rely on it (e.g. deriveP2BKSecretKey).
  static equals(t, e) {
    if (t.length !== e.length) return !1;
    let n = 0;
    for (let r = 0; r < t.length; r++)
      n |= t[r] ^ e[r];
    return n === 0;
  }
  static compare(t, e) {
    const n = Math.min(t.length, e.length);
    for (let r = 0; r < n; r++) {
      if (t[r] < e[r]) return -1;
      if (t[r] > e[r]) return 1;
    }
    return t.length - e.length;
  }
}
function It(s) {
  return _.toBase64(s).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
function qt(s) {
  return _.fromBase64(s);
}
function me(s) {
  const t = JSON.stringify(s);
  return Je(_.toBase64(_.fromString(t)));
}
function Ve(s) {
  const t = _.toString(_.fromBase64(Ge(s)));
  return JSON.parse(t);
}
function Ge(s) {
  return s.replace(/-/g, "+").replace(/_/g, "/").split("=")[0];
}
function Je(s) {
  return s.replace(/\+/g, "-").replace(/\//g, "_").split("=")[0];
}
function Ut(s) {
  if (typeof s != "string" || s.length === 0) return !1;
  const t = /^[A-Za-z0-9\-_]+={0,2}$/, e = /^[A-Za-z0-9+/]+={0,2}$/;
  if (!t.test(s) && !e.test(s)) return !1;
  const n = s.replace(/-/g, "+").replace(/_/g, "/"), r = (4 - n.length % 4) % 4;
  if (r > 2) return !1;
  const i = n + "=".repeat(r);
  try {
    const o = _.fromBase64(i), a = _.toBase64(o), c = a.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, ""), u = n.replace(/=+$/, "");
    return a.replace(/=+$/, "") === u || c === u;
  } catch {
    return !1;
  }
}
function Xe(s) {
  return typeof s == "number" || typeof s == "string";
}
function Rt(s) {
  const t = [];
  return Nt(s, t), new Uint8Array(t);
}
function Nt(s, t) {
  if (s === null)
    t.push(246);
  else if (s === void 0)
    t.push(247);
  else if (typeof s == "boolean")
    t.push(s ? 245 : 244);
  else if (typeof s == "number")
    en(s, t);
  else if (typeof s == "string")
    ye(s, t);
  else if (Array.isArray(s))
    sn(s, t);
  else if (s instanceof Uint8Array)
    nn(s, t);
  else if (
    // Defensive: POJO only (null/array handled above)
    typeof s == "object" && s !== null && !Array.isArray(s)
  )
    rn(s, t);
  else
    throw new Error("Unsupported type");
}
function Ye(s, t) {
  if (s < 24)
    t.push(s);
  else if (s < 256)
    t.push(24, s);
  else if (s < 65536)
    t.push(25, s >>> 8 & 255, s & 255);
  else if (s < 4294967296)
    t.push(
      26,
      s >>> 24 & 255,
      s >>> 16 & 255,
      s >>> 8 & 255,
      s & 255
    );
  else
    throw new Error("Unsupported integer size");
}
function Ze(s, t) {
  const e = -1 - s;
  if (e < 24)
    t.push(32 | e);
  else if (e < 256)
    t.push(56, e & 255);
  else if (e < 65536)
    t.push(57, e >>> 8 & 255, e & 255);
  else if (e < 4294967296)
    t.push(
      58,
      e >>> 24 & 255,
      e >>> 16 & 255,
      e >>> 8 & 255,
      e & 255
    );
  else
    throw new Error("Unsupported integer size");
}
function tn(s, t) {
  const e = new ArrayBuffer(8), n = new DataView(e);
  n.setFloat64(0, s, !1), t.push(251);
  for (let r = 0; r < 8; r++) t.push(n.getUint8(r));
}
function en(s, t) {
  Number.isInteger(s) ? s >= 0 ? Ye(s, t) : Ze(s, t) : tn(s, t);
}
function nn(s, t) {
  const e = s.length;
  if (e < 24)
    t.push(64 + e);
  else if (e < 256)
    t.push(88, e);
  else if (e < 65536)
    t.push(89, e >> 8 & 255, e & 255);
  else if (e < 4294967296)
    t.push(
      90,
      e >>> 24 & 255,
      e >>> 16 & 255,
      e >>> 8 & 255,
      e & 255
    );
  else
    throw new Error("Byte string too long to encode");
  for (let n = 0; n < s.length; n++)
    t.push(s[n]);
}
function ye(s, t) {
  const e = new TextEncoder().encode(s), n = e.length;
  if (n < 24)
    t.push(96 + n);
  else if (n < 256)
    t.push(120, n);
  else if (n < 65536)
    t.push(121, n >>> 8 & 255, n & 255);
  else if (n < 4294967296)
    t.push(
      122,
      n >>> 24 & 255,
      n >>> 16 & 255,
      n >>> 8 & 255,
      n & 255
    );
  else
    throw new Error("String too long to encode");
  for (let r = 0; r < e.length; r++)
    t.push(e[r]);
}
function sn(s, t) {
  const e = s.length;
  if (e < 24)
    t.push(128 | e);
  else if (e < 256)
    t.push(152, e);
  else if (e < 65536)
    t.push(153, e >>> 8 & 255, e & 255);
  else
    throw new Error("Unsupported array length");
  for (const n of s)
    Nt(n, t);
}
function rn(s, t) {
  const e = Object.keys(s), n = e.length;
  if (n >= 4294967296)
    throw new Error("Object has too many keys to encode");
  n < 24 ? t.push(160 | n) : n < 256 ? t.push(184, n) : n < 65536 ? t.push(185, n >> 8 & 255, n & 255) : t.push(
    186,
    n >> 24 & 255,
    n >> 16 & 255,
    n >> 8 & 255,
    n & 255
  );
  for (const r of e)
    ye(r, t), Nt(s[r], t);
}
function Ft(s) {
  const t = new DataView(s.buffer, s.byteOffset, s.byteLength);
  return mt(t, 0).value;
}
function mt(s, t) {
  if (t >= s.byteLength)
    throw new Error("Unexpected end of data");
  const e = s.getUint8(t++), n = e >> 5, r = e & 31;
  switch (n) {
    case 0:
      return on(s, t, r);
    case 1:
      return an(s, t, r);
    case 2:
      return cn(s, t, r);
    case 3:
      return un(s, t, r);
    case 4:
      return hn(s, t, r);
    case 5:
      return ln(s, t, r);
    case 7:
      return fn(s, t, r);
    default:
      throw new Error(`Unsupported major type: ${n}`);
  }
}
function V(s, t, e) {
  if (t + e > s.byteLength)
    throw new Error("Unexpected end of data");
}
function ot(s, t, e) {
  if (e < 24) return { value: e, offset: t };
  if (e === 24)
    return V(s, t, 1), { value: s.getUint8(t++), offset: t };
  if (e === 25) {
    V(s, t, 2);
    const n = s.getUint16(t, !1);
    return t += 2, { value: n, offset: t };
  }
  if (e === 26) {
    V(s, t, 4);
    const n = s.getUint32(t, !1);
    return t += 4, { value: n, offset: t };
  }
  if (e === 27) {
    V(s, t, 8);
    const n = s.getUint32(t, !1), r = s.getUint32(t + 4, !1);
    return t += 8, { value: n * 2 ** 32 + r, offset: t };
  }
  throw new Error(`Unsupported length: ${e}`);
}
function on(s, t, e) {
  const { value: n, offset: r } = ot(s, t, e);
  return { value: n, offset: r };
}
function an(s, t, e) {
  const { value: n, offset: r } = ot(s, t, e);
  return { value: -1 - n, offset: r };
}
function cn(s, t, e) {
  const { value: n, offset: r } = ot(s, t, e);
  if (r + n > s.byteLength)
    throw new Error("Byte string length exceeds data length");
  return { value: new Uint8Array(s.buffer, s.byteOffset + r, n), offset: r + n };
}
function un(s, t, e) {
  const { value: n, offset: r } = ot(s, t, e);
  if (r + n > s.byteLength)
    throw new Error("String length exceeds data length");
  const i = new Uint8Array(s.buffer, s.byteOffset + r, n);
  return { value: new TextDecoder().decode(i), offset: r + n };
}
function hn(s, t, e) {
  const { value: n, offset: r } = ot(s, t, e), i = [];
  let o = r;
  for (let a = 0; a < n; a++) {
    const c = mt(s, o);
    i.push(c.value), o = c.offset;
  }
  return { value: i, offset: o };
}
function ln(s, t, e) {
  const { value: n, offset: r } = ot(s, t, e), i = {};
  let o = r;
  for (let a = 0; a < n; a++) {
    const c = mt(s, o);
    if (!Xe(c.value))
      throw new Error("Invalid key type");
    const u = mt(s, c.offset);
    i[c.value] = u.value, o = u.offset;
  }
  return { value: i, offset: o };
}
function dn(s) {
  const t = (s & 31744) >> 10, e = s & 1023, n = s & 32768 ? -1 : 1;
  return t === 0 ? n * 2 ** -14 * (e / 1024) : t === 31 ? e ? NaN : n * (1 / 0) : n * 2 ** (t - 15) * (1 + e / 1024);
}
function fn(s, t, e) {
  if (e < 24)
    switch (e) {
      case 20:
        return { value: !1, offset: t };
      case 21:
        return { value: !0, offset: t };
      case 22:
        return { value: null, offset: t };
      case 23:
        return { value: void 0, offset: t };
      default:
        throw new Error(`Unknown simple value: ${e}`);
    }
  if (e === 24)
    return V(s, t, 1), { value: s.getUint8(t++), offset: t };
  if (e === 25) {
    V(s, t, 2);
    const n = dn(s.getUint16(t, !1));
    return t += 2, { value: n, offset: t };
  }
  if (e === 26) {
    V(s, t, 4);
    const n = s.getFloat32(t, !1);
    return t += 4, { value: n, offset: t };
  }
  if (e === 27) {
    V(s, t, 8);
    const n = s.getFloat64(t, !1);
    return t += 8, { value: n, offset: t };
  }
  throw new Error(`Unknown simple or float value: ${e}`);
}
const Zt = $e("Cashu_P2BK_v1");
function gn(s, t, e) {
  if (!s.length) return { blinded: [], Ehex: "" };
  e = e ?? b.utils.randomSecretKey();
  const n = b.Point.Fn.fromBytes(e), r = b.getPublicKey(e, !0), i = H(t);
  return { blinded: s.map((a, c) => {
    const u = X(a), l = we(u, n, i, c), h = u.add(b.Point.BASE.multiply(l));
    if (h.equals(b.Point.ZERO)) throw new Error("Blinded key at infinity");
    return h.toHex(!0);
  }), Ehex: J(r) };
}
function pn(s, t, e, n) {
  const r = Array.isArray(t) ? t : [t], i = Array.isArray(e) ? e : [e], o = /* @__PURE__ */ new Set(), a = b.Point.fromHex(s), c = H(n);
  for (const u of r) {
    const l = b.Point.Fn.fromBytes(H(u)), h = b.getPublicKey(H(u), !0);
    i.forEach((d, p) => {
      const m = we(a, l, c, p), P = H(d), A = mn(u, m, P, h);
      A && o.add(A);
    });
  }
  return Array.from(o);
}
function mn(s, t, e, n) {
  const r = b.Point.CURVE().n, i = typeof s == "string" ? dt(s) : s, o = typeof t == "string" ? dt(t) : t;
  if (i <= 0n || i >= r) throw new Error("Invalid private key");
  if (o <= 0n || o >= r) throw new Error("Invalid scalar r");
  if (n = n ?? b.Point.BASE.multiply(i).toBytes(!0), n.length !== 33) throw new Error("naturalPub must be 33 bytes");
  const a = (i + o) % r, c = (r - i + o) % r;
  if (!e) {
    if (a === 0n) throw new Error("Derived secret key is zero");
    return Mt(a);
  }
  if (e.length !== 33) throw new Error("blindPubkey must be 33 bytes");
  const u = b.Point.fromHex(e), l = b.Point.BASE.multiply(o), h = u.subtract(l);
  if (h.equals(b.Point.ZERO)) return null;
  const d = h.toBytes(!0).slice(1), p = n.slice(1);
  if (!_.equals(d, p))
    return null;
  const m = h.toBytes(!0)[0] & 1, P = n[0] & 1, A = m === P ? a : c;
  if (A === 0n) throw new Error("Derived secret key is zero");
  return Mt(A);
}
function we(s, t, e, n) {
  const r = s.multiply(t).toBytes(!0).slice(1), i = new Uint8Array([n & 255]);
  let o = $(K(_.concat(Zt, r, e, i)));
  if ((o === 0n || o >= b.Point.CURVE().n) && (o = $(K(_.concat(Zt, r, e, i, new Uint8Array([255])))), o === 0n || o >= b.Point.CURVE().n))
    throw new Error("P2BK: tweak derivation failed");
  return o;
}
const ys = (s) => {
  const t = [
    "P2PK",
    {
      nonce: q(Ot(32)),
      data: s
    }
  ];
  return JSON.stringify(t);
}, Q = (s) => {
  try {
    return s instanceof Uint8Array && (s = new TextDecoder().decode(s)), JSON.parse(s);
  } catch {
    throw new Error("can't parse secret");
  }
}, yn = (s, t) => {
  const e = K(s), n = Y.sign(e, t);
  return q(n);
}, wn = (s, t) => {
  const e = K(s), n = Y.sign(e, t);
  return q(n);
}, Lt = (s, t, e) => {
  try {
    const n = K(t), r = e.length === 66 ? e.slice(2) : e;
    if (Y.verify(s, n, O(r)))
      return !0;
  } catch (n) {
    console.error("verifyP2PKsecret error:", n);
  }
  return !1;
}, ws = (s, t) => t.witness ? Wt(t.witness).some((n) => {
  try {
    return Lt(n, t.secret, s);
  } catch {
    return !1;
  }
}) : !1;
function $t(s) {
  try {
    const t = typeof s == "string" ? Q(s) : s;
    if (t[0] !== "P2PK")
      throw new Error('Invalid P2PK secret: must start with "P2PK"');
    const e = Math.floor(Date.now() / 1e3);
    return _e(t) > e ? ke(t) : be(t);
  } catch {
  }
  return [];
}
function ke(s) {
  const t = typeof s == "string" ? Q(s) : s;
  if (t[0] !== "P2PK")
    throw new Error('Invalid P2PK secret: must start with "P2PK"');
  const { data: e, tags: n } = t[1], r = n && n.find((o) => o[0] === "pubkeys"), i = r && r.length > 1 ? r.slice(1) : [];
  return [e, ...i].filter(Boolean);
}
function be(s) {
  const t = typeof s == "string" ? Q(s) : s;
  if (t[0] !== "P2PK")
    throw new Error('Invalid P2PK secret: must start with "P2PK"');
  const { tags: e } = t[1], n = e && e.find((r) => r[0] === "refund");
  return n && n.length > 1 ? n.slice(1).filter(Boolean) : [];
}
function _e(s) {
  const t = typeof s == "string" ? Q(s) : s;
  if (t[0] !== "P2PK")
    throw new Error('Invalid P2PK secret: must start with "P2PK"');
  const { tags: e } = t[1], n = e && e.find((r) => r[0] === "locktime");
  return n && n.length > 1 ? parseInt(n[1], 10) : 1 / 0;
}
function kn(s) {
  const t = typeof s == "string" ? Q(s) : s;
  if (t[0] !== "P2PK")
    throw new Error('Invalid P2PK secret: must start with "P2PK"');
  if (!$t(t).length)
    return 0;
  const { tags: n } = t[1], r = Math.floor(Date.now() / 1e3);
  if (_e(t) > r) {
    const a = n && n.find((c) => c[0] === "n_sigs");
    return a && a.length > 1 ? parseInt(a[1], 10) : 1;
  }
  const o = n && n.find((a) => a[0] === "n_sigs_refund");
  return o && o.length > 1 ? parseInt(o[1], 10) : 1;
}
function ks(s) {
  const t = typeof s == "string" ? Q(s) : s;
  if (t[0] !== "P2PK")
    throw new Error('Invalid P2PK secret: must start with "P2PK"');
  const { tags: e } = t[1], n = e && e.find((r) => r[0] === "sigflag");
  return n && n.length > 1 ? n[1] : "SIG_INPUTS";
}
const Wt = (s) => {
  if (!s) return [];
  if (typeof s == "string")
    try {
      return JSON.parse(s).signatures || [];
    } catch (t) {
      return console.error("Failed to parse witness string:", t), [];
    }
  return s.signatures || [];
}, bn = (s, t, e = L) => s.map((n, r) => {
  try {
    const i = Pn(t, n);
    let o = n;
    for (const a of i)
      try {
        o = _n(o, a);
      } catch (c) {
        const u = c instanceof Error ? c.message : "Unknown error";
        e.warn(`Proof #${r + 1}: ${u}`);
      }
    return o;
  } catch (i) {
    const o = i instanceof Error ? i.message : "Unknown error";
    throw e.error(`Proof #${r + 1}: ${o}`), new Error(`Failed signing proof #${r + 1}: ${o}`);
  }
}), _n = (s, t) => {
  const e = Q(s.secret);
  if (e[0] !== "P2PK")
    throw new Error("not a P2PK secret");
  const n = q(Y.getPublicKey(t)), r = $t(e);
  if (!r.length || !r.some((c) => c.includes(n)))
    throw new Error(`Signature not required from [02|03]${n}`);
  const i = Wt(s.witness);
  if (i.some((c) => {
    try {
      return Lt(c, s.secret, n);
    } catch {
      return !1;
    }
  }))
    throw new Error(`Proof already signed by [02|03]${n}`);
  const a = yn(s.secret, t);
  return { ...s, witness: { signatures: [...i, a] } };
}, bs = (s) => {
  if (!s.witness)
    throw new Error("could not verify signature, no witness provided");
  const t = Q(s.secret), e = $t(t);
  if (!e.length)
    throw new Error("no signatures required, proof is unlocked");
  let n = 0;
  const r = kn(t), i = Wt(s.witness);
  for (const o of e)
    i.some((c) => {
      try {
        return Lt(c, s.secret, o);
      } catch {
        return !1;
      }
    }) && n++;
  return n >= r;
}, _s = (s, t) => {
  if (!s.witness?.signatures || s.witness.signatures.length === 0)
    throw new Error("could not verify signature, no witness signatures provided");
  return Y.verify(
    s.witness.signatures[0],
    K(s.B_.toHex(!0)),
    t.slice(2)
  );
}, Pe = (s, t) => {
  const e = s.B_.toHex(!0), n = wn(e, t);
  return s.witness = { signatures: [n] }, s;
}, Ps = (s, t) => s.map((e) => Pe(e, t));
function Pn(s, t) {
  const e = Array.isArray(s) ? s : [s], n = t?.p2pk_e;
  if (!n)
    return Array.from(new Set(e));
  const r = Q(t.secret), i = [...ke(r), ...be(r)], o = t.id;
  return pn(n, e, i, o);
}
const An = O("536563703235366b315f48617368546f43757276655f43617368755f");
function ft(s) {
  const t = K(_.concat(An, s)), e = new Uint32Array(1), n = 2 ** 16;
  for (let r = 0; r < n; r++) {
    const i = new Uint8Array(e.buffer), o = K(_.concat(t, i));
    try {
      return X(q(_.concat(new Uint8Array([2]), o)));
    } catch {
      e[0]++;
    }
  }
  throw new Error("No valid point found");
}
function Ae(s) {
  const e = s.map((n) => n.toHex(!1)).join("");
  return K(new TextEncoder().encode(e));
}
function As(s) {
  return b.Point.fromHex(q(s));
}
function X(s) {
  return b.Point.fromHex(s);
}
const vn = (s) => {
  let t;
  return /^[a-fA-F0-9]+$/.test(s) ? t = dt(s) % BigInt(2 ** 31 - 1) : t = $(qt(s)) % BigInt(2 ** 31 - 1), t;
};
function ve() {
  return b.utils.randomSecretKey();
}
function vs(s, t, e, n) {
  return { C_: s.multiply($(t)), amount: e, id: n };
}
function Es(s) {
  return gt(
    Ot(32),
    $(b.utils.randomSecretKey()),
    s
  );
}
function gt(s, t, e) {
  const n = ft(s);
  t || (t = $(b.utils.randomSecretKey()));
  const r = b.Point.BASE.multiply(t), i = n.add(r);
  return e !== void 0 ? Pe({ B_: i, r: t, secret: s }, e) : { B_: i, r: t, secret: s };
}
function En(s, t, e) {
  return s.subtract(e.multiply(t));
}
function Sn(s, t, e, n) {
  const r = n, i = En(s.C_, t, r);
  return {
    id: s.id,
    amount: s.amount,
    secret: e,
    C: i
  };
}
const Tn = (s) => ({
  amount: s.amount,
  C: s.C.toHex(!0),
  id: s.id,
  secret: new TextDecoder().decode(s.secret),
  witness: JSON.stringify(s.witness)
}), Ss = (s) => ({
  amount: s.amount,
  C: X(s.C),
  id: s.id,
  secret: new TextEncoder().encode(s.secret),
  witness: s.witness ? JSON.parse(s.witness) : void 0
}), te = "m/0'/0'/0'";
function In(s) {
  const t = {};
  return Object.keys(s).forEach((e) => {
    t[e] = q(s[e]);
  }), t;
}
function Ts(s) {
  const t = {};
  return Object.keys(s).forEach((e) => {
    t[e] = O(s[e]);
  }), t;
}
function Mn(s) {
  return b.getPublicKey(s, !0);
}
function Is(s, t) {
  let e = 0n;
  const n = {}, r = {};
  let i;
  for (t && (i = he.fromMasterSeed(t)); e < s; ) {
    const a = (2n ** e).toString();
    if (i) {
      const c = i.derive(`${te}/${e}`).privateKey;
      if (c)
        r[a] = c;
      else
        throw new Error(`Could not derive Private key from: ${te}/${e}`);
    } else
      r[a] = ve();
    n[a] = Mn(r[a]), e++;
  }
  const o = Qt(In(n));
  return { pubKeys: n, privKeys: r, keysetId: o };
}
function Ms(s, t) {
  return ft(s.secret).multiply($(t)).equals(s.C);
}
const Cn = "m/129372'/0'", xn = (s, t, e) => {
  const n = /^[a-fA-F0-9]+$/.test(t);
  if (!n && Ut(t) || n && t.startsWith("00"))
    return yt(
      s,
      t,
      e,
      0
      /* SECRET */
    );
  if (n && t.startsWith("01"))
    return Ee(
      s,
      t,
      e,
      0
      /* SECRET */
    );
  throw new Error(`Unrecognized keyset ID version ${t.slice(0, 2)}`);
}, Bn = (s, t, e) => {
  const n = /^[a-fA-F0-9]+$/.test(t);
  if (!n && Ut(t) || n && t.startsWith("00"))
    return yt(
      s,
      t,
      e,
      1
      /* BLINDING_FACTOR */
    );
  if (n && t.startsWith("01"))
    return Ee(
      s,
      t,
      e,
      1
      /* BLINDING_FACTOR */
    );
  throw new Error(`Unrecognized keyset ID version ${t.slice(0, 2)}`);
}, Ee = (s, t, e, n) => {
  let r = _.concat(
    _.fromString("Cashu_KDF_HMAC_SHA256"),
    _.fromHex(t),
    _.writeBigUint64BE(BigInt(e))
  );
  switch (n) {
    case 0:
      r = _.concat(r, _.fromHex("00"));
      break;
    case 1:
      r = _.concat(r, _.fromHex("01"));
  }
  return We(K, s, r);
}, yt = (s, t, e, n) => {
  const r = he.fromMasterSeed(s), i = vn(t), o = `${Cn}/${i}'/${e}'/${n}`, a = r.derive(o);
  if (a.privateKey === null)
    throw new Error("Could not derive private key");
  return a.privateKey;
};
function On(s, t) {
  if (s.length !== t.length) return !1;
  for (let e = 0; e < s.length; e++)
    if (s[e] !== t[e]) return !1;
  return !0;
}
const Kn = (s, t, e, n) => {
  const r = b.Point.BASE.multiply(b.Point.Fn.fromBytes(s.s)), i = n.multiply($(s.e)), o = t.multiply($(s.s)), a = e.multiply($(s.e)), c = r.subtract(i), u = o.subtract(a), l = Ae([c, u, n, e]);
  return On(l, s.e);
}, Dn = (s, t, e, n) => {
  if (t.r === void 0) throw new Error("verifyDLEQProof_reblind: Undefined blinding factor");
  const r = ft(s), i = e.add(n.multiply(t.r)), o = b.Point.BASE.multiply(t.r), a = r.add(o);
  return Kn(t, a, i, n);
}, Cs = (s, t) => {
  const e = b.Point.Fn.fromBytes(ve()), n = b.Point.BASE.multiply(e), r = s.multiply(e), i = b.Point.Fn.fromBytes(t), o = s.multiply(i), a = b.Point.BASE.multiply(i), c = Ae([n, r, a, o]), u = b.Point.Fn.fromBytes(c), l = b.Point.Fn.add(e, b.Point.Fn.mul(u, i));
  return { s: Le(l, 32), e: c };
};
function Se(s, t) {
  let e = s;
  for (const r of t)
    e += r.B_;
  const n = new TextEncoder().encode(e);
  return K(n);
}
function qn(s, t, e) {
  const n = Se(t, e), r = H(s), i = Y.sign(n, r);
  return J(i);
}
function xs(s, t, e, n) {
  const r = H(n);
  let i = H(s);
  if (i.length !== 33) return !1;
  i = i.slice(1);
  const o = Se(t, e);
  return Y.verify(r, o, i);
}
class Ht {
  constructor(t, e, n, r, i, o, a = !1, c, u = !1) {
    this.transport = t, this.id = e, this.amount = n, this.unit = r, this.mints = i, this.description = o, this.singleUse = a, this.nut10 = c, this.nut26 = u;
  }
  toRawRequest() {
    const t = {};
    return this.transport && (t.t = this.transport.map((e) => ({
      t: e.type,
      a: e.target,
      g: e.tags
    }))), this.id && (t.i = this.id), this.amount && (t.a = this.amount), this.unit && (t.u = this.unit), this.mints && (t.m = this.mints), this.description && (t.d = this.description), this.singleUse && (t.s = this.singleUse), this.nut10 && (t.nut10 = {
      k: this.nut10.kind,
      d: this.nut10.data,
      t: this.nut10.tags
    }), this.nut26 && (t.nut26 = this.nut26), t;
  }
  toEncodedRequest() {
    const t = this.toRawRequest(), e = Rt(t);
    return "creqA" + _.toBase64(e);
  }
  getTransport(t) {
    return this.transport?.find((e) => e.type === t);
  }
  static fromRawRequest(t) {
    const e = t.t ? t.t.map((r) => ({
      type: r.t,
      target: r.a,
      tags: r.g
    })) : void 0, n = t.nut10 ? {
      kind: t.nut10.k,
      data: t.nut10.d,
      tags: t.nut10.t
    } : void 0;
    return new Ht(
      e,
      t.i,
      t.a,
      t.u,
      t.m,
      t.d,
      t.s,
      n,
      t.nut26
    );
  }
  static fromEncodedRequest(t) {
    if (!t.startsWith("creq"))
      throw new Error("unsupported pr: invalid prefix");
    if (t[4] !== "A")
      throw new Error("unsupported pr version");
    const n = t.slice(5), r = qt(n), i = Ft(r);
    return this.fromRawRequest(i);
  }
}
function G(s, t, e, n) {
  if (e) {
    const i = ee(e);
    if (s === 0 && i === 0)
      return e;
    const o = e.filter((c) => c > 0), a = ee(o);
    if (a > s)
      throw new Error(`Split is greater than total amount: ${a} > ${s}`);
    if (o.some((c) => !Ie(c, t)))
      throw new Error("Provided amount preferences do not match the amounts of the mint keyset.");
    if (a === s)
      return o;
    e = o, s -= a;
  } else
    e = [];
  const r = Te(t, "desc");
  if (!r || r.length === 0)
    throw new Error("Cannot split amount, keyset is inactive or contains no keys");
  for (const i of r) {
    if (i <= 0) continue;
    const o = Math.floor(s / i);
    if (e.push(...Array(o).fill(i)), s -= i * o, s === 0) break;
  }
  if (s !== 0)
    throw new Error(`Unable to split remaining amount: ${s}`);
  return n ? e.sort((i, o) => n === "desc" ? o - i : i - o) : e;
}
function Un(s, t, e, n) {
  const r = [], i = s.map((c) => c.amount);
  Te(e, "asc").forEach((c) => {
    const u = i.filter((h) => h === c).length, l = Math.max(n - u, 0);
    for (let h = 0; h < l && !(r.reduce((d, p) => d + p, 0) + c > t); ++h)
      r.push(c);
  });
  const a = t - r.reduce((c, u) => c + u, 0);
  return a && G(a, e).forEach((u) => {
    r.push(u);
  }), r.sort((c, u) => c - u);
}
function Te(s, t = "desc") {
  return t == "desc" ? Object.keys(s).map((e) => parseInt(e)).sort((e, n) => n - e) : Object.keys(s).map((e) => parseInt(e)).sort((e, n) => e - n);
}
function Ie(s, t) {
  return s in t;
}
function $(s) {
  return dt(q(s));
}
function dt(s) {
  return BigInt(`0x${s}`);
}
function Mt(s) {
  return s.toString(16).padStart(64, "0");
}
function Ct(s) {
  return /^[a-f0-9]*$/i.test(s);
}
function jt(s) {
  return Array.isArray(s) ? s.some((t) => !Ct(t.id)) : !Ct(s.id);
}
function Bs(s, t) {
  return typeof t == "bigint" ? t.toString() : t;
}
function Rn(s, t) {
  jt(s.proofs) || (s.proofs = Me(s.proofs)), t && (s.proofs = Ke(s.proofs));
  const e = { token: [{ mint: s.mint, proofs: s.proofs }] };
  return s.unit && (e.unit = s.unit), s.memo && (e.memo = s.memo), "cashu" + "A" + me(e);
}
function Me(s) {
  return s.map((t) => {
    const e = { ...t };
    return e.id = e.id.slice(0, 16), e;
  });
}
function Os(s, t) {
  if (jt(s.proofs) || t?.version === 3) {
    if (t?.version === 4)
      throw new Error("can not encode to v4 token if proofs contain non-hex keyset id");
    return Rn(s, t?.removeDleq);
  }
  return Nn(s, t?.removeDleq);
}
function Nn(s, t) {
  if (t && (s.proofs = Ke(s.proofs)), s.proofs.forEach((c) => {
    if (c.dleq && c.dleq.r == null)
      throw new Error("Missing blinding factor in included DLEQ proof");
  }), jt(s.proofs))
    throw new Error("can not encode to v4 token if proofs contain non-hex keyset id");
  s.proofs = Me(s.proofs);
  const n = Ce(s), r = Rt(n), i = "cashu", o = "B", a = It(r);
  return i + o + a;
}
function Ce(s) {
  const t = {}, e = s.mint;
  for (let r = 0; r < s.proofs.length; r++) {
    const i = s.proofs[r];
    t[i.id] ? t[i.id].push(i) : t[i.id] = [i];
  }
  const n = {
    m: e,
    u: s.unit || "sat",
    t: Object.keys(t).map(
      (r) => ({
        i: O(r),
        p: t[r].map(
          (i) => ({
            a: i.amount,
            s: i.secret,
            c: O(i.C),
            ...i.dleq && {
              d: {
                e: O(i.dleq.e),
                s: O(i.dleq.s),
                r: O(i.dleq.r ?? "00")
              }
            },
            ...i.p2pk_e && {
              pe: O(i.p2pk_e)
            },
            ...i.witness && {
              w: JSON.stringify(i.witness)
            }
          })
        )
      })
    )
  };
  return s.memo && (n.d = s.memo), n;
}
function xe(s) {
  const t = [];
  s.t.forEach(
    (n) => n.p.forEach((r) => {
      t.push({
        secret: r.s,
        C: q(r.c),
        amount: r.a,
        id: q(n.i),
        ...r.d && {
          dleq: {
            r: q(r.d.r),
            s: q(r.d.s),
            e: q(r.d.e)
          }
        },
        ...r.pe && {
          p2pk_e: q(r.pe)
        },
        ...r.w && {
          witness: r.w
        }
      });
    })
  );
  const e = { mint: s.m, proofs: t, unit: s.u || "sat" };
  return s.d && (e.memo = s.d), e;
}
function Fn(s, t) {
  const e = qe(s), n = Be(e);
  return n.proofs = Wn(n.proofs, t), n;
}
function Ks(s) {
  s = qe(s);
  const t = Be(s);
  return {
    unit: t.unit || "sat",
    mint: t.mint,
    amount: rt(t.proofs),
    ...t.memo && { memo: t.memo },
    incompleteProofs: t.proofs.map((e) => ({
      secret: e.secret,
      C: e.C,
      amount: e.amount,
      ...e.dleq && {
        dleq: e.dleq
      },
      ...e.witness && {
        witness: e.witness
      }
    }))
  };
}
function Be(s) {
  const t = s.slice(0, 1), e = s.slice(1);
  if (t === "A") {
    const n = Ve(e);
    if (n.token.length > 1)
      throw new Error("Multi entry token are not supported");
    const r = n.token[0], i = {
      mint: r.mint,
      proofs: r.proofs,
      unit: n.unit || "sat"
    };
    return n.memo && (i.memo = n.memo), i;
  } else if (t === "B") {
    const n = qt(e), r = Ft(n);
    return xe(r);
  }
  throw new Error("Token version is not supported");
}
function Qt(s, t, e, n = 0, r = !1) {
  if (r) {
    const c = Object.entries(s).sort((h, d) => +h[0] - +d[0]).map(([, h]) => h).reduce((h, d) => h + d, ""), u = K(c);
    return _.toBase64(u).slice(0, 12);
  }
  let i = Object.entries(s).sort((c, u) => +c[0] - +u[0]).map(([, c]) => O(c)).reduce((c, u) => Pt(c, u), new Uint8Array()), o, a;
  switch (n) {
    case 0:
      return o = K(i), a = _.toHex(o).slice(0, 14), "00" + a;
    case 1:
      if (!t)
        throw new Error("Cannot compute keyset ID version 01: unit is required.");
      return i = Pt(i, _.fromString("unit:" + t)), e && (i = Pt(
        i,
        _.fromString("final_expiry:" + e.toString())
      )), o = K(i), a = _.toHex(o), "01" + a;
    default:
      throw new Error(`Unrecognized keyset ID version: ${n}`);
  }
}
function Pt(s, t) {
  const e = new Uint8Array(s.length + t.length);
  return e.set(s), e.set(t, s.length), e;
}
function Ds(s) {
  return s.sort((t, e) => t.id.localeCompare(e.id));
}
function T(s) {
  return typeof s == "object";
}
function qs(s) {
  if (T(s)) {
    if ("error" in s && s.error)
      throw new Error(s.error);
    if ("detail" in s && s.detail)
      throw new Error(s.detail);
  }
}
function W(...s) {
  return s.map((t) => t.replace(/(^\/+|\/+$)/g, "")).join("/");
}
function Oe(s) {
  return s.replace(/\/$/, "");
}
function rt(s) {
  return s.reduce((t, e) => t + e.amount, 0);
}
function Us(s) {
  return Ht.fromEncodedRequest(s);
}
class Ln {
  get value() {
    return this._value;
  }
  set value(t) {
    this._value = t;
  }
  get next() {
    return this._next;
  }
  set next(t) {
    this._next = t;
  }
  constructor(t) {
    this._value = t, this._next = null;
  }
}
class $n {
  get first() {
    return this._first;
  }
  set first(t) {
    this._first = t;
  }
  get last() {
    return this._last;
  }
  set last(t) {
    this._last = t;
  }
  get size() {
    return this._size;
  }
  set size(t) {
    this._size = t;
  }
  constructor() {
    this._first = null, this._last = null, this._size = 0;
  }
  enqueue(t) {
    const e = new Ln(t);
    return this._size === 0 || !this._last ? (this._first = e, this._last = e) : (this._last.next = e, this._last = e), this._size++, !0;
  }
  dequeue() {
    if (this._size === 0 || !this._first) return null;
    const t = this._first;
    return this._first = t.next, t.next = null, this._size--, t.value;
  }
}
function Ke(s) {
  return s.map((t) => {
    const e = { ...t };
    return delete e.dleq, e;
  });
}
function Rs(s) {
  const t = Ut(s.id), e = /^[a-fA-F0-9]+$/.test(s.id), n = e ? O(s.id)[0] : 0;
  return Qt(
    s.keys,
    s.unit,
    s.final_expiry,
    n,
    t && !e
  ) === s.id;
}
function Wn(s, t) {
  const e = [];
  for (const n of s) {
    let r;
    try {
      r = O(n.id);
    } catch {
      e.push(n);
      continue;
    }
    if (r[0] === 0)
      e.push(n);
    else if (r[0] === 1) {
      if (!t)
        throw new Error("A short keyset ID v2 was encountered, but got no keysets to map it to.");
      let i = !1;
      for (const o of t)
        if (n.id === o.id.slice(0, n.id.length)) {
          n.id = o.id, e.push(n), i = !0;
          break;
        }
      if (!i)
        throw new Error(
          `Couldn't map short keyset ID ${n.id} to any known keysets of the current Mint`
        );
    } else
      throw new Error(`Unknown keyset ID version: ${r[0]}`);
  }
  return e;
}
function De(s, t) {
  if (s.dleq == null)
    return !1;
  const e = {
    e: O(s.dleq.e),
    s: O(s.dleq.s),
    r: dt(s.dleq.r ?? "00")
  };
  if (!Ie(s.amount, t.keys))
    throw new Error(`undefined key for amount ${s.amount}`);
  const n = t.keys[s.amount];
  return Dn(
    new TextEncoder().encode(s.secret),
    e,
    X(s.C),
    X(n)
  );
}
function Hn(...s) {
  const t = s.reduce((r, i) => r + i.length, 0), e = new Uint8Array(t);
  let n = 0;
  for (let r = 0; r < s.length; r++)
    e.set(s[r], n), n = n + s[r].length;
  return e;
}
function Ns(s) {
  const t = new TextEncoder(), e = Ce(s), n = Rt(e), r = t.encode("craw"), i = t.encode("B");
  return Hn(r, i, n);
}
function Fs(s) {
  const t = new TextDecoder(), e = t.decode(s.slice(0, 4)), n = t.decode(new Uint8Array([s[4]]));
  if (e !== "craw" || n !== "B")
    throw new Error("not a valid binary token");
  const r = s.slice(5), i = Ft(r);
  return xe(i);
}
function ee(s) {
  return s.reduce((t, e) => t + e, 0);
}
function ne(s, t) {
  if (s === t) return !0;
  if (s == null || t == null || typeof s != "object" || typeof t != "object") return !1;
  if (Array.isArray(s) && Array.isArray(t))
    return s.length !== t.length ? !1 : s.every((r, i) => ne(r, t[i]));
  if (Array.isArray(s) || Array.isArray(t)) return !1;
  const e = Object.keys(s), n = Object.keys(t);
  return e.length !== n.length ? !1 : e.every((r) => n.includes(r) && ne(s[r], t[r]));
}
function qe(s) {
  return ["web+cashu://", "cashu://", "cashu:", "cashu"].forEach((e) => {
    s.startsWith(e) && (s = s.slice(e.length));
  }), s;
}
class it {
  constructor() {
    this.connectionMap = /* @__PURE__ */ new Map();
  }
  static getInstance() {
    return it.instance || (it.instance = new it()), it.instance;
  }
  getConnection(t, e) {
    if (this.connectionMap.has(t))
      return this.connectionMap.get(t);
    const n = new jn(t, e);
    return this.connectionMap.set(t, n), n;
  }
}
class jn {
  constructor(t, e) {
    this.subListeners = {}, this.rpcListeners = {}, this.rpcId = 0, this.onCloseCallbacks = [], this._WS = ze(), this.url = new URL(t), this.messageQueue = new $n(), this._logger = e ?? L;
  }
  connect() {
    return this.connectionPromise || (this.connectionPromise = new Promise((t, e) => {
      try {
        this.ws = new this._WS(this.url.toString()), this.onCloseCallbacks = [];
      } catch (n) {
        e(n instanceof Error ? n : new Error(String(n)));
        return;
      }
      this.ws.onopen = () => {
        t();
      }, this.ws.onerror = () => {
        e(new Error("Failed to open WebSocket"));
      }, this.ws.onmessage = (n) => {
        this.messageQueue.enqueue(n.data), this.handlingInterval || (this.handlingInterval = setInterval(
          this.handleNextMessage.bind(this),
          0
        ));
      }, this.ws.onclose = (n) => {
        this.connectionPromise = void 0, this.onCloseCallbacks.forEach((r) => r(n));
      };
    })), this.connectionPromise;
  }
  sendRequest(t, e) {
    if (this.ws?.readyState !== 1) {
      if (t === "unsubscribe")
        return;
      throw this._logger.error("Attempted sendRequest, but socket was not open"), new Error("Socket not open");
    }
    const n = this.rpcId;
    this.rpcId++;
    const r = JSON.stringify({ jsonrpc: "2.0", method: t, params: e, id: n });
    this.ws?.send(r);
  }
  /**
   * @deprecated Use cancelSubscription for JSONRPC compliance.
   */
  closeSubscription(t) {
    this.ws?.send(JSON.stringify(["CLOSE", t]));
  }
  addSubListener(t, e) {
    (this.subListeners[t] = this.subListeners[t] || []).push(
      e
    );
  }
  addRpcListener(t, e, n) {
    this.rpcListeners[n] = { callback: t, errorCallback: e };
  }
  removeRpcListener(t) {
    delete this.rpcListeners[t];
  }
  removeListener(t, e) {
    if (this.subListeners[t]) {
      if (this.subListeners[t].length === 1) {
        delete this.subListeners[t];
        return;
      }
      this.subListeners[t] = this.subListeners[t].filter(
        (n) => n !== e
      );
    }
  }
  async ensureConnection() {
    this.ws?.readyState !== 1 && await this.connect();
  }
  handleNextMessage() {
    if (this.messageQueue.size === 0) {
      clearInterval(this.handlingInterval), this.handlingInterval = void 0;
      return;
    }
    const t = this.messageQueue.dequeue();
    let e;
    try {
      if (e = JSON.parse(t), "result" in e && e.id != null)
        this.rpcListeners[e.id] && (this.rpcListeners[e.id].callback(), this.removeRpcListener(e.id));
      else if ("error" in e && e.id != null)
        this.rpcListeners[e.id] && (this.rpcListeners[e.id].errorCallback(new Error(e.error.message)), this.removeRpcListener(e.id));
      else if ("method" in e && !("id" in e)) {
        const n = e.params?.subId;
        if (!n)
          return;
        if (this.subListeners[n]?.length > 0) {
          const r = e;
          this.subListeners[n].forEach((i) => i(r.params?.payload));
        }
      }
    } catch (n) {
      this._logger.error("Error doing handleNextMessage", { e: n });
      return;
    }
  }
  createSubscription(t, e, n) {
    if (this.ws?.readyState !== 1)
      throw this._logger.error("Attempted createSubscription, but socket was not open"), new Error("Socket is not open");
    const r = (Math.random() + 1).toString(36).substring(7);
    return this.addRpcListener(
      () => {
        this.addSubListener(r, e);
      },
      n,
      this.rpcId
    ), this.sendRequest("subscribe", { ...t, subId: r }), this.rpcId++, r;
  }
  /**
   * Cancels a subscription, sending an unsubscribe request and handling responses.
   *
   * @param subId The subscription ID to cancel.
   * @param callback The original payload callback to remove.
   * @param errorCallback Optional callback for unsubscribe errors (defaults to logging).
   */
  cancelSubscription(t, e, n) {
    this.removeListener(t, e), this.addRpcListener(
      () => {
        this._logger.info("Unsubscribed {subId}", { subId: t });
      },
      n || ((r) => this._logger.error("Unsubscribe failed", { e: r })),
      this.rpcId
    ), this.sendRequest("unsubscribe", { subId: t });
  }
  get activeSubscriptions() {
    return Object.keys(this.subListeners);
  }
  close() {
    this.ws && this.ws?.close();
  }
  onClose(t) {
    this.onCloseCallbacks.push(t);
  }
}
function At(s, t) {
  return s.state || (t.warn(
    "Field 'state' not found in MeltQuoteResponse. Update NUT-05 of mint: https://github.com/cashubtc/nuts/pull/136)"
  ), typeof s.paid == "boolean" && (s.state = s.paid ? ut.PAID : ut.UNPAID)), s;
}
function se(s, t) {
  return s.state || (t.warn(
    "Field 'state' not found in MintQuoteResponse. Update NUT-04 of mint: https://github.com/cashubtc/nuts/pull/141)"
  ), typeof s.paid == "boolean" && (s.state = s.paid ? Tt.PAID : Tt.UNPAID)), s;
}
function Qn(s, t) {
  return Array.isArray(s?.contact) && s?.contact.length > 0 && (s.contact = s.contact.map((e) => Array.isArray(e) && e.length === 2 && typeof e[0] == "string" && typeof e[1] == "string" ? (t.warn(
    "Mint returned deprecated 'contact' field: Update NUT-06: https://github.com/cashubtc/nuts/pull/117"
  ), { method: e[0], info: e[1] }) : e)), s;
}
class wt {
  constructor(t) {
    this.REGEX_METACHAR = /[\\^$.*+?()[\]{}|]/, this._mintInfo = t;
    const e = this.toEndpoints(t?.nuts?.[22]?.protected_endpoints);
    this._protected22 = this.buildIndex(e);
    const n = this.toEndpoints(t?.nuts?.[21]?.protected_endpoints);
    this._protected21 = this.buildIndex(n);
  }
  isSupported(t) {
    switch (t) {
      case 4:
      case 5:
        return this.checkMintMelt(t);
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 14:
      case 20:
        return this.checkGenericNut(t);
      case 17:
        return this.checkNut17();
      case 15:
        return this.checkNut15();
      default:
        throw new Error("nut is not supported by cashu-ts");
    }
  }
  requiresBlindAuthToken(t, e) {
    return this.matchesProtected(this._protected22, t, e);
  }
  requiresClearAuthToken(t, e) {
    return this.matchesProtected(this._protected21, t, e);
  }
  matchesProtected(t, e, n) {
    if (!t) return !1;
    const r = `${e} ${n}`, i = t.cache[r];
    if (typeof i == "boolean") return i;
    const o = t.exact.some((u) => u.method === e && u.path === n), a = o ? !1 : t.regex.some((u) => u.method === e && u.regex.test(n)), c = o || a;
    return t.cache[r] = c, c;
  }
  checkGenericNut(t) {
    return this._mintInfo.nuts[t]?.supported ? { supported: !0 } : { supported: !1 };
  }
  checkMintMelt(t) {
    const e = this._mintInfo.nuts[t];
    return e && e.methods.length > 0 && !e.disabled ? { disabled: !1, params: e.methods } : { disabled: !0, params: e?.methods ?? [] };
  }
  checkNut17() {
    return this._mintInfo.nuts[17] && this._mintInfo.nuts[17].supported.length > 0 ? { supported: !0, params: this._mintInfo.nuts[17].supported } : { supported: !1 };
  }
  checkNut15() {
    return this._mintInfo.nuts[15] && this._mintInfo.nuts[15].methods.length > 0 ? { supported: !0, params: this._mintInfo.nuts[15].methods } : { supported: !1 };
  }
  // ---------- private helpers ----------
  toEndpoints(t) {
    if (!Array.isArray(t)) return [];
    const e = [];
    for (const n of t)
      if (n && typeof n == "object") {
        const r = n, i = r.method, o = r.path;
        if (typeof i == "string" && typeof o == "string") {
          const a = i.toUpperCase();
          (a === "GET" || a === "POST") && e.push({ method: a, path: o });
        }
      }
    return e;
  }
  buildIndex(t) {
    if (!t || t.length === 0) return;
    const e = [], n = [], r = this.REGEX_METACHAR;
    for (const o of t) {
      if (o.path.startsWith("^") || o.path.endsWith("$") || r.test(o.path))
        try {
          n.push({ method: o.method, regex: new RegExp(o.path) });
          continue;
        } catch {
        }
      e.push({ method: o.method, path: o.path });
    }
    return { cache: {}, exact: e, regex: n };
  }
  // ---------- getters ----------
  get contact() {
    return this._mintInfo.contact;
  }
  get description() {
    return this._mintInfo.description;
  }
  get description_long() {
    return this._mintInfo.description_long;
  }
  get name() {
    return this._mintInfo.name;
  }
  get pubkey() {
    return this._mintInfo.pubkey;
  }
  get nuts() {
    return this._mintInfo.nuts;
  }
  get version() {
    return this._mintInfo.version;
  }
  get motd() {
    return this._mintInfo.motd;
  }
  /**
   * @deprecated Use supportsNut04Description(method, unit)
   */
  get supportsBolt12Description() {
    return this.supportsNut04Description("bolt12");
  }
  /**
   * Checks if the mint supports creating invoices/offers with a description for the specified
   * payment method.
   *
   * @param method - The payment method to check ('bolt11' or 'bolt12')
   * @returns True if the mint supports description for the method, false otherwise.
   */
  supportsNut04Description(t, e) {
    return this._mintInfo.nuts[4]?.methods.some(
      (n) => n.method === t && (e ? n.unit === e : !0) && (n.options?.description === !0 || n.description === !0)
    );
  }
}
class zt {
  constructor(t, e) {
    this.tokenListeners = [], this.discoveryUrl = t, this.logger = e?.logger ?? L, this.clientId = e?.clientId ?? "cashu-client", this.scope = e?.scope ?? "openid", this.onTokens = e?.onTokens;
  }
  static fromMintInfo(t, e) {
    const n = t?.nuts?.["21"];
    if (!n?.openid_discovery)
      throw new Error("OIDCAuth: mint does not advertise NUT-21 openid_discovery");
    const r = e?.clientId ?? n.client_id ?? "cashu-client";
    return new zt(n.openid_discovery, { ...e, clientId: r });
  }
  setClient(t) {
    this.clientId = t;
  }
  setScope(t) {
    this.scope = t ?? "openid";
  }
  /**
   * Subscribe to token updates. Listeners are called after the primary onTokens callback.
   */
  addTokenListener(t) {
    this.tokenListeners.push(t);
  }
  // ---- Discovery ----
  async loadConfig() {
    if (this.config) return this.config;
    const t = await fetch(this.discoveryUrl, {
      method: "GET",
      headers: { Accept: "application/json" }
    }), e = await t.text();
    let n;
    try {
      n = e ? JSON.parse(e) : void 0;
    } catch (i) {
      this.logger.warn("OIDCAuth: bad discovery JSON", { err: i });
    }
    if (!t.ok || !n)
      throw new Error("OIDCAuth: invalid discovery document");
    const r = n;
    if (typeof r.token_endpoint != "string" || r.token_endpoint.length === 0)
      throw new Error("OIDCAuth: invalid discovery document, missing token_endpoint");
    return this.config = r, r;
  }
  // --- Authorization Code with PKCE ---
  /**
   * Generate a PKCE verifier and S256 challenge.
   *
   * - Verifier: base64url of random bytes, length >= 43, RFC 7636 compliant.
   * - Challenge: base64url(sha256(verifier))
   */
  generatePKCE() {
    const t = Ot(48), e = It(t), n = _.fromString(e), r = K(n), i = It(r);
    return { verifier: e, challenge: i };
  }
  /**
   * Build an Authorization Code + PKCE URL.
   */
  async buildAuthCodeUrl(t) {
    const e = await this.loadConfig(), n = t.scope ?? this.scope, r = new URLSearchParams({
      response_type: "code",
      client_id: this.clientId,
      redirect_uri: t.redirectUri,
      scope: n,
      code_challenge_method: t.codeChallengeMethod ?? "S256",
      code_challenge: t.codeChallenge
    });
    if (t.state && r.set("state", t.state), !e.authorization_endpoint)
      throw new Error("OIDCAuth: discovery lacks authorization_endpoint");
    return `${e.authorization_endpoint}?${r.toString()}`;
  }
  /**
   * Exchange an auth code for tokens, using the PKCE verifier.
   */
  async exchangeAuthCode(t) {
    const e = await this.loadConfig(), n = this.toForm({
      grant_type: "authorization_code",
      code: t.code,
      redirect_uri: t.redirectUri,
      client_id: this.clientId,
      code_verifier: t.codeVerifier
    }), r = await this.postFormStrict(e.token_endpoint, n);
    return this.handleTokens(r), r;
  }
  // ---- Device Code (recommended for CLIs) ----
  async deviceStart() {
    const e = (await this.loadConfig()).device_authorization_endpoint;
    if (!e) throw new Error("OIDCAuth: provider lacks device_authorization_endpoint");
    const n = this.toForm({ client_id: this.clientId, scope: this.scope });
    return this.postFormStrict(e, n);
  }
  async devicePoll(t, e = 5) {
    const n = await this.loadConfig();
    let r = Math.max(1, e);
    for (; ; ) {
      await this.sleep(r * 1e3);
      const i = this.toForm({
        grant_type: "urn:ietf:params:oauth:grant-type:device_code",
        device_code: t,
        client_id: this.clientId
      }), o = await this.postFormLoose(n.token_endpoint, i);
      if (o.access_token)
        return this.handleTokens(o), o;
      const a = (o.error ?? "").toString();
      if (a === "authorization_pending") continue;
      if (a === "slow_down") {
        r = Math.max(r + 5, r * 2);
        continue;
      }
      const c = o.error_description || a || "device authorization failed";
      throw new Error(`OIDCAuth: ${c}`);
    }
  }
  /**
   * One call convenience for Device Code flow.
   *
   * @remarks
   * Polling interval will be the MAX of intervalSec and Mint interval.
   * @param intervalSec Desired polling interval in seconds.
   * @returns The start fields and helpers to poll or cancel.
   */
  async startDeviceAuth(t = 5) {
    const e = await this.deviceStart(), n = Math.max(e.interval ?? 1, t);
    let r = !1;
    return { ...e, poll: async () => {
      const a = await this.loadConfig();
      let c = Math.max(1, n);
      for (; ; ) {
        if (r) throw new Error("OIDCAuth: device polling cancelled");
        await this.sleep(c * 1e3);
        const u = this.toForm({
          grant_type: "urn:ietf:params:oauth:grant-type:device_code",
          device_code: e.device_code,
          client_id: this.clientId
        }), l = await this.postFormLoose(a.token_endpoint, u);
        if (l.access_token)
          return this.handleTokens(l), l;
        const h = (l.error ?? "").toString();
        if (h === "authorization_pending") continue;
        if (h === "slow_down") {
          c = Math.max(c + 5, c * 2);
          continue;
        }
        const d = l.error_description || h || "device authorization failed";
        throw new Error(`OIDCAuth: ${d}`);
      }
    }, cancel: () => {
      r = !0;
    } };
  }
  // ---- Refresh ----
  async refresh(t) {
    const e = await this.loadConfig(), n = this.toForm({
      grant_type: "refresh_token",
      refresh_token: t,
      client_id: this.clientId
    }), r = await this.postFormStrict(e.token_endpoint, n);
    return this.handleTokens(r), r;
  }
  // ---- ROPC (discouraged, but some mints allow it) ----
  async passwordGrant(t, e) {
    const n = await this.loadConfig(), r = this.toForm({
      grant_type: "password",
      client_id: this.clientId,
      username: t,
      password: e,
      scope: this.scope
    }), i = await this.postFormStrict(n.token_endpoint, r);
    return this.handleTokens(i), i;
  }
  // ---- internals ----
  /**
   * Fire and forget token fan out. Any listener errors are logged inside safeCallback. Nothing
   * thrown here will come from listeners.
   */
  handleTokens(t) {
    if (!t.access_token) {
      const e = t.error_description || t.error || "token response missing access_token";
      throw new Error(`OIDCAuth: ${e}`);
    }
    queueMicrotask(
      () => lt(this.onTokens, t, this.logger, { where: "OIDCAuth.handleTokens" })
    );
    for (const e of this.tokenListeners)
      queueMicrotask(
        () => lt(e, t, this.logger, {
          where: "OIDCAuth.handleTokens.listener"
        })
      );
  }
  toForm(t) {
    const e = (n) => encodeURIComponent(n).replace(/%20/g, "+");
    return Object.entries(t).map(([n, r]) => `${e(n)}=${e(r)}`).join("&");
  }
  // Strict, throws on non 2xx
  async postFormStrict(t, e) {
    try {
      this.logger.debug("OIDCAuth Request", { formBody: e });
      const n = await fetch(t, {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          Accept: "application/json"
        },
        body: e
      }), r = await n.text();
      let i;
      try {
        i = r ? JSON.parse(r) : void 0;
      } catch (o) {
        this.logger.warn("OIDCAuth: bad JSON (strict)", { err: o });
      }
      if (!n.ok) {
        const o = i ?? {}, a = o.error_description || o.error || `HTTP ${n.status}`;
        throw new Error(`OIDCAuth: ${a}`);
      }
      return this.logger.debug("OIDCAuth Response", { json: i }), i ?? {};
    } catch (n) {
      throw this.logger.error("OIDCAuth: postFormStrict failed", { err: n }), n;
    }
  }
  // Loose, returns JSON payload even on non 2xx
  async postFormLoose(t, e) {
    try {
      this.logger.debug("OIDCAuth Request", { formBody: e });
      const r = await (await fetch(t, {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          Accept: "application/json"
        },
        body: e
      })).text();
      let i;
      try {
        i = r ? JSON.parse(r) : void 0;
      } catch (o) {
        this.logger.warn("OIDCAuth: bad JSON (loose)", { err: o });
      }
      return this.logger.debug("OIDCAuth Response", { json: i }), i ?? {};
    } catch (n) {
      return this.logger.error("OIDCAuth: postFormLoose network error", { err: n }), { error: "network_error", error_description: String(n) };
    }
  }
  sleep(t) {
    return new Promise((e) => setTimeout(e, t));
  }
}
class Vt {
  /**
   * @param mintUrl Requires mint URL to create this object.
   * @param customRequest Optional, for custom network communication with the mint.
   * @param authTokenGetter Optional. Function to obtain a NUT-22 BlindedAuthToken (e.g. from a
   *   database or localstorage)
   */
  constructor(t, e) {
    this._mintUrl = Oe(t), this._request = e?.customRequest ?? pe, this._authProvider = e?.authProvider, this._logger = e?.logger ?? L, je(this._logger);
  }
  get mintUrl() {
    return this._mintUrl;
  }
  /**
   * Create an OIDC client using this mints NUT-21 metadata.
   *
   * @example
   *
   * ```ts
   * const oidc = await mint.oidcAuth({ onTokens: (t) => authMgr.setCAT(t.access_token!) });
   * const start = await oidc.deviceStart();
   * // show start.user_code / start.verification_uri to the user
   * const token = await oidc.devicePoll(start.device_code, start.interval ?? 5);
   * // token.access_token is your CAT
   * ```
   */
  async oidcAuth(t) {
    const e = (await this.getLazyMintInfo()).nuts[21];
    if (!e?.openid_discovery)
      throw new Error("Mint: no NUT-21 openid_discovery");
    return new zt(e.openid_discovery, {
      ...t,
      clientId: t?.clientId ?? e.client_id ?? "cashu-client"
    });
  }
  /**
   * Fetches mint's info at the /info endpoint.
   *
   * @param customRequest Optional override for the request function.
   * @returns The mint's information response.
   */
  async getInfo(t) {
    const n = await (t ?? this._request)({
      endpoint: W(this._mintUrl, "/v1/info")
    });
    return Qn(n, this._logger);
  }
  /**
   * Lazily fetches and caches the mint's info if not already loaded.
   *
   * @returns The parsed MintInfo object.
   */
  async getLazyMintInfo() {
    if (this._mintInfo)
      return this._mintInfo;
    const t = await this.getInfo();
    return this._mintInfo = new wt(t), this._mintInfo;
  }
  /**
   * Performs a swap operation with ecash inputs and outputs.
   *
   * @param swapPayload Payload containing inputs and outputs.
   * @param customRequest Optional override for the request function.
   * @returns Signed outputs.
   */
  async swap(t, e) {
    const n = await this.requestWithAuth(
      "POST",
      "/v1/swap",
      { requestBody: t },
      e
    );
    if (!T(n) || !Array.isArray(n?.signatures)) {
      const r = T(n) && "detail" in n ? n.detail : void 0;
      throw new Error(r ?? "bad response");
    }
    return n;
  }
  /**
   * Requests a new mint quote from the mint.
   *
   * @param mintQuotePayload Payload for creating a new mint quote.
   * @param customRequest Optional override for the request function.
   * @returns A new mint quote containing a payment request for the specified amount and unit.
   */
  async createMintQuoteBolt11(t, e) {
    const n = await this.requestWithAuth("POST", "/v1/mint/quote/bolt11", { requestBody: t }, e);
    return se(n, this._logger);
  }
  /**
   * Requests a new BOLT12 mint quote from the mint using Lightning Network offers.
   *
   * @param mintQuotePayload Payload containing amount, unit, optional description, and required
   *   pubkey.
   * @param customRequest Optional override for the request function.
   * @returns A mint quote containing a BOLT12 offer.
   */
  async createMintQuoteBolt12(t, e) {
    return await this.requestWithAuth(
      "POST",
      "/v1/mint/quote/bolt12",
      { requestBody: t },
      e
    );
  }
  /**
   * Gets an existing mint quote from the mint.
   *
   * @param quote Quote ID.
   * @param customRequest Optional override for the request function.
   * @returns The status of the mint quote, including payment details and state.
   */
  async checkMintQuoteBolt11(t, e) {
    const n = await this.requestWithAuth("GET", `/v1/mint/quote/bolt11/${t}`, {}, e);
    return se(n, this._logger);
  }
  /**
   * Gets an existing BOLT12 mint quote from the mint.
   *
   * @param quote Quote ID to check.
   * @param customRequest Optional override for the request function.
   * @returns Updated quote with current payment and issuance amounts.
   */
  async checkMintQuoteBolt12(t, e) {
    return await this.requestWithAuth(
      "GET",
      `/v1/mint/quote/bolt12/${t}`,
      {},
      e
    );
  }
  /**
   * Mints new tokens by requesting blind signatures on the provided outputs.
   *
   * @param mintPayload Payload containing the outputs to get blind signatures on.
   * @param customRequest Optional override for the request function.
   * @returns Serialized blinded signatures.
   */
  async mintBolt11(t, e) {
    const n = await this.requestWithAuth(
      "POST",
      "/v1/mint/bolt11",
      { requestBody: t },
      e
    );
    if (!T(n) || !Array.isArray(n?.signatures)) {
      const r = T(n) && "detail" in n ? n.detail : void 0;
      throw new Error(r ?? "bad response");
    }
    return n;
  }
  /**
   * Mints new tokens using a BOLT12 quote by requesting blind signatures on the provided outputs.
   *
   * @param mintPayload Payload containing the quote ID and outputs to get blind signatures on.
   * @param customRequest Optional override for the request function.
   * @returns Serialized blinded signatures for the requested outputs.
   */
  async mintBolt12(t, e) {
    const n = await this.requestWithAuth(
      "POST",
      "/v1/mint/bolt12",
      { requestBody: t },
      e
    );
    if (!T(n) || !Array.isArray(n?.signatures)) {
      const r = T(n) && "detail" in n ? n.detail : void 0;
      throw new Error(r ?? "bad response");
    }
    return n;
  }
  /**
   * Requests a new melt quote from the mint.
   *
   * @param meltQuotePayload Payload for creating a new melt quote.
   * @param customRequest Optional override for the request function.
   * @returns The melt quote response.
   */
  async createMeltQuoteBolt11(t, e) {
    const n = await this.requestWithAuth("POST", "/v1/melt/quote/bolt11", { requestBody: t }, e), r = At(n, this._logger);
    if (!T(r) || typeof r?.amount != "number" || typeof r?.fee_reserve != "number" || typeof r?.quote != "string") {
      const i = T(r) && "detail" in r ? r.detail : void 0;
      throw new Error(i ?? "bad response");
    }
    return r;
  }
  /**
   * Requests a new BOLT12 melt quote from the mint for paying a Lightning Network offer. For
   * amount-less offers, specify the amount in options.amountless.amount_msat.
   *
   * @param meltQuotePayload Payload containing the BOLT12 offer to pay and unit.
   * @param customRequest Optional override for the request function.
   * @returns Melt quote with amount, fee reserve, and payment state.
   */
  async createMeltQuoteBolt12(t, e) {
    return await this.requestWithAuth(
      "POST",
      "/v1/melt/quote/bolt12",
      { requestBody: t },
      e
    );
  }
  /**
   * Gets an existing melt quote.
   *
   * @param quote Quote ID.
   * @param customRequest Optional override for the request function.
   * @returns The melt quote response.
   */
  async checkMeltQuoteBolt11(t, e) {
    const n = await this.requestWithAuth("GET", `/v1/melt/quote/bolt11/${t}`, {}, e), r = At(n, this._logger);
    if (!T(r) || typeof r?.amount != "number" || typeof r?.fee_reserve != "number" || typeof r?.quote != "string" || typeof r?.state != "string" || !Object.values(ut).includes(r.state)) {
      const i = T(r) && "detail" in r ? r.detail : void 0;
      throw new Error(i ?? "bad response");
    }
    return r;
  }
  /**
   * Gets an existing BOLT12 melt quote from the mint. Returns current payment state (UNPAID,
   * PENDING, or PAID) and payment preimage if paid.
   *
   * @param quote Quote ID to check.
   * @param customRequest Optional override for the request function.
   * @returns Updated quote with current payment state and preimage if available.
   */
  async checkMeltQuoteBolt12(t, e) {
    return await this.requestWithAuth(
      "GET",
      `/v1/melt/quote/bolt12/${t}`,
      {},
      e
    );
  }
  /**
   * Requests the mint to pay for a Bolt11 payment request by providing ecash as inputs to be spent.
   * The inputs contain the amount and the fee_reserves for a Lightning payment. The payload can
   * also contain blank outputs in order to receive back overpaid Lightning fees.
   *
   * @param meltPayload The melt payload containing inputs and optional outputs.
   * @param options.customRequest Optional override for the request function.
   * @param options.preferAsync Optional override to set 'respond-async' header.
   * @returns The melt response.
   */
  async meltBolt11(t, e) {
    const n = {
      ...e?.preferAsync ? { Prefer: "respond-async" } : {}
    }, r = await this.requestWithAuth(
      "POST",
      "/v1/melt/bolt11",
      {
        requestBody: t,
        headers: n
      },
      e?.customRequest
    ), i = At(r, this._logger);
    if (!T(i) || typeof i?.state != "string" || !Object.values(ut).includes(i.state)) {
      const o = T(i) && "detail" in i ? i.detail : void 0;
      throw new Error(o ?? "bad response");
    }
    return i;
  }
  /**
   * Requests the mint to pay a BOLT12 offer by providing ecash inputs to be spent. The inputs must
   * cover the amount plus fee reserves. Optional outputs can be included to receive change for
   * overpaid Lightning fees.
   *
   * @param meltPayload Payload containing quote ID, inputs, and optional outputs for change.
   * @param options.customRequest Optional override for the request function.
   * @param options.preferAsync Optional override to set 'respond-async' header.
   * @returns Payment result with state and optional change signatures.
   */
  async meltBolt12(t, e) {
    const n = {
      ...e?.preferAsync ? { Prefer: "respond-async" } : {}
    };
    return await this.requestWithAuth(
      "POST",
      "/v1/melt/bolt12",
      {
        requestBody: t,
        headers: n
      },
      e?.customRequest
    );
  }
  /**
   * Checks if specific proofs have already been redeemed.
   *
   * @param checkPayload The payload containing proofs to check.
   * @param customRequest Optional override for the request function.
   * @returns Redeemed and unredeemed ordered list of booleans.
   */
  async check(t, e) {
    const n = await this.requestWithAuth(
      "POST",
      "/v1/checkstate",
      { requestBody: t },
      e
    );
    if (!T(n) || !Array.isArray(n?.states)) {
      const r = T(n) && "detail" in n ? n.detail : void 0;
      throw new Error(r ?? "bad response");
    }
    return n;
  }
  /**
   * Get the mint's public keys.
   *
   * @param keysetId Optional param to get the keys for a specific keyset. If not specified, the
   *   keys from all active keysets are fetched.
   * @param mintUrl Optional alternative mint URL to use for this request.
   * @param customRequest Optional override for the request function.
   * @returns The mint's public keys.
   */
  async getKeys(t, e, n) {
    const r = e || this._mintUrl;
    t && (t = t.replace(/\//g, "_").replace(/\+/g, "-"));
    const o = await (n ?? this._request)({
      endpoint: t ? W(r, "/v1/keys", t) : W(r, "/v1/keys")
    });
    if (!T(o) || !Array.isArray(o.keysets)) {
      const a = T(o) && "detail" in o ? o.detail : void 0;
      throw new Error(a ?? "bad response");
    }
    return o;
  }
  /**
   * Get the mint's keysets in no specific order.
   *
   * @param customRequest Optional override for the request function.
   * @returns All the mint's past and current keysets.
   */
  async getKeySets(t) {
    return (t ?? this._request)({ endpoint: W(this._mintUrl, "/v1/keysets") });
  }
  /**
   * Restores proofs from the provided blinded messages.
   *
   * @param restorePayload The payload containing outputs to restore.
   * @param customRequest Optional override for the request function.
   * @returns The restore response with outputs and signatures.
   */
  async restore(t, e) {
    const r = await (e ?? this._request)({
      endpoint: W(this._mintUrl, "/v1/restore"),
      method: "POST",
      requestBody: t
    });
    if (!T(r) || !Array.isArray(r?.outputs) || !Array.isArray(r?.signatures)) {
      const i = T(r) && "detail" in r ? r.detail : void 0;
      throw new Error(i ?? "bad response");
    }
    return r;
  }
  /**
   * Tries to establish a websocket connection with the websocket mint url according to NUT-17.
   */
  async connectWebSocket() {
    if (this.ws)
      await this.ws.ensureConnection();
    else {
      const t = new URL(this._mintUrl), e = "v1/ws";
      t.pathname && (t.pathname.endsWith("/") ? t.pathname += e : t.pathname += "/" + e), this.ws = it.getInstance().getConnection(
        `${t.protocol === "https:" ? "wss" : "ws"}://${t.host}${t.pathname}`
      );
      try {
        await this.ws.connect();
      } catch (n) {
        throw this._logger.error("Failed to connect to WebSocket...", { e: n }), new Error("Failed to connect to WebSocket...");
      }
    }
  }
  /**
   * Closes a websocket connection.
   */
  disconnectWebSocket() {
    this.ws && this.ws.close();
  }
  get webSocketConnection() {
    return this.ws;
  }
  /**
   * Returns the Clear Authentication Token (CAT) to use in the 'Clear-auth' header, or undefined if
   * not required for the given path and method.
   *
   * @param method The method to call on the path.
   * @param path The API path to check for blind auth requirement.
   * @returns The blind auth token if required, otherwise undefined.
   */
  async handleClearAuth(t, e) {
    if (!(!this._authProvider || !(await this.getLazyMintInfo()).requiresClearAuthToken(t, e)))
      return this._logger.error("Clear Authentication Token...", { cat: this._authProvider.getCAT() }), this._authProvider.getCAT();
  }
  /**
   * Returns a serialized Blind Authentication Token (BAT) to use in the 'Blind-auth' header, or
   * undefined if not required for the given path and method.
   *
   * @param method The method to call on the path.
   * @param path The API path to check for blind auth requirement.
   * @returns The blind auth token if required, otherwise undefined.
   */
  async handleBlindAuth(t, e) {
    if (!this._authProvider || !(await this.getLazyMintInfo()).requiresBlindAuthToken(t, e)) return;
    const r = await this._authProvider.getBlindAuthToken({ method: t, path: e });
    return this._logger.error("Blind Authentication Token...", { bat: r }), r;
  }
  async requestWithAuth(t, e, n = {}, r) {
    const i = r ?? this._request, o = await this.handleBlindAuth(t, e), a = await this.handleClearAuth(t, e), c = {
      ...n.headers ?? {},
      ...o ? { "Blind-auth": o } : {},
      ...a ? { "Clear-auth": a } : {}
    };
    return i({
      ...n,
      endpoint: W(this._mintUrl, e),
      method: t,
      headers: c
    });
  }
}
class zn {
  constructor(t, e, n, r, i) {
    this._keys = {}, this._id = t, this._unit = e, this._active = n, this._input_fee_ppk = r, this._final_expiry = i;
  }
  get id() {
    return this._id;
  }
  get unit() {
    return this._unit;
  }
  get isActive() {
    return this._active;
  }
  get fee() {
    return this._input_fee_ppk ?? 0;
  }
  get expiry() {
    return this._final_expiry;
  }
  get hasKeys() {
    return Object.keys(this._keys).length > 0;
  }
  get hasHexId() {
    return Ct(this._id);
  }
  get keys() {
    return this._keys;
  }
  set keys(t) {
    this._keys = t;
  }
  /**
   * For compat with v2 MintKeyset type.
   */
  get active() {
    return this._active;
  }
  /**
   * For compat with v2 MintKeyset type.
   */
  get input_fee_ppk() {
    return this._input_fee_ppk ?? 0;
  }
  /**
   * For compat with v2 MintKeyset type.
   */
  get final_expiry() {
    return this._final_expiry;
  }
  /**
   * To Mint API MintKeyset format.
   *
   * @returns MintKeyset object.
   */
  toMintKeyset() {
    return {
      id: this._id,
      unit: this._unit,
      active: this._active,
      input_fee_ppk: this._input_fee_ppk,
      final_expiry: this._final_expiry
    };
  }
  /**
   * To Mint API MintKeys format.
   *
   * @returns MintKeys object.
   */
  toMintKeys() {
    return this.hasKeys ? {
      id: this._id,
      unit: this._unit,
      keys: this._keys
    } : null;
  }
  /**
   * Verifies that the keyset's ID matches the derived ID from its keys, unit, and expiry.
   *
   * @returns True if verification succeeds, false otherwise (e.g., no keys or mismatch).
   */
  verify() {
    if (!this.hasKeys)
      return !1;
    const t = O(this._id)[0];
    return Qt(this._keys, this._unit, this._final_expiry, t) === this._id;
  }
}
class Ue {
  constructor(t, e, n, r) {
    if (this.keysets = {}, this.mint = typeof t == "string" ? new Vt(t) : t, this.unit = e, n && r) {
      const i = Array.isArray(r) ? r : [r];
      this.buildKeychain(n, i);
    }
  }
  /**
   * Single entry point to load or refresh keysets and keys for the unit.
   *
   * @remarks
   * Fetches in parallel, filters by unit, assigns keys.
   * @param forceRefresh If true, refetch even if loaded.
   */
  async init(t) {
    if (Object.keys(this.keysets).length > 0 && !t)
      return;
    const [e, n] = await Promise.all([this.mint.getKeySets(), this.mint.getKeys()]);
    this.buildKeychain(e.keysets, n.keysets), this.getCheapestKeyset();
  }
  /**
   * Builds keychain from Mint Keyset and Keys data.
   *
   * @param allKeysets Keyset data from mint.getKeySets() API.
   * @param allKeys Keys data from mint.getKeys() API.
   */
  buildKeychain(t, e) {
    this.keysets = {}, t.filter((i) => i.unit === this.unit).forEach((i) => {
      this.keysets[i.id] = new zn(i.id, i.unit, i.active, i.input_fee_ppk, i.final_expiry);
    });
    const r = new Map(
      e.filter((i) => i.unit === this.unit).map((i) => [i.id, i])
    );
    Object.values(this.keysets).forEach((i) => {
      if (!i.hasHexId || !i.isActive) return;
      const o = r.get(i.id);
      if (o && (i.keys = o.keys, !i.verify()))
        throw new Error(`Keyset verification failed for ID ${i.id}`);
    });
  }
  /**
   * Get a keyset by ID or the cheapest keyset if no ID is provided.
   *
   * @param id Optional keyset ID.
   * @returns Keyset with keys.
   * @throws If keyset not found or uninitialized.
   */
  getKeyset(t) {
    const e = t ? this.keysets[t] : this.getCheapestKeyset();
    if (!e)
      throw new Error(`Keyset '${t}' not found`);
    return e;
  }
  /**
   * Get the cheapest active keyset.
   *
   * @remarks
   * Selects active keyset with lowest fee and hex ID.
   * @returns Active Keyset.
   * @throws If none found or uninitialized.
   */
  getCheapestKeyset() {
    if (Object.keys(this.keysets).length === 0)
      throw new Error("KeyChain not initialized");
    const t = Object.values(this.keysets).filter(
      (e) => e.isActive && e.hasHexId && e.hasKeys
    );
    if (t.length === 0)
      throw new Error("No active keyset found");
    return t.sort((e, n) => e.fee - n.fee)[0];
  }
  /**
   * Get list of all keysets for the unit.
   *
   * @returns Array of Keysets.
   * @throws If uninitialized.
   */
  getKeysets() {
    if (Object.keys(this.keysets).length === 0)
      throw new Error("KeyChain not initialized");
    return Object.values(this.keysets);
  }
  /**
   * Extract the Mint API data from the keychain.
   *
   * @remarks
   * Useful for instantiating new wallets / keychains without repeatedly calling the mint API.
   */
  getCache() {
    const t = this.getKeysets(), e = t.filter((n) => n.hasKeys).map((n) => n.toMintKeys()).filter((n) => n !== null);
    return {
      keysets: t.map((n) => n.toMintKeyset()),
      keys: e,
      unit: this.unit,
      mintUrl: this.mint.mintUrl
    };
  }
}
class vt {
  constructor(t, e, n) {
    this.amount = t, this.B_ = e, this.id = n;
  }
  getSerializedBlindedMessage() {
    return { amount: this.amount, B_: this.B_.toHex(!0), id: this.id };
  }
}
const Vn = /* @__PURE__ */ new Set([
  "locktime",
  "pubkeys",
  "n_sigs",
  "refund",
  "n_sigs_refund"
]);
function Re(s) {
  if (!s || typeof s != "string") throw new Error("tag key must be a non empty string");
  if (Vn.has(s))
    throw new Error(`additionalTags must not use reserved key "${s}"`);
}
const re = 1024, xt = /* @__PURE__ */ new WeakMap();
function Gn(s, t) {
  t && xt.set(s, t);
}
function Jn(s) {
  const t = xt.get(s);
  if (t)
    return xt.delete(s), t;
}
class N {
  constructor(t, e, n) {
    this.secret = n, this.blindingFactor = e, this.blindedMessage = t;
  }
  toProof(t, e) {
    let n;
    t.dleq && (n = {
      s: H(t.dleq.s),
      e: H(t.dleq.e),
      r: this.blindingFactor
    });
    const r = {
      id: t.id,
      amount: t.amount,
      C_: X(t.C_)
    }, i = X(e.keys[t.amount]), o = Sn(r, this.blindingFactor, this.secret, i), a = {
      ...Tn(o),
      ...n && {
        dleq: {
          s: J(n.s),
          e: J(n.e),
          r: Mt(n.r ?? BigInt(0))
        }
      }
    }, c = Jn(this);
    return c && (a.p2pk_e = c), a;
  }
  static createP2PKData(t, e, n, r) {
    return G(e, n.keys, r).map((o) => this.createSingleP2PKData(t, o, n.id));
  }
  static createSingleP2PKData(t, e, n) {
    const r = Array.isArray(t.pubkey) ? t.pubkey : [t.pubkey], i = t.refundKeys ?? [], o = Math.max(1, Math.min(t.requiredSignatures ?? 1, r.length)), a = Math.max(
      1,
      Math.min(t.requiredRefundSignatures ?? 1, i.length || 1)
    );
    let c = r[0], u = r.slice(1), l = i, h;
    if (t.blindKeys) {
      const x = [c, ...u, ...i], { blinded: S, Ehex: B } = gn(x, n);
      c = S[0], u = S.slice(1, r.length), l = S.slice(r.length), h = B;
    }
    const d = [], p = t.locktime ?? NaN;
    if (Number.isSafeInteger(p) && p >= 0 && d.push(["locktime", String(p)]), u.length > 0 && (d.push(["pubkeys", ...u]), o > 1 && d.push(["n_sigs", String(o)])), l.length > 0 && (d.push(["refund", ...l]), a > 1 && d.push(["n_sigs_refund", String(a)])), t.additionalTags?.length) {
      const x = t.additionalTags.map(([S, ...B]) => (Re(S), [S, ...B.map(String)]));
      d.push(...x);
    }
    const m = [
      "P2PK",
      {
        nonce: J(Xt(32)),
        data: c,
        tags: d
      }
    ], P = JSON.stringify(m), A = [...P].length;
    if (A > re)
      throw new Error(`Secret too long (${A} characters), maximum is ${re}`);
    const w = new TextEncoder().encode(P), { r: v, B_: I } = gt(w), U = new N(
      new vt(e, I, n).getSerializedBlindedMessage(),
      v,
      w
    );
    return t.blindKeys && h && Gn(U, h), U;
  }
  static createRandomData(t, e, n) {
    return G(t, e.keys, n).map((i) => this.createSingleRandomData(i, e.id));
  }
  static createSingleRandomData(t, e) {
    const n = J(Xt(32)), r = new TextEncoder().encode(n), { r: i, B_: o } = gt(r);
    return new N(
      new vt(t, o, e).getSerializedBlindedMessage(),
      i,
      r
    );
  }
  static createDeterministicData(t, e, n, r, i) {
    return G(t, r.keys, i).map(
      (a, c) => this.createSingleDeterministicData(a, e, n + c, r.id)
    );
  }
  static createSingleDeterministicData(t, e, n, r) {
    const i = xn(e, r, n), o = J(i), a = new TextEncoder().encode(o), c = $(Bn(e, r, n)), { r: u, B_: l } = gt(a, c);
    return new N(
      new vt(t, l, r).getSerializedBlindedMessage(),
      u,
      a
    );
  }
  /**
   * Calculates the sum of amounts in an array of OutputDataLike objects.
   *
   * @param outputs Array of OutputDataLike objects.
   * @returns The total sum of amounts.
   */
  static sumOutputAmounts(t) {
    return t.reduce((e, n) => e + n.blindedMessage.amount, 0);
  }
}
function ie(s) {
  const t = s.toLowerCase();
  if (t.length === 66 && (t.startsWith("02") || t.startsWith("03"))) return t;
  if (t.length === 64) return `02${t}`;
  throw new Error(
    `Invalid pubkey, expected 33 byte compressed or 32 byte x only, got length ${t.length}`
  );
}
function Xn(s) {
  return s instanceof Date ? Math.floor(s.getTime() / 1e3) : s < 1e12 ? Math.floor(s) : Math.floor(s / 1e3);
}
class Ne {
  constructor() {
    this.lockSet = /* @__PURE__ */ new Set(), this.refundSet = /* @__PURE__ */ new Set(), this.extraTags = [];
  }
  addLockPubkey(t) {
    const e = Array.isArray(t) ? t : [t];
    for (const n of e) this.lockSet.add(ie(n));
    return this;
  }
  addRefundPubkey(t) {
    const e = Array.isArray(t) ? t : [t];
    for (const n of e) this.refundSet.add(ie(n));
    return this;
  }
  lockUntil(t) {
    return this.locktime = Xn(t), this;
  }
  requireLockSignatures(t) {
    return this.nSigs = Math.max(1, Math.trunc(t)), this;
  }
  requireRefundSignatures(t) {
    return this.nSigsRefund = Math.max(1, Math.trunc(t)), this;
  }
  addTag(t, e) {
    Re(t);
    const n = e === void 0 ? [] : Array.isArray(e) ? e : [e];
    return this.extraTags.push([t, ...n.map(String)]), this;
  }
  addTags(t) {
    for (const [e, ...n] of t) this.addTag(e, n);
    return this;
  }
  /**
   * @alpha
   */
  blindKeys() {
    return this._blindKeys = !0, this;
  }
  toOptions() {
    const t = Array.from(this.lockSet), e = Array.from(this.refundSet);
    if (t.length === 0) throw new Error("At least one lock pubkey is required");
    if (e.length > 0 && this.locktime === void 0)
      throw new Error(
        "Refund pubkeys require a locktime, add lockUntil(...) or remove refund keys"
      );
    const n = t.length + e.length;
    if (n > 10)
      throw new Error(`Too many pubkeys, ${n} provided, maximum allowed is 10 in total`);
    const r = this.nSigs ? Math.min(Math.max(1, this.nSigs), t.length) : void 0, i = this.nSigsRefund ? Math.min(Math.max(1, this.nSigsRefund), Math.max(1, e.length)) : void 0, a = {
      pubkey: t.length === 1 ? t[0] : t,
      ...this.locktime !== void 0 ? { locktime: this.locktime } : {},
      ...e.length ? { refundKeys: e } : {},
      ...r && r > 1 ? { requiredSignatures: r } : {},
      ...i && i > 1 ? { requiredRefundSignatures: i } : {},
      ...this.extraTags.length ? { additionalTags: this.extraTags.slice() } : {},
      ...this._blindKeys ? { blindKeys: !0 } : {}
    };
    return N.createSingleP2PKData(a, 1, "deedbeef"), a;
  }
  static fromOptions(t) {
    const e = new Ne(), n = Array.isArray(t.pubkey) ? t.pubkey : [t.pubkey];
    return e.addLockPubkey(n), t.locktime !== void 0 && e.lockUntil(t.locktime), t.refundKeys?.length && e.addRefundPubkey(t.refundKeys), t.requiredSignatures !== void 0 && e.requireLockSignatures(t.requiredSignatures), t.requiredRefundSignatures !== void 0 && e.requireRefundSignatures(t.requiredRefundSignatures), t.additionalTags?.length && e.addTags(t.additionalTags), t.blindKeys && e.blindKeys(), e;
  }
}
const Yn = (s, t, e, n = !1, r = !1, i = L) => {
  const h = He();
  let d = null, p = 1 / 0, m = 0, P = 0;
  const A = (f) => {
    try {
      return e.getKeyset(f.id).fee;
    } catch (g) {
      bt(`Could not get fee. No keyset found for keyset id: ${f.id}`, i, {
        error: g,
        keychain: e.getKeysets()
      });
    }
  }, w = (f, g) => f - (n ? Math.ceil(g / 1e3) : 0), v = (f) => {
    const g = [...f];
    for (let k = g.length - 1; k > 0; k--) {
      const y = Math.floor(Math.random() * (k + 1));
      [g[k], g[y]] = [g[y], g[k]];
    }
    return g;
  }, I = (f, g, k) => {
    let y = 0, F = f.length - 1, E = null;
    for (; y <= F; ) {
      const z = Math.floor((y + F) / 2), et = f[z].exFee;
      (k ? et <= g : et >= g) ? (E = z, k ? y = z + 1 : F = z - 1) : k ? F = z - 1 : y = z + 1;
    }
    return k ? E : y < f.length ? y : null;
  }, U = (f, g) => {
    const k = g.exFee;
    let y = 0, F = f.length;
    for (; y < F; ) {
      const E = Math.floor((y + F) / 2);
      f[E].exFee < k ? y = E + 1 : F = E;
    }
    f.splice(y, 0, g);
  }, x = (f, g) => w(f, g) < t ? 1 / 0 : f + g / 1e3 - t;
  let S = 0, B = 0;
  const at = s.map((f) => {
    const g = A(f), k = n ? f.amount - g / 1e3 : f.amount, y = { proof: f, exFee: k, ppkfee: g };
    return (!n || k > 0) && (S += f.amount, B += g), y;
  });
  let M = n ? at.filter((f) => f.exFee > 0) : at;
  if (M.sort((f, g) => f.exFee - g.exFee), M.length > 0) {
    let f;
    if (r) {
      const g = I(M, t, !0);
      f = g !== null ? g + 1 : 0;
    } else {
      const g = I(M, t, !1);
      if (g !== null) {
        const k = M[g].exFee, y = I(M, k, !0);
        de(y, "Unexpected null rightIndex in binary search", i), f = y + 1;
      } else
        f = M.length;
    }
    for (let g = f; g < M.length; g++)
      S -= M[g].proof.amount, B -= M[g].ppkfee;
    M = M.slice(0, f);
  }
  const Z = w(S, B);
  if (t <= 0 || t > Z)
    return { keep: s, send: [] };
  const tt = Math.min(
    Math.ceil(t * (1 + 0 / 100)),
    t + 0,
    Z
  );
  for (let f = 0; f < 60; f++) {
    const g = [];
    let k = 0, y = 0;
    for (const C of v(M)) {
      const R = k + C.proof.amount, D = y + C.ppkfee, j = w(R, D);
      if (r && j > t || (g.push(C), k = R, y = D, j >= t)) break;
    }
    const F = new Set(g), E = M.filter((C) => !F.has(C)), z = v(Array.from({ length: g.length }, (C, R) => R)).slice(
      0,
      5e3
    );
    for (const C of z) {
      const R = w(k, y);
      if (R === t || !r && R >= t && R <= tt)
        break;
      const D = g[C], j = k - D.proof.amount, nt = y - D.ppkfee, Fe = w(j, nt), Jt = t - Fe, _t = I(E, Jt, r);
      if (_t !== null) {
        const ct = E[_t];
        (!r || ct.exFee > D.exFee) && (Jt >= 0 || ct.exFee <= D.exFee) && (g[C] = ct, k = j + ct.proof.amount, y = nt + ct.ppkfee, E.splice(_t, 1), U(E, D));
      }
    }
    const et = x(k, y);
    if (et < p) {
      i.debug(
        `selectProofsToSend: best solution found in trial #${f} - amount: ${k}, delta: ${et}`
      ), d = [...g].sort((R, D) => D.exFee - R.exFee), p = et, m = k, P = y;
      const C = [...d];
      for (; C.length > 1 && p > 0; ) {
        const R = C.pop(), D = k - R.proof.amount, j = y - R.ppkfee, nt = x(D, j);
        if (nt == 1 / 0) break;
        nt < p && (d = [...C], p = nt, m = D, P = j, k = D, y = j);
      }
    }
    if (d && p < 1 / 0) {
      const C = w(m, P);
      if (C === t || !r && C >= t && C <= tt)
        break;
    }
    if (h.elapsed() > 1e3) {
      le(
        r,
        "Proof selection took too long. Try again with a smaller proof set.",
        i
      ), i.warn("Proof selection took too long. Returning best selection so far.");
      break;
    }
  }
  if (d && p < 1 / 0) {
    const f = d.map((y) => y.proof), g = new Set(f), k = s.filter((y) => !g.has(y));
    return i.info(`Proof selection took ${h.elapsed()}ms`), { keep: k, send: f };
  }
  return { keep: s, send: [] };
};
class Zn {
  constructor(t) {
    if (this.next = /* @__PURE__ */ new Map(), this.locks = /* @__PURE__ */ new Map(), t)
      for (const [e, n] of Object.entries(t)) this.next.set(e, n);
  }
  async withLock(t, e) {
    const n = this.locks.get(t) ?? Promise.resolve();
    let r;
    const i = new Promise((a) => r = a), o = n.then(() => i);
    this.locks.set(t, o);
    try {
      return await n, await e();
    } finally {
      r(), this.locks.get(t) === o && this.locks.delete(t);
    }
  }
  async reserve(t, e) {
    if (e < 0) throw new Error("reserve called with negative count");
    return this.withLock(t, () => {
      const n = this.next.get(t) ?? 0;
      return e === 0 ? { start: n, count: 0 } : (this.next.set(t, n + e), { start: n, count: e });
    });
  }
  async advanceToAtLeast(t, e) {
    await this.withLock(t, () => {
      const n = this.next.get(t) ?? 0;
      e > n && this.next.set(t, e);
    });
  }
  async setNext(t, e) {
    await this.withLock(t, () => {
      if (e < 0) throw new Error("setNext: negative next not allowed");
      this.next.set(t, e);
    });
  }
  snapshot() {
    return Promise.resolve(Object.fromEntries(this.next.entries()));
  }
}
class ts {
  constructor(t) {
    this.wallet = t;
  }
  send(t, e) {
    return new es(this.wallet, t, e);
  }
  receive(t) {
    return new ns(this.wallet, t);
  }
  mintBolt11(t, e) {
    return new oe(this.wallet, "bolt11", t, e);
  }
  mintBolt12(t, e) {
    return new oe(this.wallet, "bolt12", t, e);
  }
  meltBolt11(t, e) {
    return new ae(this.wallet, "bolt11", t, e);
  }
  meltBolt12(t, e) {
    return new ae(this.wallet, "bolt12", t, e);
  }
}
class es {
  constructor(t, e, n) {
    this.wallet = t, this.amount = e, this.proofs = n, this.config = {};
  }
  /**
   * Use random blinding for the sent outputs.
   *
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asRandom(t) {
    return this.sendOT = { type: "random", denominations: t }, this;
  }
  /**
   * Use deterministic outputs for the sent proofs.
   *
   * @param counter Starting counter. Zero means auto reserve using the wallets CounterSource.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asDeterministic(t = 0, e) {
    return this.sendOT = { type: "deterministic", counter: t, denominations: e }, this;
  }
  /**
   * Use P2PK locked outputs for the sent proofs.
   *
   * @param options NUT 11 options like pubkey and locktime.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asP2PK(t, e) {
    return this.sendOT = { type: "p2pk", options: t, denominations: e }, this;
  }
  /**
   * Use a factory to generate OutputData for the sent proofs.
   *
   * @param factory OutputDataFactory used to produce blinded messages.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asFactory(t, e) {
    return this.sendOT = { type: "factory", factory: t, denominations: e }, this;
  }
  /**
   * Provide pre created OutputData for the sent proofs.
   *
   * @param data Fully formed OutputData. Their amounts must sum to the send amount, otherwise the
   *   wallet will throw.
   */
  asCustom(t) {
    return this.sendOT = { type: "custom", data: t }, this;
  }
  /**
   * Use random blinding for change outputs.
   *
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  keepAsRandom(t) {
    return this.keepOT = { type: "random", denominations: t }, this;
  }
  /**
   * Use deterministic outputs for change.
   *
   * @param counter Starting counter. Zero means auto reserve using the wallets CounterSource.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  keepAsDeterministic(t = 0, e) {
    return this.keepOT = { type: "deterministic", counter: t, denominations: e }, this;
  }
  /**
   * Use P2PK locked change (NUT 11).
   *
   * @param options Locking options applied to the kept proofs.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  keepAsP2PK(t, e) {
    return this.keepOT = { type: "p2pk", options: t, denominations: e }, this;
  }
  /**
   * Use a factory to generate OutputData for change.
   *
   * @param factory OutputDataFactory used to produce blinded messages.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  keepAsFactory(t, e) {
    return this.keepOT = { type: "factory", factory: t, denominations: e }, this;
  }
  /**
   * Provide pre created OutputData for change.
   *
   * @param data Fully formed OutputData for the keep (change) amount.
   */
  keepAsCustom(t) {
    return this.keepOT = { type: "custom", data: t }, this;
  }
  /**
   * Make the sender cover the receivers future spend fee.
   *
   * @param on When true, include fees in the sent amount. Default true if called.
   */
  includeFees(t = !0) {
    return this.config.includeFees = t, this;
  }
  /**
   * Use a specific keyset for the operation.
   *
   * @param id Keyset id to use for mint keys and fee lookup.
   */
  keyset(t) {
    return this.config.keysetId = t, this;
  }
  /**
  * Provide existing proofs to help optimise denomination selection.
  *
  * @remarks
  * Has no effect if denominations (custom split) was specified.
  * @param p Proofs currently held by the wallet, used to hit denomination targets.
  */
  proofsWeHave(t) {
    return this.config.proofsWeHave = t, this;
  }
  /**
   * Receive a callback once counters are atomically reserved for deterministic outputs.
   *
   * @param cb Called with OperationCounters when counters are reserved.
   */
  onCountersReserved(t) {
    return this.config.onCountersReserved = t, this;
  }
  /**
   * Force a pure offline, exact match selection. No mint calls are made. If an exact match cannot
   * be found, this throws.
   *
   * @param requireDleq Only consider proofs with a DLEQ when true.
   */
  offlineExactOnly(t = !1) {
    return this.offlineExact = { requireDleq: t }, this;
  }
  /**
   * Force a pure offline selection that allows a close match, overspend permitted per wallet RGLI.
   * No mint calls are made. Returns the best offline subset found, or throws if funds are
   * insufficient.
   *
   * @param requireDleq Only consider proofs with a DLEQ when true.
   */
  offlineCloseMatch(t = !1) {
    return this.offlineClose = { requireDleq: t }, this;
  }
  /**
   * Execute the send or swap.
   *
   * @returns The split result with kept and sent proofs.
   */
  async run() {
    if ((this.offlineExact || this.offlineClose) && (this.sendOT || this.keepOT))
      throw new Error(
        "Offline selection cannot be combined with custom output types. Remove send/keep output configuration, or use an online swap."
      );
    if (this.offlineExact)
      return this.wallet.sendOffline(this.amount, this.proofs, {
        includeFees: this.config.includeFees,
        exactMatch: !0,
        requireDleq: this.offlineExact.requireDleq
      });
    if (this.offlineClose)
      return this.wallet.sendOffline(this.amount, this.proofs, {
        includeFees: this.config.includeFees,
        exactMatch: !1,
        requireDleq: this.offlineClose.requireDleq
      });
    const t = {
      send: this.sendOT ?? this.wallet.defaultOutputType(),
      ...this.keepOT ? { keep: this.keepOT } : {}
    };
    return this.wallet.send(this.amount, this.proofs, this.config, t);
  }
}
class ns {
  constructor(t, e) {
    this.wallet = t, this.token = e, this.config = {};
  }
  /**
   * Use random blinding for the received outputs.
   *
   * @remarks
   * If denoms specified, proofsWeHave() will have no effect.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asRandom(t) {
    return this.outputType = { type: "random", denominations: t }, this;
  }
  /**
   * Use deterministic outputs for the received proofs.
   *
   * @remarks
   * If denoms specified, proofsWeHave() will have no effect.
   * @param counter Starting counter. Zero means auto reserve using the wallets CounterSource.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asDeterministic(t = 0, e) {
    return this.outputType = { type: "deterministic", counter: t, denominations: e }, this;
  }
  /**
   * Use P2PK locked outputs for the received proofs.
   *
   * @remarks
   * If denoms specified, proofsWeHave() will have no effect.
   * @param options NUT 11 options like pubkey and locktime.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asP2PK(t, e) {
    return this.outputType = { type: "p2pk", options: t, denominations: e }, this;
  }
  /**
   * Use a factory to generate OutputData for received proofs.
   *
   * @remarks
   * If denoms specified, proofsWeHave() will have no effect.
   * @param factory OutputDataFactory used to produce blinded messages.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asFactory(t, e) {
    return this.outputType = { type: "factory", factory: t, denominations: e }, this;
  }
  /**
   * Provide pre created OutputData for received proofs.
   *
   * @param data Fully formed OutputData for the final amount.
   */
  asCustom(t) {
    return this.outputType = { type: "custom", data: t }, this;
  }
  /**
   * Use a specific keyset for the operation.
   *
   * @param id Keyset id to use for mint keys and fee lookup.
   */
  keyset(t) {
    return this.config.keysetId = t, this;
  }
  /**
   * Require all incoming proofs to have a valid DLEQ for the selected keyset.
   *
   * @param on When true, proofs without DLEQ are rejected.
   */
  requireDleq(t = !0) {
    return this.config.requireDleq = t, this;
  }
  /**
   * Private key used to sign P2PK locked incoming proofs.
   *
   * @param k Single key or array of multisig keys.
   */
  privkey(t) {
    return this.config.privkey = t, this;
  }
  /**
   * Provide existing proofs to help optimise denomination selection.
   *
   * @remarks
   * Has no effect if denominations (custom split) was specified.
   * @param p Proofs currently held by the wallet, used to hit denomination targets.
   */
  proofsWeHave(t) {
    return this.config.proofsWeHave = t, this;
  }
  /**
   * Receive a callback once counters are atomically reserved for deterministic outputs.
   *
   * @param cb Called with OperationCounters when counters are reserved.
   */
  onCountersReserved(t) {
    return this.config.onCountersReserved = t, this;
  }
  async run() {
    return this.wallet.receive(this.token, this.config, this.outputType);
  }
}
class oe {
  constructor(t, e, n, r) {
    this.wallet = t, this.method = e, this.amount = n, this.quote = r, this.config = {}, this._hasPrivkey;
  }
  /**
   * Use random blinding for the minted proofs.
   *
   * @remarks
   * If denoms specified, proofsWeHave() will have no effect.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asRandom(t) {
    return this.outputType = { type: "random", denominations: t }, this;
  }
  /**
   * Use deterministic outputs for the minted proofs.
   *
   * @remarks
   * If denoms specified, proofsWeHave() will have no effect.
   * @param counter Starting counter. Zero means auto reserve using the wallets CounterSource.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asDeterministic(t = 0, e) {
    return this.outputType = { type: "deterministic", counter: t, denominations: e }, this;
  }
  /**
   * Use P2PK locked outputs for the minted proofs.
   *
   * @remarks
   * If denoms specified, proofsWeHave() will have no effect.
   * @param options NUT 11 options like pubkey and locktime.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asP2PK(t, e) {
    return this.outputType = { type: "p2pk", options: t, denominations: e }, this;
  }
  /**
   * Use a factory to generate OutputData for minted proofs.
   *
   * @remarks
   * If denoms specified, proofsWeHave() will have no effect.
   * @param factory OutputDataFactory used to produce blinded messages.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asFactory(t, e) {
    return this.outputType = { type: "factory", factory: t, denominations: e }, this;
  }
  /**
   * Provide pre created OutputData for minted proofs.
   *
   * @param data Fully formed OutputData for the final amount.
   */
  asCustom(t) {
    return this.outputType = { type: "custom", data: t }, this;
  }
  /**
   * Use a specific keyset for the operation.
   *
   * @param id Keyset id to use for mint keys and fee lookup.
   */
  keyset(t) {
    return this.config.keysetId = t, this;
  }
  /**
   * Private key to sign locked mint quotes.
   *
   * @param k Private key for locked quotes.
   */
  privkey(t) {
    return this.config.privkey = t, this;
  }
  /**
   * Provide existing proofs to help optimise denomination selection.
   *
   * @remarks
   * Has no effect if denominations (custom split) was specified.
   * @param p Proofs currently held by the wallet, used to hit denomination targets.
   */
  proofsWeHave(t) {
    return this.config.proofsWeHave = t, this;
  }
  /**
   * Receive a callback once counters are atomically reserved for deterministic outputs.
   *
   * @param cb Called with OperationCounters when counters are reserved.
   */
  onCountersReserved(t) {
    return this.config.onCountersReserved = t, this;
  }
  /**
   * Execute minting against the quote.
   *
   * @remarks
   * This method can only be called for bolt12 quotes when .privkey() is set.
   * @returns The newly minted proofs.
   */
  async run() {
    if (this.method === "bolt11") {
      const e = this.quote;
      if (e.pubkey && !this.config.privkey)
        throw new Error("privkey is required for locked BOLT11 mint quotes");
      return this.wallet.mintProofsBolt11(this.amount, e, this.config, this.outputType);
    }
    const t = this.quote;
    if (!this.config.privkey)
      throw new Error("privkey is required for BOLT12 mint quotes");
    return this.wallet.mintProofsBolt12(
      this.amount,
      t,
      this.config.privkey,
      this.config,
      this.outputType
    );
  }
}
class ae {
  constructor(t, e, n, r) {
    this.wallet = t, this.method = e, this.quote = n, this.proofs = r, this.config = {};
  }
  /**
   * Use random blinding for change outputs.
   *
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asRandom(t) {
    return this.outputType = { type: "random", denominations: t }, this;
  }
  /**
   * Use deterministic outputs for change.
   *
   * @param counter Starting counter. Zero means auto reserve using the wallets CounterSource.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asDeterministic(t = 0, e) {
    return this.outputType = { type: "deterministic", counter: t, denominations: e }, this;
  }
  /**
   * Use P2PK-locked change (NUT-11).
   *
   * @param options NUT-11 locking options (e.g., pubkey, locktime).
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asP2PK(t, e) {
    return this.outputType = { type: "p2pk", options: t, denominations: e }, this;
  }
  /**
   * Use a factory to generate OutputData for change.
   *
   * @param factory Factory used to produce blinded messages.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asFactory(t, e) {
    return this.outputType = { type: "factory", factory: t, denominations: e }, this;
  }
  /**
   * Provide pre-created OutputData for change.
   *
   * @param data Fully formed OutputData for the change amount.
   */
  asCustom(t) {
    return this.outputType = { type: "custom", data: t }, this;
  }
  /**
   * Use a specific keyset for the melt operation.
   *
   * @param id Keyset id to use for mint keys and fee lookup.
   */
  keyset(t) {
    return this.config.keysetId = t, this;
  }
  /**
   * Receive a callback once counters are atomically reserved for deterministic outputs.
   *
   * @param cb Called with OperationCounters when counters are reserved.
   */
  onCountersReserved(t) {
    return this.config.onCountersReserved = t, this;
  }
  /**
   * Receive a callback when NUT-08 blanks (0-sat change outputs) are created for async melts.
   *
   * @remarks
   * You can persist these blanks and later call `wallet.completeMelt(blanks)` to finalize and
   * recover change once the invoice/offer is paid.
   * @param cb Callback invoked with the created blanks payload.
   */
  onChangeOutputsCreated(t) {
    return this.config.onChangeOutputsCreated = t, this;
  }
  /**
   * Execute the melt against the quote.
   *
   * @returns The melt result: `{ quote, change }`.
   */
  async run() {
    return this.method === "bolt11" ? this.wallet.meltProofsBolt11(this.quote, this.proofs, this.config, this.outputType) : this.wallet.meltProofsBolt12(this.quote, this.proofs, this.config, this.outputType);
  }
}
function ss(s) {
  const t = /* @__PURE__ */ new WeakSet();
  try {
    return JSON.stringify(s, (e, n) => {
      if (typeof n == "object" && n !== null) {
        if (t.has(n)) return "[Circular]";
        t.add(n);
      }
      return n;
    });
  } catch {
    return Object.prototype.toString.call(s);
  }
}
function ce(s) {
  if (s instanceof Error) return s;
  const t = typeof s == "string" ? s : ss(s), e = new Error(t);
  return e.cause = s, e;
}
function ue() {
  const s = new Error("Aborted");
  return Object.defineProperty(s, "name", { value: "AbortError" }), s;
}
function st(s) {
  s && Promise.resolve(s).then((t) => {
    try {
      t();
    } catch {
    }
  }).catch(() => {
  });
}
class rs {
  constructor(t) {
    this.wallet = t, this.countersReservedHandlers = /* @__PURE__ */ new Set(), this.meltBlanksHandlers = /* @__PURE__ */ new Set();
  }
  // Binds an abort signal to each subscription canceller
  withAbort(t, e) {
    if (!t) return e;
    if (t.aborted)
      return e(), () => {
      };
    const n = () => e();
    return t.addEventListener("abort", n, { once: !0 }), () => {
      t.removeEventListener("abort", n), e();
    };
  }
  // Subscribe to a quote-paid event and resolve when it fires.
  // Supports AbortSignal and timeout, and always cleans up.
  waitUntilPaid(t, e, n, r = "Timeout waiting for paid") {
    return new Promise((i, o) => {
      let a = null, c = null;
      const u = (h) => {
        st(a), c && (clearTimeout(c), c = null), n?.signal && n.signal.removeEventListener("abort", l), h && o(ce(h));
      }, l = () => u(ue());
      if (n?.signal) {
        if (n.signal.aborted) return l();
        n.signal.addEventListener("abort", l, { once: !0 });
      }
      n?.timeoutMs && n.timeoutMs > 0 && (c = setTimeout(() => u(new Error(r)), n.timeoutMs)), a = t(
        e,
        (h) => {
          u(), i(h);
        },
        (h) => u(h),
        // reject if subscription itself errors
        { signal: n?.signal }
        // delegate abort to subscription as well
      );
    });
  }
  /**
   * Register a callback that fires whenever deterministic counters are reserved.
   *
   * Timing: the callback is invoked synchronously _after_ a successful reservation and _before_ the
   * enclosing wallet method returns. The wallet does **not** await your callback, it is
   * fire-and-forget.
   *
   * Responsibility for async work is on the consumer. If your handler calls an async function (e.g.
   * persisting `start + count` to storage), make sure to handle errors inside it to avoid unhandled
   * rejections.
   *
   * Typical use: persist `start + count` for the `keysetId` so counters survive restarts.
   *
   * @example
   *
   * ```ts
   * wallet.on.countersReserved(({ keysetId, start, count, next }) => {
   * 	saveNextToDb(keysetId, start + count); // handle async errors inside saveNextToDb
   * });
   * ```
   *
   * @param cb Handler called with { keysetId, start, count }.
   * @returns A function that unsubscribes the handler.
   */
  countersReserved(t, e) {
    this.countersReservedHandlers.add(t);
    const n = () => this.countersReservedHandlers.delete(t);
    return this.withAbort(e?.signal, n);
  }
  /**
   * @internal
   */
  _emitCountersReserved(t) {
    for (const e of this.countersReservedHandlers)
      lt(e, t, this.wallet.logger, { event: "countersReserved" });
  }
  /**
   * Register a callback fired whenever NUT-08 blanks are created during a melt.
   *
   * Called synchronously right after blanks are prepared (before the melt request), and the wallet
   * does not await your handler.
   *
   * Typical use: persist `payload` so you can later call `wallet.completeMelt(payload)`.
   */
  meltBlanksCreated(t, e) {
    this.meltBlanksHandlers.add(t);
    const n = () => this.meltBlanksHandlers.delete(t);
    return this.withAbort(e?.signal, n);
  }
  /**
   * @internal
   */
  _emitMeltBlanksCreated(t) {
    for (const e of this.meltBlanksHandlers)
      lt(e, t, this.wallet.logger, { event: "meltBlanksCreated" });
  }
  /**
   * Register a callback to be called whenever a mint quote's state changes.
   *
   * @param quoteIds List of mint quote IDs that should be subscribed to.
   * @param callback Callback function that will be called whenever a mint quote state changes.
   * @param errorCallback
   * @returns
   */
  async mintQuoteUpdates(t, e, n, r) {
    await this.wallet.mint.connectWebSocket();
    const i = this.wallet.mint.webSocketConnection;
    if (!i) throw new Error("Failed to establish WebSocket connection.");
    const o = Array.from(new Set(t)), a = i.createSubscription({ kind: "bolt11_mint_quote", filters: o }, e, n), c = () => i.cancelSubscription(a, e);
    return this.withAbort(r?.signal, c);
  }
  /**
   * Register a callback to be called when a single mint quote gets paid.
   *
   * @param quoteId Mint quote id that should be subscribed to.
   * @param callback Callback function that will be called when this mint quote gets paid.
   * @param errorCallback
   * @returns
   */
  async mintQuotePaid(t, e, n, r) {
    return this.mintQuoteUpdates(
      [t],
      (i) => {
        i.state === Tt.PAID && e(i);
      },
      n,
      r
    );
  }
  /**
   * Register a callback to be called whenever a melt quotes state changes.
   *
   * @param quoteId Melt quote id that should be subscribed to.
   * @param callback Callback function that will be called when this melt quote gets paid.
   * @param errorCallback
   * @returns
   */
  async meltQuoteUpdates(t, e, n, r) {
    await this.wallet.mint.connectWebSocket();
    const i = this.wallet.mint.webSocketConnection;
    if (!i) throw new Error("Failed to establish WebSocket connection.");
    const o = Array.from(new Set(t)), a = i.createSubscription({ kind: "bolt11_melt_quote", filters: o }, e, n), c = () => i.cancelSubscription(a, e);
    return this.withAbort(r?.signal, c);
  }
  /**
   * Register a callback to be called when a single melt quote gets paid.
   *
   * @param quoteIds List of melt quote IDs that should be subscribed to.
   * @param callback Callback function that will be called whenever a melt quote state changes.
   * @param errorCallback
   * @returns
   */
  async meltQuotePaid(t, e, n, r) {
    return this.meltQuoteUpdates(
      [t],
      (i) => {
        i.state === ut.PAID && e(i);
      },
      n,
      r
    );
  }
  /**
   * Register a callback to be called whenever a subscribed proof state changes.
   *
   * @param proofs List of proofs that should be subscribed to.
   * @param callback Callback function that will be called whenever a proof's state changes.
   * @param errorCallback
   * @returns
   */
  async proofStateUpdates(t, e, n, r) {
    await this.wallet.mint.connectWebSocket();
    const i = this.wallet.mint.webSocketConnection;
    if (!i) throw new Error("Failed to establish WebSocket connection.");
    const o = new TextEncoder(), a = {};
    for (const d of t) {
      const p = ft(o.encode(d.secret)).toHex(!0);
      a[p] = d;
    }
    const c = Object.keys(a), u = (d) => {
      e({ ...d, proof: a[d.Y] });
    }, l = i.createSubscription({ kind: "proof_state", filters: c }, u, n), h = () => i.cancelSubscription(l, u);
    return this.withAbort(r?.signal, h);
  }
  /**
   * Resolve once a mint quote transitions to PAID, with automatic unsubscription, optional abort
   * signal, and optional timeout.
   *
   * The underlying subscription is always cancelled after resolution or rejection, including on
   * timeout or abort.
   *
   * @example
   *
   * ```ts
   * const ac = new AbortController();
   * // Cancel if the user navigates away
   * window.addEventListener('beforeunload', () => ac.abort(), { once: true });
   *
   * try {
   * 	const paid = await wallet.on.onceMintPaid(quoteId, {
   * 		signal: ac.signal,
   * 		timeoutMs: 60_000,
   * 	});
   * 	console.log('Mint paid, amount', paid.amount);
   * } catch (e) {
   * 	if ((e as Error).name === 'AbortError') {
   * 		console.log('User aborted');
   * 	} else {
   * 		console.error('Mint not paid', e);
   * 	}
   * }
   * ```
   *
   * @param id Mint quote id to watch.
   * @param opts Optional controls.
   * @param opts.signal AbortSignal to cancel the wait early.
   * @param opts.timeoutMs Milliseconds to wait before rejecting with a timeout error.
   * @returns A promise that resolves with the latest `MintQuoteResponse` once PAID.
   */
  onceMintPaid(t, e) {
    return this.waitUntilPaid(
      this.mintQuotePaid.bind(this),
      t,
      e,
      "Timeout waiting for mint paid"
    );
  }
  /**
   * Resolve when ANY of several mint quotes is PAID, cancelling the rest.
   *
   * Subscribes to all distinct ids, resolves with `{ id, quote }` for the first PAID, and cancels
   * all remaining subscriptions.
   *
   * Errors from individual subscriptions are ignored by default so a single noisy stream does not
   * abort the whole race. Set `failOnError: true` to reject on the first error instead. If all
   * subscriptions error and none paid, the promise rejects with the last seen error.
   *
   * @example
   *
   * ```ts
   * // Race multiple quotes obtained from splitting a large top up
   * const { id, quote } = await wallet.on.onceAnyMintPaid(batchQuoteIds, {
   * 	timeoutMs: 120_000,
   * });
   * console.log('First top up paid', id, quote.preimage?.length);
   * ```
   *
   * @param ids Array of mint quote ids (duplicates are ignored).
   * @param opts Optional controls.
   * @param opts.signal AbortSignal to cancel the wait early.
   * @param opts.timeoutMs Milliseconds to wait before rejecting with a timeout error.
   * @param opts.failOnError When true, reject on first error. Default false.
   * @returns A promise resolving to the id that won and its `MintQuoteResponse`.
   */
  onceAnyMintPaid(t, e) {
    return new Promise((n, r) => {
      const i = Array.from(new Set(t)), o = /* @__PURE__ */ new Map();
      let a = null, c = null, u = !1;
      const l = (d) => {
        for (const p of o.values()) st(p);
        o.clear(), a && (clearTimeout(a), a = null), e?.signal && e.signal.removeEventListener("abort", h), d && r(ce(d));
      }, h = () => l(ue());
      if (e?.signal) {
        if (e.signal.aborted) return h();
        e.signal.addEventListener("abort", h, { once: !0 });
      }
      if (e?.timeoutMs && e.timeoutMs > 0 && (a = setTimeout(
        () => l(new Error("Timeout waiting for any mint paid")),
        e.timeoutMs
      )), i.length === 0) return l(new Error("No quote ids provided"));
      for (const d of i) {
        const p = this.mintQuotePaid(
          d,
          (m) => {
            l(), n({ id: d, quote: m });
          },
          (m) => {
            if (e?.failOnError) {
              l(m);
              return;
            }
            c = m;
            const P = o.get(d);
            P && (st(P), o.delete(d)), u && o.size === 0 && l(c ?? new Error("No subscriptions remaining"));
          }
        );
        o.set(d, p);
      }
      u = !0;
    });
  }
  /**
   * Resolve once a melt quote transitions to PAID, with automatic unsubscription, optional abort
   * signal, and optional timeout.
   *
   * Mirrors onceMintPaid, but for melts.
   *
   * @example
   *
   * ```ts
   * try {
   * 	const paid = await wallet.on.onceMeltPaid(meltId, { timeoutMs: 45_000 });
   * 	console.log('Invoice paid by mint, paid msat', paid.paid ?? 0);
   * } catch (e) {
   * 	console.error('Payment did not complete in time', e);
   * }
   * ```
   *
   * @param id Melt quote id to watch.
   * @param opts Optional controls.
   * @param opts.signal AbortSignal to cancel the wait early.
   * @param opts.timeoutMs Milliseconds to wait before rejecting with a timeout error.
   * @returns A promise that resolves with the `MeltQuoteResponse` once PAID.
   */
  onceMeltPaid(t, e) {
    return this.waitUntilPaid(
      this.meltQuotePaid.bind(this),
      t,
      e,
      "Timeout waiting for melt paid"
    );
  }
  /**
   * Async iterable that yields proof state updates for the provided proofs.
   *
   * Adds a bounded buffer option:
   *
   * - If `maxBuffer` is set and the queue is full when a new payload arrives, either drop the oldest
   *   queued payload (`drop: 'oldest'`, default) or the incoming payload (`drop: 'newest'`). In
   *   both cases `onDrop` is invoked with the dropped payload.
   *
   * The stream ends and cleans up on abort or on the wallet error callback. Errors from the wallet
   * are treated as a graceful end for this iterator.
   *
   * @example
   *
   * ```ts
   * const ac = new AbortController();
   * try {
   * 	for await (const update of wallet.on.proofStatesStream(myProofs)) {
   * 		if (update.state === CheckStateEnum.SPENT) {
   * 			console.warn('Spent proof', update.proof.id);
   * 		}
   * 	}
   * } catch (e) {
   * 	if ((e as Error).name !== 'AbortError') {
   * 		console.error('Stream error', e);
   * 	}
   * }
   * ```
   *
   * @param proofs The proofs to subscribe to. Only `secret` is required.
   * @param opts Optional controls.
   * @param opts.signal AbortSignal that stops the stream when aborted.
   * @param opts.maxBuffer Maximum number of queued items before applying the drop strategy.
   * @param opts.drop Overflow strategy when `maxBuffer` is reached, 'oldest' | 'newest'. Default
   *   'oldest'.
   * @param opts.onDrop Callback invoked with the payload that was dropped.
   * @returns An async iterable of update payloads.
   */
  proofStatesStream(t, e) {
    return async function* () {
      const n = [];
      let r = !1, i = null;
      const o = e?.maxBuffer && e.maxBuffer > 0 ? e.maxBuffer : 1 / 0, a = e?.drop ?? "oldest", c = () => {
        const d = i;
        i = null, d && d();
      }, u = (d) => {
        if (n.length >= o)
          if (a === "oldest") {
            const p = n.shift();
            if (p !== void 0)
              try {
                e?.onDrop?.(p);
              } catch {
              }
            n.push(d);
          } else {
            try {
              e?.onDrop?.(d);
            } catch {
            }
            return;
          }
        else
          n.push(d);
        c();
      }, l = this.proofStateUpdates(
        t,
        (d) => {
          u(d);
        },
        () => {
          r = !0, c();
        },
        { signal: e?.signal }
      ), h = () => {
        r = !0, c();
      };
      try {
        for (e?.signal && (e.signal.aborted ? h() : e.signal.addEventListener("abort", h, { once: !0 })); !r || n.length; ) {
          for (; n.length; ) yield n.shift();
          if (r) break;
          await new Promise((d) => i = d);
        }
      } finally {
        st(l), e?.signal && e.signal.removeEventListener("abort", h);
      }
    }.call(this);
  }
  /**
   * Create a composite canceller that can collect many subscriptions and dispose them all in one
   * call.
   *
   * Accepts both a `SubscriptionCanceller` and a `Promise<SubscriptionCanceller>`. When the
   * composite canceller is called, all collected cancellations are invoked. Errors from individual
   * cancellers are caught and ignored.
   *
   * The returned function also has an `.add()` method to register more cancellers, and a
   * `.cancelled` boolean property for debugging.
   *
   * @example
   *
   * ```ts
   * const cancelAll = wallet.on.group();
   * cancelAll.add(wallet.on.mintQuotes(ids, onUpdate, onErr));
   * cancelAll.add(asyncSubscribeElsewhere());
   *
   * // later
   * cancelAll(); // disposes everything
   * ```
   *
   * @returns Composite canceller function with `.add()` and `.cancelled` members.
   */
  group() {
    const t = [];
    let e = !1;
    const n = (() => {
      if (!e)
        for (e = !0; t.length; ) st(t.pop());
    });
    return n.add = (r) => e ? (st(r), r) : (t.push(r), r), Object.defineProperty(n, "cancelled", {
      get: () => e,
      enumerable: !0
    }), n;
  }
}
class is {
  constructor(t) {
    this.src = t;
  }
  /**
   * Returns the "next" counter for a specified keyset.
   */
  async peekNext(t) {
    return (await this.src.reserve(t, 0)).start;
  }
  /**
   * Bumps the counter if it is behind `minNext` (no-op if ahead).
   */
  async advanceToAtLeast(t, e) {
    await this.src.advanceToAtLeast(t, e);
  }
  /**
   * Hard-sets the cursor (useful for tests or migrations).
   *
   * @throws If the CounterSource does not support setNext()
   */
  async setNext(t, e) {
    if (typeof this.src.setNext == "function") {
      await this.src.setNext(t, e);
      return;
    }
    throw new Error("CounterSource does not support setNext()");
  }
  /**
   * Returns the current "next" per keyset (what will be reserved next).
   *
   * @throws If the CounterSource does not support snapshot()
   */
  async snapshot() {
    if (typeof this.src.snapshot == "function")
      return await this.src.snapshot();
    throw new Error("CounterSource does not support snapshot()");
  }
}
const Et = {
  UNSPENT: "UNSPENT",
  PENDING: "PENDING",
  SPENT: "SPENT"
}, St = "__PENDING__";
class Gt {
  /**
   * Create a wallet for a given mint and unit. Call `loadMint` before use.
   *
   * Binding, if `options.keysetId` is omitted, the wallet binds to the cheapest active keyset for
   * this unit during `loadMint`. The keychain only loads keysets for this unit.
   *
   * Caching, to preload, provide both `keysets` and `keys`, otherwise the cache is ignored.
   *
   * Deterministic secrets, pass `bip39seed` and optionally `secretsPolicy`. Deterministic outputs
   * reserve counters from `counterSource`, or an ephemeral in memory source if not supplied.
   * `initialCounter` applies only with a supplied `keysetId` and the ephemeral source.
   *
   * Splitting, `denominationTarget` guides proof splits, default is 3. Override coin selection with
   * `selectProofs` if needed. Logging defaults to a null logger.
   *
   * @param mint Mint instance or URL.
   * @param options Optional settings.
   * @param options.unit Wallet unit, default 'sat'.
   * @param options.keysetId Bind to this keyset id, else bind on `loadMint`.
   * @param options.bip39seed BIP39 seed for deterministic secrets.
   * @param options.secretsPolicy Secrets policy, default 'auto'.
   * @param options.counterSource Counter source for deterministic outputs. If provided, this takes
   *   precedence over counterInit. Use when you need persistence across processes or devices.
   * @param options.counterInit Seed values for the built-in EphemeralCounterSource. Ignored if
   *   counterSource is also provided.
   * @param options.keys Cached keys for this unit, only used when `keysets` is also provided.
   * @param options.keysets Cached keysets for this unit, only used when `keys` is also provided.
   * @param options.mintInfo Optional cached mint info.
   * @param options.denominationTarget Target proofs per denomination, default 3.
   * @param options.selectProofs Custom proof selection function.
   * @param options.logger Logger instance, default null logger.
   */
  constructor(t, e) {
    this._seed = void 0, this._unit = "sat", this._mintInfo = void 0, this._denominationTarget = 3, this._secretsPolicy = "auto", this._boundKeysetId = St, this.swap = this.send.bind(this), this.ops = new ts(this), this.on = new rs(this), this._logger = e?.logger ?? L, this._selectProofs = e?.selectProofs ?? Yn, this.mint = typeof t == "string" ? new Vt(t, { authProvider: e?.authProvider, logger: this._logger }) : t, this._unit = e?.unit ?? this._unit, this._boundKeysetId = e?.keysetId ?? this._boundKeysetId, e?.bip39seed && (this.failIf(
      !(e.bip39seed instanceof Uint8Array),
      "bip39seed must be a valid Uint8Array",
      {
        bip39seed: e.bip39seed
      }
    ), this._seed = e.bip39seed), this._secretsPolicy = e?.secretsPolicy ?? this._secretsPolicy, e?.counterSource ? this._counterSource = e.counterSource : this._counterSource = new Zn(e?.counterInit), this.counters = new is(this._counterSource), this.keyChain = new Ue(this.mint, this._unit, e?.keysets, e?.keys), this._mintInfo = e?.mintInfo ? new wt(e.mintInfo) : this._mintInfo, this._denominationTarget = e?.denominationTarget ?? this._denominationTarget;
  }
  // Convenience wrappers for "log and throw"
  fail(t, e) {
    return bt(t, this._logger, e);
  }
  failIf(t, e, n) {
    return le(t, e, this._logger, n);
  }
  failIfNullish(t, e, n) {
    return de(t, e, this._logger, n);
  }
  safeCallback(t, e, n) {
    lt(t, e, this._logger, n);
  }
  /**
   * Load mint information, keysets, and keys. Must be called before using other methods.
   *
   * @param forceRefresh If true, re-fetches data even if cached.
   * @throws If fetching mint info, keysets, or keys fails.
   */
  async loadMint(t) {
    const e = [];
    if ((!this._mintInfo || t) && e.push(
      this.mint.getInfo().then((n) => (this._mintInfo = new wt(n), null))
    ), e.push(this.keyChain.init(t).then(() => null)), await Promise.all(e), this._logger.debug("KeyChain", { keychain: this.keyChain.getCache() }), this._boundKeysetId === St)
      this._boundKeysetId = this.keyChain.getCheapestKeyset().id;
    else {
      const n = this.keyChain.getKeyset(this._boundKeysetId);
      this.failIf(!n.hasKeys, "Wallet keyset has no keys after refresh", { keyset: n.id });
    }
  }
  // -----------------------------------------------------------------
  // Section: Getters
  // -----------------------------------------------------------------
  /**
   * Get the wallet's unit.
   *
   * @returns The unit (e.g., 'sat').
   */
  get unit() {
    return this._unit;
  }
  /**
   * Get information about the mint.
   *
   * @remarks
   * Returns cached mint info. Call `loadMint` first to initialize the wallet.
   * @returns Mint info.
   * @throws If mint info is not initialized.
   */
  getMintInfo() {
    return this.failIfNullish(this._mintInfo, "Mint info not initialized; call loadMint first"), this._mintInfo;
  }
  /**
   * The keyset ID bound to this wallet instance.
   */
  get keysetId() {
    return this.failIf(this._boundKeysetId === St, "Wallet not initialised, call loadMint"), this._boundKeysetId;
  }
  /**
   * Gets the requested keyset or the keyset bound to the wallet.
   *
   * @remarks
   * This method enforces wallet policies. If `id` is omitted, it returns the keyset bound to this
   * wallet, including validation that:
   *
   * - The keyset exists in the keychain,
   * - The unit matches the wallet's unit,
   * - Keys are loaded for that keyset.
   *
   * Contrast with `keyChain.getKeyset(id?)`, which, when called without an id, returns the cheapest
   * active keyset for the unit, ignoring the wallet binding.
   * @param id Optional keyset id to resolve. If omitted, the wallet's bound keyset is used.
   * @returns The resolved `Keyset`.
   * @throws If the keyset is not found, has no keys, or its unit differs from the wallet.
   */
  getKeyset(t) {
    const e = this.keyChain.getKeyset(t ?? this.keysetId);
    return this.failIf(e.unit !== this._unit, "Keyset unit does not match wallet unit", {
      keyset: e.id,
      unit: e.unit,
      walletUnit: this._unit
    }), this.failIf(!e.hasKeys, "Keyset has no keys loaded", { keyset: e.id }), e;
  }
  get logger() {
    return this._logger;
  }
  // -----------------------------------------------------------------
  // Section: Counters
  // -----------------------------------------------------------------
  async reserveFor(t, e) {
    return e <= 0 ? { start: 0, count: 0 } : this._counterSource.reserve(t, e);
  }
  countersNeeded(t) {
    return t.type !== "deterministic" || t.counter !== 0 ? 0 : (t.denominations ?? []).length;
  }
  async addCountersToOutputTypes(t, ...e) {
    const n = e.reduce((c, u) => c + this.countersNeeded(u), 0);
    if (n === 0) return { outputTypes: e };
    const r = await this.reserveFor(t, n);
    let i = r.start;
    const o = e.map((c) => {
      if (c.type === "deterministic" && c.counter === 0) {
        const u = (c.denominations ?? []).length;
        if (u > 0) {
          const l = { ...c, counter: i };
          return i += u, l;
        }
      }
      return c;
    }), a = {
      keysetId: t,
      start: r.start,
      count: r.count,
      next: r.start + r.count
    };
    return this.on._emitCountersReserved(a), { outputTypes: o, used: a };
  }
  /**
   * Bind this wallet to a specific keyset id.
   *
   * @remarks
   * This changes the default keyset used by all operations that do not explicitly pass a keysetId.
   * The method validates that the keyset exists in the keychain, matches the wallet unit, and has
   * keys loaded.
   *
   * Typical uses:
   *
   * 1. After loadMint, to pin the wallet to a particular active keyset.
   * 2. After a refresh, to rebind deliberately rather than falling back to cheapest.
   *
   * @param id The keyset identifier to bind to.
   * @throws If keyset not found, if it has no keys loaded, or if its unit is not the wallet unit.
   */
  bindKeyset(t) {
    const e = this.keyChain.getKeyset(t);
    this.failIf(e.unit !== this._unit, "Keyset unit does not match wallet unit", {
      keyset: e.id,
      unit: e.unit,
      walletUnit: this._unit
    }), this.failIf(!e.hasKeys, "Keyset has no keys loaded", { keyset: e.id }), this._boundKeysetId = e.id, this._logger.debug("Wallet bound to keyset", {
      keysetId: e.id,
      unit: e.unit,
      feePPK: e.fee
    });
  }
  /**
   * Creates a new Wallet bound to a different keyset, sharing the same CounterSource.
   *
   * Use this to operate on multiple keysets concurrently without mutating your original wallet.
   * Counters remain monotonic across instances because the same CounterSource is reused.
   *
   * Do NOT pass a fresh CounterSource for the same seed unless you know exactly why. Reusing
   * counters can recreate secrets that a mint will reject.
   *
   * @param id The keyset identifier to bind to.
   * @throws If keyset not found, if it has no keys loaded, or if its unit is not the wallet unit.
   */
  withKeyset(t, e) {
    return new Gt(this.mint, {
      keysetId: t,
      bip39seed: this._seed,
      secretsPolicy: this._secretsPolicy,
      logger: this._logger,
      counterSource: e?.counterSource ?? this._counterSource,
      ...this.keyChain.getCache()
    });
  }
  /**
   * Returns the default OutputType for this wallet, based on its configured secrets policy
   * (options?.secretsPolicy) and seed state.
   *
   * - If the secrets policy is 'random', returns { type: 'random' }.
   * - If the policy is 'deterministic', requires a seed and returns { type: 'deterministic', counter:
   *   0 }. Counter 0 is a flag meaning "auto-increment from current state".
   * - If no explicit policy is set, falls back to:
   *
   *   - Deterministic if a seed is present.
   *   - Random if no seed is present.
   *
   * @returns An OutputType object describing the default output strategy.
   * @throws Error if the policy is 'deterministic' but no seed has been set.
   */
  defaultOutputType() {
    return this._secretsPolicy === "random" ? { type: "random" } : this._secretsPolicy === "deterministic" ? (this.failIfNullish(this._seed, "Deterministic policy requires a seed"), { type: "deterministic", counter: 0 }) : this._seed ? { type: "deterministic", counter: 0 } : { type: "random" };
  }
  // -----------------------------------------------------------------
  // Section: Output Creation
  // -----------------------------------------------------------------
  /**
   * Configures output denominations with fee adjustments and optimization.
   *
   * @remarks
   * If 'custom' outputType, data outputs MUST sum to the amount. Other outputTypes may supply
   * denominations. If no denominations are passed in, they will be calculated based on proofsWeHave
   * or the default split. If partial denominations are passed in, the balance will be added using
   * default split. Additional denominations to cover fees will then be added if required.
   * @param amount The total amount for outputs.
   * @param keyset The mint keyset.
   * @param outputType The output configuration.
   * @param includeFees Whether to include swap fees in the output amount.
   * @param proofsWeHave Optional proofs for optimizing denomination splitting.
   * @returns OutputType with required denominations.
   */
  configureOutputs(t, e, n, r = !1, i = []) {
    let o = t;
    if (n.type === "custom") {
      this.failIf(r, "The custom OutputType does not support automatic fee inclusion");
      const c = N.sumOutputAmounts(n.data);
      return this.failIf(
        c !== t,
        `Custom output data total (${c}) does not match amount (${t})`
      ), n;
    }
    let a = n.denominations ?? [];
    if (a.length === 0 && i.length > 0 && (a = Un(
      i,
      o,
      e.keys,
      this._denominationTarget
    )), a = G(o, e.keys, a), r) {
      let c = this.getFeesForKeyset(a.length, e.id), u = G(c, e.keys);
      for (; this.getFeesForKeyset(a.length + u.length, e.id) > c; )
        c++, u = G(c, e.keys);
      o += c, a = [...a, ...u];
    }
    return { ...n, denominations: a };
  }
  /**
   * Sum total implied by a prepared OutputType. Note: Empty denomination is valid (e.g: zero
   * change).
   */
  preparedTotal(t) {
    return t.type === "custom" ? N.sumOutputAmounts(t.data) : (t.denominations ?? []).reduce((n, r) => n + r, 0);
  }
  /**
   * Generates blinded messages based on the specified output type.
   *
   * @param amount The total amount for outputs.
   * @param keyset The mint keys.
   * @param outputType The output configuration.
   * @returns Prepared output data.
   */
  createOutputData(t, e, n) {
    if (this.failIf(t < 0, "Amount was negative", { amount: t }), // 'custom' OutputType has no denominations. Every other OutputType does.
    // so let's sanity check those were filled properly (eg: configureOutputs)
    n.type != "custom" && n.denominations && n.denominations.length > 0) {
      const i = n.denominations.reduce((o, a) => o + a, 0);
      this.failIf(i !== t, "Denominations do not sum to the expected amount", {
        splitSum: i,
        expected: t
      });
    }
    let r;
    switch (n.type) {
      case "random":
        r = N.createRandomData(t, e, n.denominations);
        break;
      case "deterministic":
        this.failIfNullish(
          this._seed,
          "Deterministic outputs require a seed configured in the wallet"
        ), r = N.createDeterministicData(
          t,
          this._seed,
          n.counter,
          e,
          n.denominations
        );
        break;
      case "p2pk":
        r = N.createP2PKData(
          n.options,
          t,
          e,
          n.denominations
        );
        break;
      case "factory": {
        r = G(t, e.keys, n.denominations).map((o) => n.factory(o, e));
        break;
      }
      case "custom": {
        r = n.data;
        const i = N.sumOutputAmounts(r);
        this.failIf(
          i !== t,
          `Custom output data total (${i}) does not match amount (${t})`
        );
        break;
      }
      default:
        this.fail("Invalid OutputType");
    }
    return r;
  }
  /**
   * Creates a swap transaction with sorted outputs for privacy. This prevents a mint working out
   * which proofs will be sent or kept.
   *
   * @param inputs Prepared input proofs.
   * @param keepOutputs Outputs to keep (change or receiver's proofs).
   * @param sendOutputs Outputs to send (optional, default empty for receive/mint).
   * @returns Swap transaction with payload and metadata for processing signatures.
   */
  createSwapTransaction(t, e, n = []) {
    t = this._prepareInputsForMint(t);
    const r = [...e, ...n], i = r.map((h, d) => d).sort(
      (h, d) => r[h].blindedMessage.amount - r[d].blindedMessage.amount
    ), o = [
      ...Array.from({ length: e.length }, () => !0),
      ...Array.from({ length: n.length }, () => !1)
    ], a = i.map((h) => r[h]), c = i.map((h) => o[h]), u = a.map((h) => h.blindedMessage);
    return this._logger.debug("createSwapTransaction:", {
      indices: i,
      sortedKeepVector: c
      // outputs, // <-- removed for security
    }), {
      payload: {
        inputs: t,
        outputs: u
      },
      outputData: a,
      keepVector: c,
      sortedIndices: i
    };
  }
  // -----------------------------------------------------------------
  // Section: Send and Receive
  // -----------------------------------------------------------------
  /**
   * Receive a token (swaps with mint for new proofs)
   *
   * @example
   *
   * ```typescript
   * const result = await wallet.receive(
   * 	token,
   * 	{ includeFees: true },
   * 	{ type: 'deterministic', counter: 0 },
   * );
   * ```
   *
   * @param token Token string or decoded token.
   * @param config Optional receive config.
   * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().
   * @returns Newly minted proofs.
   */
  async receive(t, e, n) {
    const { keysetId: r, privkey: i, requireDleq: o, proofsWeHave: a, onCountersReserved: c } = e || {};
    n = n ?? this.defaultOutputType();
    const u = typeof t == "string" ? this.decodeToken(t) : t, l = Oe(u.mint);
    this.failIf(l !== this.mint.mintUrl, "Token belongs to a different mint", {
      token: l,
      wallet: this.mint.mintUrl
    }), this.failIf(u.unit !== this._unit, "Token is not in wallet unit", {
      token: u.unit,
      wallet: this._unit
    });
    let h = [];
    ({ proofs: h } = u);
    const d = rt(h);
    if (d === 0)
      return [];
    i && (h = this.signP2PKProofs(h, i));
    const p = this.getKeyset(r);
    if (o)
      for (const S of h) {
        const B = this.keyChain.getKeyset(S.id);
        De(S, B) || this.fail("Token contains proofs with invalid or missing DLEQ");
      }
    const m = d - this.getFeesForProofs(h);
    let P = this.configureOutputs(
      m,
      p,
      n,
      !1,
      // includeFees is not applicable for receive
      a
    );
    const A = await this.addCountersToOutputTypes(p.id, P);
    [P] = A.outputTypes, A.used && this.safeCallback(c, A.used, { op: "receive" }), this._logger.debug("receive counter", { counter: A.used, receiveOT: P });
    const w = this.createOutputData(this.preparedTotal(P), p, P), v = this.createSwapTransaction(h, w, []), { signatures: I } = await this.mint.swap(v.payload), U = v.outputData.map(
      (S, B) => S.toProof(I[B], p)
    ), x = [];
    return v.sortedIndices.forEach((S, B) => {
      x[S] = U[B];
    }), this._logger.debug("RECEIVE COMPLETED", { amounts: x.map((S) => S.amount) }), x;
  }
  /**
   * Sends proofs of a given amount from provided proofs.
   *
   * @remarks
   * If proofs are P2PK-locked to your public key, call signP2PKProofs first to sign them. The
   * default config uses exact match selection, and does not includeFees or requireDleq. Because the
   * send is offline, the user will unlock the signed proofs when they receive them online.
   * @param amount Amount to send.
   * @param proofs Array of proofs (must sum >= amount; pre-sign if P2PK-locked).
   * @param config Optional parameters for the send.
   * @returns SendResponse with keep/send proofs.
   * @throws Throws if the send cannot be completed offline.
   */
  sendOffline(t, e, n) {
    const { requireDleq: r = !1, includeFees: i = !1, exactMatch: o = !0 } = n || {};
    r && (e = e.filter((l) => l.dleq != null)), this.failIf(rt(e) < t, "Not enough funds available to send");
    const { keep: a, send: c } = this.selectProofsToSend(e, t, i, o), u = this._prepareInputsForMint(c, r);
    return { keep: a, send: u };
  }
  /**
   * Send proofs with online swap if necessary.
   *
   * @remarks
   * If proofs are P2PK-locked to your public key, call signP2PKProofs first to sign them.
   * @example
   *
   * ```typescript
   * // Simple send
   * const result = await wallet.send(5, proofs);
   *
   * // With a SendConfig
   * const result = await wallet.send(5, proofs, { includeFees: true });
   *
   * // With Custom output configuration
   * const customConfig: OutputConfig = {
   * 	send: { type: 'p2pk', options: { pubkey: '...' } },
   * 	keep: { type: 'deterministic', counter: 0 },
   * };
   * const customResult = await wallet.send(5, proofs, { includeFees: true }, customConfig);
   * ```
   *
   * @param amount Amount to send (receiver gets this net amount).
   * @param proofs Array of proofs to split.
   * @param config Optional parameters for the swap.
   * @returns SendResponse with keep/send proofs.
   * @throws Throws if the send cannot be completed offline or if funds are insufficient.
   */
  async send(t, e, n, r) {
    const { keysetId: i, includeFees: o = !1, onCountersReserved: a } = n || {};
    r = r ?? {
      send: this.defaultOutputType(),
      keep: this.defaultOutputType()
    };
    try {
      const f = this.defaultOutputType().type === "deterministic", g = (E) => !E || E.type === "random" && (!E.denominations || E.denominations.length === 0);
      if (i || f || !g(r.send) || r.keep && !g(r.keep)) {
        const E = [];
        throw i && E.push("keysetId override"), f && E.push("wallet default is deterministic"), g(r.send) || E.push("non-default send output type"), r.keep && !g(r.keep) && E.push("non-default keep output type"), new Error(`Options require a swap: ${E.join(", ")}`);
      }
      const { keep: k, send: y } = this.sendOffline(t, e, {
        includeFees: o,
        exactMatch: !0,
        requireDleq: !1
        // safety
      }), F = o ? this.getFeesForProofs(y) : 0;
      if (rt(y) === t + F)
        return this._logger.info("Successful exactMatch offline selection!"), { keep: k, send: y };
    } catch (f) {
      const g = f instanceof Error ? f.message : "Unknown error";
      this._logger.debug("ExactMatch offline selection failed.", { e: g });
    }
    const c = this.getKeyset(i);
    let u = this.configureOutputs(
      t,
      c,
      r.send ?? this.defaultOutputType(),
      o
    );
    const l = this.preparedTotal(u), { keep: h, send: d } = this.selectProofsToSend(
      e,
      l,
      !0
      // Include fees to cover swap fee
    );
    if (d.length === 0)
      throw new Error("Not enough funds available to send");
    const p = rt(d), m = this.getFeesForProofs(d), P = p - m - l;
    this.failIf(P < 0, "Not enough funds available for swap", {
      selectedSum: p,
      swapFee: m,
      sendAmount: l,
      changeAmount: P
    });
    let A = this.configureOutputs(
      P,
      c,
      r.keep ?? this.defaultOutputType(),
      !1,
      n?.proofsWeHave
    );
    const w = this.preparedTotal(A), v = await this.addCountersToOutputTypes(c.id, u, A);
    [u, A] = v.outputTypes, v.used && this.safeCallback(a, v.used, { op: "send" }), this._logger.debug("send counters", { counter: v.used, sendOT: u, keepOT: A });
    const I = this.createOutputData(l, c, u), U = this.createOutputData(w, c, A), x = this.createSwapTransaction(d, U, I), { signatures: S } = await this.mint.swap(x.payload), B = x.outputData.map((f, g) => f.toProof(S[g], c)), at = Array(B.length), M = Array(x.keepVector.length);
    x.sortedIndices.forEach((f, g) => {
      M[f] = x.keepVector[g], at[f] = B[g];
    });
    const Z = [], tt = [];
    return at.forEach((f, g) => {
      M[g] ? Z.push(f) : tt.push(f);
    }), this._logger.debug("SEND COMPLETED", {
      unselectedProofs: h.map((f) => f.amount),
      keepProofs: Z.map((f) => f.amount),
      sendProofs: tt.map((f) => f.amount)
    }), {
      keep: [...Z, ...h],
      send: tt
    };
  }
  // -----------------------------------------------------------------
  // Section: Transaction Helpers
  // -----------------------------------------------------------------
  /**
   * Selects proofs to send based on amount and fee inclusion.
   *
   * @remarks
   * Uses an adapted Randomized Greedy with Local Improvement (RGLI) algorithm, which has a time
   * complexity O(n log n) and space complexity O(n).
   * @param proofs Array of Proof objects available to select from.
   * @param amountToSend The target amount to send.
   * @param includeFees Optional boolean to include fees; Default: false.
   * @param exactMatch Optional boolean to require exact match; Default: false.
   * @returns SendResponse containing proofs to keep and proofs to send.
   * @throws Throws an error if an exact match cannot be found within MAX_TIMEMS.
   * @see https://crypto.ethz.ch/publications/files/Przyda02.pdf
   */
  selectProofsToSend(t, e, n = !1, r = !1) {
    const { keep: i, send: o } = this._selectProofs(
      t,
      e,
      this.keyChain,
      n,
      r
    );
    return { keep: i, send: o };
  }
  /**
   * Prepares proofs for sending by signing P2PK-locked proofs.
   *
   * @remarks
   * Call this method before operations like send if the proofs are P2PK-locked and need unlocking.
   * This is a public wrapper for signing.
   * @param proofs The proofs to sign.
   * @param privkey The private key for signing.
   * @returns Signed proofs.
   */
  signP2PKProofs(t, e) {
    return bn(t, e);
  }
  /**
   * Calculates the fees based on inputs (proofs)
   *
   * @param proofs Input proofs to calculate fees for.
   * @returns Fee amount.
   * @throws Throws an error if the proofs keyset is unknown.
   */
  getFeesForProofs(t) {
    const e = t.reduce((n, r) => n + this.getProofFeePPK(r), 0);
    return Math.ceil(e / 1e3);
  }
  /**
   * Returns the current fee PPK for a proof according to the cached keyset.
   *
   * @param proof {Proof} A single proof.
   * @returns FeePPK {number} The feePPK for the selected proof.
   * @throws Throws an error if the proofs keyset is unknown.
   */
  getProofFeePPK(t) {
    try {
      return this.keyChain.getKeyset(t.id).fee;
    } catch (e) {
      this.fail(`Could not get fee. No keyset found for keyset id: ${t.id}`, {
        e,
        keychain: this.keyChain.getKeysets()
      });
    }
  }
  /**
   * Calculates the fees based on inputs for a given keyset.
   *
   * @param nInputs Number of inputs.
   * @param keysetId KeysetId used to lookup `input_fee_ppk`
   * @returns Fee amount.
   */
  getFeesForKeyset(t, e) {
    try {
      const n = this.keyChain.getKeyset(e).fee;
      return Math.floor(Math.max((t * n + 999) / 1e3, 0));
    } catch (n) {
      this.fail(`No keyset found with ID ${e}`, { e: n });
    }
  }
  /**
   * Prepares inputs for a mint operation.
   *
   * @remarks
   * Internal method; strips DLEQ (NUT-12) and p2pk_e (NUT-26) for privacy and serializes witnesses.
   * Returns an array of new proof objects - does not mutate the originals.
   * @param proofs The proofs to prepare.
   * @param keepDleq Optional boolean to keep DLEQ (default: false, strips for privacy).
   * @returns Prepared proofs for mint payload.
   */
  _prepareInputsForMint(t, e = !1) {
    return t.map((n) => {
      const r = n.witness && typeof n.witness != "string" ? JSON.stringify(n.witness) : n.witness, { dleq: i, p2pk_e: o, ...a } = n;
      return e && i ? { ...a, dleq: i, witness: r } : { ...a, witness: r };
    });
  }
  /**
   * Decodes a string token.
   *
   * @remarks
   * Rehydrates a token from the space-saving CBOR format, including mapping short keyset ids to
   * their full representation.
   * @param token The token in string format (cashuB...)
   * @returns Token object.
   */
  decodeToken(t) {
    const e = this.keyChain.getKeysets();
    return Fn(t, e);
  }
  // -----------------------------------------------------------------
  // Section: Restore
  // -----------------------------------------------------------------
  /**
   * Restores batches of deterministic proofs until no more signatures are returned from the mint.
   *
   * @param [gapLimit=300] The amount of empty counters that should be returned before restoring
   *   ends (defaults to 300). Default is `300`
   * @param [batchSize=100] The amount of proofs that should be restored at a time (defaults to
   *   100). Default is `100`
   * @param [counter=0] The counter that should be used as a starting point (defaults to 0). Default
   *   is `0`
   * @param [keysetId] Which keysetId to use for the restoration. If none is passed the instance's
   *   default one will be used.
   */
  async batchRestore(t = 300, e = 100, n = 0, r) {
    const i = Math.ceil(t / e), o = [];
    let a, c = 0;
    for (; c < i; ) {
      const u = await this.restore(n, e, { keysetId: r });
      u.proofs.length > 0 ? (c = 0, o.push(...u.proofs), a = u.lastCounterWithSignature) : c++, n += e;
    }
    return { proofs: o, lastCounterWithSignature: a };
  }
  /**
   * Regenerates.
   *
   * @param start Set starting point for count (first cycle for each keyset should usually be 0)
   * @param count Set number of blinded messages that should be generated.
   * @param options.keysetId Set a custom keysetId to restore from. @see `keyChain)`
   */
  async restore(t, e, n) {
    const { keysetId: r } = n || {}, i = this.getKeyset(r);
    this.failIfNullish(this._seed, "Cashu Wallet must be initialized with a seed to use restore");
    const o = Array(e).fill(0), a = N.createDeterministicData(0, this._seed, t, i, o), { outputs: c, signatures: u } = await this.mint.restore({
      outputs: a.map((p) => p.blindedMessage)
    }), l = {};
    c.forEach((p, m) => l[p.B_] = u[m]);
    const h = [];
    let d;
    for (let p = 0; p < a.length; p++) {
      const m = l[a[p].blindedMessage.B_];
      m && (d = t + p, a[p].blindedMessage.amount = m.amount, h.push(a[p].toProof(m, i)));
    }
    return {
      proofs: h,
      lastCounterWithSignature: d
    };
  }
  // -----------------------------------------------------------------
  // Section: Create Mint Quote
  // -----------------------------------------------------------------
  /**
   * @deprecated Use createMintQuoteBolt11()
   */
  async createMintQuote(t, e) {
    return this.createMintQuoteBolt11(t, e);
  }
  /**
   * Requests a mint quote from the mint. Response returns a Lightning payment request for the
   * requested given amount and unit.
   *
   * @param amount Amount requesting for mint.
   * @param description Optional description for the mint quote.
   * @param pubkey Optional public key to lock the quote to.
   * @returns The mint will return a mint quote with a Lightning invoice for minting tokens of the
   *   specified amount and unit.
   */
  async createMintQuoteBolt11(t, e) {
    e && (this.getMintInfo().supportsNut04Description("bolt11", this._unit) || this.fail("Mint does not support description for bolt11"));
    const n = {
      unit: this._unit,
      amount: t,
      description: e
    }, r = await this.mint.createMintQuoteBolt11(n);
    return { ...r, amount: r.amount || t, unit: r.unit || this._unit };
  }
  /**
   * Requests a mint quote from the mint that is locked to a public key.
   *
   * @param amount Amount requesting for mint.
   * @param pubkey Public key to lock the quote to.
   * @param description Optional description for the mint quote.
   * @returns The mint will return a mint quote with a Lightning invoice for minting tokens of the
   *   specified amount and unit. The quote will be locked to the specified `pubkey`.
   */
  async createLockedMintQuote(t, e, n) {
    const { supported: r } = this.getMintInfo().isSupported(20);
    this.failIf(!r, "Mint does not support NUT-20");
    const i = {
      unit: this._unit,
      amount: t,
      description: n,
      pubkey: e
    }, o = await this.mint.createMintQuoteBolt11(i);
    this.failIf(typeof o.pubkey != "string", "Mint returned unlocked mint quote");
    const a = o.pubkey;
    return {
      ...o,
      pubkey: a,
      amount: o.amount || t,
      unit: o.unit || this._unit
    };
  }
  /**
   * Requests a mint quote from the mint. Response returns a Lightning BOLT12 offer for the
   * requested given amount and unit.
   *
   * @param pubkey Public key to lock the quote to.
   * @param options.amount BOLT12 offer amount requesting for mint. If not specified, the offer will
   *   be amountless.
   * @param options.description Description for the mint quote.
   * @returns The mint will return a mint quote with a BOLT12 offer for minting tokens of the
   *   specified amount and unit.
   */
  async createMintQuoteBolt12(t, e) {
    const n = this.getMintInfo();
    e?.description && !n.supportsNut04Description("bolt12", this._unit) && this.fail("Mint does not support description for bolt12");
    const r = {
      pubkey: t,
      unit: this._unit,
      amount: e?.amount,
      description: e?.description
    };
    return this.mint.createMintQuoteBolt12(r);
  }
  // -----------------------------------------------------------------
  // Section: Check Mint Quote
  // -----------------------------------------------------------------
  /**
   * @deprecated Use checkMintQuoteBolt11()
   */
  async checkMintQuote(t) {
    return this.checkMintQuoteBolt11(t);
  }
  /**
   * Gets an existing mint quote from the mint.
   *
   * @param quote Quote ID.
   * @returns The mint will create and return a Lightning invoice for the specified amount.
   */
  async checkMintQuoteBolt11(t) {
    const e = typeof t == "string" ? t : t.quote, n = await this.mint.checkMintQuoteBolt11(e);
    return typeof t == "string" ? n : { ...n, amount: n.amount || t.amount, unit: n.unit || t.unit };
  }
  /**
   * Gets an existing BOLT12 mint quote from the mint.
   *
   * @param quote Quote ID.
   * @returns The latest mint quote for the given quote ID.
   */
  async checkMintQuoteBolt12(t) {
    return this.mint.checkMintQuoteBolt12(t);
  }
  // -----------------------------------------------------------------
  // Section: Mint Proofs
  // -----------------------------------------------------------------
  /**
   * @deprecated Use mintProofsBolt11()
   */
  async mintProofs(t, e, n, r) {
    return this._mintProofs("bolt11", t, e, n, r);
  }
  /**
   * Mint proofs for a bolt11 quote.
   *
   * @param amount Amount to mint.
   * @param quote Mint quote ID or object (bolt11).
   * @param config Optional parameters (e.g. privkey for locked quotes).
   * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().
   * @returns Minted proofs.
   */
  async mintProofsBolt11(t, e, n, r) {
    return this._mintProofs("bolt11", t, e, n, r);
  }
  /**
   * Mints proofs for a bolt12 quote.
   *
   * @param amount Amount to mint.
   * @param quote Bolt12 mint quote.
   * @param privkey Private key to unlock the quote.
   * @param config Optional parameters (e.g. keysetId).
   * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().
   * @returns Minted proofs.
   */
  async mintProofsBolt12(t, e, n, r, i) {
    return this._mintProofs("bolt12", t, e, { ...r, privkey: n }, i);
  }
  /**
   * Internal helper for minting proofs with bolt11 or bolt12.
   *
   * @remarks
   * Handles blinded messages, signatures, and proof construction. Use public methods like
   * mintProofs or helpers for API access.
   * @param method 'bolt11' or 'bolt12'.
   * @param amount Amount to mint (must be positive).
   * @param quote Quote ID or object.
   * @param config Optional (privkey, keysetId).
   * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().
   * @returns Minted proofs.
   * @throws If params are invalid or mint returns errors.
   */
  async _mintProofs(t, e, n, r, i) {
    i = i ?? this.defaultOutputType();
    const { privkey: o, keysetId: a, proofsWeHave: c, onCountersReserved: u } = r ?? {};
    this.failIf(e <= 0, "Invalid mint amount: must be positive", { amount: e });
    const l = this.getKeyset(a);
    let h = this.configureOutputs(
      e,
      l,
      i,
      !1,
      // no fees
      c
    );
    const d = this.preparedTotal(h), p = await this.addCountersToOutputTypes(l.id, h);
    [h] = p.outputTypes, p.used && this.safeCallback(u, p.used, { op: "mintProofs" }), this._logger.debug("mint counter", { counter: p.used, mintOT: h });
    const m = this.createOutputData(d, l, h), P = m.map((v) => v.blindedMessage), A = {
      outputs: P,
      quote: typeof n == "string" ? n : n.quote
    };
    if (typeof n != "string" && n.pubkey) {
      this.failIf(!o, "Can not sign locked quote without private key");
      const v = qn(o, n.quote, P);
      A.signature = v;
    }
    let w;
    return t === "bolt12" ? { signatures: w } = await this.mint.mintBolt12(A) : { signatures: w } = await this.mint.mintBolt11(A), this.failIf(
      w.length !== m.length,
      `Mint returned ${w.length} signatures, expected ${m.length}`
    ), this._logger.debug("MINT COMPLETED", { amounts: m.map((v) => v.blindedMessage.amount) }), m.map((v, I) => v.toProof(w[I], l));
  }
  // -----------------------------------------------------------------
  // Section: Create Melt Quote
  // -----------------------------------------------------------------
  /**
   * @deprecated Use createMeltQuoteBolt11.
   */
  async createMeltQuote(t) {
    return this.createMeltQuoteBolt11(t);
  }
  /**
   * Requests a melt quote from the mint. Response returns amount and fees for a given unit in order
   * to pay a Lightning invoice.
   *
   * @param invoice LN invoice that needs to get a fee estimate.
   * @returns The mint will create and return a melt quote for the invoice with an amount and fee
   *   reserve.
   */
  async createMeltQuoteBolt11(t) {
    const e = {
      unit: this._unit,
      request: t
    }, n = await this.mint.createMeltQuoteBolt11(e);
    return {
      ...n,
      unit: n.unit || this._unit,
      request: n.request || t
    };
  }
  /**
   * Requests a melt quote from the mint. Response returns amount and fees for a given unit in order
   * to pay a BOLT12 offer.
   *
   * @param offer BOLT12 offer that needs to get a fee estimate.
   * @param amountMsat Amount in millisatoshis for amount-less offers. If this is defined and the
   *   offer has an amount, they **MUST** be equal.
   * @returns The mint will create and return a melt quote for the offer with an amount and fee
   *   reserve.
   */
  async createMeltQuoteBolt12(t, e) {
    return this.mint.createMeltQuoteBolt12({
      unit: this._unit,
      request: t,
      options: e ? {
        amountless: {
          amount_msat: e
        }
      } : void 0
    });
  }
  /**
   * Requests a multi path melt quote from the mint.
   *
   * @remarks
   * Uses NUT-15 Partial multi-path payments for BOLT11.
   * @param invoice LN invoice that needs to get a fee estimate.
   * @param partialAmount The partial amount of the invoice's total to be paid by this instance.
   * @returns The mint will create and return a melt quote for the invoice with an amount and fee
   *   reserve.
   * @see https://github.com/cashubtc/nuts/blob/main/15.md
   */
  async createMultiPathMeltQuote(t, e) {
    const { supported: n, params: r } = this.getMintInfo().isSupported(15);
    this.failIf(!n, "Mint does not support NUT-15"), this.failIf(
      !r?.some((u) => u.method === "bolt11" && u.unit === this._unit),
      `Mint does not support MPP for bolt11 and ${this._unit}`
    );
    const o = {
      mpp: {
        amount: e
      }
    }, a = {
      unit: this._unit,
      request: t,
      options: o
    };
    return { ...await this.mint.createMeltQuoteBolt11(a), request: t, unit: this._unit };
  }
  // -----------------------------------------------------------------
  // Section: Check Melt Quote
  // -----------------------------------------------------------------
  /**
   * @deprecated Use checkMeltQuoteBolt11()
   */
  async checkMeltQuote(t) {
    return this.checkMeltQuoteBolt11(t);
  }
  /**
   * Returns an existing bolt11 melt quote from the mint.
   *
   * @param quote ID of the melt quote.
   * @returns The mint will return an existing melt quote.
   */
  async checkMeltQuoteBolt11(t) {
    const e = typeof t == "string" ? t : t.quote, n = await this.mint.checkMeltQuoteBolt11(e);
    return typeof t == "string" ? n : { ...n, request: t.request, unit: t.unit };
  }
  /**
   * Returns an existing bolt12 melt quote from the mint.
   *
   * @param quote ID of the melt quote.
   * @returns The mint will return an existing melt quote.
   */
  async checkMeltQuoteBolt12(t) {
    return this.mint.checkMeltQuoteBolt12(t);
  }
  // -----------------------------------------------------------------
  // Section: Melt Proofs
  // -----------------------------------------------------------------
  /**
   * @deprecated Use meltProofsBolt11()
   */
  async meltProofs(t, e, n, r) {
    return this._meltProofs("bolt11", t, e, n, r);
  }
  /**
   * Melt proofs for a bolt11 melt quote.
   *
   * @remarks
   * ProofsToSend must be at least amount+fee_reserve from the melt quote. This function does not
   * perform coin selection!.
   * @param meltQuote ID of the melt quote.
   * @param proofsToSend Proofs to melt.
   * @param config Optional parameters.
   * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().
   * @returns MeltProofsResponse with quote and change proofs.
   */
  async meltProofsBolt11(t, e, n, r) {
    return this._meltProofs("bolt11", t, e, n, r);
  }
  /**
   * Melt proofs for a bolt12 melt quote, returns change proofs using specified outputType.
   *
   * @remarks
   * ProofsToSend must be at least amount+fee_reserve from the melt quote. This function does not
   * perform coin selection!.
   * @param meltQuote ID of the melt quote.
   * @param proofsToSend Proofs to melt.
   * @param config Optional parameters.
   * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().
   * @returns MeltProofsResponse with quote and change proofs.
   */
  async meltProofsBolt12(t, e, n, r) {
    return this._meltProofs("bolt12", t, e, n, r);
  }
  /**
   * Melt proofs for a given melt quote created with the bolt11 or bolt12 method.
   *
   * @remarks
   * Creates NUT-08 blanks (1-sat) for Lightning fee return. Get these by setting a
   * config.onChangeOutputsCreated callback for async melting. @see completeMelt.
   * @param method Payment method of the quote.
   * @param meltQuote The bolt11 or bolt12 melt quote.
   * @param proofsToSend Proofs to melt.
   * @param config Optional (keysetId, onChangeOutputsCreated).
   * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().
   * @returns MeltProofsResponse.
   * @throws If params are invalid or mint returns errors.
   * @see https://github.com/cashubtc/nuts/blob/main/08.md.
   */
  async _meltProofs(t, e, n, r, i) {
    i = i ?? this.defaultOutputType();
    const { keysetId: o, onChangeOutputsCreated: a, onCountersReserved: c } = r || {}, u = this.getKeyset(o), l = rt(n), h = l - e.amount;
    let d = [];
    if (this.failIf(h < 0, "Not enough proofs to cover amount + fee reserve", {
      sendAmount: l,
      quoteAmount: e.amount
    }), h > 0) {
      let w = Math.ceil(Math.log2(h)) || 1;
      w < 0 && (w = 0);
      const v = w ? new Array(w).fill(0) : [];
      this._logger.debug("Creating NUT-08 blanks for fee reserve", {
        feeReserve: h,
        denominations: v
      }), i.type === "custom" && this.fail("Custom OutputType not supported for melt change (must be 0-sat blanks)");
      let I = { ...i, denominations: v };
      const U = await this.addCountersToOutputTypes(u.id, I);
      [I] = U.outputTypes, U.used && this.safeCallback(c, U.used, { op: "meltProofs" }), this._logger.debug("melt counter", { counter: U.used, meltOT: I }), d = this.createOutputData(0, u, I);
    }
    n = this._prepareInputsForMint(n);
    const p = {
      quote: e.quote,
      inputs: n,
      outputs: d.map((w) => w.blindedMessage)
    };
    if (d.length > 0) {
      const w = {
        method: t,
        payload: p,
        outputData: d,
        keyset: u,
        quote: e
      };
      this.safeCallback(a, w, { op: "meltProofs" }), this.on._emitMeltBlanksCreated(w);
    }
    let m;
    const P = typeof a == "function";
    t === "bolt12" ? m = await this.mint.meltBolt12(p, { preferAsync: P }) : m = await this.mint.meltBolt11(p, { preferAsync: P }), this.failIf(
      (m.change?.length ?? 0) > d.length,
      `Mint returned ${m.change?.length ?? 0} signatures, but only ${d.length} blanks were provided`
    );
    const A = m.change?.map((w, v) => d[v].toProof(w, u)) ?? [];
    return this._logger.debug("MELT COMPLETED", { changeAmounts: A.map((w) => w.amount) }), { quote: { ...m, unit: e.unit, request: e.request }, change: A };
  }
  /**
   * Completes a pending melt by re-calling the melt endpoint and constructing change proofs.
   *
   * @remarks
   * Use with blanks from onChangeOutputsCreated to retry pending melts. Works for Bolt11/Bolt12.
   * Returns change proofs if paid, else empty change.
   * @param blanks The blanks from onChangeOutputsCreated.
   * @returns Updated MeltProofsResponse.
   * @throws If melt fails or signatures don't match output count.
   */
  async completeMelt(t) {
    const e = t.method === "bolt12" ? await this.mint.meltBolt12(t.payload) : await this.mint.meltBolt11(t.payload);
    this.failIf(
      (e.change?.length ?? 0) > t.outputData.length,
      `Mint returned ${e.change?.length ?? 0} signatures, but only ${t.outputData.length} blanks were provided`
    );
    const n = e.change?.map((r, i) => t.outputData[i].toProof(r, t.keyset)) ?? [];
    return this._logger.debug("COMPLETE MELT", { changeAmounts: n.map((r) => r.amount) }), {
      quote: { ...e, unit: t.quote.unit, request: t.quote.request },
      change: n
    };
  }
  // -----------------------------------------------------------------
  // Section: Proof States
  // -----------------------------------------------------------------
  /**
   * Get an array of the states of proofs from the mint (as an array of CheckStateEnum's)
   *
   * @param proofs (only the `secret` field is required)
   * @returns NUT-07 state for each proof, in same order.
   */
  async checkProofsStates(t) {
    const e = new TextEncoder(), n = t.map(
      (o) => ft(e.encode(o.secret)).toHex(!0)
    ), r = 100, i = [];
    for (let o = 0; o < n.length; o += r) {
      const a = n.slice(o, o + r), { states: c } = await this.mint.check({
        Ys: a
      }), u = {};
      c.forEach((l) => {
        u[l.Y] = l;
      });
      for (let l = 0; l < a.length; l++) {
        const h = u[a[l]];
        this.failIfNullish(h, "Could not find state for proof with Y: " + a[l]), i.push(h);
      }
    }
    return i;
  }
  /**
   * Groups proofs by their corresponding state, preserving order within each group.
   *
   * @param proofs (only the `secret` field is required)
   * @returns An object with arrays of proofs grouped by CheckStateEnum state.
   */
  async groupProofsByState(t) {
    const e = await this.checkProofsStates(t), n = {
      unspent: [],
      pending: [],
      spent: []
    };
    for (let r = 0; r < e.length; r++) {
      const i = t[r];
      switch (e[r].state) {
        case Et.UNSPENT:
          n.unspent.push(i);
          break;
        case Et.PENDING:
          n.pending.push(i);
          break;
        case Et.SPENT:
          n.spent.push(i);
          break;
      }
    }
    return n;
  }
}
var os = /* @__PURE__ */ ((s) => (s.POST = "post", s.NOSTR = "nostr", s))(os || {});
const kt = class kt {
  constructor(t, e) {
    this.tokens = {}, this.pool = [], this.desiredPoolSize = 10, this.maxPerMint = 10, this.mintUrl = t, this.req = e?.request ?? pe, this.logger = e?.logger ?? L, this.desiredPoolSize = Math.max(1, e?.desiredPoolSize ?? this.desiredPoolSize), this.maxPerMint = Math.max(1, e?.maxPerMint ?? this.maxPerMint);
  }
  // ------------------------------
  // Public API
  // ------------------------------
  /**
   * Attach an OIDCAuth instance so this manager can refresh CATs. Registers a listener to update
   * internal CAT/refresh state on new tokens.
   */
  attachOIDC(t) {
    return this.oidc = t, this.oidc.addTokenListener((e) => this.updateFromOIDC(e)), this;
  }
  get poolSize() {
    return this.pool.length;
  }
  get poolTarget() {
    return this.desiredPoolSize;
  }
  get activeAuthKeysetId() {
    try {
      return this.keychain?.getCheapestKeyset().id;
    } catch {
      return;
    }
  }
  get hasCAT() {
    return !!this.tokens.accessToken;
  }
  // ------------------------------
  // AuthProvider (NUT-21, Clear-auth)
  // ------------------------------
  getCAT() {
    return this.tokens.accessToken;
  }
  setCAT(t) {
    this.tokens.accessToken = t, t || (this.tokens.refreshToken = void 0, this.tokens.expiresAt = void 0);
  }
  /**
   * Ensure a valid CAT is available (refresh if expiring soon). Returns a token safe to send right
   * now, or undefined if unobtainable.
   */
  async ensureCAT(t) {
    return this.validForAtLeast(t) ? this.tokens.accessToken : !this.oidc || !this.tokens.refreshToken ? this.tokens.accessToken : (this.inflightRefresh || (this.inflightRefresh = (async () => {
      try {
        const e = await this.oidc.refresh(this.tokens.refreshToken);
        this.updateFromOIDC(e);
      } catch (e) {
        this.logger.warn("AuthManager: CAT refresh failed", { err: e });
      } finally {
        this.inflightRefresh = void 0;
      }
    })()), await this.inflightRefresh, this.validForAtLeast(0) ? this.tokens.accessToken : void 0);
  }
  // Returns true if expiry date is >minValidSecs away
  validForAtLeast(t = kt.MIN_VALID_SECS) {
    const { accessToken: e, expiresAt: n } = this.tokens;
    return e ? n ? Date.now() + t * 1e3 < n : !0 : !1;
  }
  // Updates access and refresh tokens in our store, using either the explicit expires_in key or falling back to the JWT expiry.
  updateFromOIDC(t) {
    if (!t.access_token) return;
    const e = Date.now();
    if (this.tokens.accessToken = t.access_token, t.refresh_token && (this.tokens.refreshToken = t.refresh_token), typeof t.expires_in == "number" && t.expires_in > 0)
      this.tokens.expiresAt = e + t.expires_in * 1e3;
    else {
      const n = this.parseJwtExpSec(t.access_token);
      this.tokens.expiresAt = n ? n * 1e3 : void 0;
    }
    this.logger.debug("AuthManager: OIDC tokens updated", { expiresAt: this.tokens.expiresAt });
  }
  // ------------------------------
  // AuthProvider (NUT-22, Blind-auth)
  // ------------------------------
  /**
   * Ensure there are enough BAT tokens (topping up if needed)
   *
   * @param minTokens Minimum tokens needed.
   */
  async ensure(t) {
    if (await this.init(), this.pool.length >= t) return;
    const e = Math.max(this.desiredPoolSize, t), n = this.getBatMaxMint(), r = Math.min(e - this.pool.length, n);
    r <= 0 || await this.topUp(r);
  }
  /**
   * Gets a Blind Authentication Token (BAT)
   *
   * @param {method, path} to Call (not used in our implementation)
   * @returns The serialized BAT ready to insert into request header.
   */
  async getBlindAuthToken({
    method: t,
    path: e
  }) {
    return this.info && !this.info.requiresBlindAuthToken(t, e) && this.logger.warn("Endpoint is not marked as protected by NUT-22; still issuing BAT", {
      method: t,
      path: e
    }), this.withLock(async () => {
      if (await this.ensure(1), this.pool.length === 0)
        throw new Error("AuthManager: no BATs available and minting failed");
      const n = this.pool.pop();
      return this.logger.debug("AuthManager: BAT requested", {
        method: t,
        path: e,
        remaining: this.pool.length
      }), as(n);
    });
  }
  /**
   * Replace or merge the current BAT pool with previously persisted BATs.
   */
  importPool(t, e = "replace") {
    e === "replace" && (this.pool = []);
    const n = new Map(this.pool.map((r) => [r.secret, r]));
    for (const r of t)
      !r || !r.secret || !r.C || !r.id || n.has(r.secret) || (this.pool.push(r), n.set(r.secret, r));
  }
  /**
   * Return a deep-copied snapshot of the current BAT pool (full Proofs, including dleq).
   */
  exportPool() {
    return this.pool.map((t) => ({ ...t, dleq: t.dleq ? { ...t.dleq } : void 0 }));
  }
  // ------------------------------
  // Internals
  // ------------------------------
  /**
   * Extract exp, seconds since epoch, from a JWT access token.
   */
  parseJwtExpSec(t) {
    if (!t) return;
    const e = t.split(".");
    if (e.length === 3)
      try {
        const n = _.toString(_.fromBase64(e[1])), r = JSON.parse(n), i = typeof r.exp == "number" ? r.exp : Number(r.exp);
        if (Number.isFinite(i) && i > 0) return i;
      } catch {
        this.logger.warn("JWT access token was malformed.", {
          token: t
        });
      }
  }
  /**
   * Simple mutex lock - chains promises in order.
   */
  async withLock(t) {
    const e = this.lockChain ?? Promise.resolve();
    let n;
    const r = new Promise((o) => {
      n = o;
    }), i = e.then(() => r);
    this.lockChain = i;
    try {
      return await e, await t();
    } finally {
      n(), this.lockChain === i && (this.lockChain = void 0);
    }
  }
  /**
   * Initialise mint info and auth keysets/keys as needed.
   */
  async init() {
    if (!this.info) {
      const t = await this.req({
        endpoint: W(this.mintUrl, "/v1/info"),
        method: "GET"
      });
      this.info = new wt(t);
    }
    if (!this.keychain) {
      const [t, e] = await Promise.all([
        this.req({
          endpoint: W(this.mintUrl, "/v1/auth/blind/keysets"),
          method: "GET"
        }),
        this.req({
          endpoint: W(this.mintUrl, "/v1/auth/blind/keys"),
          method: "GET"
        })
      ]);
      this.keychain = new Ue(this.mintUrl, "auth", t.keysets, e.keysets), this.keychain.getCheapestKeyset();
    }
  }
  /**
   * Gets the BAT minting limit: lower of manager limit and Mints NUT-22 limit.
   */
  getBatMaxMint() {
    if (!this.info) throw new Error("AuthManager: mint info not loaded");
    const e = this.info.nuts[22]?.bat_max_mint ?? this.maxPerMint;
    return Math.max(1, Math.min(this.maxPerMint, e));
  }
  getActiveKeys() {
    if (!this.keychain) throw new Error("AuthManager: keyset not loaded for active keyset");
    return this.keychain.getCheapestKeyset();
  }
  /**
   * Mint a batch of BATs using the current CAT if the endpoint is protected by NUT-21.
   */
  async topUp(t) {
    if (!this.info) throw new Error("AuthManager: mint info not loaded");
    const e = this.info.requiresClearAuthToken("POST", "/v1/auth/blind/mint");
    let n;
    if (e && (n = await this.ensureCAT(), !n))
      throw new Error(
        "AuthManager: Clear-auth token required for /v1/auth/blind/mint but not available. Authenticate with the mint to obtain a CAT first."
      );
    const r = this.getActiveKeys(), i = N.createRandomData(t, r), o = { outputs: i.map((l) => l.blindedMessage) }, a = {};
    n && (a["Clear-auth"] = n);
    const c = await this.req({
      endpoint: W(this.mintUrl, "/v1/auth/blind/mint"),
      method: "POST",
      headers: a,
      requestBody: o
    });
    if (!Array.isArray(c?.signatures) || c.signatures.length !== i.length)
      throw new Error("AuthManager: bad BAT mint response");
    const u = i.map((l, h) => l.toProof(c.signatures[h], r));
    for (const l of u)
      if (!De(l, r))
        throw new Error("AuthManager: mint returned BAT with invalid DLEQ");
    this.pool.push(...u), this.logger.debug("AuthManager: performed topUp", {
      minted: u.length,
      pool: this.pool.length
    });
  }
};
kt.MIN_VALID_SECS = 30;
let Bt = kt;
function as(s) {
  const t = { id: s.id, secret: s.secret, C: s.C };
  return `authA${me(t)}`;
}
async function Ls(s, t) {
  const e = new Bt(s, {
    desiredPoolSize: t?.authPool ?? 10,
    logger: t?.logger
  }), n = new Vt(s, { authProvider: e, logger: t?.logger }), r = await n.oidcAuth({
    ...t?.oidc,
    logger: t?.logger,
    onTokens: (o) => e.setCAT(o.access_token)
    // set CAT automatically
  });
  e.attachOIDC(r);
  const i = new Gt(n, { authProvider: e, logger: t?.logger });
  return await i.loadMint(), { mint: n, auth: e, oidc: r, wallet: i };
}
export {
  Bt as AuthManager,
  Et as CheckStateEnum,
  gs as ConsoleLogger,
  ht as HttpResponseError,
  Ue as KeyChain,
  zn as Keyset,
  ae as MeltBuilder,
  ut as MeltQuoteState,
  Ln as MessageNode,
  $n as MessageQueue,
  Vt as Mint,
  oe as MintBuilder,
  wt as MintInfo,
  Dt as MintOperationError,
  Tt as MintQuoteState,
  Kt as NetworkError,
  zt as OIDCAuth,
  N as OutputData,
  Zt as P2BK_DST,
  Ne as P2PKBuilder,
  Ht as PaymentRequest,
  os as PaymentRequestTransportType,
  ns as ReceiveBuilder,
  es as SendBuilder,
  jn as WSConnection,
  Gt as Wallet,
  is as WalletCounters,
  rs as WalletEvents,
  ts as WalletOps,
  Bs as bigIntStringify,
  gt as blindMessage,
  $ as bytesToNumber,
  qs as checkResponse,
  Sn as constructProofFromPromise,
  Ls as createAuthWallet,
  vs as createBlindSignature,
  Cs as createDLEQProof,
  Is as createNewMintKeys,
  ys as createP2PKsecret,
  Es as createRandomBlindedMessage,
  ve as createRandomSecretKey,
  Us as decodePaymentRequest,
  ne as deepEqual,
  Bn as deriveBlindingFactor,
  Qt as deriveKeysetId,
  gn as deriveP2BKBlindedPubkeys,
  mn as deriveP2BKSecretKey,
  pn as deriveP2BKSecretKeys,
  xn as deriveSecret,
  Ts as deserializeMintKeys,
  Ss as deserializeProof,
  Fn as getDecodedToken,
  Fs as getDecodedTokenBinary,
  Os as getEncodedToken,
  Ns as getEncodedTokenBinary,
  Rn as getEncodedTokenV3,
  Nn as getEncodedTokenV4,
  Un as getKeepAmounts,
  Te as getKeysetAmounts,
  vn as getKeysetIdInt,
  $t as getP2PKExpectedKWitnessPubkeys,
  _e as getP2PKLocktime,
  kn as getP2PKNSigs,
  ks as getP2PKSigFlag,
  ke as getP2PKWitnessPubkeys,
  be as getP2PKWitnessRefundkeys,
  Wt as getP2PKWitnessSignatures,
  Mn as getPubKeyFromPrivKey,
  Pe as getSignedOutput,
  Ps as getSignedOutputs,
  Ks as getTokenMetadata,
  Be as handleTokens,
  Ie as hasCorrespondingKey,
  jt as hasNonHexId,
  ws as hasP2PKSignedProof,
  De as hasValidDleq,
  ft as hashToCurve,
  Ae as hash_e,
  dt as hexToNumber,
  ms as injectWebSocketImpl,
  T as isObj,
  Ct as isValidHex,
  W as joinUrls,
  Pn as maybeDeriveP2BKPrivateKeys,
  Pt as mergeUInt8Arrays,
  Mt as numberToHexPadded64,
  Q as parseP2PKSecret,
  As as pointFromBytes,
  X as pointFromHex,
  Oe as sanitizeUrl,
  Yn as selectProofsRGLI,
  In as serializeMintKeys,
  Tn as serializeProof,
  ps as setGlobalRequestOptions,
  wn as signBlindedMessage,
  qn as signMintQuote,
  _n as signP2PKProof,
  bn as signP2PKProofs,
  yn as signP2PKSecret,
  Ds as sortProofsById,
  G as splitAmount,
  Ke as stripDleq,
  rt as sumProofs,
  En as unblindSignature,
  Kn as verifyDLEQProof,
  Dn as verifyDLEQProof_reblind,
  Rs as verifyKeysetId,
  xs as verifyMintQuoteSignature,
  Lt as verifyP2PKSecretSignature,
  bs as verifyP2PKSig,
  _s as verifyP2PKSigOutput,
  Ms as verifyProof
};
//# sourceMappingURL=cashu-ts.es.js.map
