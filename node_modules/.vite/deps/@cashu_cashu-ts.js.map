{
  "version": 3,
  "sources": ["../../@noble/hashes/src/crypto.ts", "../../@noble/hashes/src/utils.ts", "../../@noble/hashes/src/_md.ts", "../../@noble/hashes/src/_u64.ts", "../../@noble/hashes/src/sha2.ts", "../../@noble/hashes/src/hmac.ts", "../../@noble/curves/src/utils.ts", "../../@noble/curves/src/abstract/modular.ts", "../../@noble/curves/src/abstract/curve.ts", "../../@noble/curves/src/abstract/weierstrass.ts", "../../@noble/curves/src/_shortw_utils.ts", "../../@noble/curves/src/abstract/hash-to-curve.ts", "../../@noble/curves/src/secp256k1.ts", "../../@noble/hashes/src/legacy.ts", "../../@scure/base/index.ts", "../../@scure/bip32/index.ts", "../../@cashu/cashu-ts/src/mint/types/responses.ts", "../../@cashu/cashu-ts/src/model/Errors.ts", "../../@cashu/cashu-ts/src/logger/NullLogger.ts", "../../@cashu/cashu-ts/src/logger/helpers.ts", "../../@cashu/cashu-ts/src/logger/ConsoleLogger.ts", "../../@cashu/cashu-ts/src/transport/request.ts", "../../@cashu/cashu-ts/src/transport/ws.ts", "../../@cashu/cashu-ts/src/utils/Bytes.ts", "../../@cashu/cashu-ts/src/utils/base64.ts", "../../@cashu/cashu-ts/src/utils/cbor.ts", "../../@cashu/cashu-ts/src/crypto/NUT26.ts", "../../@cashu/cashu-ts/src/crypto/NUT11.ts", "../../@cashu/cashu-ts/src/crypto/core.ts", "../../@cashu/cashu-ts/src/crypto/NUT01.ts", "../../@cashu/cashu-ts/src/crypto/NUT13.ts", "../../@cashu/cashu-ts/src/crypto/NUT12.ts", "../../@cashu/cashu-ts/src/crypto/NUT20.ts", "../../@cashu/cashu-ts/src/model/PaymentRequest.ts", "../../@cashu/cashu-ts/src/utils/core.ts", "../../@cashu/cashu-ts/src/transport/WSConnection.ts", "../../@cashu/cashu-ts/src/legacy/nut-05.ts", "../../@cashu/cashu-ts/src/legacy/nut-04.ts", "../../@cashu/cashu-ts/src/legacy/nut-06.ts", "../../@cashu/cashu-ts/src/model/MintInfo.ts", "../../@cashu/cashu-ts/src/auth/OIDCAuth.ts", "../../@cashu/cashu-ts/src/mint/Mint.ts", "../../@cashu/cashu-ts/src/wallet/Keyset.ts", "../../@cashu/cashu-ts/src/wallet/KeyChain.ts", "../../@cashu/cashu-ts/src/model/BlindedMessage.ts", "../../@cashu/cashu-ts/src/model/OutputData.ts", "../../@cashu/cashu-ts/src/wallet/P2PKBuilder.ts", "../../@cashu/cashu-ts/src/wallet/SelectProofs.ts", "../../@cashu/cashu-ts/src/wallet/CounterSource.ts", "../../@cashu/cashu-ts/src/wallet/WalletOps.ts", "../../@cashu/cashu-ts/src/wallet/WalletEvents.ts", "../../@cashu/cashu-ts/src/wallet/WalletCounters.ts", "../../@cashu/cashu-ts/src/model/types/proof-state.ts", "../../@cashu/cashu-ts/src/wallet/Wallet.ts", "../../@cashu/cashu-ts/src/wallet/types/payment-requests.ts", "../../@cashu/cashu-ts/src/auth/AuthManager.ts", "../../@cashu/cashu-ts/src/auth/createAuthWallet.ts"],
  "sourcesContent": ["/**\n * Internal webcrypto alias.\n * We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n * See utils.ts for details.\n * @module\n */\ndeclare const globalThis: Record<string, any> | undefined;\nexport const crypto: any =\n  typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n", "/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is positive integer. */\nexport function anumber(n: number): void {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n/** Asserts something is Uint8Array. */\nexport function abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\n/** Asserts something is hash */\nexport function ahash(h: IHash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.createHasher');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out: any, instance: any): void {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays: TypedArray[]): void {\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word: number, shift: number): number {\n  return (word << (32 - shift)) | (word >>> shift);\n}\n\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word: number, shift: number): number {\n  return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n\n/** The byte swap operation for uint32 */\nexport function byteSwap(word: number): number {\n  return (\n    ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff)\n  );\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE: (n: number) => number = isLE\n  ? (n: number) => n\n  : (n: number) => byteSwap(n);\n\n/** @deprecated */\nexport const byteSwapIfBE: typeof swap8IfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr: Uint32Array): Uint32Array {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n  return arr;\n}\n\nexport const swap32IfBE: (u: Uint32Array) => Uint32Array = isLE\n  ? (u: Uint32Array) => u\n  : byteSwap32;\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async (): Promise<void> => {};\n\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(\n  iters: number,\n  tick: number,\n  cb: (i: number) => void\n): Promise<void> {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes: Uint8Array): string {\n  return new TextDecoder().decode(bytes);\n}\n\n/** Accepted input of hash functions. Strings are converted to byte arrays. */\nexport type Input = string | Uint8Array;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** KDFs can accept string or Uint8Array for user convenience. */\nexport type KDFInput = string | Uint8Array;\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data: KDFInput): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Hash interface. */\nexport type IHash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\n\n/** For runtime check if class implements interface */\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  abstract clone(): T;\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\n/** Hash function */\nexport type CHash = ReturnType<typeof createHasher>;\n/** Hash function with output */\nexport type CHashO = ReturnType<typeof createOptHasher>;\n/** XOF with output */\nexport type CHashXO = ReturnType<typeof createXOFer>;\n\n/** Wraps hash function, creating an interface on top of it */\nexport function createHasher<T extends Hash<T>>(\n  hashCons: () => Hash<T>\n): {\n  (msg: Input): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(): Hash<T>;\n} {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function createOptHasher<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): Hash<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function createXOFer<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): HashXOF<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\nexport const wrapConstructor: typeof createHasher = createHasher;\nexport const wrapConstructorWithOpts: typeof createOptHasher = createOptHasher;\nexport const wrapXOFConstructorWithOpts: typeof createXOFer = createXOFer;\n\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  // Legacy Node.js compatibility\n  if (crypto && typeof crypto.randomBytes === 'function') {\n    return Uint8Array.from(crypto.randomBytes(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n", "/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { type Input, Hash, abytes, aexists, aoutput, clean, createView, toBytes } from './utils.ts';\n\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nexport function setBigUint64(\n  view: DataView,\n  byteOffset: number,\n  value: bigint,\n  isLE: boolean\n): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n/** Choice: a ? b : c */\nexport function Chi(a: number, b: number, c: number): number {\n  return (a & b) ^ (~a & c);\n}\n\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a: number, b: number, c: number): number {\n  return (a & b) ^ (a & c) ^ (b & c);\n}\n\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport abstract class HashMD<T extends HashMD<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n\n  readonly blockLen: number;\n  readonly outputLen: number;\n  readonly padOffset: number;\n  readonly isLE: boolean;\n\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(blockLen: number, outputLen: number, padOffset: number, isLE: boolean) {\n    super();\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.padOffset = padOffset;\n    this.isLE = isLE;\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    const { view, buffer, blockLen } = this;\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    clean(this.buffer.subarray(pos));\n    // we have less than padOffset left in buffer, so we cannot put length in\n    // current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.destroyed = destroyed;\n    to.finished = finished;\n    to.length = length;\n    to.pos = pos;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexport const SHA256_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexport const SHA224_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexport const SHA384_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n  0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexport const SHA512_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n  0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n", "/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\nfunction fromBig(\n  n: bigint,\n  le = false\n): {\n  h: number;\n  l: number;\n} {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false): Uint32Array[] {\n  const len = lst.length;\n  let Ah = new Uint32Array(len);\n  let Al = new Uint32Array(len);\n  for (let i = 0; i < len; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number): bigint => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number): number => h >>> s;\nconst shrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number): number => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number): number => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number): number => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number): number => l;\nconst rotr32L = (h: number, _l: number): number => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number): number => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number): number => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number): number => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number): number => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(\n  Ah: number,\n  Al: number,\n  Bh: number,\n  Bl: number\n): {\n  h: number;\n  l: number;\n} {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number): number => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number): number =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number): number =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number): number =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig\n};\n// prettier-ignore\nconst u64: { fromBig: typeof fromBig; split: typeof split; toBig: (h: number, l: number) => bigint; shrSH: (h: number, _l: number, s: number) => number; shrSL: (h: number, l: number, s: number) => number; rotrSH: (h: number, l: number, s: number) => number; rotrSL: (h: number, l: number, s: number) => number; rotrBH: (h: number, l: number, s: number) => number; rotrBL: (h: number, l: number, s: number) => number; rotr32H: (_h: number, l: number) => number; rotr32L: (h: number, _l: number) => number; rotlSH: (h: number, l: number, s: number) => number; rotlSL: (h: number, l: number, s: number) => number; rotlBH: (h: number, l: number, s: number) => number; rotlBL: (h: number, l: number, s: number) => number; add: typeof add; add3L: (Al: number, Bl: number, Cl: number) => number; add3H: (low: number, Ah: number, Bh: number, Ch: number) => number; add4L: (Al: number, Bl: number, Cl: number, Dl: number) => number; add4H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number) => number; add5H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) => number; add5L: (Al: number, Bl: number, Cl: number, Dl: number, El: number) => number; } = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n", "/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nimport { Chi, HashMD, Maj, SHA224_IV, SHA256_IV, SHA384_IV, SHA512_IV } from './_md.ts';\nimport * as u64 from './_u64.ts';\nimport { type CHash, clean, createHasher, rotr } from './utils.ts';\n\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  protected A: number = SHA256_IV[0] | 0;\n  protected B: number = SHA256_IV[1] | 0;\n  protected C: number = SHA256_IV[2] | 0;\n  protected D: number = SHA256_IV[3] | 0;\n  protected E: number = SHA256_IV[4] | 0;\n  protected F: number = SHA256_IV[5] | 0;\n  protected G: number = SHA256_IV[6] | 0;\n  protected H: number = SHA256_IV[7] | 0;\n\n  constructor(outputLen: number = 32) {\n    super(64, outputLen, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean(): void {\n    clean(SHA256_W);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\nexport class SHA224 extends SHA256 {\n  protected A: number = SHA224_IV[0] | 0;\n  protected B: number = SHA224_IV[1] | 0;\n  protected C: number = SHA224_IV[2] | 0;\n  protected D: number = SHA224_IV[3] | 0;\n  protected E: number = SHA224_IV[4] | 0;\n  protected F: number = SHA224_IV[5] | 0;\n  protected G: number = SHA224_IV[6] | 0;\n  protected H: number = SHA224_IV[7] | 0;\n  constructor() {\n    super(28);\n  }\n}\n\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n  '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n  '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n  '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n  '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n  '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n  '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n  '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n  '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n  '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n  '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n  '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n  '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n  '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n  '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n  '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n  '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n  '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n  '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n  '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n  '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\n\nexport class SHA512 extends HashMD<SHA512> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  // h -- high 32 bits, l -- low 32 bits\n  protected Ah: number = SHA512_IV[0] | 0;\n  protected Al: number = SHA512_IV[1] | 0;\n  protected Bh: number = SHA512_IV[2] | 0;\n  protected Bl: number = SHA512_IV[3] | 0;\n  protected Ch: number = SHA512_IV[4] | 0;\n  protected Cl: number = SHA512_IV[5] | 0;\n  protected Dh: number = SHA512_IV[6] | 0;\n  protected Dl: number = SHA512_IV[7] | 0;\n  protected Eh: number = SHA512_IV[8] | 0;\n  protected El: number = SHA512_IV[9] | 0;\n  protected Fh: number = SHA512_IV[10] | 0;\n  protected Fl: number = SHA512_IV[11] | 0;\n  protected Gh: number = SHA512_IV[12] | 0;\n  protected Gl: number = SHA512_IV[13] | 0;\n  protected Hh: number = SHA512_IV[14] | 0;\n  protected Hl: number = SHA512_IV[15] | 0;\n\n  constructor(outputLen: number = 64) {\n    super(128, outputLen, 16, false);\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n  }\n  // prettier-ignore\n  protected set(\n    Ah: number, Al: number, Bh: number, Bl: number, Ch: number, Cl: number, Dh: number, Dl: number,\n    Eh: number, El: number, Fh: number, Fl: number, Gh: number, Gl: number, Hh: number, Hl: number\n  ): void {\n    this.Ah = Ah | 0;\n    this.Al = Al | 0;\n    this.Bh = Bh | 0;\n    this.Bl = Bl | 0;\n    this.Ch = Ch | 0;\n    this.Cl = Cl | 0;\n    this.Dh = Dh | 0;\n    this.Dl = Dl | 0;\n    this.Eh = Eh | 0;\n    this.El = El | 0;\n    this.Fh = Fh | 0;\n    this.Fl = Fl | 0;\n    this.Gh = Gh | 0;\n    this.Gl = Gl | 0;\n    this.Hh = Hh | 0;\n    this.Hl = Hl | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) {\n      SHA512_W_H[i] = view.getUint32(offset);\n      SHA512_W_L[i] = view.getUint32((offset += 4));\n    }\n    for (let i = 16; i < 80; i++) {\n      // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n      const W15h = SHA512_W_H[i - 15] | 0;\n      const W15l = SHA512_W_L[i - 15] | 0;\n      const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n      const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n      // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n      const W2h = SHA512_W_H[i - 2] | 0;\n      const W2l = SHA512_W_L[i - 2] | 0;\n      const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n      const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n      // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n      const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n      const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n      SHA512_W_H[i] = SUMh | 0;\n      SHA512_W_L[i] = SUMl | 0;\n    }\n    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    // Compression function main loop, 80 rounds\n    for (let i = 0; i < 80; i++) {\n      // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n      const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n      const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n      //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n      const CHIl = (El & Fl) ^ (~El & Gl);\n      // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n      // prettier-ignore\n      const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n      const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n      const T1l = T1ll | 0;\n      // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n      const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n      const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n      const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n      const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n      Hh = Gh | 0;\n      Hl = Gl | 0;\n      Gh = Fh | 0;\n      Gl = Fl | 0;\n      Fh = Eh | 0;\n      Fl = El | 0;\n      ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n      Dh = Ch | 0;\n      Dl = Cl | 0;\n      Ch = Bh | 0;\n      Cl = Bl | 0;\n      Bh = Ah | 0;\n      Bl = Al | 0;\n      const All = u64.add3L(T1l, sigma0l, MAJl);\n      Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n      Al = All | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n    ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n    ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n    ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n    ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n    ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n    ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n    ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n  }\n  protected roundClean(): void {\n    clean(SHA512_W_H, SHA512_W_L);\n  }\n  destroy(): void {\n    clean(this.buffer);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\nexport class SHA384 extends SHA512 {\n  protected Ah: number = SHA384_IV[0] | 0;\n  protected Al: number = SHA384_IV[1] | 0;\n  protected Bh: number = SHA384_IV[2] | 0;\n  protected Bl: number = SHA384_IV[3] | 0;\n  protected Ch: number = SHA384_IV[4] | 0;\n  protected Cl: number = SHA384_IV[5] | 0;\n  protected Dh: number = SHA384_IV[6] | 0;\n  protected Dl: number = SHA384_IV[7] | 0;\n  protected Eh: number = SHA384_IV[8] | 0;\n  protected El: number = SHA384_IV[9] | 0;\n  protected Fh: number = SHA384_IV[10] | 0;\n  protected Fl: number = SHA384_IV[11] | 0;\n  protected Gh: number = SHA384_IV[12] | 0;\n  protected Gl: number = SHA384_IV[13] | 0;\n  protected Hh: number = SHA384_IV[14] | 0;\n  protected Hl: number = SHA384_IV[15] | 0;\n\n  constructor() {\n    super(48);\n  }\n}\n\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n  0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n  0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n  0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n  0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\n\nexport class SHA512_224 extends SHA512 {\n  protected Ah: number = T224_IV[0] | 0;\n  protected Al: number = T224_IV[1] | 0;\n  protected Bh: number = T224_IV[2] | 0;\n  protected Bl: number = T224_IV[3] | 0;\n  protected Ch: number = T224_IV[4] | 0;\n  protected Cl: number = T224_IV[5] | 0;\n  protected Dh: number = T224_IV[6] | 0;\n  protected Dl: number = T224_IV[7] | 0;\n  protected Eh: number = T224_IV[8] | 0;\n  protected El: number = T224_IV[9] | 0;\n  protected Fh: number = T224_IV[10] | 0;\n  protected Fl: number = T224_IV[11] | 0;\n  protected Gh: number = T224_IV[12] | 0;\n  protected Gl: number = T224_IV[13] | 0;\n  protected Hh: number = T224_IV[14] | 0;\n  protected Hl: number = T224_IV[15] | 0;\n\n  constructor() {\n    super(28);\n  }\n}\n\nexport class SHA512_256 extends SHA512 {\n  protected Ah: number = T256_IV[0] | 0;\n  protected Al: number = T256_IV[1] | 0;\n  protected Bh: number = T256_IV[2] | 0;\n  protected Bl: number = T256_IV[3] | 0;\n  protected Ch: number = T256_IV[4] | 0;\n  protected Cl: number = T256_IV[5] | 0;\n  protected Dh: number = T256_IV[6] | 0;\n  protected Dl: number = T256_IV[7] | 0;\n  protected Eh: number = T256_IV[8] | 0;\n  protected El: number = T256_IV[9] | 0;\n  protected Fh: number = T256_IV[10] | 0;\n  protected Fl: number = T256_IV[11] | 0;\n  protected Gh: number = T256_IV[12] | 0;\n  protected Gl: number = T256_IV[13] | 0;\n  protected Hh: number = T256_IV[14] | 0;\n  protected Hl: number = T256_IV[15] | 0;\n\n  constructor() {\n    super(32);\n  }\n}\n\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */\nexport const sha256: CHash = /* @__PURE__ */ createHasher(() => new SHA256());\n/** SHA2-224 hash function from RFC 4634 */\nexport const sha224: CHash = /* @__PURE__ */ createHasher(() => new SHA224());\n\n/** SHA2-512 hash function from RFC 4634. */\nexport const sha512: CHash = /* @__PURE__ */ createHasher(() => new SHA512());\n/** SHA2-384 hash function from RFC 4634. */\nexport const sha384: CHash = /* @__PURE__ */ createHasher(() => new SHA384());\n\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_256: CHash = /* @__PURE__ */ createHasher(() => new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_224: CHash = /* @__PURE__ */ createHasher(() => new SHA512_224());\n", "/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\nimport { abytes, aexists, ahash, clean, Hash, toBytes, type CHash, type Input } from './utils.ts';\n\nexport class HMAC<T extends Hash<T>> extends Hash<HMAC<T>> {\n  oHash: T;\n  iHash: T;\n  blockLen: number;\n  outputLen: number;\n  private finished = false;\n  private destroyed = false;\n\n  constructor(hash: CHash, _key: Input) {\n    super();\n    ahash(hash);\n    const key = toBytes(_key);\n    this.iHash = hash.create() as T;\n    if (typeof this.iHash.update !== 'function')\n      throw new Error('Expected instance of class which extends utils.Hash');\n    this.blockLen = this.iHash.blockLen;\n    this.outputLen = this.iHash.outputLen;\n    const blockLen = this.blockLen;\n    const pad = new Uint8Array(blockLen);\n    // blockLen can be bigger than outputLen\n    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36;\n    this.iHash.update(pad);\n    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n    this.oHash = hash.create() as T;\n    // Undo internal XOR && apply outer XOR\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36 ^ 0x5c;\n    this.oHash.update(pad);\n    clean(pad);\n  }\n  update(buf: Input): this {\n    aexists(this);\n    this.iHash.update(buf);\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    abytes(out, this.outputLen);\n    this.finished = true;\n    this.iHash.digestInto(out);\n    this.oHash.update(out);\n    this.oHash.digestInto(out);\n    this.destroy();\n  }\n  digest(): Uint8Array {\n    const out = new Uint8Array(this.oHash.outputLen);\n    this.digestInto(out);\n    return out;\n  }\n  _cloneInto(to?: HMAC<T>): HMAC<T> {\n    // Create new instance without calling constructor since key already in state and we don't know it.\n    to ||= Object.create(Object.getPrototypeOf(this), {});\n    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n    to = to as this;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.blockLen = blockLen;\n    to.outputLen = outputLen;\n    to.oHash = oHash._cloneInto(to.oHash);\n    to.iHash = iHash._cloneInto(to.iHash);\n    return to;\n  }\n  clone(): HMAC<T> {\n    return this._cloneInto();\n  }\n  destroy(): void {\n    this.destroyed = true;\n    this.oHash.destroy();\n    this.iHash.destroy();\n  }\n}\n\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nexport const hmac: {\n  (hash: CHash, key: Input, message: Input): Uint8Array;\n  create(hash: CHash, key: Input): HMAC<any>;\n} = (hash: CHash, key: Input, message: Input): Uint8Array =>\n  new HMAC<any>(hash, key).update(message).digest();\nhmac.create = (hash: CHash, key: Input) => new HMAC<any>(hash, key);\n", "/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  abytes as abytes_,\n  bytesToHex as bytesToHex_,\n  concatBytes as concatBytes_,\n  hexToBytes as hexToBytes_,\n  isBytes as isBytes_,\n} from '@noble/hashes/utils.js';\nexport {\n  abytes,\n  anumber,\n  bytesToHex,\n  bytesToUtf8,\n  concatBytes,\n  hexToBytes,\n  isBytes,\n  randomBytes,\n  utf8ToBytes,\n} from '@noble/hashes/utils.js';\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nexport type Hex = Uint8Array | string; // hex strings are accepted for simplicity\nexport type PrivKey = Hex | bigint; // bigints are accepted to ease learning curve\nexport type CHash = {\n  (message: Uint8Array | string): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create(opts?: { dkLen?: number }): any; // For shake\n};\nexport type FHash = (message: Uint8Array | string) => Uint8Array;\n\nexport function abool(title: string, value: boolean): void {\n  if (typeof value !== 'boolean') throw new Error(title + ' boolean expected, got ' + value);\n}\n\n// tmp name until v2\nexport function _abool2(value: boolean, title: string = ''): boolean {\n  if (typeof value !== 'boolean') {\n    const prefix = title && `\"${title}\"`;\n    throw new Error(prefix + 'expected boolean, got type=' + typeof value);\n  }\n  return value;\n}\n\n// tmp name until v2\n/** Asserts something is Uint8Array. */\nexport function _abytes2(value: Uint8Array, length?: number, title: string = ''): Uint8Array {\n  const bytes = isBytes_(value);\n  const len = value?.length;\n  const needsLen = length !== undefined;\n  if (!bytes || (needsLen && len !== length)) {\n    const prefix = title && `\"${title}\" `;\n    const ofLen = needsLen ? ` of length ${length}` : '';\n    const got = bytes ? `length=${len}` : `type=${typeof value}`;\n    throw new Error(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);\n  }\n  return value;\n}\n\n// Used in weierstrass, der\nexport function numberToHexUnpadded(num: number | bigint): string {\n  const hex = num.toString(16);\n  return hex.length & 1 ? '0' + hex : hex;\n}\n\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex_(bytes));\n}\nexport function bytesToNumberLE(bytes: Uint8Array): bigint {\n  abytes_(bytes);\n  return hexToNumber(bytesToHex_(Uint8Array.from(bytes).reverse()));\n}\n\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes_(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n: number | bigint, len: number): Uint8Array {\n  return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n: number | bigint): Uint8Array {\n  return hexToBytes_(numberToHexUnpadded(n));\n}\n\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'secret key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title: string, hex: Hex, expectedLength?: number): Uint8Array {\n  let res: Uint8Array;\n  if (typeof hex === 'string') {\n    try {\n      res = hexToBytes_(hex);\n    } catch (e) {\n      throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n    }\n  } else if (isBytes_(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(title + ' must be hex string or Uint8Array');\n  }\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength)\n    throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n  return res;\n}\n\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n/**\n * Copies Uint8Array. We can't use u8a.slice(), because u8a can be Buffer,\n * and Buffer#slice creates mutable copy. Never use Buffers!\n */\nexport function copyBytes(bytes: Uint8Array): Uint8Array {\n  return Uint8Array.from(bytes);\n}\n\n/**\n * Decodes 7-bit ASCII string to Uint8Array, throws on non-ascii symbols\n * Should be safe to use for things expected to be ASCII.\n * Returns exact same result as utf8ToBytes for ASCII or throws.\n */\nexport function asciiToBytes(ascii: string): Uint8Array {\n  return Uint8Array.from(ascii, (c, i) => {\n    const charCode = c.charCodeAt(0);\n    if (c.length !== 1 || charCode > 127) {\n      throw new Error(\n        `string contains non-ASCII character \"${ascii[i]}\" with code ${charCode} at position ${i}`\n      );\n    }\n    return charCode;\n  });\n}\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\n// export const utf8ToBytes: typeof utf8ToBytes_ = utf8ToBytes_;\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\n// export const bytesToUtf8: typeof bytesToUtf8_ = bytesToUtf8_;\n\n// Is positive bigint\nconst isPosBig = (n: bigint) => typeof n === 'bigint' && _0n <= n;\n\nexport function inRange(n: bigint, min: bigint, max: bigint): boolean {\n  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nexport function aInRange(title: string, n: bigint, min: bigint, max: bigint): void {\n  // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n  // consider P=256n, min=0n, max=P\n  // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n  // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n  // - our way is the cleanest:               `inRange('x', x, 0n, P)\n  if (!inRange(n, min, max))\n    throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n\n// Bit operations\n\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */\nexport function bitLen(n: bigint): number {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\n\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n: bigint, pos: number): bigint {\n  return (n >> BigInt(pos)) & _1n;\n}\n\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n: bigint, pos: number, value: boolean): bigint {\n  return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n: number): bigint => (_1n << BigInt(n)) - _1n;\n\n// DRBG\n\ntype Pred<T> = (v: Uint8Array) => T | undefined;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg<T>(\n  hashLen: number,\n  qByteLen: number,\n  hmacFn: (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array\n): (seed: Uint8Array, predicate: Pred<T>) => T {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  const u8n = (len: number) => new Uint8Array(len); // creates Uint8Array\n  const u8of = (byte: number) => Uint8Array.of(byte); // another shortcut\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...b: Uint8Array[]) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n  const reseed = (seed = u8n(0)) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8of(0x00), seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(u8of(0x01), seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out: Uint8Array[] = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes_(...out);\n  };\n  const genUntil = (seed: Uint8Array, pred: Pred<T>): T => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res: T | undefined = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n\n// Validating curves and fields\n\nconst validatorFns = {\n  bigint: (val: any): boolean => typeof val === 'bigint',\n  function: (val: any): boolean => typeof val === 'function',\n  boolean: (val: any): boolean => typeof val === 'boolean',\n  string: (val: any): boolean => typeof val === 'string',\n  stringOrUint8Array: (val: any): boolean => typeof val === 'string' || isBytes_(val),\n  isSafeInteger: (val: any): boolean => Number.isSafeInteger(val),\n  array: (val: any): boolean => Array.isArray(val),\n  field: (val: any, object: any): any => (object as any).Fp.isValid(val),\n  hash: (val: any): boolean => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n} as const;\ntype Validator = keyof typeof validatorFns;\ntype ValMap<T extends Record<string, any>> = { [K in keyof T]?: Validator };\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\n\nexport function validateObject<T extends Record<string, any>>(\n  object: T,\n  validators: ValMap<T>,\n  optValidators: ValMap<T> = {}\n): T {\n  const checkField = (fieldName: keyof T, type: Validator, isOptional: boolean) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function') throw new Error('invalid validator function');\n\n    const val = object[fieldName as keyof typeof object];\n    if (isOptional && val === undefined) return;\n    if (!checkVal(val, object)) {\n      throw new Error(\n        'param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val\n      );\n    }\n  };\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type!, false);\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type!, true);\n  return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n\nexport function isHash(val: CHash): boolean {\n  return typeof val === 'function' && Number.isSafeInteger(val.outputLen);\n}\nexport function _validateObject(\n  object: Record<string, any>,\n  fields: Record<string, string>,\n  optFields: Record<string, string> = {}\n): void {\n  if (!object || typeof object !== 'object') throw new Error('expected valid options object');\n  type Item = keyof typeof object;\n  function checkField(fieldName: Item, expectedType: string, isOpt: boolean) {\n    const val = object[fieldName];\n    if (isOpt && val === undefined) return;\n    const current = typeof val;\n    if (current !== expectedType || val === null)\n      throw new Error(`param \"${fieldName}\" is invalid: expected ${expectedType}, got ${current}`);\n  }\n  Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));\n  Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));\n}\n\n/**\n * throws not implemented error\n */\nexport const notImplemented = (): never => {\n  throw new Error('not implemented');\n};\n\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nexport function memoized<T extends object, R, O extends any[]>(\n  fn: (arg: T, ...args: O) => R\n): (arg: T, ...args: O) => R {\n  const map = new WeakMap<T, R>();\n  return (arg: T, ...args: O): R => {\n    const val = map.get(arg);\n    if (val !== undefined) return val;\n    const computed = fn(arg, ...args);\n    map.set(arg, computed);\n    return computed;\n  };\n}\n", "/**\n * Utils for modular division and fields.\n * Field over 11 is a finite (Galois) field is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  _validateObject,\n  anumber,\n  bitMask,\n  bytesToNumberBE,\n  bytesToNumberLE,\n  ensureBytes,\n  numberToBytesBE,\n  numberToBytesLE,\n} from '../utils.ts';\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _7n = /* @__PURE__ */ BigInt(7);\n// prettier-ignore\nconst _8n = /* @__PURE__ */ BigInt(8), _9n = /* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);\n\n// Calculates a modulo b\nexport function mod(a: bigint, b: bigint): bigint {\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nexport function pow(num: bigint, power: bigint, modulo: bigint): bigint {\n  return FpPow(Field(modulo), num, power);\n}\n\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nexport function pow2(x: bigint, power: bigint, modulo: bigint): bigint {\n  let res = x;\n  while (power-- > _0n) {\n    res *= res;\n    res %= modulo;\n  }\n  return res;\n}\n\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nexport function invert(number: bigint, modulo: bigint): bigint {\n  if (number === _0n) throw new Error('invert: expected non-zero number');\n  if (modulo <= _0n) throw new Error('invert: expected positive modulus, got ' + modulo);\n  // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n  let a = mod(number, modulo);\n  let b = modulo;\n  // prettier-ignore\n  let x = _0n, y = _1n, u = _1n, v = _0n;\n  while (a !== _0n) {\n    // JIT applies optimization if those two lines follow each other\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    // prettier-ignore\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n\nfunction assertIsSquare<T>(Fp: IField<T>, root: T, n: T): void {\n  if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n}\n\n// Not all roots are possible! Example which will throw:\n// const NUM =\n// n = 72057594037927816n;\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\nfunction sqrt3mod4<T>(Fp: IField<T>, n: T) {\n  const p1div4 = (Fp.ORDER + _1n) / _4n;\n  const root = Fp.pow(n, p1div4);\n  assertIsSquare(Fp, root, n);\n  return root;\n}\n\nfunction sqrt5mod8<T>(Fp: IField<T>, n: T) {\n  const p5div8 = (Fp.ORDER - _5n) / _8n;\n  const n2 = Fp.mul(n, _2n);\n  const v = Fp.pow(n2, p5div8);\n  const nv = Fp.mul(n, v);\n  const i = Fp.mul(Fp.mul(nv, _2n), v);\n  const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n  assertIsSquare(Fp, root, n);\n  return root;\n}\n\n// Based on RFC9380, Kong algorithm\n// prettier-ignore\nfunction sqrt9mod16(P: bigint): <T>(Fp: IField<T>, n: T) => T {\n  const Fp_ = Field(P);\n  const tn = tonelliShanks(P);\n  const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));//  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n  const c2 = tn(Fp_, c1);              //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n  const c3 = tn(Fp_, Fp_.neg(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n  const c4 = (P + _7n) / _16n;         //  4. c4 = (q + 7) / 16        # Integer arithmetic\n  return <T>(Fp: IField<T>, n: T) => {\n    let tv1 = Fp.pow(n, c4);           //  1. tv1 = x^c4\n    let tv2 = Fp.mul(tv1, c1);         //  2. tv2 = c1 * tv1\n    const tv3 = Fp.mul(tv1, c2);       //  3. tv3 = c2 * tv1\n    const tv4 = Fp.mul(tv1, c3);       //  4. tv4 = c3 * tv1\n    const e1 = Fp.eql(Fp.sqr(tv2), n); //  5.  e1 = (tv2^2) == x\n    const e2 = Fp.eql(Fp.sqr(tv3), n); //  6.  e2 = (tv3^2) == x\n    tv1 = Fp.cmov(tv1, tv2, e1);       //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    tv2 = Fp.cmov(tv4, tv3, e2);       //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    const e3 = Fp.eql(Fp.sqr(tv2), n); //  9.  e3 = (tv2^2) == x\n    const root = Fp.cmov(tv1, tv2, e3);// 10.  z = CMOV(tv1, tv2, e3)   # Select sqrt from tv1 & tv2\n    assertIsSquare(Fp, root, n);\n    return root;\n  };\n}\n\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P: bigint): <T>(Fp: IField<T>, n: T) => T {\n  // Initialization (precomputation).\n  // Caching initialization could boost perf by 7%.\n  if (P < _3n) throw new Error('sqrt is not defined for small field');\n  // Factor P - 1 = Q * 2^S, where Q is odd\n  let Q = P - _1n;\n  let S = 0;\n  while (Q % _2n === _0n) {\n    Q /= _2n;\n    S++;\n  }\n\n  // Find the first quadratic non-residue Z >= 2\n  let Z = _2n;\n  const _Fp = Field(P);\n  while (FpLegendre(_Fp, Z) === 1) {\n    // Basic primality test for P. After x iterations, chance of\n    // not finding quadratic non-residue is 2^x, so 2^1000.\n    if (Z++ > 1000) throw new Error('Cannot find square root: probably non-prime P');\n  }\n  // Fast-path; usually done before Z, but we do \"primality test\".\n  if (S === 1) return sqrt3mod4;\n\n  // Slow-path\n  // TODO: test on Fp2 and others\n  let cc = _Fp.pow(Z, Q); // c = z^Q\n  const Q1div2 = (Q + _1n) / _2n;\n  return function tonelliSlow<T>(Fp: IField<T>, n: T): T {\n    if (Fp.is0(n)) return n;\n    // Check if n is a quadratic residue using Legendre symbol\n    if (FpLegendre(Fp, n) !== 1) throw new Error('Cannot find square root');\n\n    // Initialize variables for the main loop\n    let M = S;\n    let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\n    let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\n    let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\n\n    // Main loop\n    // while t != 1\n    while (!Fp.eql(t, Fp.ONE)) {\n      if (Fp.is0(t)) return Fp.ZERO; // if t=0 return R=0\n      let i = 1;\n\n      // Find the smallest i >= 1 such that t^(2^i)  1 (mod P)\n      let t_tmp = Fp.sqr(t); // t^(2^1)\n      while (!Fp.eql(t_tmp, Fp.ONE)) {\n        i++;\n        t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\n        if (i === M) throw new Error('Cannot find square root');\n      }\n\n      // Calculate the exponent for b: 2^(M - i - 1)\n      const exponent = _1n << BigInt(M - i - 1); // bigint is important\n      const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\n\n      // Update variables\n      M = i;\n      c = Fp.sqr(b); // c = b^2\n      t = Fp.mul(t, c); // t = (t * b^2)\n      R = Fp.mul(R, b); // R = R*b\n    }\n    return R;\n  };\n}\n\n/**\n * Square root for a finite field. Will try optimized versions first:\n *\n * 1. P  3 (mod 4)\n * 2. P  5 (mod 8)\n * 3. P  9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nexport function FpSqrt(P: bigint): <T>(Fp: IField<T>, n: T) => T {\n  // P  3 (mod 4) => n = n^((P+1)/4)\n  if (P % _4n === _3n) return sqrt3mod4;\n  // P  5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\n  if (P % _8n === _5n) return sqrt5mod8;\n  // P  9 (mod 16) => Kong algorithm, page 11 of https://eprint.iacr.org/2012/685.pdf (algorithm 4)\n  if (P % _16n === _9n) return sqrt9mod16(P);\n  // Tonelli-Shanks algorithm\n  return tonelliShanks(P);\n}\n\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num: bigint, modulo: bigint): boolean =>\n  (mod(num, modulo) & _1n) === _1n;\n\n/** Field is not always over prime: for example, Fp2 has ORDER(q)=p^m. */\nexport interface IField<T> {\n  ORDER: bigint;\n  isLE: boolean;\n  BYTES: number;\n  BITS: number;\n  MASK: bigint;\n  ZERO: T;\n  ONE: T;\n  // 1-arg\n  create: (num: T) => T;\n  isValid: (num: T) => boolean;\n  is0: (num: T) => boolean;\n  isValidNot0: (num: T) => boolean;\n  neg(num: T): T;\n  inv(num: T): T;\n  sqrt(num: T): T;\n  sqr(num: T): T;\n  // 2-args\n  eql(lhs: T, rhs: T): boolean;\n  add(lhs: T, rhs: T): T;\n  sub(lhs: T, rhs: T): T;\n  mul(lhs: T, rhs: T | bigint): T;\n  pow(lhs: T, power: bigint): T;\n  div(lhs: T, rhs: T | bigint): T;\n  // N for NonNormalized (for now)\n  addN(lhs: T, rhs: T): T;\n  subN(lhs: T, rhs: T): T;\n  mulN(lhs: T, rhs: T | bigint): T;\n  sqrN(num: T): T;\n\n  // Optional\n  // Should be same as sgn0 function in\n  // [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#section-4.1).\n  // NOTE: sgn0 is 'negative in LE', which is same as odd. And negative in LE is kinda strange definition anyway.\n  isOdd?(num: T): boolean; // Odd instead of even since we have it for Fp2\n  allowedLengths?: number[];\n  // legendre?(num: T): T;\n  invertBatch: (lst: T[]) => T[];\n  toBytes(num: T): Uint8Array;\n  fromBytes(bytes: Uint8Array, skipValidation?: boolean): T;\n  // If c is False, CMOV returns a, otherwise it returns b.\n  cmov(a: T, b: T, c: boolean): T;\n}\n// prettier-ignore\nconst FIELD_FIELDS = [\n  'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n  'eql', 'add', 'sub', 'mul', 'pow', 'div',\n  'addN', 'subN', 'mulN', 'sqrN'\n] as const;\nexport function validateField<T>(field: IField<T>): IField<T> {\n  const initial = {\n    ORDER: 'bigint',\n    MASK: 'bigint',\n    BYTES: 'number',\n    BITS: 'number',\n  } as Record<string, string>;\n  const opts = FIELD_FIELDS.reduce((map, val: string) => {\n    map[val] = 'function';\n    return map;\n  }, initial);\n  _validateObject(field, opts);\n  // const max = 16384;\n  // if (field.BYTES < 1 || field.BYTES > max) throw new Error('invalid field');\n  // if (field.BITS < 1 || field.BITS > 8 * max) throw new Error('invalid field');\n  return field;\n}\n\n// Generic field functions\n\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow<T>(Fp: IField<T>, num: T, power: bigint): T {\n  if (power < _0n) throw new Error('invalid exponent, negatives unsupported');\n  if (power === _0n) return Fp.ONE;\n  if (power === _1n) return num;\n  let p = Fp.ONE;\n  let d = num;\n  while (power > _0n) {\n    if (power & _1n) p = Fp.mul(p, d);\n    d = Fp.sqr(d);\n    power >>= _1n;\n  }\n  return p;\n}\n\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */\nexport function FpInvertBatch<T>(Fp: IField<T>, nums: T[], passZero = false): T[] {\n  const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n  // Walk from first to last, multiply them by each other MOD p\n  const multipliedAcc = nums.reduce((acc, num, i) => {\n    if (Fp.is0(num)) return acc;\n    inverted[i] = acc;\n    return Fp.mul(acc, num);\n  }, Fp.ONE);\n  // Invert last element\n  const invertedAcc = Fp.inv(multipliedAcc);\n  // Walk from last to first, multiply them by inverted each other MOD p\n  nums.reduceRight((acc, num, i) => {\n    if (Fp.is0(num)) return acc;\n    inverted[i] = Fp.mul(acc, inverted[i]);\n    return Fp.mul(acc, num);\n  }, invertedAcc);\n  return inverted;\n}\n\n// TODO: remove\nexport function FpDiv<T>(Fp: IField<T>, lhs: T, rhs: T | bigint): T {\n  return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p).\n *\n * * (a | p)  1    if a is a square (mod p), quadratic residue\n * * (a | p)  -1   if a is not a square (mod p), quadratic non residue\n * * (a | p)  0    if a  0 (mod p)\n */\nexport function FpLegendre<T>(Fp: IField<T>, n: T): -1 | 0 | 1 {\n  // We can use 3rd argument as optional cache of this value\n  // but seems unneeded for now. The operation is very fast.\n  const p1mod2 = (Fp.ORDER - _1n) / _2n;\n  const powered = Fp.pow(n, p1mod2);\n  const yes = Fp.eql(powered, Fp.ONE);\n  const zero = Fp.eql(powered, Fp.ZERO);\n  const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n  if (!yes && !zero && !no) throw new Error('invalid Legendre symbol result');\n  return yes ? 1 : zero ? 0 : -1;\n}\n\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare<T>(Fp: IField<T>, n: T): boolean {\n  const l = FpLegendre(Fp, n);\n  return l === 1;\n}\n\nexport type NLength = { nByteLength: number; nBitLength: number };\n// CURVE.n lengths\nexport function nLength(n: bigint, nBitLength?: number): NLength {\n  // Bit size, byte size of CURVE.n\n  if (nBitLength !== undefined) anumber(nBitLength);\n  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n  const nByteLength = Math.ceil(_nBitLength / 8);\n  return { nBitLength: _nBitLength, nByteLength };\n}\n\ntype FpField = IField<bigint> & Required<Pick<IField<bigint>, 'isOdd'>>;\ntype SqrtFn = (n: bigint) => bigint;\ntype FieldOpts = Partial<{\n  sqrt: SqrtFn;\n  isLE: boolean;\n  BITS: number;\n  modFromBytes: boolean; // bls12-381 requires mod(n) instead of rejecting keys >= n\n  allowedLengths?: readonly number[]; // for P521 (adds padding for smaller sizes)\n}>;\n/**\n * Creates a finite field. Major performance optimizations:\n * * 1. Denormalized operations like mulN instead of mul.\n * * 2. Identical object shape: never add or remove keys.\n * * 3. `Object.freeze`.\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n *\n * Note about field properties:\n * * CHARACTERISTIC p = prime number, number of elements in main subgroup.\n * * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.\n *\n * @param ORDER field order, probably prime, or could be composite\n * @param bitLen how many bits the field consumes\n * @param isLE (default: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(\n  ORDER: bigint,\n  bitLenOrOpts?: number | FieldOpts, // TODO: use opts only in v2?\n  isLE = false,\n  opts: { sqrt?: SqrtFn } = {}\n): Readonly<FpField> {\n  if (ORDER <= _0n) throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n  let _nbitLength: number | undefined = undefined;\n  let _sqrt: SqrtFn | undefined = undefined;\n  let modFromBytes: boolean = false;\n  let allowedLengths: undefined | readonly number[] = undefined;\n  if (typeof bitLenOrOpts === 'object' && bitLenOrOpts != null) {\n    if (opts.sqrt || isLE) throw new Error('cannot specify opts in two arguments');\n    const _opts = bitLenOrOpts;\n    if (_opts.BITS) _nbitLength = _opts.BITS;\n    if (_opts.sqrt) _sqrt = _opts.sqrt;\n    if (typeof _opts.isLE === 'boolean') isLE = _opts.isLE;\n    if (typeof _opts.modFromBytes === 'boolean') modFromBytes = _opts.modFromBytes;\n    allowedLengths = _opts.allowedLengths;\n  } else {\n    if (typeof bitLenOrOpts === 'number') _nbitLength = bitLenOrOpts;\n    if (opts.sqrt) _sqrt = opts.sqrt;\n  }\n  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);\n  if (BYTES > 2048) throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n  let sqrtP: ReturnType<typeof FpSqrt>; // cached sqrtP\n  const f: Readonly<FpField> = Object.freeze({\n    ORDER,\n    isLE,\n    BITS,\n    BYTES,\n    MASK: bitMask(BITS),\n    ZERO: _0n,\n    ONE: _1n,\n    allowedLengths: allowedLengths,\n    create: (num) => mod(num, ORDER),\n    isValid: (num) => {\n      if (typeof num !== 'bigint')\n        throw new Error('invalid field element: expected bigint, got ' + typeof num);\n      return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n    },\n    is0: (num) => num === _0n,\n    // is valid and invertible\n    isValidNot0: (num: bigint) => !f.is0(num) && f.isValid(num),\n    isOdd: (num) => (num & _1n) === _1n,\n    neg: (num) => mod(-num, ORDER),\n    eql: (lhs, rhs) => lhs === rhs,\n\n    sqr: (num) => mod(num * num, ORDER),\n    add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n    pow: (num, power) => FpPow(f, num, power),\n    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n\n    // Same as above, but doesn't normalize\n    sqrN: (num) => num * num,\n    addN: (lhs, rhs) => lhs + rhs,\n    subN: (lhs, rhs) => lhs - rhs,\n    mulN: (lhs, rhs) => lhs * rhs,\n\n    inv: (num) => invert(num, ORDER),\n    sqrt:\n      _sqrt ||\n      ((n) => {\n        if (!sqrtP) sqrtP = FpSqrt(ORDER);\n        return sqrtP(f, n);\n      }),\n    toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n    fromBytes: (bytes, skipValidation = true) => {\n      if (allowedLengths) {\n        if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {\n          throw new Error(\n            'Field.fromBytes: expected ' + allowedLengths + ' bytes, got ' + bytes.length\n          );\n        }\n        const padded = new Uint8Array(BYTES);\n        // isLE add 0 to right, !isLE to the left.\n        padded.set(bytes, isLE ? 0 : padded.length - bytes.length);\n        bytes = padded;\n      }\n      if (bytes.length !== BYTES)\n        throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n      let scalar = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n      if (modFromBytes) scalar = mod(scalar, ORDER);\n      if (!skipValidation)\n        if (!f.isValid(scalar)) throw new Error('invalid field element: outside of range 0..ORDER');\n      // NOTE: we don't validate scalar here, please use isValid. This done such way because some\n      // protocol may allow non-reduced scalar that reduced later or changed some other way.\n      return scalar;\n    },\n    // TODO: we don't need it here, move out to separate fn\n    invertBatch: (lst) => FpInvertBatch(f, lst),\n    // We can't move this out because Fp6, Fp12 implement it\n    // and it's unclear what to return in there.\n    cmov: (a, b, c) => (c ? b : a),\n  } as FpField);\n  return Object.freeze(f);\n}\n\n// Generic random scalar, we can do same for other fields if via Fp2.mul(Fp2.ONE, Fp2.random)?\n// This allows unsafe methods like ignore bias or zero. These unsafe, but often used in different protocols (if deterministic RNG).\n// which mean we cannot force this via opts.\n// Not sure what to do with randomBytes, we can accept it inside opts if wanted.\n// Probably need to export getMinHashLength somewhere?\n// random(bytes?: Uint8Array, unsafeAllowZero = false, unsafeAllowBias = false) {\n//   const LEN = !unsafeAllowBias ? getMinHashLength(ORDER) : BYTES;\n//   if (bytes === undefined) bytes = randomBytes(LEN); // _opts.randomBytes?\n//   const num = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n//   // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n//   const reduced = unsafeAllowZero ? mod(num, ORDER) : mod(num, ORDER - _1n) + _1n;\n//   return reduced;\n// },\n\nexport function FpSqrtOdd<T>(Fp: IField<T>, elm: T): T {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? root : Fp.neg(root);\n}\n\nexport function FpSqrtEven<T>(Fp: IField<T>, elm: T): T {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */\nexport function hashToPrivateScalar(\n  hash: string | Uint8Array,\n  groupOrder: bigint,\n  isLE = false\n): bigint {\n  hash = ensureBytes('privateHash', hash);\n  const hashLen = hash.length;\n  const minLen = nLength(groupOrder).nByteLength + 8;\n  if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n    throw new Error(\n      'hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen\n    );\n  const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n  return mod(num, groupOrder - _1n) + _1n;\n}\n\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder: bigint): number {\n  if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');\n  const bitLength = fieldOrder.toString(2).length;\n  return Math.ceil(bitLength / 8);\n}\n\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder: bigint): number {\n  const length = getFieldBytesLength(fieldOrder);\n  return length + Math.ceil(length / 2);\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key: Uint8Array, fieldOrder: bigint, isLE = false): Uint8Array {\n  const len = key.length;\n  const fieldLen = getFieldBytesLength(fieldOrder);\n  const minLen = getMinHashLength(fieldOrder);\n  // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n  if (len < 16 || len < minLen || len > 1024)\n    throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n  const num = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);\n  // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n  const reduced = mod(num, fieldOrder - _1n) + _1n;\n  return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n", "/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { bitLen, bitMask, validateObject } from '../utils.ts';\nimport { Field, FpInvertBatch, nLength, validateField, type IField } from './modular.ts';\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n\nexport type AffinePoint<T> = {\n  x: T;\n  y: T;\n} & { Z?: never };\n\n// This was initialy do this way to re-use montgomery ladder in field (add->mul,double->sqr), but\n// that didn't happen and there is probably not much reason to have separate Group like this?\nexport interface Group<T extends Group<T>> {\n  double(): T;\n  negate(): T;\n  add(other: T): T;\n  subtract(other: T): T;\n  equals(other: T): boolean;\n  multiply(scalar: bigint): T;\n  toAffine?(invertedZ?: any): AffinePoint<any>;\n}\n\n// We can't \"abstract out\" coordinates (X, Y, Z; and T in Edwards): argument names of constructor\n// are not accessible. See Typescript gh-56093, gh-41594.\n//\n// We have to use recursive types, so it will return actual point, not constained `CurvePoint`.\n// If, at any point, P is `any`, it will erase all types and replace it\n// with `any`, because of recursion, `any implements CurvePoint`,\n// but we lose all constrains on methods.\n\n/** Base interface for all elliptic curve Points. */\nexport interface CurvePoint<F, P extends CurvePoint<F, P>> extends Group<P> {\n  /** Affine x coordinate. Different from projective / extended X coordinate. */\n  x: F;\n  /** Affine y coordinate. Different from projective / extended Y coordinate. */\n  y: F;\n  Z?: F;\n  double(): P;\n  negate(): P;\n  add(other: P): P;\n  subtract(other: P): P;\n  equals(other: P): boolean;\n  multiply(scalar: bigint): P;\n  assertValidity(): void;\n  clearCofactor(): P;\n  is0(): boolean;\n  isTorsionFree(): boolean;\n  isSmallOrder(): boolean;\n  multiplyUnsafe(scalar: bigint): P;\n  /**\n   * Massively speeds up `p.multiply(n)` by using precompute tables (caching). See {@link wNAF}.\n   * @param isLazy calculate cache now. Default (true) ensures it's deferred to first `multiply()`\n   */\n  precompute(windowSize?: number, isLazy?: boolean): P;\n  /** Converts point to 2D xy affine coordinates */\n  toAffine(invertedZ?: F): AffinePoint<F>;\n  toBytes(): Uint8Array;\n  toHex(): string;\n}\n\n/** Base interface for all elliptic curve Point constructors. */\nexport interface CurvePointCons<P extends CurvePoint<any, P>> {\n  [Symbol.hasInstance]: (item: unknown) => boolean;\n  BASE: P;\n  ZERO: P;\n  /** Field for basic curve math */\n  Fp: IField<P_F<P>>;\n  /** Scalar field, for scalars in multiply and others */\n  Fn: IField<bigint>;\n  /** Creates point from x, y. Does NOT validate if the point is valid. Use `.assertValidity()`. */\n  fromAffine(p: AffinePoint<P_F<P>>): P;\n  fromBytes(bytes: Uint8Array): P;\n  fromHex(hex: Uint8Array | string): P;\n}\n\n// Type inference helpers: PC - PointConstructor, P - Point, Fp - Field element\n// Short names, because we use them a lot in result types:\n// * we can't do 'P = GetCurvePoint<PC>': this is default value and doesn't constrain anything\n// * we can't do 'type X = GetCurvePoint<PC>': it won't be accesible for arguments/return types\n// * `CurvePointCons<P extends CurvePoint<any, P>>` constraints from interface definition\n//   won't propagate, if `PC extends CurvePointCons<any>`: the P would be 'any', which is incorrect\n// * PC could be super specific with super specific P, which implements CurvePoint<any, P>.\n//   this means we need to do stuff like\n//   `function test<P extends CurvePoint<any, P>, PC extends CurvePointCons<P>>(`\n//   if we want type safety around P, otherwise PC_P<PC> will be any\n\n/** Returns Fp type from Point (P_F<P> == P.F) */\nexport type P_F<P extends CurvePoint<any, P>> = P extends CurvePoint<infer F, P> ? F : never;\n/** Returns Fp type from PointCons (PC_F<PC> == PC.P.F) */\nexport type PC_F<PC extends CurvePointCons<CurvePoint<any, any>>> = PC['Fp']['ZERO'];\n/** Returns Point type from PointCons (PC_P<PC> == PC.P) */\nexport type PC_P<PC extends CurvePointCons<CurvePoint<any, any>>> = PC['ZERO'];\n\n// Ugly hack to get proper type inference, because in typescript fails to infer resursively.\n// The hack allows to do up to 10 chained operations without applying type erasure.\n//\n// Types which won't work:\n// * `CurvePointCons<CurvePoint<any, any>>`, will return `any` after 1 operation\n// * `CurvePointCons<any>: WeierstrassPointCons<bigint> extends CurvePointCons<any> = false`\n// * `P extends CurvePoint, PC extends CurvePointCons<P>`\n//     * It can't infer P from PC alone\n//     * Too many relations between F, P & PC\n//     * It will infer P/F if `arg: CurvePointCons<F, P>`, but will fail if PC is generic\n//     * It will work correctly if there is an additional argument of type P\n//     * But generally, we don't want to parametrize `CurvePointCons` over `F`: it will complicate\n//       types, making them un-inferable\n// prettier-ignore\nexport type PC_ANY = CurvePointCons<\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any, any>\n  >>>>>>>>>\n>;\n\nexport interface CurveLengths {\n  secretKey?: number;\n  publicKey?: number;\n  publicKeyUncompressed?: number;\n  publicKeyHasPrefix?: boolean;\n  signature?: number;\n  seed?: number;\n}\nexport type GroupConstructor<T> = {\n  BASE: T;\n  ZERO: T;\n};\n/** @deprecated */\nexport type ExtendedGroupConstructor<T> = GroupConstructor<T> & {\n  Fp: IField<any>;\n  Fn: IField<bigint>;\n  fromAffine(ap: AffinePoint<any>): T;\n};\nexport type Mapper<T> = (i: T[]) => T[];\n\nexport function negateCt<T extends { negate: () => T }>(condition: boolean, item: T): T {\n  const neg = item.negate();\n  return condition ? neg : item;\n}\n\n/**\n * Takes a bunch of Projective Points but executes only one\n * inversion on all of them. Inversion is very slow operation,\n * so this improves performance massively.\n * Optimization: converts a list of projective points to a list of identical points with Z=1.\n */\nexport function normalizeZ<P extends CurvePoint<any, P>, PC extends CurvePointCons<P>>(\n  c: PC,\n  points: P[]\n): P[] {\n  const invertedZs = FpInvertBatch(\n    c.Fp,\n    points.map((p) => p.Z!)\n  );\n  return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));\n}\n\nfunction validateW(W: number, bits: number) {\n  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n    throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\n\n/** Internal wNAF opts for specific W and scalarBits */\nexport type WOpts = {\n  windows: number;\n  windowSize: number;\n  mask: bigint;\n  maxNumber: number;\n  shiftBy: bigint;\n};\n\nfunction calcWOpts(W: number, scalarBits: number): WOpts {\n  validateW(W, scalarBits);\n  const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n  const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n  const maxNumber = 2 ** W; // W=8 256\n  const mask = bitMask(W); // W=8 255 == mask 0b11111111\n  const shiftBy = BigInt(W); // W=8 8\n  return { windows, windowSize, mask, maxNumber, shiftBy };\n}\n\nfunction calcOffsets(n: bigint, window: number, wOpts: WOpts) {\n  const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n  let wbits = Number(n & mask); // extract W bits.\n  let nextN = n >> shiftBy; // shift number by W bits.\n\n  // What actually happens here:\n  // const highestBit = Number(mask ^ (mask >> 1n));\n  // let wbits2 = wbits - 1; // skip zero\n  // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n\n  // split if bits > max: +224 => 256-32\n  if (wbits > windowSize) {\n    // we skip zero, which means instead of `>= size-1`, we do `> size`\n    wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n    nextN += _1n; // +256 (carry)\n  }\n  const offsetStart = window * windowSize;\n  const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n  const isZero = wbits === 0; // is current window slice a 0?\n  const isNeg = wbits < 0; // is current window slice negative?\n  const isNegF = window % 2 !== 0; // fake random statement for noise\n  const offsetF = offsetStart; // fake offset for noise\n  return { nextN, offset, isZero, isNeg, isNegF, offsetF };\n}\n\nfunction validateMSMPoints(points: any[], c: any) {\n  if (!Array.isArray(points)) throw new Error('array expected');\n  points.forEach((p, i) => {\n    if (!(p instanceof c)) throw new Error('invalid point at index ' + i);\n  });\n}\nfunction validateMSMScalars(scalars: any[], field: any) {\n  if (!Array.isArray(scalars)) throw new Error('array of scalars expected');\n  scalars.forEach((s, i) => {\n    if (!field.isValid(s)) throw new Error('invalid scalar at index ' + i);\n  });\n}\n\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap<any, any[]>();\nconst pointWindowSizes = new WeakMap<any, number>();\n\nfunction getW(P: any): number {\n  // To disable precomputes:\n  // return 1;\n  return pointWindowSizes.get(P) || 1;\n}\n\nfunction assert0(n: bigint): void {\n  if (n !== _0n) throw new Error('invalid wNAF');\n}\n\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Table generation takes **30MB of ram and 10ms on high-end CPU**,\n * but may take much longer on slow devices. Actual generation will happen on\n * first call of `multiply()`. By default, `BASE` point is precomputed.\n *\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nexport class wNAF<PC extends PC_ANY> {\n  private readonly BASE: PC_P<PC>;\n  private readonly ZERO: PC_P<PC>;\n  private readonly Fn: PC['Fn'];\n  readonly bits: number;\n\n  // Parametrized with a given Point class (not individual point)\n  constructor(Point: PC, bits: number) {\n    this.BASE = Point.BASE;\n    this.ZERO = Point.ZERO;\n    this.Fn = Point.Fn;\n    this.bits = bits;\n  }\n\n  // non-const time multiplication ladder\n  _unsafeLadder(elm: PC_P<PC>, n: bigint, p: PC_P<PC> = this.ZERO): PC_P<PC> {\n    let d: PC_P<PC> = elm;\n    while (n > _0n) {\n      if (n & _1n) p = p.add(d);\n      d = d.double();\n      n >>= _1n;\n    }\n    return p;\n  }\n\n  /**\n   * Creates a wNAF precomputation window. Used for caching.\n   * Default window size is set by `utils.precompute()` and is equal to 8.\n   * Number of precomputed points depends on the curve size:\n   * 2^(1) * (Math.ceil( / ) + 1), where:\n   * -  is the window size\n   * -  is the bitlength of the curve order.\n   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n   * @param point Point instance\n   * @param W window size\n   * @returns precomputed point tables flattened to a single array\n   */\n  private precomputeWindow(point: PC_P<PC>, W: number): PC_P<PC>[] {\n    const { windows, windowSize } = calcWOpts(W, this.bits);\n    const points: PC_P<PC>[] = [];\n    let p: PC_P<PC> = point;\n    let base = p;\n    for (let window = 0; window < windows; window++) {\n      base = p;\n      points.push(base);\n      // i=1, bc we skip 0\n      for (let i = 1; i < windowSize; i++) {\n        base = base.add(p);\n        points.push(base);\n      }\n      p = base.double();\n    }\n    return points;\n  }\n\n  /**\n   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n   * More compact implementation:\n   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n   * @returns real and fake (for const-time) points\n   */\n  private wNAF(W: number, precomputes: PC_P<PC>[], n: bigint): { p: PC_P<PC>; f: PC_P<PC> } {\n    // Scalar should be smaller than field order\n    if (!this.Fn.isValid(n)) throw new Error('invalid scalar');\n    // Accumulators\n    let p = this.ZERO;\n    let f = this.BASE;\n    // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n    // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n    // there is negate now: it is possible that negated element from low value\n    // would be the same as high element, which will create carry into next window.\n    // It's not obvious how this can fail, but still worth investigating later.\n    const wo = calcWOpts(W, this.bits);\n    for (let window = 0; window < wo.windows; window++) {\n      // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n      const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\n      n = nextN;\n      if (isZero) {\n        // bits are 0: add garbage to fake point\n        // Important part for const-time getPublicKey: add random \"noise\" point to f.\n        f = f.add(negateCt(isNegF, precomputes[offsetF]));\n      } else {\n        // bits are 1: add to result point\n        p = p.add(negateCt(isNeg, precomputes[offset]));\n      }\n    }\n    assert0(n);\n    // Return both real and fake points: JIT won't eliminate f.\n    // At this point there is a way to F be infinity-point even if p is not,\n    // which makes it less const-time: around 1 bigint multiply.\n    return { p, f };\n  }\n\n  /**\n   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n   * @param acc accumulator point to add result of multiplication\n   * @returns point\n   */\n  private wNAFUnsafe(\n    W: number,\n    precomputes: PC_P<PC>[],\n    n: bigint,\n    acc: PC_P<PC> = this.ZERO\n  ): PC_P<PC> {\n    const wo = calcWOpts(W, this.bits);\n    for (let window = 0; window < wo.windows; window++) {\n      if (n === _0n) break; // Early-exit, skip 0 value\n      const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\n      n = nextN;\n      if (isZero) {\n        // Window bits are 0: skip processing.\n        // Move to next window.\n        continue;\n      } else {\n        const item = precomputes[offset];\n        acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n      }\n    }\n    assert0(n);\n    return acc;\n  }\n\n  private getPrecomputes(W: number, point: PC_P<PC>, transform?: Mapper<PC_P<PC>>): PC_P<PC>[] {\n    // Calculate precomputes on a first run, reuse them after\n    let comp = pointPrecomputes.get(point);\n    if (!comp) {\n      comp = this.precomputeWindow(point, W) as PC_P<PC>[];\n      if (W !== 1) {\n        // Doing transform outside of if brings 15% perf hit\n        if (typeof transform === 'function') comp = transform(comp);\n        pointPrecomputes.set(point, comp);\n      }\n    }\n    return comp;\n  }\n\n  cached(\n    point: PC_P<PC>,\n    scalar: bigint,\n    transform?: Mapper<PC_P<PC>>\n  ): { p: PC_P<PC>; f: PC_P<PC> } {\n    const W = getW(point);\n    return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);\n  }\n\n  unsafe(point: PC_P<PC>, scalar: bigint, transform?: Mapper<PC_P<PC>>, prev?: PC_P<PC>): PC_P<PC> {\n    const W = getW(point);\n    if (W === 1) return this._unsafeLadder(point, scalar, prev); // For W=1 ladder is ~x2 faster\n    return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);\n  }\n\n  // We calculate precomputes for elliptic curve point multiplication\n  // using windowed method. This specifies window size and\n  // stores precomputed values. Usually only base point would be precomputed.\n  createCache(P: PC_P<PC>, W: number): void {\n    validateW(W, this.bits);\n    pointWindowSizes.set(P, W);\n    pointPrecomputes.delete(P);\n  }\n\n  hasCache(elm: PC_P<PC>): boolean {\n    return getW(elm) !== 1;\n  }\n}\n\n/**\n * Endomorphism-specific multiplication for Koblitz curves.\n * Cost: 128 dbl, 0-256 adds.\n */\nexport function mulEndoUnsafe<P extends CurvePoint<any, P>, PC extends CurvePointCons<P>>(\n  Point: PC,\n  point: P,\n  k1: bigint,\n  k2: bigint\n): { p1: P; p2: P } {\n  let acc = point;\n  let p1 = Point.ZERO;\n  let p2 = Point.ZERO;\n  while (k1 > _0n || k2 > _0n) {\n    if (k1 & _1n) p1 = p1.add(acc);\n    if (k2 & _1n) p2 = p2.add(acc);\n    acc = acc.double();\n    k1 >>= _1n;\n    k2 >>= _1n;\n  }\n  return { p1, p2 };\n}\n\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka secret keys / bigints)\n */\nexport function pippenger<P extends CurvePoint<any, P>, PC extends CurvePointCons<P>>(\n  c: PC,\n  fieldN: IField<bigint>,\n  points: P[],\n  scalars: bigint[]\n): P {\n  // If we split scalars by some window (let's say 8 bits), every chunk will only\n  // take 256 buckets even if there are 4096 scalars, also re-uses double.\n  // TODO:\n  // - https://eprint.iacr.org/2024/750.pdf\n  // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n  // 0 is accepted in scalars\n  validateMSMPoints(points, c);\n  validateMSMScalars(scalars, fieldN);\n  const plength = points.length;\n  const slength = scalars.length;\n  if (plength !== slength) throw new Error('arrays of points and scalars must have equal length');\n  // if (plength === 0) throw new Error('array must be of length >= 2');\n  const zero = c.ZERO;\n  const wbits = bitLen(BigInt(plength));\n  let windowSize = 1; // bits\n  if (wbits > 12) windowSize = wbits - 3;\n  else if (wbits > 4) windowSize = wbits - 2;\n  else if (wbits > 0) windowSize = 2;\n  const MASK = bitMask(windowSize);\n  const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n  let sum = zero;\n  for (let i = lastBits; i >= 0; i -= windowSize) {\n    buckets.fill(zero);\n    for (let j = 0; j < slength; j++) {\n      const scalar = scalars[j];\n      const wbits = Number((scalar >> BigInt(i)) & MASK);\n      buckets[wbits] = buckets[wbits].add(points[j]);\n    }\n    let resI = zero; // not using this will do small speed-up, but will lose ct\n    // Skip first bucket, because it is zero\n    for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n      sumI = sumI.add(buckets[j]);\n      resI = resI.add(sumI);\n    }\n    sum = sum.add(resI);\n    if (i !== 0) for (let j = 0; j < windowSize; j++) sum = sum.double();\n  }\n  return sum as P;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nexport function precomputeMSMUnsafe<P extends CurvePoint<any, P>, PC extends CurvePointCons<P>>(\n  c: PC,\n  fieldN: IField<bigint>,\n  points: P[],\n  windowSize: number\n): (scalars: bigint[]) => P {\n  /**\n   * Performance Analysis of Window-based Precomputation\n   *\n   * Base Case (256-bit scalar, 8-bit window):\n   * - Standard precomputation requires:\n   *   - 31 additions per scalar  256 scalars = 7,936 ops\n   *   - Plus 255 summary additions = 8,191 total ops\n   *   Note: Summary additions can be optimized via accumulator\n   *\n   * Chunked Precomputation Analysis:\n   * - Using 32 chunks requires:\n   *   - 255 additions per chunk\n   *   - 256 doublings\n   *   - Total: (255  32) + 256 = 8,416 ops\n   *\n   * Memory Usage Comparison:\n   * Window Size | Standard Points | Chunked Points\n   * ------------|-----------------|---------------\n   *     4-bit   |     520         |      15\n   *     8-bit   |    4,224        |     255\n   *    10-bit   |   13,824        |   1,023\n   *    16-bit   |  557,056        |  65,535\n   *\n   * Key Advantages:\n   * 1. Enables larger window sizes due to reduced memory overhead\n   * 2. More efficient for smaller scalar counts:\n   *    - 16 chunks: (16  255) + 256 = 4,336 ops\n   *    - ~2x faster than standard 8,191 ops\n   *\n   * Limitations:\n   * - Not suitable for plain precomputes (requires 256 constant doublings)\n   * - Performance degrades with larger scalar counts:\n   *   - Optimal for ~256 scalars\n   *   - Less efficient for 4096+ scalars (Pippenger preferred)\n   */\n  validateW(windowSize, fieldN.BITS);\n  validateMSMPoints(points, c);\n  const zero = c.ZERO;\n  const tableSize = 2 ** windowSize - 1; // table size (without zero)\n  const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n  const MASK = bitMask(windowSize);\n  const tables = points.map((p: P) => {\n    const res = [];\n    for (let i = 0, acc = p; i < tableSize; i++) {\n      res.push(acc);\n      acc = acc.add(p);\n    }\n    return res;\n  });\n  return (scalars: bigint[]): P => {\n    validateMSMScalars(scalars, fieldN);\n    if (scalars.length > points.length)\n      throw new Error('array of scalars must be smaller than array of points');\n    let res = zero;\n    for (let i = 0; i < chunks; i++) {\n      // No need to double if accumulator is still zero.\n      if (res !== zero) for (let j = 0; j < windowSize; j++) res = res.double();\n      const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n      for (let j = 0; j < scalars.length; j++) {\n        const n = scalars[j];\n        const curr = Number((n >> shiftBy) & MASK);\n        if (!curr) continue; // skip zero scalars chunks\n        res = res.add(tables[j][curr - 1]);\n      }\n    }\n    return res;\n  };\n}\n\n// TODO: remove\n/**\n * Generic BasicCurve interface: works even for polynomial fields (BLS): P, n, h would be ok.\n * Though generator can be different (Fp2 / Fp6 for BLS).\n */\nexport type BasicCurve<T> = {\n  Fp: IField<T>; // Field over which we'll do calculations (Fp)\n  n: bigint; // Curve order, total count of valid points in the field\n  nBitLength?: number; // bit length of curve order\n  nByteLength?: number; // byte length of curve order\n  h: bigint; // cofactor. we can assign default=1, but users will just ignore it w/o validation\n  hEff?: bigint; // Number to multiply to clear cofactor\n  Gx: T; // base point X coordinate\n  Gy: T; // base point Y coordinate\n  allowInfinityPoint?: boolean; // bls12-381 requires it. ZERO point is valid, but invalid pubkey\n};\n\n// TODO: remove\n/** @deprecated */\nexport function validateBasic<FP, T>(\n  curve: BasicCurve<FP> & T\n): Readonly<\n  {\n    readonly nBitLength: number;\n    readonly nByteLength: number;\n  } & BasicCurve<FP> &\n    T & {\n      p: bigint;\n    }\n> {\n  validateField(curve.Fp);\n  validateObject(\n    curve,\n    {\n      n: 'bigint',\n      h: 'bigint',\n      Gx: 'field',\n      Gy: 'field',\n    },\n    {\n      nBitLength: 'isSafeInteger',\n      nByteLength: 'isSafeInteger',\n    }\n  );\n  // Set defaults\n  return Object.freeze({\n    ...nLength(curve.n, curve.nBitLength),\n    ...curve,\n    ...{ p: curve.Fp.ORDER },\n  } as const);\n}\n\nexport type ValidCurveParams<T> = {\n  p: bigint;\n  n: bigint;\n  h: bigint;\n  a: T;\n  b?: T;\n  d?: T;\n  Gx: T;\n  Gy: T;\n};\n\nfunction createField<T>(order: bigint, field?: IField<T>, isLE?: boolean): IField<T> {\n  if (field) {\n    if (field.ORDER !== order) throw new Error('Field.ORDER must match order: Fp == p, Fn == n');\n    validateField(field);\n    return field;\n  } else {\n    return Field(order, { isLE }) as unknown as IField<T>;\n  }\n}\nexport type FpFn<T> = { Fp: IField<T>; Fn: IField<bigint> };\n\n/** Validates CURVE opts and creates fields */\nexport function _createCurveFields<T>(\n  type: 'weierstrass' | 'edwards',\n  CURVE: ValidCurveParams<T>,\n  curveOpts: Partial<FpFn<T>> = {},\n  FpFnLE?: boolean\n): FpFn<T> & { CURVE: ValidCurveParams<T> } {\n  if (FpFnLE === undefined) FpFnLE = type === 'edwards';\n  if (!CURVE || typeof CURVE !== 'object') throw new Error(`expected valid ${type} CURVE object`);\n  for (const p of ['p', 'n', 'h'] as const) {\n    const val = CURVE[p];\n    if (!(typeof val === 'bigint' && val > _0n))\n      throw new Error(`CURVE.${p} must be positive bigint`);\n  }\n  const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);\n  const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);\n  const _b: 'b' | 'd' = type === 'weierstrass' ? 'b' : 'd';\n  const params = ['Gx', 'Gy', 'a', _b] as const;\n  for (const p of params) {\n    // @ts-ignore\n    if (!Fp.isValid(CURVE[p]))\n      throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);\n  }\n  CURVE = Object.freeze(Object.assign({}, CURVE));\n  return { CURVE, Fp, Fn };\n}\n", "/**\n * Short Weierstrass curve methods. The formula is: y = x + ax + b.\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { hmac as nobleHmac } from '@noble/hashes/hmac.js';\nimport { ahash } from '@noble/hashes/utils';\nimport {\n  _validateObject,\n  _abool2 as abool,\n  _abytes2 as abytes,\n  aInRange,\n  bitLen,\n  bitMask,\n  bytesToHex,\n  bytesToNumberBE,\n  concatBytes,\n  createHmacDrbg,\n  ensureBytes,\n  hexToBytes,\n  inRange,\n  isBytes,\n  memoized,\n  numberToHexUnpadded,\n  randomBytes as randomBytesWeb,\n  type CHash,\n  type Hex,\n  type PrivKey,\n} from '../utils.ts';\nimport {\n  _createCurveFields,\n  mulEndoUnsafe,\n  negateCt,\n  normalizeZ,\n  pippenger,\n  wNAF,\n  type AffinePoint,\n  type BasicCurve,\n  type CurveLengths,\n  type CurvePoint,\n  type CurvePointCons,\n} from './curve.ts';\nimport {\n  Field,\n  FpInvertBatch,\n  getMinHashLength,\n  mapHashToField,\n  nLength,\n  validateField,\n  type IField,\n  type NLength,\n} from './modular.ts';\n\nexport type { AffinePoint };\nexport type HmacFnSync = (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array;\n\ntype EndoBasis = [[bigint, bigint], [bigint, bigint]];\n/**\n * When Weierstrass curve has `a=0`, it becomes Koblitz curve.\n * Koblitz curves allow using **efficiently-computable GLV endomorphism **.\n * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n *\n * Endomorphism consists of beta, lambda and splitScalar:\n *\n * 1. GLV endomorphism  transforms a point: `P = (x, y)  (P) = (x mod p, y)`\n * 2. GLV scalar decomposition transforms a scalar: `k  k + k (mod n)`\n * 3. Then these are combined: `kP = kP + k(P)`\n * 4. Two 128-bit point-by-scalar multiplications + one point addition is faster than\n *    one 256-bit multiplication.\n *\n * where\n * * beta:   F with  = 1,   1\n * * lambda:   F with  = 1,   1\n * * splitScalar decomposes k  k, k, by using reduced basis vectors.\n *   Gauss lattice reduction calculates them from initial basis vectors `(n, 0), (-, 0)`\n *\n * Check out `test/misc/endomorphism.js` and\n * [gist](https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066).\n */\nexport type EndomorphismOpts = {\n  beta: bigint;\n  basises?: EndoBasis;\n  splitScalar?: (k: bigint) => { k1neg: boolean; k1: bigint; k2neg: boolean; k2: bigint };\n};\n\n// We construct basis in such way that den is always positive and equals n, but num sign depends on basis (not on secret value)\nconst divNearest = (num: bigint, den: bigint) => (num + (num >= 0 ? den : -den) / _2n) / den;\n\nexport type ScalarEndoParts = { k1neg: boolean; k1: bigint; k2neg: boolean; k2: bigint };\n\n/**\n * Splits scalar for GLV endomorphism.\n */\nexport function _splitEndoScalar(k: bigint, basis: EndoBasis, n: bigint): ScalarEndoParts {\n  // Split scalar into two such that part is ~half bits: `abs(part) < sqrt(N)`\n  // Since part can be negative, we need to do this on point.\n  // TODO: verifyScalar function which consumes lambda\n  const [[a1, b1], [a2, b2]] = basis;\n  const c1 = divNearest(b2 * k, n);\n  const c2 = divNearest(-b1 * k, n);\n  // |k1|/|k2| is < sqrt(N), but can be negative.\n  // If we do `k1 mod N`, we'll get big scalar (`> sqrt(N)`): so, we do cheaper negation instead.\n  let k1 = k - c1 * a1 - c2 * a2;\n  let k2 = -c1 * b1 - c2 * b2;\n  const k1neg = k1 < _0n;\n  const k2neg = k2 < _0n;\n  if (k1neg) k1 = -k1;\n  if (k2neg) k2 = -k2;\n  // Double check that resulting scalar less than half bits of N: otherwise wNAF will fail.\n  // This should only happen on wrong basises. Also, math inside is too complex and I don't trust it.\n  const MAX_NUM = bitMask(Math.ceil(bitLen(n) / 2)) + _1n; // Half bits of N\n  if (k1 < _0n || k1 >= MAX_NUM || k2 < _0n || k2 >= MAX_NUM) {\n    throw new Error('splitScalar (endomorphism): failed, k=' + k);\n  }\n  return { k1neg, k1, k2neg, k2 };\n}\n\nexport type ECDSASigFormat = 'compact' | 'recovered' | 'der';\nexport type ECDSARecoverOpts = {\n  prehash?: boolean;\n};\nexport type ECDSAVerifyOpts = {\n  prehash?: boolean;\n  lowS?: boolean;\n  format?: ECDSASigFormat;\n};\nexport type ECDSASignOpts = {\n  prehash?: boolean;\n  lowS?: boolean;\n  format?: ECDSASigFormat;\n  extraEntropy?: Uint8Array | boolean;\n};\n\nfunction validateSigFormat(format: string): ECDSASigFormat {\n  if (!['compact', 'recovered', 'der'].includes(format))\n    throw new Error('Signature format must be \"compact\", \"recovered\", or \"der\"');\n  return format as ECDSASigFormat;\n}\n\nfunction validateSigOpts<T extends ECDSASignOpts, D extends Required<ECDSASignOpts>>(\n  opts: T,\n  def: D\n): Required<ECDSASignOpts> {\n  const optsn: ECDSASignOpts = {};\n  for (let optName of Object.keys(def)) {\n    // @ts-ignore\n    optsn[optName] = opts[optName] === undefined ? def[optName] : opts[optName];\n  }\n  abool(optsn.lowS!, 'lowS');\n  abool(optsn.prehash!, 'prehash');\n  if (optsn.format !== undefined) validateSigFormat(optsn.format);\n  return optsn as Required<ECDSASignOpts>;\n}\n\n/** Instance methods for 3D XYZ projective points. */\nexport interface WeierstrassPoint<T> extends CurvePoint<T, WeierstrassPoint<T>> {\n  /** projective X coordinate. Different from affine x. */\n  readonly X: T;\n  /** projective Y coordinate. Different from affine y. */\n  readonly Y: T;\n  /** projective z coordinate */\n  readonly Z: T;\n  /** affine x coordinate. Different from projective X. */\n  get x(): T;\n  /** affine y coordinate. Different from projective Y. */\n  get y(): T;\n  /** Encodes point using IEEE P1363 (DER) encoding. First byte is 2/3/4. Default = isCompressed. */\n  toBytes(isCompressed?: boolean): Uint8Array;\n  toHex(isCompressed?: boolean): string;\n\n  /** @deprecated use `.X` */\n  readonly px: T;\n  /** @deprecated use `.Y` */\n  readonly py: T;\n  /** @deprecated use `.Z` */\n  readonly pz: T;\n  /** @deprecated use `toBytes` */\n  toRawBytes(isCompressed?: boolean): Uint8Array;\n  /** @deprecated use `multiplyUnsafe` */\n  multiplyAndAddUnsafe(\n    Q: WeierstrassPoint<T>,\n    a: bigint,\n    b: bigint\n  ): WeierstrassPoint<T> | undefined;\n  /** @deprecated use `p.y % 2n === 0n` */\n  hasEvenY(): boolean;\n  /** @deprecated use `p.precompute(windowSize)` */\n  _setWindowSize(windowSize: number): void;\n}\n\n/** Static methods for 3D XYZ projective points. */\nexport interface WeierstrassPointCons<T> extends CurvePointCons<WeierstrassPoint<T>> {\n  /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n  new (X: T, Y: T, Z: T): WeierstrassPoint<T>;\n  CURVE(): WeierstrassOpts<T>;\n  /** @deprecated use `Point.BASE.multiply(Point.Fn.fromBytes(privateKey))` */\n  fromPrivateKey(privateKey: PrivKey): WeierstrassPoint<T>;\n  /** @deprecated use `import { normalizeZ } from '@noble/curves/abstract/curve.js';` */\n  normalizeZ(points: WeierstrassPoint<T>[]): WeierstrassPoint<T>[];\n  /** @deprecated use `import { pippenger } from '@noble/curves/abstract/curve.js';` */\n  msm(points: WeierstrassPoint<T>[], scalars: bigint[]): WeierstrassPoint<T>;\n}\n\n/**\n * Weierstrass curve options.\n *\n * * p: prime characteristic (order) of finite field, in which arithmetics is done\n * * n: order of prime subgroup a.k.a total amount of valid curve points\n * * h: cofactor, usually 1. h*n is group order; n is subgroup order\n * * a: formula param, must be in field of p\n * * b: formula param, must be in field of p\n * * Gx: x coordinate of generator point a.k.a. base point\n * * Gy: y coordinate of generator point\n */\nexport type WeierstrassOpts<T> = Readonly<{\n  p: bigint;\n  n: bigint;\n  h: bigint;\n  a: T;\n  b: T;\n  Gx: T;\n  Gy: T;\n}>;\n\n// When a cofactor != 1, there can be an effective methods to:\n// 1. Determine whether a point is torsion-free\n// 2. Clear torsion component\n// wrapPrivateKey: bls12-381 requires mod(n) instead of rejecting keys >= n\nexport type WeierstrassExtraOpts<T> = Partial<{\n  Fp: IField<T>;\n  Fn: IField<bigint>;\n  allowInfinityPoint: boolean;\n  endo: EndomorphismOpts;\n  isTorsionFree: (c: WeierstrassPointCons<T>, point: WeierstrassPoint<T>) => boolean;\n  clearCofactor: (c: WeierstrassPointCons<T>, point: WeierstrassPoint<T>) => WeierstrassPoint<T>;\n  fromBytes: (bytes: Uint8Array) => AffinePoint<T>;\n  toBytes: (\n    c: WeierstrassPointCons<T>,\n    point: WeierstrassPoint<T>,\n    isCompressed: boolean\n  ) => Uint8Array;\n}>;\n\n/**\n * Options for ECDSA signatures over a Weierstrass curve.\n *\n * * lowS: (default: true) whether produced / verified signatures occupy low half of ecdsaOpts.p. Prevents malleability.\n * * hmac: (default: noble-hashes hmac) function, would be used to init hmac-drbg for k generation.\n * * randomBytes: (default: webcrypto os-level CSPRNG) custom method for fetching secure randomness.\n * * bits2int, bits2int_modN: used in sigs, sometimes overridden by curves\n */\nexport type ECDSAOpts = Partial<{\n  lowS: boolean;\n  hmac: HmacFnSync;\n  randomBytes: (bytesLength?: number) => Uint8Array;\n  bits2int: (bytes: Uint8Array) => bigint;\n  bits2int_modN: (bytes: Uint8Array) => bigint;\n}>;\n\n/**\n * Elliptic Curve Diffie-Hellman interface.\n * Provides keygen, secret-to-public conversion, calculating shared secrets.\n */\nexport interface ECDH {\n  keygen: (seed?: Uint8Array) => { secretKey: Uint8Array; publicKey: Uint8Array };\n  getPublicKey: (secretKey: PrivKey, isCompressed?: boolean) => Uint8Array;\n  getSharedSecret: (secretKeyA: PrivKey, publicKeyB: Hex, isCompressed?: boolean) => Uint8Array;\n  Point: WeierstrassPointCons<bigint>;\n  utils: {\n    isValidSecretKey: (secretKey: PrivKey) => boolean;\n    isValidPublicKey: (publicKey: Uint8Array, isCompressed?: boolean) => boolean;\n    randomSecretKey: (seed?: Uint8Array) => Uint8Array;\n    /** @deprecated use `randomSecretKey` */\n    randomPrivateKey: (seed?: Uint8Array) => Uint8Array;\n    /** @deprecated use `isValidSecretKey` */\n    isValidPrivateKey: (secretKey: PrivKey) => boolean;\n    /** @deprecated use `Point.Fn.fromBytes()` */\n    normPrivateKeyToScalar: (key: PrivKey) => bigint;\n    /** @deprecated use `point.precompute()` */\n    precompute: (windowSize?: number, point?: WeierstrassPoint<bigint>) => WeierstrassPoint<bigint>;\n  };\n  lengths: CurveLengths;\n}\n\n/**\n * ECDSA interface.\n * Only supported for prime fields, not Fp2 (extension fields).\n */\nexport interface ECDSA extends ECDH {\n  sign: (message: Hex, secretKey: PrivKey, opts?: ECDSASignOpts) => ECDSASigRecovered;\n  verify: (\n    signature: Uint8Array,\n    message: Uint8Array,\n    publicKey: Uint8Array,\n    opts?: ECDSAVerifyOpts\n  ) => boolean;\n  recoverPublicKey(signature: Uint8Array, message: Uint8Array, opts?: ECDSARecoverOpts): Uint8Array;\n  Signature: ECDSASignatureCons;\n}\nexport class DERErr extends Error {\n  constructor(m = '') {\n    super(m);\n  }\n}\nexport type IDER = {\n  // asn.1 DER encoding utils\n  Err: typeof DERErr;\n  // Basic building block is TLV (Tag-Length-Value)\n  _tlv: {\n    encode: (tag: number, data: string) => string;\n    // v - value, l - left bytes (unparsed)\n    decode(tag: number, data: Uint8Array): { v: Uint8Array; l: Uint8Array };\n  };\n  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n  // since we always use positive integers here. It must always be empty:\n  // - add zero byte if exists\n  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n  _int: {\n    encode(num: bigint): string;\n    decode(data: Uint8Array): bigint;\n  };\n  toSig(hex: string | Uint8Array): { r: bigint; s: bigint };\n  hexFromSig(sig: { r: bigint; s: bigint }): string;\n};\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nexport const DER: IDER = {\n  // asn.1 DER encoding utils\n  Err: DERErr,\n  // Basic building block is TLV (Tag-Length-Value)\n  _tlv: {\n    encode: (tag: number, data: string): string => {\n      const { Err: E } = DER;\n      if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');\n      if (data.length & 1) throw new E('tlv.encode: unpadded data');\n      const dataLen = data.length / 2;\n      const len = numberToHexUnpadded(dataLen);\n      if ((len.length / 2) & 0b1000_0000) throw new E('tlv.encode: long form length too big');\n      // length of length with long form flag\n      const lenLen = dataLen > 127 ? numberToHexUnpadded((len.length / 2) | 0b1000_0000) : '';\n      const t = numberToHexUnpadded(tag);\n      return t + lenLen + len + data;\n    },\n    // v - value, l - left bytes (unparsed)\n    decode(tag: number, data: Uint8Array): { v: Uint8Array; l: Uint8Array } {\n      const { Err: E } = DER;\n      let pos = 0;\n      if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');\n      if (data.length < 2 || data[pos++] !== tag) throw new E('tlv.decode: wrong tlv');\n      const first = data[pos++];\n      const isLong = !!(first & 0b1000_0000); // First bit of first length byte is flag for short/long form\n      let length = 0;\n      if (!isLong) length = first;\n      else {\n        // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n        const lenLen = first & 0b0111_1111;\n        if (!lenLen) throw new E('tlv.decode(long): indefinite length not supported');\n        if (lenLen > 4) throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n        const lengthBytes = data.subarray(pos, pos + lenLen);\n        if (lengthBytes.length !== lenLen) throw new E('tlv.decode: length bytes not complete');\n        if (lengthBytes[0] === 0) throw new E('tlv.decode(long): zero leftmost byte');\n        for (const b of lengthBytes) length = (length << 8) | b;\n        pos += lenLen;\n        if (length < 128) throw new E('tlv.decode(long): not minimal encoding');\n      }\n      const v = data.subarray(pos, pos + length);\n      if (v.length !== length) throw new E('tlv.decode: wrong value length');\n      return { v, l: data.subarray(pos + length) };\n    },\n  },\n  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n  // since we always use positive integers here. It must always be empty:\n  // - add zero byte if exists\n  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n  _int: {\n    encode(num: bigint): string {\n      const { Err: E } = DER;\n      if (num < _0n) throw new E('integer: negative integers are not allowed');\n      let hex = numberToHexUnpadded(num);\n      // Pad with zero byte if negative flag is present\n      if (Number.parseInt(hex[0], 16) & 0b1000) hex = '00' + hex;\n      if (hex.length & 1) throw new E('unexpected DER parsing assertion: unpadded hex');\n      return hex;\n    },\n    decode(data: Uint8Array): bigint {\n      const { Err: E } = DER;\n      if (data[0] & 0b1000_0000) throw new E('invalid signature integer: negative');\n      if (data[0] === 0x00 && !(data[1] & 0b1000_0000))\n        throw new E('invalid signature integer: unnecessary leading zero');\n      return bytesToNumberBE(data);\n    },\n  },\n  toSig(hex: string | Uint8Array): { r: bigint; s: bigint } {\n    // parse DER signature\n    const { Err: E, _int: int, _tlv: tlv } = DER;\n    const data = ensureBytes('signature', hex);\n    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n    if (seqLeftBytes.length) throw new E('invalid signature: left bytes after parsing');\n    const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n    const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n    if (sLeftBytes.length) throw new E('invalid signature: left bytes after parsing');\n    return { r: int.decode(rBytes), s: int.decode(sBytes) };\n  },\n  hexFromSig(sig: { r: bigint; s: bigint }): string {\n    const { _tlv: tlv, _int: int } = DER;\n    const rs = tlv.encode(0x02, int.encode(sig.r));\n    const ss = tlv.encode(0x02, int.encode(sig.s));\n    const seq = rs + ss;\n    return tlv.encode(0x30, seq);\n  },\n};\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\n\nexport function _normFnElement(Fn: IField<bigint>, key: PrivKey): bigint {\n  const { BYTES: expected } = Fn;\n  let num: bigint;\n  if (typeof key === 'bigint') {\n    num = key;\n  } else {\n    let bytes = ensureBytes('private key', key);\n    try {\n      num = Fn.fromBytes(bytes);\n    } catch (error) {\n      throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);\n    }\n  }\n  if (!Fn.isValidNot0(num)) throw new Error('invalid private key: out of range [1..N-1]');\n  return num;\n}\n\n/**\n * Creates weierstrass Point constructor, based on specified curve options.\n *\n * @example\n```js\nconst opts = {\n  p: BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'),\n  n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),\n  h: BigInt(1),\n  a: BigInt('0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc'),\n  b: BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b'),\n  Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),\n  Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),\n};\nconst p256_Point = weierstrass(opts);\n```\n */\nexport function weierstrassN<T>(\n  params: WeierstrassOpts<T>,\n  extraOpts: WeierstrassExtraOpts<T> = {}\n): WeierstrassPointCons<T> {\n  const validated = _createCurveFields('weierstrass', params, extraOpts);\n  const { Fp, Fn } = validated;\n  let CURVE = validated.CURVE as WeierstrassOpts<T>;\n  const { h: cofactor, n: CURVE_ORDER } = CURVE;\n  _validateObject(\n    extraOpts,\n    {},\n    {\n      allowInfinityPoint: 'boolean',\n      clearCofactor: 'function',\n      isTorsionFree: 'function',\n      fromBytes: 'function',\n      toBytes: 'function',\n      endo: 'object',\n      wrapPrivateKey: 'boolean',\n    }\n  );\n\n  const { endo } = extraOpts;\n  if (endo) {\n    // validateObject(endo, { beta: 'bigint', splitScalar: 'function' });\n    if (!Fp.is0(CURVE.a) || typeof endo.beta !== 'bigint' || !Array.isArray(endo.basises)) {\n      throw new Error('invalid endo: expected \"beta\": bigint and \"basises\": array');\n    }\n  }\n\n  const lengths = getWLengths(Fp, Fn);\n\n  function assertCompressionIsSupported() {\n    if (!Fp.isOdd) throw new Error('compression is not supported: Field does not have .isOdd()');\n  }\n\n  // Implements IEEE P1363 point encoding\n  function pointToBytes(\n    _c: WeierstrassPointCons<T>,\n    point: WeierstrassPoint<T>,\n    isCompressed: boolean\n  ): Uint8Array {\n    const { x, y } = point.toAffine();\n    const bx = Fp.toBytes(x);\n    abool(isCompressed, 'isCompressed');\n    if (isCompressed) {\n      assertCompressionIsSupported();\n      const hasEvenY = !Fp.isOdd!(y);\n      return concatBytes(pprefix(hasEvenY), bx);\n    } else {\n      return concatBytes(Uint8Array.of(0x04), bx, Fp.toBytes(y));\n    }\n  }\n  function pointFromBytes(bytes: Uint8Array) {\n    abytes(bytes, undefined, 'Point');\n    const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths; // e.g. for 32-byte: 33, 65\n    const length = bytes.length;\n    const head = bytes[0];\n    const tail = bytes.subarray(1);\n    // No actual validation is done here: use .assertValidity()\n    if (length === comp && (head === 0x02 || head === 0x03)) {\n      const x = Fp.fromBytes(tail);\n      if (!Fp.isValid(x)) throw new Error('bad point: is not on curve, wrong x');\n      const y2 = weierstrassEquation(x); // y = x + ax + b\n      let y: T;\n      try {\n        y = Fp.sqrt(y2); // y = y ^ (p+1)/4\n      } catch (sqrtError) {\n        const err = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n        throw new Error('bad point: is not on curve, sqrt error' + err);\n      }\n      assertCompressionIsSupported();\n      const isYOdd = Fp.isOdd!(y); // (y & _1n) === _1n;\n      const isHeadOdd = (head & 1) === 1; // ECDSA-specific\n      if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n      return { x, y };\n    } else if (length === uncomp && head === 0x04) {\n      // TODO: more checks\n      const L = Fp.BYTES;\n      const x = Fp.fromBytes(tail.subarray(0, L));\n      const y = Fp.fromBytes(tail.subarray(L, L * 2));\n      if (!isValidXY(x, y)) throw new Error('bad point: is not on curve');\n      return { x, y };\n    } else {\n      throw new Error(\n        `bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`\n      );\n    }\n  }\n\n  const encodePoint = extraOpts.toBytes || pointToBytes;\n  const decodePoint = extraOpts.fromBytes || pointFromBytes;\n  function weierstrassEquation(x: T): T {\n    const x2 = Fp.sqr(x); // x * x\n    const x3 = Fp.mul(x2, x); // x * x\n    return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b); // x + a * x + b\n  }\n\n  // TODO: move top-level\n  /** Checks whether equation holds for given x, y: y == x + ax + b */\n  function isValidXY(x: T, y: T): boolean {\n    const left = Fp.sqr(y); // y\n    const right = weierstrassEquation(x); // x + ax + b\n    return Fp.eql(left, right);\n  }\n\n  // Validate whether the passed curve params are valid.\n  // Test 1: equation y = x + ax + b should work for generator point.\n  if (!isValidXY(CURVE.Gx, CURVE.Gy)) throw new Error('bad curve params: generator point');\n\n  // Test 2: discriminant  part should be non-zero: 4a + 27b != 0.\n  // Guarantees curve is genus-1, smooth (non-singular).\n  const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);\n  const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));\n  if (Fp.is0(Fp.add(_4a3, _27b2))) throw new Error('bad curve params: a or b');\n\n  /** Asserts coordinate is valid: 0 <= n < Fp.ORDER. */\n  function acoord(title: string, n: T, banZero = false) {\n    if (!Fp.isValid(n) || (banZero && Fp.is0(n))) throw new Error(`bad point coordinate ${title}`);\n    return n;\n  }\n\n  function aprjpoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('ProjectivePoint expected');\n  }\n\n  function splitEndoScalarN(k: bigint) {\n    if (!endo || !endo.basises) throw new Error('no endo');\n    return _splitEndoScalar(k, endo.basises, Fn.ORDER);\n  }\n\n  // Memoized toAffine / validity check. They are heavy. Points are immutable.\n\n  // Converts Projective point to affine (x, y) coordinates.\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\n  // (X, Y, Z)  (x=X/Z, y=Y/Z)\n  const toAffineMemo = memoized((p: Point, iz?: T): AffinePoint<T> => {\n    const { X, Y, Z } = p;\n    // Fast-path for normalized points\n    if (Fp.eql(Z, Fp.ONE)) return { x: X, y: Y };\n    const is0 = p.is0();\n    // If invZ was 0, we return zero point. However we still want to execute\n    // all operations, so we replace invZ with a random number, 1.\n    if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(Z);\n    const x = Fp.mul(X, iz);\n    const y = Fp.mul(Y, iz);\n    const zz = Fp.mul(Z, iz);\n    if (is0) return { x: Fp.ZERO, y: Fp.ZERO };\n    if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');\n    return { x, y };\n  });\n  // NOTE: on exception this will crash 'cached' and no value will be set.\n  // Otherwise true will be return\n  const assertValidMemo = memoized((p: Point) => {\n    if (p.is0()) {\n      // (0, 1, 0) aka ZERO is invalid in most contexts.\n      // In BLS, ZERO can be serialized, so we allow it.\n      // (0, 0, 0) is invalid representation of ZERO.\n      if (extraOpts.allowInfinityPoint && !Fp.is0(p.Y)) return;\n      throw new Error('bad point: ZERO');\n    }\n    // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n    const { x, y } = p.toAffine();\n    if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not field elements');\n    if (!isValidXY(x, y)) throw new Error('bad point: equation left != right');\n    if (!p.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');\n    return true;\n  });\n\n  function finishEndo(\n    endoBeta: EndomorphismOpts['beta'],\n    k1p: Point,\n    k2p: Point,\n    k1neg: boolean,\n    k2neg: boolean\n  ) {\n    k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);\n    k1p = negateCt(k1neg, k1p);\n    k2p = negateCt(k2neg, k2p);\n    return k1p.add(k2p);\n  }\n\n  /**\n   * Projective Point works in 3d / projective (homogeneous) coordinates:(X, Y, Z)  (x=X/Z, y=Y/Z).\n   * Default Point works in 2d / affine coordinates: (x, y).\n   * We're doing calculations in projective, because its operations don't require costly inversion.\n   */\n  class Point implements WeierstrassPoint<T> {\n    // base / generator point\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    // zero / infinity / identity point\n    static readonly ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0\n    // math field\n    static readonly Fp = Fp;\n    // scalar field\n    static readonly Fn = Fn;\n\n    readonly X: T;\n    readonly Y: T;\n    readonly Z: T;\n\n    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n    constructor(X: T, Y: T, Z: T) {\n      this.X = acoord('x', X);\n      this.Y = acoord('y', Y, true);\n      this.Z = acoord('z', Z);\n      Object.freeze(this);\n    }\n\n    static CURVE(): WeierstrassOpts<T> {\n      return CURVE;\n    }\n\n    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n    static fromAffine(p: AffinePoint<T>): Point {\n      const { x, y } = p || {};\n      if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');\n      if (p instanceof Point) throw new Error('projective point not allowed');\n      // (0, 0) would've produced (0, 0, 1) - instead, we need (0, 1, 0)\n      if (Fp.is0(x) && Fp.is0(y)) return Point.ZERO;\n      return new Point(x, y, Fp.ONE);\n    }\n\n    static fromBytes(bytes: Uint8Array): Point {\n      const P = Point.fromAffine(decodePoint(abytes(bytes, undefined, 'point')));\n      P.assertValidity();\n      return P;\n    }\n    static fromHex(hex: Hex): Point {\n      return Point.fromBytes(ensureBytes('pointHex', hex));\n    }\n\n    get x(): T {\n      return this.toAffine().x;\n    }\n    get y(): T {\n      return this.toAffine().y;\n    }\n\n    /**\n     *\n     * @param windowSize\n     * @param isLazy true will defer table computation until the first multiplication\n     * @returns\n     */\n    precompute(windowSize: number = 8, isLazy = true): Point {\n      wnaf.createCache(this, windowSize);\n      if (!isLazy) this.multiply(_3n); // random number\n      return this;\n    }\n\n    // TODO: return `this`\n    /** A point on curve is valid if it conforms to equation. */\n    assertValidity(): void {\n      assertValidMemo(this);\n    }\n\n    hasEvenY(): boolean {\n      const { y } = this.toAffine();\n      if (!Fp.isOdd) throw new Error(\"Field doesn't support isOdd\");\n      return !Fp.isOdd(y);\n    }\n\n    /** Compare one point to another. */\n    equals(other: Point): boolean {\n      aprjpoint(other);\n      const { X: X1, Y: Y1, Z: Z1 } = this;\n      const { X: X2, Y: Y2, Z: Z2 } = other;\n      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n      return U1 && U2;\n    }\n\n    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */\n    negate(): Point {\n      return new Point(this.X, Fp.neg(this.Y), this.Z);\n    }\n\n    // Renes-Costello-Batina exception-free doubling formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 3\n    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n    double() {\n      const { a, b } = CURVE;\n      const b3 = Fp.mul(b, _3n);\n      const { X: X1, Y: Y1, Z: Z1 } = this;\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n      let t0 = Fp.mul(X1, X1); // step 1\n      let t1 = Fp.mul(Y1, Y1);\n      let t2 = Fp.mul(Z1, Z1);\n      let t3 = Fp.mul(X1, Y1);\n      t3 = Fp.add(t3, t3); // step 5\n      Z3 = Fp.mul(X1, Z1);\n      Z3 = Fp.add(Z3, Z3);\n      X3 = Fp.mul(a, Z3);\n      Y3 = Fp.mul(b3, t2);\n      Y3 = Fp.add(X3, Y3); // step 10\n      X3 = Fp.sub(t1, Y3);\n      Y3 = Fp.add(t1, Y3);\n      Y3 = Fp.mul(X3, Y3);\n      X3 = Fp.mul(t3, X3);\n      Z3 = Fp.mul(b3, Z3); // step 15\n      t2 = Fp.mul(a, t2);\n      t3 = Fp.sub(t0, t2);\n      t3 = Fp.mul(a, t3);\n      t3 = Fp.add(t3, Z3);\n      Z3 = Fp.add(t0, t0); // step 20\n      t0 = Fp.add(Z3, t0);\n      t0 = Fp.add(t0, t2);\n      t0 = Fp.mul(t0, t3);\n      Y3 = Fp.add(Y3, t0);\n      t2 = Fp.mul(Y1, Z1); // step 25\n      t2 = Fp.add(t2, t2);\n      t0 = Fp.mul(t2, t3);\n      X3 = Fp.sub(X3, t0);\n      Z3 = Fp.mul(t2, t1);\n      Z3 = Fp.add(Z3, Z3); // step 30\n      Z3 = Fp.add(Z3, Z3);\n      return new Point(X3, Y3, Z3);\n    }\n\n    // Renes-Costello-Batina exception-free addition formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 1\n    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n    add(other: Point): Point {\n      aprjpoint(other);\n      const { X: X1, Y: Y1, Z: Z1 } = this;\n      const { X: X2, Y: Y2, Z: Z2 } = other;\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n      const a = CURVE.a;\n      const b3 = Fp.mul(CURVE.b, _3n);\n      let t0 = Fp.mul(X1, X2); // step 1\n      let t1 = Fp.mul(Y1, Y2);\n      let t2 = Fp.mul(Z1, Z2);\n      let t3 = Fp.add(X1, Y1);\n      let t4 = Fp.add(X2, Y2); // step 5\n      t3 = Fp.mul(t3, t4);\n      t4 = Fp.add(t0, t1);\n      t3 = Fp.sub(t3, t4);\n      t4 = Fp.add(X1, Z1);\n      let t5 = Fp.add(X2, Z2); // step 10\n      t4 = Fp.mul(t4, t5);\n      t5 = Fp.add(t0, t2);\n      t4 = Fp.sub(t4, t5);\n      t5 = Fp.add(Y1, Z1);\n      X3 = Fp.add(Y2, Z2); // step 15\n      t5 = Fp.mul(t5, X3);\n      X3 = Fp.add(t1, t2);\n      t5 = Fp.sub(t5, X3);\n      Z3 = Fp.mul(a, t4);\n      X3 = Fp.mul(b3, t2); // step 20\n      Z3 = Fp.add(X3, Z3);\n      X3 = Fp.sub(t1, Z3);\n      Z3 = Fp.add(t1, Z3);\n      Y3 = Fp.mul(X3, Z3);\n      t1 = Fp.add(t0, t0); // step 25\n      t1 = Fp.add(t1, t0);\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.mul(b3, t4);\n      t1 = Fp.add(t1, t2);\n      t2 = Fp.sub(t0, t2); // step 30\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.add(t4, t2);\n      t0 = Fp.mul(t1, t4);\n      Y3 = Fp.add(Y3, t0);\n      t0 = Fp.mul(t5, t4); // step 35\n      X3 = Fp.mul(t3, X3);\n      X3 = Fp.sub(X3, t0);\n      t0 = Fp.mul(t3, t1);\n      Z3 = Fp.mul(t5, Z3);\n      Z3 = Fp.add(Z3, t0); // step 40\n      return new Point(X3, Y3, Z3);\n    }\n\n    subtract(other: Point) {\n      return this.add(other.negate());\n    }\n\n    is0(): boolean {\n      return this.equals(Point.ZERO);\n    }\n\n    /**\n     * Constant time multiplication.\n     * Uses wNAF method. Windowed method may be 10% faster,\n     * but takes 2x longer to generate and consumes 2x memory.\n     * Uses precomputes when available.\n     * Uses endomorphism for Koblitz curves.\n     * @param scalar by which the point would be multiplied\n     * @returns New point\n     */\n    multiply(scalar: bigint): Point {\n      const { endo } = extraOpts;\n      if (!Fn.isValidNot0(scalar)) throw new Error('invalid scalar: out of range'); // 0 is invalid\n      let point: Point, fake: Point; // Fake point is used to const-time mult\n      const mul = (n: bigint) => wnaf.cached(this, n, (p) => normalizeZ(Point, p));\n      /** See docs for {@link EndomorphismOpts} */\n      if (endo) {\n        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);\n        const { p: k1p, f: k1f } = mul(k1);\n        const { p: k2p, f: k2f } = mul(k2);\n        fake = k1f.add(k2f);\n        point = finishEndo(endo.beta, k1p, k2p, k1neg, k2neg);\n      } else {\n        const { p, f } = mul(scalar);\n        point = p;\n        fake = f;\n      }\n      // Normalize `z` for both points, but return only real one\n      return normalizeZ(Point, [point, fake])[0];\n    }\n\n    /**\n     * Non-constant-time multiplication. Uses double-and-add algorithm.\n     * It's faster, but should only be used when you don't care about\n     * an exposed secret key e.g. sig verification, which works over *public* keys.\n     */\n    multiplyUnsafe(sc: bigint): Point {\n      const { endo } = extraOpts;\n      const p = this as Point;\n      if (!Fn.isValid(sc)) throw new Error('invalid scalar: out of range'); // 0 is valid\n      if (sc === _0n || p.is0()) return Point.ZERO;\n      if (sc === _1n) return p; // fast-path\n      if (wnaf.hasCache(this)) return this.multiply(sc);\n      if (endo) {\n        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);\n        const { p1, p2 } = mulEndoUnsafe(Point, p, k1, k2); // 30% faster vs wnaf.unsafe\n        return finishEndo(endo.beta, p1, p2, k1neg, k2neg);\n      } else {\n        return wnaf.unsafe(p, sc);\n      }\n    }\n\n    multiplyAndAddUnsafe(Q: Point, a: bigint, b: bigint): Point | undefined {\n      const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));\n      return sum.is0() ? undefined : sum;\n    }\n\n    /**\n     * Converts Projective point to affine (x, y) coordinates.\n     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch\n     */\n    toAffine(invertedZ?: T): AffinePoint<T> {\n      return toAffineMemo(this, invertedZ);\n    }\n\n    /**\n     * Checks whether Point is free of torsion elements (is in prime subgroup).\n     * Always torsion-free for cofactor=1 curves.\n     */\n    isTorsionFree(): boolean {\n      const { isTorsionFree } = extraOpts;\n      if (cofactor === _1n) return true;\n      if (isTorsionFree) return isTorsionFree(Point, this);\n      return wnaf.unsafe(this, CURVE_ORDER).is0();\n    }\n\n    clearCofactor(): Point {\n      const { clearCofactor } = extraOpts;\n      if (cofactor === _1n) return this; // Fast-path\n      if (clearCofactor) return clearCofactor(Point, this) as Point;\n      return this.multiplyUnsafe(cofactor);\n    }\n\n    isSmallOrder(): boolean {\n      // can we use this.clearCofactor()?\n      return this.multiplyUnsafe(cofactor).is0();\n    }\n\n    toBytes(isCompressed = true): Uint8Array {\n      abool(isCompressed, 'isCompressed');\n      this.assertValidity();\n      return encodePoint(Point, this, isCompressed);\n    }\n\n    toHex(isCompressed = true): string {\n      return bytesToHex(this.toBytes(isCompressed));\n    }\n\n    toString() {\n      return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;\n    }\n\n    // TODO: remove\n    get px(): T {\n      return this.X;\n    }\n    get py(): T {\n      return this.X;\n    }\n    get pz(): T {\n      return this.Z;\n    }\n    toRawBytes(isCompressed = true): Uint8Array {\n      return this.toBytes(isCompressed);\n    }\n    _setWindowSize(windowSize: number) {\n      this.precompute(windowSize);\n    }\n    static normalizeZ(points: Point[]): Point[] {\n      return normalizeZ(Point, points);\n    }\n    static msm(points: Point[], scalars: bigint[]): Point {\n      return pippenger(Point, Fn, points, scalars);\n    }\n    static fromPrivateKey(privateKey: PrivKey) {\n      return Point.BASE.multiply(_normFnElement(Fn, privateKey));\n    }\n  }\n  const bits = Fn.BITS;\n  const wnaf = new wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);\n  Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n  return Point;\n}\n\n/** Methods of ECDSA signature instance. */\nexport interface ECDSASignature {\n  readonly r: bigint;\n  readonly s: bigint;\n  readonly recovery?: number;\n  addRecoveryBit(recovery: number): ECDSASigRecovered;\n  hasHighS(): boolean;\n  toBytes(format?: string): Uint8Array;\n  toHex(format?: string): string;\n\n  /** @deprecated */\n  assertValidity(): void;\n  /** @deprecated */\n  normalizeS(): ECDSASignature;\n  /** @deprecated use standalone method `curve.recoverPublicKey(sig.toBytes('recovered'), msg)` */\n  recoverPublicKey(msgHash: Hex): WeierstrassPoint<bigint>;\n  /** @deprecated use `.toBytes('compact')` */\n  toCompactRawBytes(): Uint8Array;\n  /** @deprecated use `.toBytes('compact')` */\n  toCompactHex(): string;\n  /** @deprecated use `.toBytes('der')` */\n  toDERRawBytes(): Uint8Array;\n  /** @deprecated use `.toBytes('der')` */\n  toDERHex(): string;\n}\nexport type ECDSASigRecovered = ECDSASignature & {\n  readonly recovery: number;\n};\n/** Methods of ECDSA signature constructor. */\nexport type ECDSASignatureCons = {\n  new (r: bigint, s: bigint, recovery?: number): ECDSASignature;\n  fromBytes(bytes: Uint8Array, format?: ECDSASigFormat): ECDSASignature;\n  fromHex(hex: string, format?: ECDSASigFormat): ECDSASignature;\n\n  /** @deprecated use `.fromBytes(bytes, 'compact')` */\n  fromCompact(hex: Hex): ECDSASignature;\n  /** @deprecated use `.fromBytes(bytes, 'der')` */\n  fromDER(hex: Hex): ECDSASignature;\n};\n\n// Points start with byte 0x02 when y is even; otherwise 0x03\nfunction pprefix(hasEvenY: boolean): Uint8Array {\n  return Uint8Array.of(hasEvenY ? 0x02 : 0x03);\n}\n\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio<T>(\n  Fp: IField<T>,\n  Z: T\n): (u: T, v: T) => { isValid: boolean; value: T } {\n  // Generic implementation\n  const q = Fp.ORDER;\n  let l = _0n;\n  for (let o = q - _1n; o % _2n === _0n; o /= _2n) l += _1n;\n  const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n  // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n  // 2n ** c1 == 2n << (c1-1)\n  const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n  const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n  const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n  const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n  const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n  const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n  const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n  const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n  let sqrtRatio = (u: T, v: T): { isValid: boolean; value: T } => {\n    let tv1 = c6; // 1. tv1 = c6\n    let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n    let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n    tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n    let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n    tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n    tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n    tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n    tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n    let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n    tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n    let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n    tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n    tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n    tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n    tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n    // 17. for i in (c1, c1 - 1, ..., 2):\n    for (let i = c1; i > _1n; i--) {\n      let tv5 = i - _2n; // 18.    tv5 = i - 2\n      tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n      let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n      const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n      tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n      tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n      tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n      tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n      tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n    }\n    return { isValid: isQR, value: tv3 };\n  };\n  if (Fp.ORDER % _4n === _3n) {\n    // sqrt_ratio_3mod4(u, v)\n    const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n    const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n    sqrtRatio = (u: T, v: T) => {\n      let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n      const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n      tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n      let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n      y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n      const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n      const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n      const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n      let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n      return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n    };\n  }\n  // No curves uses that\n  // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n  return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nexport function mapToCurveSimpleSWU<T>(\n  Fp: IField<T>,\n  opts: {\n    A: T;\n    B: T;\n    Z: T;\n  }\n): (u: T) => { x: T; y: T } {\n  validateField(Fp);\n  const { A, B, Z } = opts;\n  if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z))\n    throw new Error('mapToCurveSimpleSWU: invalid opts');\n  const sqrtRatio = SWUFpSqrtRatio(Fp, Z);\n  if (!Fp.isOdd) throw new Error('Field does not have .isOdd()');\n  // Input: u, an element of F.\n  // Output: (x, y), a point on E.\n  return (u: T): { x: T; y: T } => {\n    // prettier-ignore\n    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n    tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, Z); // 2.  tv1 = Z * tv1\n    tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n    tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n    tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n    tv3 = Fp.mul(tv3, B); // 6.  tv3 = B * tv3\n    tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n    tv4 = Fp.mul(tv4, A); // 8.  tv4 = A * tv4\n    tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n    tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n    tv5 = Fp.mul(tv6, A); // 11. tv5 = A * tv6\n    tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n    tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n    tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n    tv5 = Fp.mul(tv6, B); // 15. tv5 = B * tv6\n    tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n    x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n    const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n    y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n    y = Fp.mul(y, value); // 20.   y = y * y1\n    x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n    y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n    const e1 = Fp.isOdd!(u) === Fp.isOdd!(y); // 23.  e1 = sgn0(u) == sgn0(y)\n    y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n    const tv4_inv = FpInvertBatch(Fp, [tv4], true)[0];\n    x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4\n    return { x, y };\n  };\n}\n\nfunction getWLengths<T>(Fp: IField<T>, Fn: IField<bigint>) {\n  return {\n    secretKey: Fn.BYTES,\n    publicKey: 1 + Fp.BYTES,\n    publicKeyUncompressed: 1 + 2 * Fp.BYTES,\n    publicKeyHasPrefix: true,\n    signature: 2 * Fn.BYTES,\n  };\n}\n\n/**\n * Sometimes users only need getPublicKey, getSharedSecret, and secret key handling.\n * This helper ensures no signature functionality is present. Less code, smaller bundle size.\n */\nexport function ecdh(\n  Point: WeierstrassPointCons<bigint>,\n  ecdhOpts: { randomBytes?: (bytesLength?: number) => Uint8Array } = {}\n): ECDH {\n  const { Fn } = Point;\n  const randomBytes_ = ecdhOpts.randomBytes || randomBytesWeb;\n  const lengths = Object.assign(getWLengths(Point.Fp, Fn), { seed: getMinHashLength(Fn.ORDER) });\n\n  function isValidSecretKey(secretKey: PrivKey) {\n    try {\n      return !!_normFnElement(Fn, secretKey);\n    } catch (error) {\n      return false;\n    }\n  }\n\n  function isValidPublicKey(publicKey: Uint8Array, isCompressed?: boolean): boolean {\n    const { publicKey: comp, publicKeyUncompressed } = lengths;\n    try {\n      const l = publicKey.length;\n      if (isCompressed === true && l !== comp) return false;\n      if (isCompressed === false && l !== publicKeyUncompressed) return false;\n      return !!Point.fromBytes(publicKey);\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * Produces cryptographically secure secret key from random of size\n   * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n   */\n  function randomSecretKey(seed = randomBytes_(lengths.seed)): Uint8Array {\n    return mapHashToField(abytes(seed, lengths.seed, 'seed'), Fn.ORDER);\n  }\n\n  /**\n   * Computes public key for a secret key. Checks for validity of the secret key.\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns Public key, full when isCompressed=false; short when isCompressed=true\n   */\n  function getPublicKey(secretKey: PrivKey, isCompressed = true): Uint8Array {\n    return Point.BASE.multiply(_normFnElement(Fn, secretKey)).toBytes(isCompressed);\n  }\n\n  function keygen(seed?: Uint8Array) {\n    const secretKey = randomSecretKey(seed);\n    return { secretKey, publicKey: getPublicKey(secretKey) };\n  }\n\n  /**\n   * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n   */\n  function isProbPub(item: PrivKey | PubKey): boolean | undefined {\n    if (typeof item === 'bigint') return false;\n    if (item instanceof Point) return true;\n    const { secretKey, publicKey, publicKeyUncompressed } = lengths;\n    if (Fn.allowedLengths || secretKey === publicKey) return undefined;\n    const l = ensureBytes('key', item).length;\n    return l === publicKey || l === publicKeyUncompressed;\n  }\n\n  /**\n   * ECDH (Elliptic Curve Diffie Hellman).\n   * Computes shared public key from secret key A and public key B.\n   * Checks: 1) secret key validity 2) shared key is on-curve.\n   * Does NOT hash the result.\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns shared public key\n   */\n  function getSharedSecret(secretKeyA: PrivKey, publicKeyB: Hex, isCompressed = true): Uint8Array {\n    if (isProbPub(secretKeyA) === true) throw new Error('first arg must be private key');\n    if (isProbPub(publicKeyB) === false) throw new Error('second arg must be public key');\n    const s = _normFnElement(Fn, secretKeyA);\n    const b = Point.fromHex(publicKeyB); // checks for being on-curve\n    return b.multiply(s).toBytes(isCompressed);\n  }\n\n  const utils = {\n    isValidSecretKey,\n    isValidPublicKey,\n    randomSecretKey,\n\n    // TODO: remove\n    isValidPrivateKey: isValidSecretKey,\n    randomPrivateKey: randomSecretKey,\n    normPrivateKeyToScalar: (key: PrivKey) => _normFnElement(Fn, key),\n    precompute(windowSize = 8, point = Point.BASE): WeierstrassPoint<bigint> {\n      return point.precompute(windowSize, false);\n    },\n  };\n\n  return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point, utils, lengths });\n}\n\n/**\n * Creates ECDSA signing interface for given elliptic curve `Point` and `hash` function.\n * We need `hash` for 2 features:\n * 1. Message prehash-ing. NOT used if `sign` / `verify` are called with `prehash: false`\n * 2. k generation in `sign`, using HMAC-drbg(hash)\n *\n * ECDSAOpts are only rarely needed.\n *\n * @example\n * ```js\n * const p256_Point = weierstrass(...);\n * const p256_sha256 = ecdsa(p256_Point, sha256);\n * const p256_sha224 = ecdsa(p256_Point, sha224);\n * const p256_sha224_r = ecdsa(p256_Point, sha224, { randomBytes: (length) => { ... } });\n * ```\n */\nexport function ecdsa(\n  Point: WeierstrassPointCons<bigint>,\n  hash: CHash,\n  ecdsaOpts: ECDSAOpts = {}\n): ECDSA {\n  ahash(hash);\n  _validateObject(\n    ecdsaOpts,\n    {},\n    {\n      hmac: 'function',\n      lowS: 'boolean',\n      randomBytes: 'function',\n      bits2int: 'function',\n      bits2int_modN: 'function',\n    }\n  );\n\n  const randomBytes = ecdsaOpts.randomBytes || randomBytesWeb;\n  const hmac: HmacFnSync =\n    ecdsaOpts.hmac ||\n    (((key, ...msgs) => nobleHmac(hash, key, concatBytes(...msgs))) satisfies HmacFnSync);\n\n  const { Fp, Fn } = Point;\n  const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;\n  const { keygen, getPublicKey, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);\n  const defaultSigOpts: Required<ECDSASignOpts> = {\n    prehash: false,\n    lowS: typeof ecdsaOpts.lowS === 'boolean' ? ecdsaOpts.lowS : false,\n    format: undefined as any, //'compact' as ECDSASigFormat,\n    extraEntropy: false,\n  };\n  const defaultSigOpts_format = 'compact';\n\n  function isBiggerThanHalfOrder(number: bigint) {\n    const HALF = CURVE_ORDER >> _1n;\n    return number > HALF;\n  }\n  function validateRS(title: string, num: bigint): bigint {\n    if (!Fn.isValidNot0(num))\n      throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);\n    return num;\n  }\n  function validateSigLength(bytes: Uint8Array, format: ECDSASigFormat) {\n    validateSigFormat(format);\n    const size = lengths.signature!;\n    const sizer = format === 'compact' ? size : format === 'recovered' ? size + 1 : undefined;\n    return abytes(bytes, sizer, `${format} signature`);\n  }\n\n  /**\n   * ECDSA signature with its (r, s) properties. Supports compact, recovered & DER representations.\n   */\n  class Signature implements ECDSASignature {\n    readonly r: bigint;\n    readonly s: bigint;\n    readonly recovery?: number;\n    constructor(r: bigint, s: bigint, recovery?: number) {\n      this.r = validateRS('r', r); // r in [1..N-1];\n      this.s = validateRS('s', s); // s in [1..N-1];\n      if (recovery != null) this.recovery = recovery;\n      Object.freeze(this);\n    }\n\n    static fromBytes(bytes: Uint8Array, format: ECDSASigFormat = defaultSigOpts_format): Signature {\n      validateSigLength(bytes, format);\n      let recid: number | undefined;\n      if (format === 'der') {\n        const { r, s } = DER.toSig(abytes(bytes));\n        return new Signature(r, s);\n      }\n      if (format === 'recovered') {\n        recid = bytes[0];\n        format = 'compact';\n        bytes = bytes.subarray(1);\n      }\n      const L = Fn.BYTES;\n      const r = bytes.subarray(0, L);\n      const s = bytes.subarray(L, L * 2);\n      return new Signature(Fn.fromBytes(r), Fn.fromBytes(s), recid);\n    }\n\n    static fromHex(hex: string, format?: ECDSASigFormat) {\n      return this.fromBytes(hexToBytes(hex), format);\n    }\n\n    addRecoveryBit(recovery: number): RecoveredSignature {\n      return new Signature(this.r, this.s, recovery) as RecoveredSignature;\n    }\n\n    recoverPublicKey(messageHash: Hex): WeierstrassPoint<bigint> {\n      const FIELD_ORDER = Fp.ORDER;\n      const { r, s, recovery: rec } = this;\n      if (rec == null || ![0, 1, 2, 3].includes(rec)) throw new Error('recovery id invalid');\n\n      // ECDSA recovery is hard for cofactor > 1 curves.\n      // In sign, `r = q.x mod n`, and here we recover q.x from r.\n      // While recovering q.x >= n, we need to add r+n for cofactor=1 curves.\n      // However, for cofactor>1, r+n may not get q.x:\n      // r+n*i would need to be done instead where i is unknown.\n      // To easily get i, we either need to:\n      // a. increase amount of valid recid values (4, 5...); OR\n      // b. prohibit non-prime-order signatures (recid > 1).\n      const hasCofactor = CURVE_ORDER * _2n < FIELD_ORDER;\n      if (hasCofactor && rec > 1) throw new Error('recovery id is ambiguous for h>1 curve');\n\n      const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;\n      if (!Fp.isValid(radj)) throw new Error('recovery id 2 or 3 invalid');\n      const x = Fp.toBytes(radj);\n      const R = Point.fromBytes(concatBytes(pprefix((rec & 1) === 0), x));\n      const ir = Fn.inv(radj); // r^-1\n      const h = bits2int_modN(ensureBytes('msgHash', messageHash)); // Truncate hash\n      const u1 = Fn.create(-h * ir); // -hr^-1\n      const u2 = Fn.create(s * ir); // sr^-1\n      // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1). unsafe is fine: there is no private data.\n      const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));\n      if (Q.is0()) throw new Error('point at infinify');\n      Q.assertValidity();\n      return Q;\n    }\n\n    // Signatures should be low-s, to prevent malleability.\n    hasHighS(): boolean {\n      return isBiggerThanHalfOrder(this.s);\n    }\n\n    toBytes(format: ECDSASigFormat = defaultSigOpts_format) {\n      validateSigFormat(format);\n      if (format === 'der') return hexToBytes(DER.hexFromSig(this));\n      const r = Fn.toBytes(this.r);\n      const s = Fn.toBytes(this.s);\n      if (format === 'recovered') {\n        if (this.recovery == null) throw new Error('recovery bit must be present');\n        return concatBytes(Uint8Array.of(this.recovery), r, s);\n      }\n      return concatBytes(r, s);\n    }\n\n    toHex(format?: ECDSASigFormat) {\n      return bytesToHex(this.toBytes(format));\n    }\n\n    // TODO: remove\n    assertValidity(): void {}\n    static fromCompact(hex: Hex) {\n      return Signature.fromBytes(ensureBytes('sig', hex), 'compact');\n    }\n    static fromDER(hex: Hex) {\n      return Signature.fromBytes(ensureBytes('sig', hex), 'der');\n    }\n    normalizeS() {\n      return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;\n    }\n    toDERRawBytes() {\n      return this.toBytes('der');\n    }\n    toDERHex() {\n      return bytesToHex(this.toBytes('der'));\n    }\n    toCompactRawBytes() {\n      return this.toBytes('compact');\n    }\n    toCompactHex() {\n      return bytesToHex(this.toBytes('compact'));\n    }\n  }\n  type RecoveredSignature = Signature & { recovery: number };\n\n  // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n  // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n  // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n  // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n  const bits2int =\n    ecdsaOpts.bits2int ||\n    function bits2int_def(bytes: Uint8Array): bigint {\n      // Our custom check \"just in case\", for protection against DoS\n      if (bytes.length > 8192) throw new Error('input is too large');\n      // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n      // for some cases, since bytes.length * 8 is not actual bitLength.\n      const num = bytesToNumberBE(bytes); // check for == u8 done here\n      const delta = bytes.length * 8 - fnBits; // truncate to nBitLength leftmost bits\n      return delta > 0 ? num >> BigInt(delta) : num;\n    };\n  const bits2int_modN =\n    ecdsaOpts.bits2int_modN ||\n    function bits2int_modN_def(bytes: Uint8Array): bigint {\n      return Fn.create(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n  // Pads output with zero as per spec\n  const ORDER_MASK = bitMask(fnBits);\n  /** Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`. */\n  function int2octets(num: bigint): Uint8Array {\n    // IMPORTANT: the check ensures working for case `Fn.BYTES != Fn.BITS * 8`\n    aInRange('num < 2^' + fnBits, num, _0n, ORDER_MASK);\n    return Fn.toBytes(num);\n  }\n\n  function validateMsgAndHash(message: Uint8Array, prehash: boolean) {\n    abytes(message, undefined, 'message');\n    return prehash ? abytes(hash(message), undefined, 'prehashed message') : message;\n  }\n\n  /**\n   * Steps A, D of RFC6979 3.2.\n   * Creates RFC6979 seed; converts msg/privKey to numbers.\n   * Used only in sign, not in verify.\n   *\n   * Warning: we cannot assume here that message has same amount of bytes as curve order,\n   * this will be invalid at least for P521. Also it can be bigger for P224 + SHA256.\n   */\n  function prepSig(message: Uint8Array, privateKey: PrivKey, opts: ECDSASignOpts) {\n    if (['recovered', 'canonical'].some((k) => k in opts))\n      throw new Error('sign() legacy options not supported');\n    const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);\n    message = validateMsgAndHash(message, prehash); // RFC6979 3.2 A: h1 = H(m)\n    // We can't later call bits2octets, since nested bits2int is broken for curves\n    // with fnBits % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n    // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n    const h1int = bits2int_modN(message);\n    const d = _normFnElement(Fn, privateKey); // validate secret key, convert to bigint\n    const seedArgs = [int2octets(d), int2octets(h1int)];\n    // extraEntropy. RFC6979 3.6: additional k' (optional).\n    if (extraEntropy != null && extraEntropy !== false) {\n      // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n      // gen random bytes OR pass as-is\n      const e = extraEntropy === true ? randomBytes(lengths.secretKey) : extraEntropy;\n      seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes\n    }\n    const seed = concatBytes(...seedArgs); // Step D of RFC6979 3.2\n    const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n    // Converts signature params into point w r/s, checks result for validity.\n    // To transform k => Signature:\n    // q = kG\n    // r = q.x mod n\n    // s = k^-1(m + rd) mod n\n    // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to\n    // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n    // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n    function k2sig(kBytes: Uint8Array): RecoveredSignature | undefined {\n      // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n      // Important: all mod() calls here must be done over N\n      const k = bits2int(kBytes); // mod n, not mod p\n      if (!Fn.isValidNot0(k)) return; // Valid scalars (including k) must be in 1..N-1\n      const ik = Fn.inv(k); // k^-1 mod n\n      const q = Point.BASE.multiply(k).toAffine(); // q = kG\n      const r = Fn.create(q.x); // r = q.x mod n\n      if (r === _0n) return;\n      const s = Fn.create(ik * Fn.create(m + r * d)); // Not using blinding here, see comment above\n      if (s === _0n) return;\n      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n      let normS = s;\n      if (lowS && isBiggerThanHalfOrder(s)) {\n        normS = Fn.neg(s); // if lowS was passed, ensure s is always\n        recovery ^= 1; // // in the bottom half of N\n      }\n      return new Signature(r, normS, recovery) as RecoveredSignature; // use normS, not s\n    }\n    return { seed, k2sig };\n  }\n\n  /**\n   * Signs message hash with a secret key.\n   *\n   * ```\n   * sign(m, d) where\n   *   k = rfc6979_hmac_drbg(m, d)\n   *   (x, y) = G  k\n   *   r = x mod n\n   *   s = (m + dr) / k mod n\n   * ```\n   */\n  function sign(message: Hex, secretKey: PrivKey, opts: ECDSASignOpts = {}): RecoveredSignature {\n    message = ensureBytes('message', message);\n    const { seed, k2sig } = prepSig(message, secretKey, opts); // Steps A, D of RFC6979 3.2.\n    const drbg = createHmacDrbg<RecoveredSignature>(hash.outputLen, Fn.BYTES, hmac);\n    const sig = drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    return sig;\n  }\n\n  function tryParsingSig(sg: Hex | SignatureLike) {\n    // Try to deduce format\n    let sig: Signature | undefined = undefined;\n    const isHex = typeof sg === 'string' || isBytes(sg);\n    const isObj =\n      !isHex &&\n      sg !== null &&\n      typeof sg === 'object' &&\n      typeof sg.r === 'bigint' &&\n      typeof sg.s === 'bigint';\n    if (!isHex && !isObj)\n      throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');\n    if (isObj) {\n      sig = new Signature(sg.r, sg.s);\n    } else if (isHex) {\n      try {\n        sig = Signature.fromBytes(ensureBytes('sig', sg), 'der');\n      } catch (derError) {\n        if (!(derError instanceof DER.Err)) throw derError;\n      }\n      if (!sig) {\n        try {\n          sig = Signature.fromBytes(ensureBytes('sig', sg), 'compact');\n        } catch (error) {\n          return false;\n        }\n      }\n    }\n    if (!sig) return false;\n    return sig;\n  }\n\n  /**\n   * Verifies a signature against message and public key.\n   * Rejects lowS signatures by default: see {@link ECDSAVerifyOpts}.\n   * Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n   *\n   * ```\n   * verify(r, s, h, P) where\n   *   u1 = hs^-1 mod n\n   *   u2 = rs^-1 mod n\n   *   R = u1G + u2P\n   *   mod(R.x, n) == r\n   * ```\n   */\n  function verify(\n    signature: Hex | SignatureLike,\n    message: Hex,\n    publicKey: Hex,\n    opts: ECDSAVerifyOpts = {}\n  ): boolean {\n    const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);\n    publicKey = ensureBytes('publicKey', publicKey);\n    message = validateMsgAndHash(ensureBytes('message', message), prehash);\n    if ('strict' in opts) throw new Error('options.strict was renamed to lowS');\n    const sig =\n      format === undefined\n        ? tryParsingSig(signature)\n        : Signature.fromBytes(ensureBytes('sig', signature as Hex), format);\n    if (sig === false) return false;\n    try {\n      const P = Point.fromBytes(publicKey);\n      if (lowS && sig.hasHighS()) return false;\n      const { r, s } = sig;\n      const h = bits2int_modN(message); // mod n, not mod p\n      const is = Fn.inv(s); // s^-1 mod n\n      const u1 = Fn.create(h * is); // u1 = hs^-1 mod n\n      const u2 = Fn.create(r * is); // u2 = rs^-1 mod n\n      const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2)); // u1G + u2P\n      if (R.is0()) return false;\n      const v = Fn.create(R.x); // v = r.x mod n\n      return v === r;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  function recoverPublicKey(\n    signature: Uint8Array,\n    message: Uint8Array,\n    opts: ECDSARecoverOpts = {}\n  ): Uint8Array {\n    const { prehash } = validateSigOpts(opts, defaultSigOpts);\n    message = validateMsgAndHash(message, prehash);\n    return Signature.fromBytes(signature, 'recovered').recoverPublicKey(message).toBytes();\n  }\n\n  return Object.freeze({\n    keygen,\n    getPublicKey,\n    getSharedSecret,\n    utils,\n    lengths,\n    Point,\n    sign,\n    verify,\n    recoverPublicKey,\n    Signature,\n    hash,\n  });\n}\n\n// TODO: remove everything below\n/** @deprecated use ECDSASignature */\nexport type SignatureType = ECDSASignature;\n/** @deprecated use ECDSASigRecovered */\nexport type RecoveredSignatureType = ECDSASigRecovered;\n/** @deprecated switch to Uint8Array signatures in format 'compact' */\nexport type SignatureLike = { r: bigint; s: bigint };\nexport type ECDSAExtraEntropy = Hex | boolean;\n/** @deprecated use `ECDSAExtraEntropy` */\nexport type Entropy = Hex | boolean;\nexport type BasicWCurve<T> = BasicCurve<T> & {\n  // Params: a, b\n  a: T;\n  b: T;\n\n  // Optional params\n  allowedPrivateKeyLengths?: readonly number[]; // for P521\n  wrapPrivateKey?: boolean; // bls12-381 requires mod(n) instead of rejecting keys >= n\n  endo?: EndomorphismOpts;\n  // When a cofactor != 1, there can be an effective methods to:\n  // 1. Determine whether a point is torsion-free\n  isTorsionFree?: (c: WeierstrassPointCons<T>, point: WeierstrassPoint<T>) => boolean;\n  // 2. Clear torsion component\n  clearCofactor?: (c: WeierstrassPointCons<T>, point: WeierstrassPoint<T>) => WeierstrassPoint<T>;\n};\n/** @deprecated use ECDSASignOpts */\nexport type SignOpts = ECDSASignOpts;\n/** @deprecated use ECDSASignOpts */\nexport type VerOpts = ECDSAVerifyOpts;\n\n/** @deprecated use WeierstrassPoint */\nexport type ProjPointType<T> = WeierstrassPoint<T>;\n/** @deprecated use WeierstrassPointCons */\nexport type ProjConstructor<T> = WeierstrassPointCons<T>;\n/** @deprecated use ECDSASignatureCons */\nexport type SignatureConstructor = ECDSASignatureCons;\n\n// TODO: remove\nexport type CurvePointsType<T> = BasicWCurve<T> & {\n  fromBytes?: (bytes: Uint8Array) => AffinePoint<T>;\n  toBytes?: (\n    c: WeierstrassPointCons<T>,\n    point: WeierstrassPoint<T>,\n    isCompressed: boolean\n  ) => Uint8Array;\n};\n\n// LegacyWeierstrassOpts\nexport type CurvePointsTypeWithLength<T> = Readonly<CurvePointsType<T> & Partial<NLength>>;\n\n// LegacyWeierstrass\nexport type CurvePointsRes<T> = {\n  Point: WeierstrassPointCons<T>;\n\n  /** @deprecated use `Point.CURVE()` */\n  CURVE: CurvePointsType<T>;\n  /** @deprecated use `Point` */\n  ProjectivePoint: WeierstrassPointCons<T>;\n  /** @deprecated use `Point.Fn.fromBytes(privateKey)` */\n  normPrivateKeyToScalar: (key: PrivKey) => bigint;\n  /** @deprecated */\n  weierstrassEquation: (x: T) => T;\n  /** @deprecated use `Point.Fn.isValidNot0(num)` */\n  isWithinCurveOrder: (num: bigint) => boolean;\n};\n\n// Aliases to legacy types\n// export type CurveType = LegacyECDSAOpts;\n// export type CurveFn = LegacyECDSA;\n// export type CurvePointsRes<T> = LegacyWeierstrass<T>;\n// export type CurvePointsType<T> = LegacyWeierstrassOpts<T>;\n// export type CurvePointsTypeWithLength<T> = LegacyWeierstrassOpts<T>;\n// export type BasicWCurve<T> = LegacyWeierstrassOpts<T>;\n\n/** @deprecated use `Uint8Array` */\nexport type PubKey = Hex | WeierstrassPoint<bigint>;\nexport type CurveType = BasicWCurve<bigint> & {\n  hash: CHash; // CHash not FHash because we need outputLen for DRBG\n  hmac?: HmacFnSync;\n  randomBytes?: (bytesLength?: number) => Uint8Array;\n  lowS?: boolean;\n  bits2int?: (bytes: Uint8Array) => bigint;\n  bits2int_modN?: (bytes: Uint8Array) => bigint;\n};\nexport type CurveFn = {\n  /** @deprecated use `Point.CURVE()` */\n  CURVE: CurvePointsType<bigint>;\n  keygen: ECDSA['keygen'];\n  getPublicKey: ECDSA['getPublicKey'];\n  getSharedSecret: ECDSA['getSharedSecret'];\n  sign: ECDSA['sign'];\n  verify: ECDSA['verify'];\n  Point: WeierstrassPointCons<bigint>;\n  /** @deprecated use `Point` */\n  ProjectivePoint: WeierstrassPointCons<bigint>;\n  Signature: ECDSASignatureCons;\n  utils: ECDSA['utils'];\n  lengths: ECDSA['lengths'];\n};\n/** @deprecated use `weierstrass` in newer releases */\nexport function weierstrassPoints<T>(c: CurvePointsTypeWithLength<T>): CurvePointsRes<T> {\n  const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);\n  const Point = weierstrassN(CURVE, curveOpts);\n  return _weierstrass_new_output_to_legacy(c, Point);\n}\nexport type WsPointComposed<T> = {\n  CURVE: WeierstrassOpts<T>;\n  curveOpts: WeierstrassExtraOpts<T>;\n};\nexport type WsComposed = {\n  /** @deprecated use `Point.CURVE()` */\n  CURVE: WeierstrassOpts<bigint>;\n  hash: CHash;\n  curveOpts: WeierstrassExtraOpts<bigint>;\n  ecdsaOpts: ECDSAOpts;\n};\nfunction _weierstrass_legacy_opts_to_new<T>(c: CurvePointsType<T>): WsPointComposed<T> {\n  const CURVE: WeierstrassOpts<T> = {\n    a: c.a,\n    b: c.b,\n    p: c.Fp.ORDER,\n    n: c.n,\n    h: c.h,\n    Gx: c.Gx,\n    Gy: c.Gy,\n  };\n  const Fp = c.Fp;\n  let allowedLengths = c.allowedPrivateKeyLengths\n    ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l) => Math.ceil(l / 2))))\n    : undefined;\n  const Fn = Field(CURVE.n, {\n    BITS: c.nBitLength,\n    allowedLengths: allowedLengths,\n    modFromBytes: c.wrapPrivateKey,\n  });\n  const curveOpts: WeierstrassExtraOpts<T> = {\n    Fp,\n    Fn,\n    allowInfinityPoint: c.allowInfinityPoint,\n    endo: c.endo,\n    isTorsionFree: c.isTorsionFree,\n    clearCofactor: c.clearCofactor,\n    fromBytes: c.fromBytes,\n    toBytes: c.toBytes,\n  };\n  return { CURVE, curveOpts };\n}\nfunction _ecdsa_legacy_opts_to_new(c: CurveType): WsComposed {\n  const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);\n  const ecdsaOpts: ECDSAOpts = {\n    hmac: c.hmac,\n    randomBytes: c.randomBytes,\n    lowS: c.lowS,\n    bits2int: c.bits2int,\n    bits2int_modN: c.bits2int_modN,\n  };\n  return { CURVE, curveOpts, hash: c.hash, ecdsaOpts };\n}\nexport function _legacyHelperEquat<T>(Fp: IField<T>, a: T, b: T): (x: T) => T {\n  /**\n   * y = x + ax + b: Short weierstrass curve formula. Takes x, returns y.\n   * @returns y\n   */\n  function weierstrassEquation(x: T): T {\n    const x2 = Fp.sqr(x); // x * x\n    const x3 = Fp.mul(x2, x); // x * x\n    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x + a * x + b\n  }\n  return weierstrassEquation;\n}\nfunction _weierstrass_new_output_to_legacy<T>(\n  c: CurvePointsType<T>,\n  Point: WeierstrassPointCons<T>\n): CurvePointsRes<T> {\n  const { Fp, Fn } = Point;\n  function isWithinCurveOrder(num: bigint): boolean {\n    return inRange(num, _1n, Fn.ORDER);\n  }\n  const weierstrassEquation = _legacyHelperEquat(Fp, c.a, c.b);\n  return Object.assign(\n    {},\n    {\n      CURVE: c,\n      Point: Point,\n      ProjectivePoint: Point,\n      normPrivateKeyToScalar: (key: PrivKey) => _normFnElement(Fn, key),\n      weierstrassEquation,\n      isWithinCurveOrder,\n    }\n  );\n}\nfunction _ecdsa_new_output_to_legacy(c: CurveType, _ecdsa: ECDSA): CurveFn {\n  const Point = _ecdsa.Point;\n  return Object.assign({}, _ecdsa, {\n    ProjectivePoint: Point,\n    CURVE: Object.assign({}, c, nLength(Point.Fn.ORDER, Point.Fn.BITS)),\n  });\n}\n\n// _ecdsa_legacy\nexport function weierstrass(c: CurveType): CurveFn {\n  const { CURVE, curveOpts, hash, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);\n  const Point = weierstrassN(CURVE, curveOpts);\n  const signs = ecdsa(Point, hash, ecdsaOpts);\n  return _ecdsa_new_output_to_legacy(c, signs);\n}\n", "/**\n * Utilities for short weierstrass curves, combined with noble-hashes.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { type CurveFn, type CurveType, weierstrass } from './abstract/weierstrass.ts';\nimport type { CHash } from './utils.ts';\n\n/** connects noble-curves to noble-hashes */\nexport function getHash(hash: CHash): { hash: CHash } {\n  return { hash };\n}\n/** Same API as @noble/hashes, with ability to create curve with custom hash */\nexport type CurveDef = Readonly<Omit<CurveType, 'hash'>>;\nexport type CurveFnWithCreate = CurveFn & { create: (hash: CHash) => CurveFn };\n\n/** @deprecated use new `weierstrass()` and `ecdsa()` methods */\nexport function createCurve(curveDef: CurveDef, defHash: CHash): CurveFnWithCreate {\n  const create = (hash: CHash): CurveFn => weierstrass({ ...curveDef, hash: hash });\n  return { ...create(defHash), create };\n}\n", "/**\n * hash-to-curve from RFC 9380.\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * https://www.rfc-editor.org/rfc/rfc9380\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport type { CHash } from '../utils.ts';\nimport {\n  _validateObject,\n  abytes,\n  bytesToNumberBE,\n  concatBytes,\n  isBytes,\n  isHash,\n  utf8ToBytes,\n} from '../utils.ts';\nimport type { AffinePoint, Group, GroupConstructor } from './curve.ts';\nimport { FpInvertBatch, mod, type IField } from './modular.ts';\n\nexport type UnicodeOrBytes = string | Uint8Array;\n\n/**\n * * `DST` is a domain separation tag, defined in section 2.2.5\n * * `p` characteristic of F, where F is a finite field of characteristic p and order q = p^m\n * * `m` is extension degree (1 for prime fields)\n * * `k` is the target security target in bits (e.g. 128), from section 5.1\n * * `expand` is `xmd` (SHA2, SHA3, BLAKE) or `xof` (SHAKE, BLAKE-XOF)\n * * `hash` conforming to `utils.CHash` interface, with `outputLen` / `blockLen` props\n */\nexport type H2COpts = {\n  DST: UnicodeOrBytes;\n  expand: 'xmd' | 'xof';\n  hash: CHash;\n  p: bigint;\n  m: number;\n  k: number;\n};\nexport type H2CHashOpts = {\n  expand: 'xmd' | 'xof';\n  hash: CHash;\n};\n// todo: remove\nexport type Opts = H2COpts;\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = bytesToNumberBE;\n\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value: number, length: number): Uint8Array {\n  anum(value);\n  anum(length);\n  if (value < 0 || value >= 1 << (8 * length)) throw new Error('invalid I2OSP input: ' + value);\n  const res = Array.from({ length }).fill(0) as number[];\n  for (let i = length - 1; i >= 0; i--) {\n    res[i] = value & 0xff;\n    value >>>= 8;\n  }\n  return new Uint8Array(res);\n}\n\nfunction strxor(a: Uint8Array, b: Uint8Array): Uint8Array {\n  const arr = new Uint8Array(a.length);\n  for (let i = 0; i < a.length; i++) {\n    arr[i] = a[i] ^ b[i];\n  }\n  return arr;\n}\n\nfunction anum(item: unknown): void {\n  if (!Number.isSafeInteger(item)) throw new Error('number expected');\n}\n\nfunction normDST(DST: UnicodeOrBytes): Uint8Array {\n  if (!isBytes(DST) && typeof DST !== 'string') throw new Error('DST must be Uint8Array or string');\n  return typeof DST === 'string' ? utf8ToBytes(DST) : DST;\n}\n\n/**\n * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.\n * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).\n */\nexport function expand_message_xmd(\n  msg: Uint8Array,\n  DST: UnicodeOrBytes,\n  lenInBytes: number,\n  H: CHash\n): Uint8Array {\n  abytes(msg);\n  anum(lenInBytes);\n  DST = normDST(DST);\n  // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n  if (DST.length > 255) DST = H(concatBytes(utf8ToBytes('H2C-OVERSIZE-DST-'), DST));\n  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n  const ell = Math.ceil(lenInBytes / b_in_bytes);\n  if (lenInBytes > 65535 || ell > 255) throw new Error('expand_message_xmd: invalid lenInBytes');\n  const DST_prime = concatBytes(DST, i2osp(DST.length, 1));\n  const Z_pad = i2osp(0, r_in_bytes);\n  const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n  const b = new Array<Uint8Array>(ell);\n  const b_0 = H(concatBytes(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n  b[0] = H(concatBytes(b_0, i2osp(1, 1), DST_prime));\n  for (let i = 1; i <= ell; i++) {\n    const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n    b[i] = H(concatBytes(...args));\n  }\n  const pseudo_random_bytes = concatBytes(...b);\n  return pseudo_random_bytes.slice(0, lenInBytes);\n}\n\n/**\n * Produces a uniformly random byte string using an extendable-output function (XOF) H.\n * 1. The collision resistance of H MUST be at least k bits.\n * 2. H MUST be an XOF that has been proved indifferentiable from\n *    a random oracle under a reasonable cryptographic assumption.\n * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).\n */\nexport function expand_message_xof(\n  msg: Uint8Array,\n  DST: UnicodeOrBytes,\n  lenInBytes: number,\n  k: number,\n  H: CHash\n): Uint8Array {\n  abytes(msg);\n  anum(lenInBytes);\n  DST = normDST(DST);\n  // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n  // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n  if (DST.length > 255) {\n    const dkLen = Math.ceil((2 * k) / 8);\n    DST = H.create({ dkLen }).update(utf8ToBytes('H2C-OVERSIZE-DST-')).update(DST).digest();\n  }\n  if (lenInBytes > 65535 || DST.length > 255)\n    throw new Error('expand_message_xof: invalid lenInBytes');\n  return (\n    H.create({ dkLen: lenInBytes })\n      .update(msg)\n      .update(i2osp(lenInBytes, 2))\n      // 2. DST_prime = DST || I2OSP(len(DST), 1)\n      .update(DST)\n      .update(i2osp(DST.length, 1))\n      .digest()\n  );\n}\n\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nexport function hash_to_field(msg: Uint8Array, count: number, options: H2COpts): bigint[][] {\n  _validateObject(options, {\n    p: 'bigint',\n    m: 'number',\n    k: 'number',\n    hash: 'function',\n  });\n  const { p, k, m, hash, expand, DST } = options;\n  if (!isHash(options.hash)) throw new Error('expected valid hash');\n  abytes(msg);\n  anum(count);\n  const log2p = p.toString(2).length;\n  const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n  const len_in_bytes = count * m * L;\n  let prb; // pseudo_random_bytes\n  if (expand === 'xmd') {\n    prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n  } else if (expand === 'xof') {\n    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n  } else if (expand === '_internal_pass') {\n    // for internal tests only\n    prb = msg;\n  } else {\n    throw new Error('expand must be \"xmd\" or \"xof\"');\n  }\n  const u = new Array(count);\n  for (let i = 0; i < count; i++) {\n    const e = new Array(m);\n    for (let j = 0; j < m; j++) {\n      const elm_offset = L * (j + i * m);\n      const tv = prb.subarray(elm_offset, elm_offset + L);\n      e[j] = mod(os2ip(tv), p);\n    }\n    u[i] = e;\n  }\n  return u;\n}\n\nexport type XY<T> = (x: T, y: T) => { x: T; y: T };\nexport type XYRatio<T> = [T[], T[], T[], T[]]; // xn/xd, yn/yd\nexport function isogenyMap<T, F extends IField<T>>(field: F, map: XYRatio<T>): XY<T> {\n  // Make same order as in spec\n  const coeff = map.map((i) => Array.from(i).reverse());\n  return (x: T, y: T) => {\n    const [xn, xd, yn, yd] = coeff.map((val) =>\n      val.reduce((acc, i) => field.add(field.mul(acc, x), i))\n    );\n    // 6.6.3\n    // Exceptional cases of iso_map are inputs that cause the denominator of\n    // either rational function to evaluate to zero; such cases MUST return\n    // the identity point on E.\n    const [xd_inv, yd_inv] = FpInvertBatch(field, [xd, yd], true);\n    x = field.mul(xn, xd_inv); // xNum / xDen\n    y = field.mul(y, field.mul(yn, yd_inv)); // y * (yNum / yDev)\n    return { x, y };\n  };\n}\n\n/** Point interface, which curves must implement to work correctly with the module. */\nexport interface H2CPoint<T> extends Group<H2CPoint<T>> {\n  add(rhs: H2CPoint<T>): H2CPoint<T>;\n  toAffine(iz?: bigint): AffinePoint<T>;\n  clearCofactor(): H2CPoint<T>;\n  assertValidity(): void;\n}\n\nexport interface H2CPointConstructor<T> extends GroupConstructor<H2CPoint<T>> {\n  fromAffine(ap: AffinePoint<T>): H2CPoint<T>;\n}\n\nexport type MapToCurve<T> = (scalar: bigint[]) => AffinePoint<T>;\n\n// Separated from initialization opts, so users won't accidentally change per-curve parameters\n// (changing DST is ok!)\nexport type htfBasicOpts = { DST: UnicodeOrBytes };\nexport type H2CMethod<T> = (msg: Uint8Array, options?: htfBasicOpts) => H2CPoint<T>;\n// TODO: remove\nexport type HTFMethod<T> = H2CMethod<T>;\nexport type MapMethod<T> = (scalars: bigint[]) => H2CPoint<T>;\nexport type H2CHasherBase<T> = {\n  hashToCurve: H2CMethod<T>;\n  hashToScalar: (msg: Uint8Array, options: htfBasicOpts) => bigint;\n};\n/**\n * RFC 9380 methods, with cofactor clearing. See https://www.rfc-editor.org/rfc/rfc9380#section-3.\n *\n * * hashToCurve: `map(hash(input))`, encodes RANDOM bytes to curve (WITH hashing)\n * * encodeToCurve: `map(hash(input))`, encodes NON-UNIFORM bytes to curve (WITH hashing)\n * * mapToCurve: `map(scalars)`, encodes NON-UNIFORM scalars to curve (NO hashing)\n */\nexport type H2CHasher<T> = H2CHasherBase<T> & {\n  encodeToCurve: H2CMethod<T>;\n  mapToCurve: MapMethod<T>;\n  defaults: H2COpts & { encodeDST?: UnicodeOrBytes };\n};\n// TODO: remove\nexport type Hasher<T> = H2CHasher<T>;\n\nexport const _DST_scalar: Uint8Array = utf8ToBytes('HashToScalar-');\n\n/** Creates hash-to-curve methods from EC Point and mapToCurve function. See {@link H2CHasher}. */\nexport function createHasher<T>(\n  Point: H2CPointConstructor<T>,\n  mapToCurve: MapToCurve<T>,\n  defaults: H2COpts & { encodeDST?: UnicodeOrBytes }\n): H2CHasher<T> {\n  if (typeof mapToCurve !== 'function') throw new Error('mapToCurve() must be defined');\n  function map(num: bigint[]) {\n    return Point.fromAffine(mapToCurve(num));\n  }\n  function clear(initial: H2CPoint<T>) {\n    const P = initial.clearCofactor();\n    if (P.equals(Point.ZERO)) return Point.ZERO; // zero will throw in assert\n    P.assertValidity();\n    return P;\n  }\n\n  return {\n    defaults,\n\n    hashToCurve(msg: Uint8Array, options?: htfBasicOpts): H2CPoint<T> {\n      const opts = Object.assign({}, defaults, options);\n      const u = hash_to_field(msg, 2, opts);\n      const u0 = map(u[0]);\n      const u1 = map(u[1]);\n      return clear(u0.add(u1));\n    },\n    encodeToCurve(msg: Uint8Array, options?: htfBasicOpts): H2CPoint<T> {\n      const optsDst = defaults.encodeDST ? { DST: defaults.encodeDST } : {};\n      const opts = Object.assign({}, defaults, optsDst, options);\n      const u = hash_to_field(msg, 1, opts);\n      const u0 = map(u[0]);\n      return clear(u0);\n    },\n    /** See {@link H2CHasher} */\n    mapToCurve(scalars: bigint[]): H2CPoint<T> {\n      if (!Array.isArray(scalars)) throw new Error('expected array of bigints');\n      for (const i of scalars)\n        if (typeof i !== 'bigint') throw new Error('expected array of bigints');\n      return clear(map(scalars));\n    },\n\n    // hash_to_scalar can produce 0: https://www.rfc-editor.org/errata/eid8393\n    // RFC 9380, draft-irtf-cfrg-bbs-signatures-08\n    hashToScalar(msg: Uint8Array, options?: htfBasicOpts): bigint {\n      // @ts-ignore\n      const N = Point.Fn.ORDER;\n      const opts = Object.assign({}, defaults, { p: N, m: 1, DST: _DST_scalar }, options);\n      return hash_to_field(msg, 1, opts)[0][0];\n    },\n  };\n}\n", "/**\n * SECG secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).\n *\n * Belongs to Koblitz curves: it has efficiently-computable GLV endomorphism ,\n * check out {@link EndomorphismOpts}. Seems to be rigid (not backdoored).\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport { randomBytes } from '@noble/hashes/utils.js';\nimport { createCurve, type CurveFnWithCreate } from './_shortw_utils.ts';\nimport type { CurveLengths } from './abstract/curve.ts';\nimport {\n  createHasher,\n  type H2CHasher,\n  type H2CMethod,\n  isogenyMap,\n} from './abstract/hash-to-curve.ts';\nimport { Field, mapHashToField, mod, pow2 } from './abstract/modular.ts';\nimport {\n  _normFnElement,\n  type EndomorphismOpts,\n  mapToCurveSimpleSWU,\n  type WeierstrassPoint as PointType,\n  type WeierstrassOpts,\n  type WeierstrassPointCons,\n} from './abstract/weierstrass.ts';\nimport type { Hex, PrivKey } from './utils.ts';\nimport {\n  bytesToNumberBE,\n  concatBytes,\n  ensureBytes,\n  inRange,\n  numberToBytesBE,\n  utf8ToBytes,\n} from './utils.ts';\n\n// Seems like generator was produced from some seed:\n// `Point.BASE.multiply(Point.Fn.inv(2n, N)).toAffine().x`\n// // gives short x 0x3b78ce563f89a0ed9414f5aa28ad0d96d6795f9c63n\nconst secp256k1_CURVE: WeierstrassOpts<bigint> = {\n  p: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n  n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),\n  h: BigInt(1),\n  a: BigInt(0),\n  b: BigInt(7),\n  Gx: BigInt('0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),\n  Gy: BigInt('0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8'),\n};\n\nconst secp256k1_ENDO: EndomorphismOpts = {\n  beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n  basises: [\n    [BigInt('0x3086d221a7d46bcde86c90e49284eb15'), -BigInt('0xe4437ed6010e88286f547fa90abfe4c3')],\n    [BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'), BigInt('0x3086d221a7d46bcde86c90e49284eb15')],\n  ],\n};\n\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\n\n/**\n * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y: bigint): bigint {\n  const P = secp256k1_CURVE.p;\n  // prettier-ignore\n  const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n  // prettier-ignore\n  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n  const b2 = (y * y * y) % P; // x^3, 11\n  const b3 = (b2 * b2 * y) % P; // x^7\n  const b6 = (pow2(b3, _3n, P) * b3) % P;\n  const b9 = (pow2(b6, _3n, P) * b3) % P;\n  const b11 = (pow2(b9, _2n, P) * b2) % P;\n  const b22 = (pow2(b11, _11n, P) * b11) % P;\n  const b44 = (pow2(b22, _22n, P) * b22) % P;\n  const b88 = (pow2(b44, _44n, P) * b44) % P;\n  const b176 = (pow2(b88, _88n, P) * b88) % P;\n  const b220 = (pow2(b176, _44n, P) * b44) % P;\n  const b223 = (pow2(b220, _3n, P) * b3) % P;\n  const t1 = (pow2(b223, _23n, P) * b22) % P;\n  const t2 = (pow2(t1, _6n, P) * b2) % P;\n  const root = pow2(t2, _2n, P);\n  if (!Fpk1.eql(Fpk1.sqr(root), y)) throw new Error('Cannot find square root');\n  return root;\n}\n\nconst Fpk1 = Field(secp256k1_CURVE.p, { sqrt: sqrtMod });\n\n/**\n * secp256k1 curve, ECDSA and ECDH methods.\n *\n * Field: `2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n`\n *\n * @example\n * ```js\n * import { secp256k1 } from '@noble/curves/secp256k1';\n * const { secretKey, publicKey } = secp256k1.keygen();\n * const msg = new TextEncoder().encode('hello');\n * const sig = secp256k1.sign(msg, secretKey);\n * const isValid = secp256k1.verify(sig, msg, publicKey) === true;\n * ```\n */\nexport const secp256k1: CurveFnWithCreate = createCurve(\n  { ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO },\n  sha256\n);\n\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES: { [tag: string]: Uint8Array } = {};\nfunction taggedHash(tag: string, ...messages: Uint8Array[]): Uint8Array {\n  let tagP = TAGGED_HASH_PREFIXES[tag];\n  if (tagP === undefined) {\n    const tagH = sha256(utf8ToBytes(tag));\n    tagP = concatBytes(tagH, tagH);\n    TAGGED_HASH_PREFIXES[tag] = tagP;\n  }\n  return sha256(concatBytes(tagP, ...messages));\n}\n\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point: PointType<bigint>) => point.toBytes(true).slice(1);\nconst Pointk1 = /* @__PURE__ */ (() => secp256k1.Point)();\nconst hasEven = (y: bigint) => y % _2n === _0n;\n\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv: PrivKey) {\n  const { Fn, BASE } = Pointk1;\n  const d_ = _normFnElement(Fn, priv);\n  const p = BASE.multiply(d_); // P = d'G; 0 < d' < n check is done inside\n  const scalar = hasEven(p.y) ? d_ : Fn.neg(d_);\n  return { scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x: bigint): PointType<bigint> {\n  const Fp = Fpk1;\n  if (!Fp.isValidNot0(x)) throw new Error('invalid x: Fail if x  p');\n  const xx = Fp.create(x * x);\n  const c = Fp.create(xx * x + BigInt(7)); // Let c = x + 7 mod p.\n  let y = Fp.sqrt(c); // Let y = c^(p+1)/4 mod p. Same as sqrt().\n  // Return the unique point P such that x(P) = x and\n  // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n  if (!hasEven(y)) y = Fp.neg(y);\n  const p = Pointk1.fromAffine({ x, y });\n  p.assertValidity();\n  return p;\n}\nconst num = bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args: Uint8Array[]): bigint {\n  return Pointk1.Fn.create(num(taggedHash('BIP0340/challenge', ...args)));\n}\n\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(secretKey: Hex): Uint8Array {\n  return schnorrGetExtPubKey(secretKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)\n}\n\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message: Hex, secretKey: PrivKey, auxRand: Hex = randomBytes(32)): Uint8Array {\n  const { Fn } = Pointk1;\n  const m = ensureBytes('message', message);\n  const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey); // checks for isWithinCurveOrder\n  const a = ensureBytes('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n  const t = Fn.toBytes(d ^ num(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n  const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n  // Let k' = int(rand) mod n. Fail if k' = 0. Let R = k'G\n  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(rand);\n  const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n  const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n  sig.set(rx, 0);\n  sig.set(Fn.toBytes(Fn.create(k + e * d)), 32);\n  // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n  if (!schnorrVerify(sig, m, px)) throw new Error('sign: Invalid signature produced');\n  return sig;\n}\n\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature: Hex, message: Hex, publicKey: Hex): boolean {\n  const { Fn, BASE } = Pointk1;\n  const sig = ensureBytes('signature', signature, 64);\n  const m = ensureBytes('message', message);\n  const pub = ensureBytes('publicKey', publicKey, 32);\n  try {\n    const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n    const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.\n    if (!inRange(r, _1n, secp256k1_CURVE.p)) return false;\n    const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.\n    if (!inRange(s, _1n, secp256k1_CURVE.n)) return false;\n    // int(challenge(bytes(r)||bytes(P)||m))%n\n    const e = challenge(Fn.toBytes(r), pointToBytes(P), m);\n    // R = sG - eP, where -eP == (n-e)P\n    const R = BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(Fn.neg(e)));\n    const { x, y } = R.toAffine();\n    // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.\n    if (R.is0() || !hasEven(y) || x !== r) return false;\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n\nexport type SecpSchnorr = {\n  keygen: (seed?: Uint8Array) => { secretKey: Uint8Array; publicKey: Uint8Array };\n  getPublicKey: typeof schnorrGetPublicKey;\n  sign: typeof schnorrSign;\n  verify: typeof schnorrVerify;\n  Point: WeierstrassPointCons<bigint>;\n  utils: {\n    randomSecretKey: (seed?: Uint8Array) => Uint8Array;\n    pointToBytes: (point: PointType<bigint>) => Uint8Array;\n    lift_x: typeof lift_x;\n    taggedHash: typeof taggedHash;\n\n    /** @deprecated use `randomSecretKey` */\n    randomPrivateKey: (seed?: Uint8Array) => Uint8Array;\n    /** @deprecated use `utils` */\n    numberToBytesBE: typeof numberToBytesBE;\n    /** @deprecated use `utils` */\n    bytesToNumberBE: typeof bytesToNumberBE;\n    /** @deprecated use `modular` */\n    mod: typeof mod;\n  };\n  lengths: CurveLengths;\n};\n/**\n * Schnorr signatures over secp256k1.\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n * @example\n * ```js\n * import { schnorr } from '@noble/curves/secp256k1';\n * const { secretKey, publicKey } = schnorr.keygen();\n * // const publicKey = schnorr.getPublicKey(secretKey);\n * const msg = new TextEncoder().encode('hello');\n * const sig = schnorr.sign(msg, secretKey);\n * const isValid = schnorr.verify(sig, msg, publicKey);\n * ```\n */\nexport const schnorr: SecpSchnorr = /* @__PURE__ */ (() => {\n  const size = 32;\n  const seedLength = 48;\n  const randomSecretKey = (seed = randomBytes(seedLength)): Uint8Array => {\n    return mapHashToField(seed, secp256k1_CURVE.n);\n  };\n  // TODO: remove\n  secp256k1.utils.randomSecretKey;\n  function keygen(seed?: Uint8Array) {\n    const secretKey = randomSecretKey(seed);\n    return { secretKey, publicKey: schnorrGetPublicKey(secretKey) };\n  }\n  return {\n    keygen,\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    Point: Pointk1,\n    utils: {\n      randomSecretKey: randomSecretKey,\n      randomPrivateKey: randomSecretKey,\n      taggedHash,\n\n      // TODO: remove\n      lift_x,\n      pointToBytes,\n      numberToBytesBE,\n      bytesToNumberBE,\n      mod,\n    },\n    lengths: {\n      secretKey: size,\n      publicKey: size,\n      publicKeyHasPrefix: false,\n      signature: size * 2,\n      seed: seedLength,\n    },\n  };\n})();\n\nconst isoMap = /* @__PURE__ */ (() =>\n  isogenyMap(\n    Fpk1,\n    [\n      // xNum\n      [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n      ],\n      // xDen\n      [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n      ],\n      // yNum\n      [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n      ],\n      // yDen\n      [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n      ],\n    ].map((i) => i.map((j) => BigInt(j))) as [bigint[], bigint[], bigint[], bigint[]]\n  ))();\nconst mapSWU = /* @__PURE__ */ (() =>\n  mapToCurveSimpleSWU(Fpk1, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fpk1.create(BigInt('-11')),\n  }))();\n\n/** Hashing / encoding to secp256k1 points / field. RFC 9380 methods. */\nexport const secp256k1_hasher: H2CHasher<bigint> = /* @__PURE__ */ (() =>\n  createHasher(\n    secp256k1.Point,\n    (scalars: bigint[]) => {\n      const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n      return isoMap(x, y);\n    },\n    {\n      DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n      encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n      p: Fpk1.ORDER,\n      m: 1,\n      k: 128,\n      expand: 'xmd',\n      hash: sha256,\n    }\n  ))();\n\n/** @deprecated use `import { secp256k1_hasher } from '@noble/curves/secp256k1.js';` */\nexport const hashToCurve: H2CMethod<bigint> = /* @__PURE__ */ (() =>\n  secp256k1_hasher.hashToCurve)();\n\n/** @deprecated use `import { secp256k1_hasher } from '@noble/curves/secp256k1.js';` */\nexport const encodeToCurve: H2CMethod<bigint> = /* @__PURE__ */ (() =>\n  secp256k1_hasher.encodeToCurve)();\n", "/**\n\nSHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions.\nDon't use them in a new protocol. What \"weak\" means:\n\n- Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.\n- No practical pre-image attacks (only theoretical, 2^123.4)\n- HMAC seems kinda ok: https://datatracker.ietf.org/doc/html/rfc6151\n * @module\n */\nimport { Chi, HashMD, Maj } from './_md.ts';\nimport { type CHash, clean, createHasher, rotl } from './utils.ts';\n\n/** Initial SHA1 state */\nconst SHA1_IV = /* @__PURE__ */ Uint32Array.from([\n  0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0,\n]);\n\n// Reusable temporary buffer\nconst SHA1_W = /* @__PURE__ */ new Uint32Array(80);\n\n/** SHA1 legacy hash class. */\nexport class SHA1 extends HashMD<SHA1> {\n  private A = SHA1_IV[0] | 0;\n  private B = SHA1_IV[1] | 0;\n  private C = SHA1_IV[2] | 0;\n  private D = SHA1_IV[3] | 0;\n  private E = SHA1_IV[4] | 0;\n\n  constructor() {\n    super(64, 20, 8, false);\n  }\n  protected get(): [number, number, number, number, number] {\n    const { A, B, C, D, E } = this;\n    return [A, B, C, D, E];\n  }\n  protected set(A: number, B: number, C: number, D: number, E: number): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    for (let i = 0; i < 16; i++, offset += 4) SHA1_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 80; i++)\n      SHA1_W[i] = rotl(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);\n    // Compression function main loop, 80 rounds\n    let { A, B, C, D, E } = this;\n    for (let i = 0; i < 80; i++) {\n      let F, K;\n      if (i < 20) {\n        F = Chi(B, C, D);\n        K = 0x5a827999;\n      } else if (i < 40) {\n        F = B ^ C ^ D;\n        K = 0x6ed9eba1;\n      } else if (i < 60) {\n        F = Maj(B, C, D);\n        K = 0x8f1bbcdc;\n      } else {\n        F = B ^ C ^ D;\n        K = 0xca62c1d6;\n      }\n      const T = (rotl(A, 5) + F + E + K + SHA1_W[i]) | 0;\n      E = D;\n      D = C;\n      C = rotl(B, 30);\n      B = A;\n      A = T;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    this.set(A, B, C, D, E);\n  }\n  protected roundClean(): void {\n    clean(SHA1_W);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\n/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */\nexport const sha1: CHash = /* @__PURE__ */ createHasher(() => new SHA1());\n\n/** Per-round constants */\nconst p32 = /* @__PURE__ */ Math.pow(2, 32);\nconst K = /* @__PURE__ */ Array.from({ length: 64 }, (_, i) =>\n  Math.floor(p32 * Math.abs(Math.sin(i + 1)))\n);\n\n/** md5 initial state: same as sha1, but 4 u32 instead of 5. */\nconst MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);\n\n// Reusable temporary buffer\nconst MD5_W = /* @__PURE__ */ new Uint32Array(16);\n/** MD5 legacy hash class. */\nexport class MD5 extends HashMD<MD5> {\n  private A = MD5_IV[0] | 0;\n  private B = MD5_IV[1] | 0;\n  private C = MD5_IV[2] | 0;\n  private D = MD5_IV[3] | 0;\n\n  constructor() {\n    super(64, 16, 8, true);\n  }\n  protected get(): [number, number, number, number] {\n    const { A, B, C, D } = this;\n    return [A, B, C, D];\n  }\n  protected set(A: number, B: number, C: number, D: number): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    for (let i = 0; i < 16; i++, offset += 4) MD5_W[i] = view.getUint32(offset, true);\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D } = this;\n    for (let i = 0; i < 64; i++) {\n      let F, g, s;\n      if (i < 16) {\n        F = Chi(B, C, D);\n        g = i;\n        s = [7, 12, 17, 22];\n      } else if (i < 32) {\n        F = Chi(D, B, C);\n        g = (5 * i + 1) % 16;\n        s = [5, 9, 14, 20];\n      } else if (i < 48) {\n        F = B ^ C ^ D;\n        g = (3 * i + 5) % 16;\n        s = [4, 11, 16, 23];\n      } else {\n        F = C ^ (B | ~D);\n        g = (7 * i) % 16;\n        s = [6, 10, 15, 21];\n      }\n      F = F + A + K[i] + MD5_W[g];\n      A = D;\n      D = C;\n      C = B;\n      B = B + rotl(F, s[i % 4]);\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    this.set(A, B, C, D);\n  }\n  protected roundClean(): void {\n    clean(MD5_W);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\n/**\n * MD5 (RFC 1321) legacy hash function. It was cryptographically broken.\n * MD5 architecture is similar to SHA1, with some differences:\n * - Reduced output length: 16 bytes (128 bit) instead of 20\n * - 64 rounds, instead of 80\n * - Little-endian: could be faster, but will require more code\n * - Non-linear index selection: huge speed-up for unroll\n * - Per round constants: more memory accesses, additional speed-up for unroll\n */\nexport const md5: CHash = /* @__PURE__ */ createHasher(() => new MD5());\n\n// RIPEMD-160\n\nconst Rho160 = /* @__PURE__ */ Uint8Array.from([\n  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n]);\nconst Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();\nconst Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();\nconst idxLR = /* @__PURE__ */ (() => {\n  const L = [Id160];\n  const R = [Pi160];\n  const res = [L, R];\n  for (let i = 0; i < 4; i++) for (let j of res) j.push(j[i].map((k) => Rho160[k]));\n  return res;\n})();\nconst idxL = /* @__PURE__ */ (() => idxLR[0])();\nconst idxR = /* @__PURE__ */ (() => idxLR[1])();\n// const [idxL, idxR] = idxLR;\n\nconst shifts160 = /* @__PURE__ */ [\n  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => Uint8Array.from(i));\nconst shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst Kl160 = /* @__PURE__ */ Uint32Array.from([\n  0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr160 = /* @__PURE__ */ Uint32Array.from([\n  0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// It's called f() in spec.\nfunction ripemd_f(group: number, x: number, y: number, z: number): number {\n  if (group === 0) return x ^ y ^ z;\n  if (group === 1) return (x & y) | (~x & z);\n  if (group === 2) return (x | ~y) ^ z;\n  if (group === 3) return (x & z) | (y & ~z);\n  return x ^ (y | ~z);\n}\n// Reusable temporary buffer\nconst BUF_160 = /* @__PURE__ */ new Uint32Array(16);\nexport class RIPEMD160 extends HashMD<RIPEMD160> {\n  private h0 = 0x67452301 | 0;\n  private h1 = 0xefcdab89 | 0;\n  private h2 = 0x98badcfe | 0;\n  private h3 = 0x10325476 | 0;\n  private h4 = 0xc3d2e1f0 | 0;\n\n  constructor() {\n    super(64, 20, 8, true);\n  }\n  protected get(): [number, number, number, number, number] {\n    const { h0, h1, h2, h3, h4 } = this;\n    return [h0, h1, h2, h3, h4];\n  }\n  protected set(h0: number, h1: number, h2: number, h3: number, h4: number): void {\n    this.h0 = h0 | 0;\n    this.h1 = h1 | 0;\n    this.h2 = h2 | 0;\n    this.h3 = h3 | 0;\n    this.h4 = h4 | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    for (let i = 0; i < 16; i++, offset += 4) BUF_160[i] = view.getUint32(offset, true);\n    // prettier-ignore\n    let al = this.h0 | 0, ar = al,\n        bl = this.h1 | 0, br = bl,\n        cl = this.h2 | 0, cr = cl,\n        dl = this.h3 | 0, dr = dl,\n        el = this.h4 | 0, er = el;\n\n    // Instead of iterating 0 to 80, we split it into 5 groups\n    // And use the groups in constants, functions, etc. Much simpler\n    for (let group = 0; group < 5; group++) {\n      const rGroup = 4 - group;\n      const hbl = Kl160[group], hbr = Kr160[group]; // prettier-ignore\n      const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n      const sl = shiftsL160[group], sr = shiftsR160[group]; // prettier-ignore\n      for (let i = 0; i < 16; i++) {\n        const tl = (rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el) | 0;\n        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n      }\n      // 2 loops are 10% faster\n      for (let i = 0; i < 16; i++) {\n        const tr = (rotl(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er) | 0;\n        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n      }\n    }\n    // Add the compressed chunk to the current hash value\n    this.set(\n      (this.h1 + cl + dr) | 0,\n      (this.h2 + dl + er) | 0,\n      (this.h3 + el + ar) | 0,\n      (this.h4 + al + br) | 0,\n      (this.h0 + bl + cr) | 0\n    );\n  }\n  protected roundClean(): void {\n    clean(BUF_160);\n  }\n  destroy(): void {\n    this.destroyed = true;\n    clean(this.buffer);\n    this.set(0, 0, 0, 0, 0);\n  }\n}\n\n/**\n * RIPEMD-160 - a legacy hash function from 1990s.\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n */\nexport const ripemd160: CHash = /* @__PURE__ */ createHasher(() => new RIPEMD160());\n", "/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\nexport interface Coder<F, T> {\n  encode(from: F): T;\n  decode(to: T): F;\n}\n\nexport interface BytesCoder extends Coder<Uint8Array, string> {\n  encode: (data: Uint8Array) => string;\n  decode: (str: string) => Uint8Array;\n}\n\nfunction isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\nfunction isArrayOf(isString: boolean, arr: any[]) {\n  if (!Array.isArray(arr)) return false;\n  if (arr.length === 0) return true;\n  if (isString) {\n    return arr.every((item) => typeof item === 'string');\n  } else {\n    return arr.every((item) => Number.isSafeInteger(item));\n  }\n}\n\n// no abytes: seems to have 10% slowdown. Why?!\n\nfunction afn(input: Function): input is Function {\n  if (typeof input !== 'function') throw new Error('function expected');\n  return true;\n}\n\nfunction astr(label: string, input: unknown): input is string {\n  if (typeof input !== 'string') throw new Error(`${label}: string expected`);\n  return true;\n}\n\nfunction anumber(n: number): void {\n  if (!Number.isSafeInteger(n)) throw new Error(`invalid integer: ${n}`);\n}\n\nfunction aArr(input: any[]) {\n  if (!Array.isArray(input)) throw new Error('array expected');\n}\nfunction astrArr(label: string, input: string[]) {\n  if (!isArrayOf(true, input)) throw new Error(`${label}: array of strings expected`);\n}\nfunction anumArr(label: string, input: number[]) {\n  if (!isArrayOf(false, input)) throw new Error(`${label}: array of numbers expected`);\n}\n\n// TODO: some recusive type inference so it would check correct order of input/output inside rest?\n// like <string, number>, <number, bytes>, <bytes, float>\ntype Chain = [Coder<any, any>, ...Coder<any, any>[]];\n// Extract info from Coder type\ntype Input<F> = F extends Coder<infer T, any> ? T : never;\ntype Output<F> = F extends Coder<any, infer T> ? T : never;\n// Generic function for arrays\ntype First<T> = T extends [infer U, ...any[]] ? U : never;\ntype Last<T> = T extends [...any[], infer U] ? U : never;\ntype Tail<T> = T extends [any, ...infer U] ? U : never;\n\ntype AsChain<C extends Chain, Rest = Tail<C>> = {\n  // C[K] = Coder<Input<C[K]>, Input<Rest[k]>>\n  [K in keyof C]: Coder<Input<C[K]>, Input<K extends keyof Rest ? Rest[K] : any>>;\n};\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain<T extends Chain & AsChain<T>>(...args: T): Coder<Input<First<T>>, Output<Last<T>>> {\n  const id = (a: any) => a;\n  // Wrap call in closure so JIT can inline calls\n  const wrap = (a: any, b: any) => (c: any) => a(b(c));\n  // Construct chain of args[-1].encode(args[-2].encode([...]))\n  const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n  // Construct chain of args[0].decode(args[1].decode(...))\n  const decode = args.map((x) => x.decode).reduce(wrap, id);\n  return { encode, decode };\n}\n\n/**\n * Encodes integer radix representation to array of strings using alphabet and back.\n * Could also be array of strings.\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(letters: string | string[]): Coder<number[], string[]> {\n  // mapping 1 to \"b\"\n  const lettersA = typeof letters === 'string' ? letters.split('') : letters;\n  const len = lettersA.length;\n  astrArr('alphabet', lettersA);\n\n  // mapping \"b\" to 1\n  const indexes = new Map(lettersA.map((l, i) => [l, i]));\n  return {\n    encode: (digits: number[]) => {\n      aArr(digits);\n      return digits.map((i) => {\n        if (!Number.isSafeInteger(i) || i < 0 || i >= len)\n          throw new Error(\n            `alphabet.encode: digit index outside alphabet \"${i}\". Allowed: ${letters}`\n          );\n        return lettersA[i]!;\n      });\n    },\n    decode: (input: string[]): number[] => {\n      aArr(input);\n      return input.map((letter) => {\n        astr('alphabet.decode', letter);\n        const i = indexes.get(letter);\n        if (i === undefined) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${letters}`);\n        return i;\n      });\n    },\n  };\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = ''): Coder<string[], string> {\n  astr('join', separator);\n  return {\n    encode: (from) => {\n      astrArr('join.decode', from);\n      return from.join(separator);\n    },\n    decode: (to) => {\n      astr('join.decode', to);\n      return to.split(separator);\n    },\n  };\n}\n\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits: number, chr = '='): Coder<string[], string[]> {\n  anumber(bits);\n  astr('padding', chr);\n  return {\n    encode(data: string[]): string[] {\n      astrArr('padding.encode', data);\n      while ((data.length * bits) % 8) data.push(chr);\n      return data;\n    },\n    decode(input: string[]): string[] {\n      astrArr('padding.decode', input);\n      let end = input.length;\n      if ((end * bits) % 8)\n        throw new Error('padding: invalid, string should have whole number of bytes');\n      for (; end > 0 && input[end - 1] === chr; end--) {\n        const last = end - 1;\n        const byte = last * bits;\n        if (byte % 8 === 0) throw new Error('padding: invalid, string has too much padding');\n      }\n      return input.slice(0, end);\n    },\n  };\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize<T>(fn: (val: T) => T): Coder<T, T> {\n  afn(fn);\n  return { encode: (from: T) => from, decode: (to: T) => fn(to) };\n}\n\n/**\n * Slow: O(n^2) time complexity\n */\nfunction convertRadix(data: number[], from: number, to: number): number[] {\n  // base 1 is impossible\n  if (from < 2) throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);\n  if (to < 2) throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);\n  aArr(data);\n  if (!data.length) return [];\n  let pos = 0;\n  const res = [];\n  const digits = Array.from(data, (d) => {\n    anumber(d);\n    if (d < 0 || d >= from) throw new Error(`invalid integer: ${d}`);\n    return d;\n  });\n  const dlen = digits.length;\n  while (true) {\n    let carry = 0;\n    let done = true;\n    for (let i = pos; i < dlen; i++) {\n      const digit = digits[i]!;\n      const fromCarry = from * carry;\n      const digitBase = fromCarry + digit;\n      if (\n        !Number.isSafeInteger(digitBase) ||\n        fromCarry / from !== carry ||\n        digitBase - digit !== fromCarry\n      ) {\n        throw new Error('convertRadix: carry overflow');\n      }\n      const div = digitBase / to;\n      carry = digitBase % to;\n      const rounded = Math.floor(div);\n      digits[i] = rounded;\n      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n        throw new Error('convertRadix: carry overflow');\n      if (!done) continue;\n      else if (!rounded) pos = i;\n      else done = false;\n    }\n    res.push(carry);\n    if (done) break;\n  }\n  for (let i = 0; i < data.length - 1 && data[i] === 0; i++) res.push(0);\n  return res.reverse();\n}\n\nconst gcd = (a: number, b: number): number => (b === 0 ? a : gcd(b, a % b));\nconst radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from: number, to: number) =>\n  from + (to - gcd(from, to));\nconst powers: number[] = /* @__PURE__ */ (() => {\n  let res = [];\n  for (let i = 0; i < 40; i++) res.push(2 ** i);\n  return res;\n})();\n/**\n * Implemented with numbers, because BigInt is 5x slower\n */\nfunction convertRadix2(data: number[], from: number, to: number, padding: boolean): number[] {\n  aArr(data);\n  if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);\n  if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);\n  if (radix2carry(from, to) > 32) {\n    throw new Error(\n      `convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`\n    );\n  }\n  let carry = 0;\n  let pos = 0; // bitwise position in current element\n  const max = powers[from]!;\n  const mask = powers[to]! - 1;\n  const res: number[] = [];\n  for (const n of data) {\n    anumber(n);\n    if (n >= max) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n    carry = (carry << from) | n;\n    if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n    pos += from;\n    for (; pos >= to; pos -= to) res.push(((carry >> (pos - to)) & mask) >>> 0);\n    const pow = powers[pos];\n    if (pow === undefined) throw new Error('invalid carry');\n    carry &= pow - 1; // clean carry, otherwise it will cause overflow\n  }\n  carry = (carry << (to - pos)) & mask;\n  if (!padding && pos >= from) throw new Error('Excess padding');\n  if (!padding && carry > 0) throw new Error(`Non-zero padding: ${carry}`);\n  if (padding && pos > 0) res.push(carry >>> 0);\n  return res;\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num: number): Coder<Uint8Array, number[]> {\n  anumber(num);\n  const _256 = 2 ** 8;\n  return {\n    encode: (bytes: Uint8Array) => {\n      if (!isBytes(bytes)) throw new Error('radix.encode input should be Uint8Array');\n      return convertRadix(Array.from(bytes), _256, num);\n    },\n    decode: (digits: number[]) => {\n      anumArr('radix.decode', digits);\n      return Uint8Array.from(convertRadix(digits, num, _256));\n    },\n  };\n}\n\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits: number, revPadding = false): Coder<Uint8Array, number[]> {\n  anumber(bits);\n  if (bits <= 0 || bits > 32) throw new Error('radix2: bits should be in (0..32]');\n  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n    throw new Error('radix2: carry overflow');\n  return {\n    encode: (bytes: Uint8Array) => {\n      if (!isBytes(bytes)) throw new Error('radix2.encode input should be Uint8Array');\n      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n    },\n    decode: (digits: number[]) => {\n      anumArr('radix2.decode', digits);\n      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n    },\n  };\n}\n\ntype ArgumentTypes<F extends Function> = F extends (...args: infer A) => any ? A : never;\nfunction unsafeWrapper<T extends (...args: any) => any>(fn: T) {\n  afn(fn);\n  return function (...args: ArgumentTypes<T>): ReturnType<T> | void {\n    try {\n      return fn.apply(null, args);\n    } catch (e) {}\n  };\n}\n\nfunction checksum(\n  len: number,\n  fn: (data: Uint8Array) => Uint8Array\n): Coder<Uint8Array, Uint8Array> {\n  anumber(len);\n  afn(fn);\n  return {\n    encode(data: Uint8Array) {\n      if (!isBytes(data)) throw new Error('checksum.encode: input should be Uint8Array');\n      const sum = fn(data).slice(0, len);\n      const res = new Uint8Array(data.length + len);\n      res.set(data);\n      res.set(sum, data.length);\n      return res;\n    },\n    decode(data: Uint8Array) {\n      if (!isBytes(data)) throw new Error('checksum.decode: input should be Uint8Array');\n      const payload = data.slice(0, -len);\n      const oldChecksum = data.slice(-len);\n      const newChecksum = fn(payload).slice(0, len);\n      for (let i = 0; i < len; i++)\n        if (newChecksum[i] !== oldChecksum[i]) throw new Error('Invalid checksum');\n      return payload;\n    },\n  };\n}\n\n// prettier-ignore\nexport const utils: { alphabet: typeof alphabet; chain: typeof chain; checksum: typeof checksum; convertRadix: typeof convertRadix; convertRadix2: typeof convertRadix2; radix: typeof radix; radix2: typeof radix2; join: typeof join; padding: typeof padding; } = {\n  alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n\n// RFC 4648 aka RFC 3548\n// ---------------------\n\n/**\n * base16 encoding from RFC 4648.\n * @example\n * ```js\n * base16.encode(Uint8Array.from([0x12, 0xab]));\n * // => '12AB'\n * ```\n */\nexport const base16: BytesCoder = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\n\n/**\n * base32 encoding from RFC 4648. Has padding.\n * Use `base32nopad` for unpadded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ===='\n * base32.decode('CKVQ====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32: BytesCoder = chain(\n  radix2(5),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'),\n  padding(5),\n  join('')\n);\n\n/**\n * base32 encoding from RFC 4648. No padding.\n * Use `base32` for padded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ'\n * base32nopad.decode('CKVQ');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32nopad: BytesCoder = chain(\n  radix2(5),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'),\n  join('')\n);\n/**\n * base32 encoding from RFC 4648. Padded. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hexnopad` for unpadded version.\n * @example\n * ```js\n * base32hex.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG===='\n * base32hex.decode('2ALG====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32hex: BytesCoder = chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'),\n  padding(5),\n  join('')\n);\n\n/**\n * base32 encoding from RFC 4648. No padding. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hex` for padded version.\n * @example\n * ```js\n * base32hexnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG'\n * base32hexnopad.decode('2ALG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32hexnopad: BytesCoder = chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'),\n  join('')\n);\n/**\n * base32 encoding from RFC 4648. Doug Crockford's version.\n * https://www.crockford.com/base32.html\n * @example\n * ```js\n * base32crockford.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ANG'\n * base32crockford.decode('2ANG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32crockford: BytesCoder = chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'),\n  join(''),\n  normalize((s: string) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1'))\n);\n\n// Built-in base64 conversion https://caniuse.com/mdn-javascript_builtins_uint8array_frombase64\n// prettier-ignore\nconst hasBase64Builtin: boolean = /* @__PURE__ */ (() =>\n  typeof (Uint8Array as any).from([]).toBase64 === 'function' &&\n  typeof (Uint8Array as any).fromBase64 === 'function')();\n\nconst decodeBase64Builtin = (s: string, isUrl: boolean) => {\n  astr('base64', s);\n  const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;\n  const alphabet = isUrl ? 'base64url' : 'base64';\n  if (s.length > 0 && !re.test(s)) throw new Error('invalid base64');\n  return (Uint8Array as any).fromBase64(s, { alphabet, lastChunkHandling: 'strict' });\n};\n\n/**\n * base64 from RFC 4648. Padded.\n * Use `base64nopad` for unpadded version.\n * Also check out `base64url`, `base64urlnopad`.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nexport const base64: BytesCoder = hasBase64Builtin ? {\n  encode(b) { abytes(b); return (b as any).toBase64(); },\n  decode(s) { return decodeBase64Builtin(s, false); },\n} : chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'),\n  padding(6),\n  join('')\n);\n/**\n * base64 from RFC 4648. No padding.\n * Use `base64` for padded version.\n * @example\n * ```js\n * base64nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64nopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base64nopad: BytesCoder = chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'),\n  join('')\n);\n\n/**\n * base64 from RFC 4648, using URL-safe alphabet. Padded.\n * Use `base64urlnopad` for unpadded version.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64url.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64url.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nexport const base64url: BytesCoder = hasBase64Builtin ? {\n  encode(b) { abytes(b); return (b as any).toBase64({ alphabet: 'base64url' }); },\n  decode(s) { return decodeBase64Builtin(s, true); },\n} : chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'),\n  padding(6),\n  join('')\n);\n\n/**\n * base64 from RFC 4648, using URL-safe alphabet. No padding.\n * Use `base64url` for padded version.\n * @example\n * ```js\n * base64urlnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64urlnopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base64urlnopad: BytesCoder = chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'),\n  join('')\n);\n\n// base58 code\n// -----------\nconst genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc: string) =>\n  chain(radix(58), alphabet(abc), join(''));\n\n/**\n * base58: base64 without ambigous characters +, /, 0, O, I, l.\n * Quadratic (O(n^2)) - so, can't be used on large inputs.\n * @example\n * ```js\n * base58.decode('01abcdef');\n * // => '3UhJW'\n * ```\n */\nexport const base58: BytesCoder = genBase58(\n  '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n);\n/**\n * base58: flickr version. Check out `base58`.\n */\nexport const base58flickr: BytesCoder = genBase58(\n  '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n);\n/**\n * base58: XRP version. Check out `base58`.\n */\nexport const base58xrp: BytesCoder = genBase58(\n  'rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz'\n);\n\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\n\n/**\n * base58: XMR version. Check out `base58`.\n * Done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n * Block encoding significantly reduces quadratic complexity of base58.\n */\nexport const base58xmr: BytesCoder = {\n  encode(data: Uint8Array) {\n    let res = '';\n    for (let i = 0; i < data.length; i += 8) {\n      const block = data.subarray(i, i + 8);\n      res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length]!, '1');\n    }\n    return res;\n  },\n  decode(str: string) {\n    let res: number[] = [];\n    for (let i = 0; i < str.length; i += 11) {\n      const slice = str.slice(i, i + 11);\n      const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n      const block = base58.decode(slice);\n      for (let j = 0; j < block.length - blockLen; j++) {\n        if (block[j] !== 0) throw new Error('base58xmr: wrong padding');\n      }\n      res = res.concat(Array.from(block.slice(block.length - blockLen)));\n    }\n    return Uint8Array.from(res);\n  },\n};\n\n/**\n * Method, which creates base58check encoder.\n * Requires function, calculating sha256.\n */\nexport const createBase58check = (sha256: (data: Uint8Array) => Uint8Array): BytesCoder =>\n  chain(\n    checksum(4, (data) => sha256(sha256(data))),\n    base58\n  );\n\n/**\n * Use `createBase58check` instead.\n * @deprecated\n */\nexport const base58check: (sha256: (data: Uint8Array) => Uint8Array) => BytesCoder =\n  createBase58check;\n\n// Bech32 code\n// -----------\nexport interface Bech32Decoded<Prefix extends string = string> {\n  prefix: Prefix;\n  words: number[];\n}\nexport interface Bech32DecodedWithArray<Prefix extends string = string> {\n  prefix: Prefix;\n  words: number[];\n  bytes: Uint8Array;\n}\n\nconst BECH_ALPHABET: Coder<number[], string> = chain(\n  alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'),\n  join('')\n);\n\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre: number): number {\n  const b = pre >> 25;\n  let chk = (pre & 0x1ffffff) << 5;\n  for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n    if (((b >> i) & 1) === 1) chk ^= POLYMOD_GENERATORS[i]!;\n  }\n  return chk;\n}\n\nfunction bechChecksum(prefix: string, words: number[], encodingConst = 1): string {\n  const len = prefix.length;\n  let chk = 1;\n  for (let i = 0; i < len; i++) {\n    const c = prefix.charCodeAt(i);\n    if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);\n    chk = bech32Polymod(chk) ^ (c >> 5);\n  }\n  chk = bech32Polymod(chk);\n  for (let i = 0; i < len; i++) chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n  for (let v of words) chk = bech32Polymod(chk) ^ v;\n  for (let i = 0; i < 6; i++) chk = bech32Polymod(chk);\n  chk ^= encodingConst;\n  return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]!], 30, 5, false));\n}\n\nexport interface Bech32 {\n  encode<Prefix extends string>(\n    prefix: Prefix,\n    words: number[] | Uint8Array,\n    limit?: number | false\n  ): `${Lowercase<Prefix>}1${string}`;\n  decode<Prefix extends string>(\n    str: `${Prefix}1${string}`,\n    limit?: number | false\n  ): Bech32Decoded<Prefix>;\n  encodeFromBytes(prefix: string, bytes: Uint8Array): string;\n  decodeToBytes(str: string): Bech32DecodedWithArray;\n  decodeUnsafe(str: string, limit?: number | false): void | Bech32Decoded<string>;\n  fromWords(to: number[]): Uint8Array;\n  fromWordsUnsafe(to: number[]): void | Uint8Array;\n  toWords(from: Uint8Array): number[];\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding: 'bech32' | 'bech32m'): Bech32 {\n  const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n  const _words = radix2(5);\n  const fromWords = _words.decode;\n  const toWords = _words.encode;\n  const fromWordsUnsafe = unsafeWrapper(fromWords);\n\n  function encode<Prefix extends string>(\n    prefix: Prefix,\n    words: number[] | Uint8Array,\n    limit: number | false = 90\n  ): `${Lowercase<Prefix>}1${string}` {\n    astr('bech32.encode prefix', prefix);\n    if (isBytes(words)) words = Array.from(words);\n    anumArr('bech32.encode', words);\n    const plen = prefix.length;\n    if (plen === 0) throw new TypeError(`Invalid prefix length ${plen}`);\n    const actualLength = plen + 7 + words.length;\n    if (limit !== false && actualLength > limit)\n      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n    const lowered = prefix.toLowerCase();\n    const sum = bechChecksum(lowered, words, ENCODING_CONST);\n    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}` as `${Lowercase<Prefix>}1${string}`;\n  }\n\n  function decode<Prefix extends string>(\n    str: `${Prefix}1${string}`,\n    limit?: number | false\n  ): Bech32Decoded<Prefix>;\n  function decode(str: string, limit?: number | false): Bech32Decoded;\n  function decode(str: string, limit: number | false = 90): Bech32Decoded {\n    astr('bech32.decode input', str);\n    const slen = str.length;\n    if (slen < 8 || (limit !== false && slen > limit))\n      throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);\n    // don't allow mixed case\n    const lowered = str.toLowerCase();\n    if (str !== lowered && str !== str.toUpperCase())\n      throw new Error(`String must be lowercase or uppercase`);\n    const sepIndex = lowered.lastIndexOf('1');\n    if (sepIndex === 0 || sepIndex === -1)\n      throw new Error(`Letter \"1\" must be present between prefix and data only`);\n    const prefix = lowered.slice(0, sepIndex);\n    const data = lowered.slice(sepIndex + 1);\n    if (data.length < 6) throw new Error('Data must be at least 6 characters long');\n    const words = BECH_ALPHABET.decode(data).slice(0, -6);\n    const sum = bechChecksum(prefix, words, ENCODING_CONST);\n    if (!data.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n    return { prefix, words };\n  }\n\n  const decodeUnsafe = unsafeWrapper(decode);\n\n  function decodeToBytes(str: string): Bech32DecodedWithArray {\n    const { prefix, words } = decode(str, false);\n    return { prefix, words, bytes: fromWords(words) };\n  }\n\n  function encodeFromBytes(prefix: string, bytes: Uint8Array) {\n    return encode(prefix, toWords(bytes));\n  }\n\n  return {\n    encode,\n    decode,\n    encodeFromBytes,\n    decodeToBytes,\n    decodeUnsafe,\n    fromWords,\n    fromWordsUnsafe,\n    toWords,\n  };\n}\n\n/**\n * bech32 from BIP 173. Operates on words.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nexport const bech32: Bech32 = genBech32('bech32');\n\n/**\n * bech32m from BIP 350. Operates on words.\n * It was to mitigate `bech32` weaknesses.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nexport const bech32m: Bech32 = genBech32('bech32m');\n\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * UTF-8-to-byte decoder. Uses built-in TextDecoder / TextEncoder.\n * @example\n * ```js\n * const b = utf8.decode(\"hey\"); // => new Uint8Array([ 104, 101, 121 ])\n * const str = utf8.encode(b); // \"hey\"\n * ```\n */\nexport const utf8: BytesCoder = {\n  encode: (data) => new TextDecoder().decode(data),\n  decode: (str) => new TextEncoder().encode(str),\n};\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\n// prettier-ignore\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  typeof (Uint8Array as any).from([]).toHex === 'function' &&\n  typeof (Uint8Array as any).fromHex === 'function')();\n// prettier-ignore\nconst hexBuiltin: BytesCoder = {\n  encode(data) { abytes(data); return (data as any).toHex(); },\n  decode(s) { astr('hex', s); return (Uint8Array as any).fromHex(s); },\n};\n/**\n * hex string decoder. Uses built-in function, when available.\n * @example\n * ```js\n * const b = hex.decode(\"0102ff\"); // => new Uint8Array([ 1, 2, 255 ])\n * const str = hex.encode(b); // \"0102ff\"\n * ```\n */\nexport const hex: BytesCoder = hasHexBuiltin\n  ? hexBuiltin\n  : chain(\n      radix2(4),\n      alphabet('0123456789abcdef'),\n      join(''),\n      normalize((s: string) => {\n        if (typeof s !== 'string' || s.length % 2 !== 0)\n          throw new TypeError(\n            `hex.decode: expected string, got ${typeof s} with length ${s.length}`\n          );\n        return s.toLowerCase();\n      })\n    );\n\nexport type SomeCoders = {\n  utf8: BytesCoder;\n  hex: BytesCoder;\n  base16: BytesCoder;\n  base32: BytesCoder;\n  base64: BytesCoder;\n  base64url: BytesCoder;\n  base58: BytesCoder;\n  base58xmr: BytesCoder;\n};\n// prettier-ignore\nconst CODERS: SomeCoders = {\n  utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\ntype CoderType = keyof SomeCoders;\nconst coderTypeError =\n  'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\n\n/** @deprecated */\nexport const bytesToString = (type: CoderType, bytes: Uint8Array): string => {\n  if (typeof type !== 'string' || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (!isBytes(bytes)) throw new TypeError('bytesToString() expects Uint8Array');\n  return CODERS[type].encode(bytes);\n};\n\n/** @deprecated */\nexport const str: (type: CoderType, bytes: Uint8Array) => string = bytesToString; // as in python, but for bytes only\n\n/** @deprecated */\nexport const stringToBytes = (type: CoderType, str: string): Uint8Array => {\n  if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (typeof str !== 'string') throw new TypeError('stringToBytes() expects string');\n  return CODERS[type].decode(str);\n};\n/** @deprecated */\nexport const bytes: (type: CoderType, str: string) => Uint8Array = stringToBytes;\n", "/**\n * @module BIP32 hierarchical deterministic (HD) wallets over secp256k1.\n * @example\n * ```js\n * import { HDKey } from \"@scure/bip32\";\n * const hdkey1 = HDKey.fromMasterSeed(seed);\n * const hdkey2 = HDKey.fromExtendedKey(base58key);\n * const hdkey3 = HDKey.fromJSON({ xpriv: string });\n *\n * // props\n * [hdkey1.depth, hdkey1.index, hdkey1.chainCode];\n * console.log(hdkey2.privateKey, hdkey2.publicKey);\n * console.log(hdkey3.derive(\"m/0/2147483647'/1\"));\n * const sig = hdkey3.sign(hash);\n * hdkey3.verify(hash, sig);\n * ```\n */\n/*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */\nimport { mod } from '@noble/curves/abstract/modular';\nimport { secp256k1 as secp } from '@noble/curves/secp256k1';\nimport { hmac } from '@noble/hashes/hmac';\nimport { ripemd160 } from '@noble/hashes/legacy';\nimport { sha256, sha512 } from '@noble/hashes/sha2';\nimport {\n  abytes,\n  bytesToHex,\n  concatBytes,\n  createView,\n  hexToBytes,\n  utf8ToBytes,\n} from '@noble/hashes/utils';\nimport { createBase58check } from '@scure/base';\n\nconst Point = secp.ProjectivePoint;\nconst base58check = createBase58check(sha256);\n\nfunction bytesToNumber(bytes: Uint8Array): bigint {\n  abytes(bytes);\n  const h = bytes.length === 0 ? '0' : bytesToHex(bytes);\n  return BigInt('0x' + h);\n}\n\nfunction numberToBytes(num: bigint): Uint8Array {\n  if (typeof num !== 'bigint') throw new Error('bigint expected');\n  return hexToBytes(num.toString(16).padStart(64, '0'));\n}\n\nconst MASTER_SECRET = utf8ToBytes('Bitcoin seed');\n// Bitcoin hardcoded by default\nconst BITCOIN_VERSIONS: Versions = { private: 0x0488ade4, public: 0x0488b21e };\nexport const HARDENED_OFFSET: number = 0x80000000;\n\nexport interface Versions {\n  private: number;\n  public: number;\n}\n\nconst hash160 = (data: Uint8Array) => ripemd160(sha256(data));\nconst fromU32 = (data: Uint8Array) => createView(data).getUint32(0, false);\nconst toU32 = (n: number) => {\n  if (!Number.isSafeInteger(n) || n < 0 || n > 2 ** 32 - 1) {\n    throw new Error('invalid number, should be from 0 to 2**32-1, got ' + n);\n  }\n  const buf = new Uint8Array(4);\n  createView(buf).setUint32(0, n, false);\n  return buf;\n};\n\ninterface HDKeyOpt {\n  versions?: Versions;\n  depth?: number;\n  index?: number;\n  parentFingerprint?: number;\n  chainCode?: Uint8Array;\n  publicKey?: Uint8Array;\n  privateKey?: Uint8Array | bigint;\n}\n\nexport class HDKey {\n  get fingerprint(): number {\n    if (!this.pubHash) {\n      throw new Error('No publicKey set!');\n    }\n    return fromU32(this.pubHash);\n  }\n  get identifier(): Uint8Array | undefined {\n    return this.pubHash;\n  }\n  get pubKeyHash(): Uint8Array | undefined {\n    return this.pubHash;\n  }\n  get privateKey(): Uint8Array | null {\n    return this.privKeyBytes || null;\n  }\n  get publicKey(): Uint8Array | null {\n    return this.pubKey || null;\n  }\n  get privateExtendedKey(): string {\n    const priv = this.privateKey;\n    if (!priv) {\n      throw new Error('No private key');\n    }\n    return base58check.encode(\n      this.serialize(this.versions.private, concatBytes(new Uint8Array([0]), priv))\n    );\n  }\n  get publicExtendedKey(): string {\n    if (!this.pubKey) {\n      throw new Error('No public key');\n    }\n    return base58check.encode(this.serialize(this.versions.public, this.pubKey));\n  }\n\n  public static fromMasterSeed(seed: Uint8Array, versions: Versions = BITCOIN_VERSIONS): HDKey {\n    abytes(seed);\n    if (8 * seed.length < 128 || 8 * seed.length > 512) {\n      throw new Error(\n        'HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got ' +\n          seed.length\n      );\n    }\n    const I = hmac(sha512, MASTER_SECRET, seed);\n    return new HDKey({\n      versions,\n      chainCode: I.slice(32),\n      privateKey: I.slice(0, 32),\n    });\n  }\n\n  public static fromExtendedKey(base58key: string, versions: Versions = BITCOIN_VERSIONS): HDKey {\n    // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n    const keyBuffer: Uint8Array = base58check.decode(base58key);\n    const keyView = createView(keyBuffer);\n    const version = keyView.getUint32(0, false);\n    const opt = {\n      versions,\n      depth: keyBuffer[4],\n      parentFingerprint: keyView.getUint32(5, false),\n      index: keyView.getUint32(9, false),\n      chainCode: keyBuffer.slice(13, 45),\n    };\n    const key = keyBuffer.slice(45);\n    const isPriv = key[0] === 0;\n    if (version !== versions[isPriv ? 'private' : 'public']) {\n      throw new Error('Version mismatch');\n    }\n    if (isPriv) {\n      return new HDKey({ ...opt, privateKey: key.slice(1) });\n    } else {\n      return new HDKey({ ...opt, publicKey: key });\n    }\n  }\n\n  public static fromJSON(json: { xpriv: string }): HDKey {\n    return HDKey.fromExtendedKey(json.xpriv);\n  }\n  public readonly versions: Versions;\n  public readonly depth: number = 0;\n  public readonly index: number = 0;\n  public readonly chainCode: Uint8Array | null = null;\n  public readonly parentFingerprint: number = 0;\n  private privKey?: bigint;\n  private privKeyBytes?: Uint8Array;\n  private pubKey?: Uint8Array;\n  private pubHash: Uint8Array | undefined;\n\n  constructor(opt: HDKeyOpt) {\n    if (!opt || typeof opt !== 'object') {\n      throw new Error('HDKey.constructor must not be called directly');\n    }\n    this.versions = opt.versions || BITCOIN_VERSIONS;\n    this.depth = opt.depth || 0;\n    this.chainCode = opt.chainCode || null;\n    this.index = opt.index || 0;\n    this.parentFingerprint = opt.parentFingerprint || 0;\n    if (!this.depth) {\n      if (this.parentFingerprint || this.index) {\n        throw new Error('HDKey: zero depth with non-zero index/parent fingerprint');\n      }\n    }\n    if (opt.publicKey && opt.privateKey) {\n      throw new Error('HDKey: publicKey and privateKey at same time.');\n    }\n    if (opt.privateKey) {\n      if (!secp.utils.isValidPrivateKey(opt.privateKey)) {\n        throw new Error('Invalid private key');\n      }\n      this.privKey =\n        typeof opt.privateKey === 'bigint' ? opt.privateKey : bytesToNumber(opt.privateKey);\n      this.privKeyBytes = numberToBytes(this.privKey);\n      this.pubKey = secp.getPublicKey(opt.privateKey, true);\n    } else if (opt.publicKey) {\n      this.pubKey = Point.fromHex(opt.publicKey).toRawBytes(true); // force compressed point\n    } else {\n      throw new Error('HDKey: no public or private key provided');\n    }\n    this.pubHash = hash160(this.pubKey);\n  }\n\n  public derive(path: string): HDKey {\n    if (!/^[mM]'?/.test(path)) {\n      throw new Error('Path must start with \"m\" or \"M\"');\n    }\n    if (/^[mM]'?$/.test(path)) {\n      return this;\n    }\n    const parts = path.replace(/^[mM]'?\\//, '').split('/');\n    // tslint:disable-next-line\n    let child: HDKey = this;\n    for (const c of parts) {\n      const m = /^(\\d+)('?)$/.exec(c);\n      const m1 = m && m[1];\n      if (!m || m.length !== 3 || typeof m1 !== 'string')\n        throw new Error('invalid child index: ' + c);\n      let idx = +m1;\n      if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) {\n        throw new Error('Invalid index');\n      }\n      // hardened key\n      if (m[2] === \"'\") {\n        idx += HARDENED_OFFSET;\n      }\n      child = child.deriveChild(idx);\n    }\n    return child;\n  }\n\n  public deriveChild(index: number): HDKey {\n    if (!this.pubKey || !this.chainCode) {\n      throw new Error('No publicKey or chainCode set');\n    }\n    let data = toU32(index);\n    if (index >= HARDENED_OFFSET) {\n      // Hardened\n      const priv = this.privateKey;\n      if (!priv) {\n        throw new Error('Could not derive hardened child key');\n      }\n      // Hardened child: 0x00 || ser256(kpar) || ser32(index)\n      data = concatBytes(new Uint8Array([0]), priv, data);\n    } else {\n      // Normal child: serP(point(kpar)) || ser32(index)\n      data = concatBytes(this.pubKey, data);\n    }\n    const I = hmac(sha512, this.chainCode, data);\n    const childTweak = bytesToNumber(I.slice(0, 32));\n    const chainCode = I.slice(32);\n    if (!secp.utils.isValidPrivateKey(childTweak)) {\n      throw new Error('Tweak bigger than curve order');\n    }\n    const opt: HDKeyOpt = {\n      versions: this.versions,\n      chainCode,\n      depth: this.depth + 1,\n      parentFingerprint: this.fingerprint,\n      index,\n    };\n    try {\n      // Private parent key -> private child key\n      if (this.privateKey) {\n        const added = mod(this.privKey! + childTweak, secp.CURVE.n);\n        if (!secp.utils.isValidPrivateKey(added)) {\n          throw new Error('The tweak was out of range or the resulted private key is invalid');\n        }\n        opt.privateKey = added;\n      } else {\n        const added = Point.fromHex(this.pubKey).add(Point.fromPrivateKey(childTweak));\n        // Cryptographically impossible: hmac-sha512 preimage would need to be found\n        if (added.equals(Point.ZERO)) {\n          throw new Error('The tweak was equal to negative P, which made the result key invalid');\n        }\n        opt.publicKey = added.toRawBytes(true);\n      }\n      return new HDKey(opt);\n    } catch (err) {\n      return this.deriveChild(index + 1);\n    }\n  }\n\n  public sign(hash: Uint8Array): Uint8Array {\n    if (!this.privateKey) {\n      throw new Error('No privateKey set!');\n    }\n    abytes(hash, 32);\n    return secp.sign(hash, this.privKey!).toCompactRawBytes();\n  }\n\n  public verify(hash: Uint8Array, signature: Uint8Array): boolean {\n    abytes(hash, 32);\n    abytes(signature, 64);\n    if (!this.publicKey) {\n      throw new Error('No publicKey set!');\n    }\n    let sig;\n    try {\n      sig = secp.Signature.fromCompact(signature);\n    } catch (error) {\n      return false;\n    }\n    return secp.verify(sig, hash, this.publicKey);\n  }\n\n  public wipePrivateData(): this {\n    this.privKey = undefined;\n    if (this.privKeyBytes) {\n      this.privKeyBytes.fill(0);\n      this.privKeyBytes = undefined;\n    }\n    return this;\n  }\n  public toJSON(): { xpriv: string; xpub: string } {\n    return {\n      xpriv: this.privateExtendedKey,\n      xpub: this.publicExtendedKey,\n    };\n  }\n\n  private serialize(version: number, key: Uint8Array) {\n    if (!this.chainCode) {\n      throw new Error('No chainCode set');\n    }\n    abytes(key, 33);\n    // version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n    return concatBytes(\n      toU32(version),\n      new Uint8Array([this.depth]),\n      toU32(this.parentFingerprint),\n      toU32(this.index),\n      this.chainCode,\n      key\n    );\n  }\n}\n", "import type {\n\tSerializedBlindedMessage,\n\tSerializedBlindedSignature,\n} from '../../model/types/blinded';\nimport type { ProofState } from '../../model/types/proof-state';\n\n/**\n * Cashu api error.\n */\nexport type ApiError = {\n\t/**\n\t * Error message.\n\t */\n\terror?: string;\n\t/**\n\t * HTTP error code.\n\t */\n\tcode?: number;\n\t/**\n\t * Detailed error message.\n\t */\n\tdetail?: string;\n};\n\n/**\n * Response when checking proofs if they are spendable. Should not rely on this for receiving, since\n * it can be easily cheated.\n */\nexport type CheckStateResponse = {\n\tstates: ProofState[];\n} & ApiError;\n\n/**\n * Response from mint at /info endpoint.\n */\nexport type GetInfoResponse = {\n\tname: string;\n\tpubkey: string;\n\tversion: string;\n\tdescription?: string;\n\tdescription_long?: string;\n\ticon_url?: string;\n\tcontact: MintContactInfo[];\n\tnuts: {\n\t\t'4': {\n\t\t\t// Minting\n\t\t\tmethods: SwapMethod[];\n\t\t\tdisabled: boolean;\n\t\t};\n\t\t'5': {\n\t\t\t// Melting\n\t\t\tmethods: SwapMethod[];\n\t\t\tdisabled: boolean;\n\t\t};\n\t\t'7'?: {\n\t\t\t// Token state check\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'8'?: {\n\t\t\t// Overpaid melt fees\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'9'?: {\n\t\t\t// Restore\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'10'?: {\n\t\t\t// Spending conditions\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'11'?: {\n\t\t\t// P2PK\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'12'?: {\n\t\t\t// DLEQ\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'14'?: {\n\t\t\t// HTLCs\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'15'?: {\n\t\t\t// MPP\n\t\t\tmethods: MPPMethod[];\n\t\t};\n\t\t'17'?: {\n\t\t\t// WebSockets\n\t\t\tsupported: WebSocketSupport[];\n\t\t};\n\t\t'20'?: {\n\t\t\t// Locked Mint Quote\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'21'?: {\n\t\t\t// Clear Authentication\n\t\t\topenid_discovery: string;\n\t\t\tclient_id: string;\n\t\t\tprotected_endpoints?: Array<{ method: 'GET' | 'POST'; path: string }>;\n\t\t};\n\t\t'22'?: {\n\t\t\t// Blind Authentication\n\t\t\tbat_max_mint: number;\n\t\t\tprotected_endpoints: Array<{ method: 'GET' | 'POST'; path: string }>;\n\t\t};\n\t};\n\tmotd?: string;\n};\n\n/**\n * Response from the mint after requesting a melt quote.\n */\nexport type PartialMeltQuoteResponse = {\n\t/**\n\t * Quote ID.\n\t */\n\tquote: string;\n\t/**\n\t * Amount to be melted.\n\t */\n\tamount: number;\n\t/**\n\t * Fee reserve to be added to the amount.\n\t */\n\tfee_reserve: number;\n\t/**\n\t * State of the melt quote.\n\t */\n\tstate: MeltQuoteState;\n\t/**\n\t * Timestamp of when the quote expires.\n\t */\n\texpiry: number;\n\t/**\n\t * Preimage of the paid invoice. is null if it the invoice has not been paid yet. can be null,\n\t * depending on which LN-backend the mint uses.\n\t */\n\tpayment_preimage: string | null;\n\t/**\n\t * Return/Change from overpaid fees. This happens due to Lighting fee estimation being inaccurate.\n\t */\n\tchange?: SerializedBlindedSignature[];\n\t/**\n\t * Payment request for the melt quote.\n\t */\n\trequest?: string;\n\t/**\n\t * Unit of the melt quote.\n\t */\n\tunit?: string;\n} & ApiError;\n\nexport type MeltQuoteResponse = PartialMeltQuoteResponse & { request: string; unit: string };\n\n/**\n * Response from the mint after requesting a BOLT12 melt quote. Contains payment details and state\n * for paying Lightning Network offers.\n */\nexport type Bolt12MeltQuoteResponse = MeltQuoteResponse;\n\nexport const MeltQuoteState = {\n\tUNPAID: 'UNPAID',\n\tPENDING: 'PENDING',\n\tPAID: 'PAID',\n} as const;\nexport type MeltQuoteState = (typeof MeltQuoteState)[keyof typeof MeltQuoteState];\n\nexport type MintContactInfo = {\n\tmethod: string;\n\tinfo: string;\n};\n\nexport const MintQuoteState = {\n\tUNPAID: 'UNPAID',\n\tPAID: 'PAID',\n\tISSUED: 'ISSUED',\n} as const;\nexport type MintQuoteState = (typeof MintQuoteState)[keyof typeof MintQuoteState];\n\n/**\n * Response from the mint after requesting a mint.\n */\nexport type PartialMintQuoteResponse = {\n\t/**\n\t * Payment request.\n\t */\n\trequest: string;\n\t/**\n\t * Quote ID.\n\t */\n\tquote: string;\n\t/**\n\t * State of the mint quote.\n\t */\n\tstate: MintQuoteState;\n\t/**\n\t * Timestamp of when the quote expires.\n\t */\n\texpiry: number;\n\t/**\n\t * Public key the quote is locked to.\n\t */\n\tpubkey?: string;\n\t/**\n\t * Unit of the quote.\n\t */\n\tunit?: string;\n\t/**\n\t * Amount requested for mint quote.\n\t */\n\tamount?: number;\n} & ApiError;\n\nexport type MintQuoteResponse = PartialMintQuoteResponse & { amount: number; unit: string };\n\nexport type LockedMintQuoteResponse = MintQuoteResponse & { pubkey: string };\n\n/**\n * Response from the mint after requesting a BOLT12 mint quote. Contains a Lightning Network offer\n * and tracks payment/issuance amounts.\n */\nexport type Bolt12MintQuoteResponse = {\n\t/**\n\t * Quote identifier.\n\t */\n\tquote: string;\n\t/**\n\t * BOLT12 offer that can be paid to mint tokens.\n\t */\n\trequest: string;\n\t/**\n\t * Requested amount. This is null for amount-less offers.\n\t */\n\tamount: number | null;\n\t/**\n\t * Unit of the amount.\n\t */\n\tunit: string;\n\t/**\n\t * Unix timestamp when quote expires.\n\t */\n\texpiry: number | null;\n\t/**\n\t * Public key that locked this quote.\n\t */\n\tpubkey: string;\n\t/**\n\t * The amount that has been paid to the mint via the bolt12 offer. The difference between this and\n\t * `amount_issued` can be minted.\n\t */\n\tamount_paid: number;\n\t/**\n\t * The amount of ecash that has been issued for the given mint quote.\n\t */\n\tamount_issued: number;\n};\n\n/**\n * Response from the mint after requesting a mint.\n */\nexport type MintResponse = {\n\tsignatures: SerializedBlindedSignature[];\n} & ApiError;\n\n/**\n * Response from mint at /v1/restore endpoint.\n */\nexport type PostRestoreResponse = {\n\toutputs: SerializedBlindedMessage[];\n\tsignatures: SerializedBlindedSignature[];\n};\n\n/**\n * Ecash to other MoE swap method, displayed in @type {GetInfoResponse}\n */\nexport type SwapMethod = {\n\tmethod: string;\n\tunit: string;\n\tmin_amount: number;\n\tmax_amount: number;\n\tdescription?: boolean; //added this for Nutshell =>0.16.4 compatibility, see https://github.com/cashubtc/nutshell/pull/783\n\toptions?: {\n\t\tdescription?: boolean;\n\t};\n};\n\n/**\n * Response from the mint after performing a split action.\n */\nexport type SwapResponse = {\n\t/**\n\t * Represents the outputs after the split.\n\t */\n\tsignatures: SerializedBlindedSignature[];\n} & ApiError;\n\n/**\n * MPP supported methods.\n */\nexport type MPPMethod = {\n\tmethod: string;\n\tunit: string;\n};\n\n/**\n * WebSocket supported methods.\n */\nexport type WebSocketSupport = {\n\tmethod: string;\n\tunit: string;\n\tcommands: string[];\n};\n\n/**\n * Response from the mint after blind auth minting.\n */\nexport type BlindAuthMintResponse = {\n\tsignatures: SerializedBlindedSignature[];\n} & ApiError;\n", "/**\n * This error is thrown when a HTTP response is not 2XX nor a protocol error.\n */\nexport class HttpResponseError extends Error {\n\tstatus: number;\n\tconstructor(message: string, status: number) {\n\t\tsuper(message);\n\t\tthis.status = status;\n\t\tthis.name = 'HttpResponseError';\n\t\tObject.setPrototypeOf(this, HttpResponseError.prototype);\n\t}\n}\n\n/**\n * This error is thrown when a network request fails.\n */\nexport class NetworkError extends Error {\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = 'NetworkError';\n\t\tObject.setPrototypeOf(this, NetworkError.prototype);\n\t}\n}\n\n/**\n * This error is thrown when a [protocol\n * error](https://github.com/cashubtc/nuts/blob/main/00.md#errors) occurs. See error codes\n * [here](https://github.com/cashubtc/nuts/blob/main/error_codes.md).\n */\nexport class MintOperationError extends HttpResponseError {\n\tcode: number;\n\tconstructor(code: number, detail: string) {\n\t\tsuper(detail || 'Unknown mint operation error', 400);\n\t\tthis.code = code;\n\t\tthis.name = 'MintOperationError';\n\t\tObject.setPrototypeOf(this, MintOperationError.prototype);\n\t}\n}\n", "import type { Logger } from './Logger';\n\n// The default logger implementation - does nothing\n/* eslint-disable @typescript-eslint/no-empty-function */\nexport const NULL_LOGGER: Logger = {\n\terror() {},\n\twarn() {},\n\tinfo() {},\n\tdebug() {},\n\ttrace() {},\n\tlog() {},\n};\n/* eslint-enable @typescript-eslint/no-empty-function */\n", "import { type Logger } from './Logger';\nimport { NULL_LOGGER } from './NullLogger';\n\n/**\n * Log at ERROR and throw. Always throws.\n *\n * @param message - Error message to log and throw.\n * @param logger - Logger to use, defaults to NULL_LOGGER.\n * @param context - Optional structured context for the log.\n * @throws {Error} Always throws with the given message.\n */\nexport function fail(\n\tmessage: string,\n\tlogger: Logger = NULL_LOGGER,\n\tcontext?: Record<string, unknown>,\n): never {\n\tlogger.error(message, context);\n\tthrow new Error(message);\n}\n\n/**\n * Throw if a Boolean condition is true. On return, the compiler knows the condition is false.\n *\n * @param condition - Condition that must be false to continue.\n * @param message - Error message if condition is true.\n * @param logger - Logger to use, defaults to NULL_LOGGER.\n * @param context - Optional structured context for the log.\n * @throws {Error} If condition is true, throws with the given message.\n */\nexport function failIf(\n\tcondition: boolean,\n\tmessage: string,\n\tlogger: Logger = NULL_LOGGER,\n\tcontext?: Record<string, unknown>,\n): asserts condition is false {\n\tif (condition) fail(message, logger, context);\n}\n\n/**\n * Throw if a value is null or undefined. Value is narrowed thereafter.\n *\n * @typeParam T - The value type to check.\n * @param value - The value to validate.\n * @param message - Error message if value is nullish.\n * @param logger - Logger to use, defaults to NULL_LOGGER.\n * @param context - Optional structured context for the log.\n * @throws {Error} If value is null or undefined.\n */\nexport function failIfNullish<T>(\n\tvalue: T,\n\tmessage: string,\n\tlogger: Logger = NULL_LOGGER,\n\tcontext?: Record<string, unknown>,\n): asserts value is Exclude<T, null | undefined> {\n\tif (value == null) fail(message, logger, context);\n}\n\n/**\n * Invoke a user-supplied callback safely in a fire-and-forget manner.\n *\n * Used for per-operation hooks (e.g. `onCountersReserved`, `onChangeOutputsCreated`) where user\n * code must never break the wallets control flow. The callback is invoked synchronously,\n * exceptions are caught and logged (as a warning), and then swallowed.\n *\n * The wallet never `await`s the callback.\n *\n * @example\n *\n * ```ts\n * if (autoCounters.used) {\n * \tsafeCallback(onCountersReserved, autoCounters.used, _logger, { keysetId });\n * }\n * ```\n *\n * @typeParam T Type of the payload passed to the callback.\n * @param cb The callback to invoke, or `undefined`.\n * @param payload The payload to pass to the callback.\n * @param logger Logger to use (defaults to NULL_LOGGER).\n * @param context Optional structured context for the log.\n */\nexport function safeCallback<T>(\n\tcb: ((p: T) => void | Promise<void>) | undefined,\n\tpayload: T,\n\tlogger: Logger = NULL_LOGGER,\n\tcontext?: Record<string, unknown>,\n): void {\n\tif (!cb) return;\n\n\ttry {\n\t\tconst maybePromise = cb(payload);\n\t\tif (maybePromise && typeof maybePromise.then === 'function') {\n\t\t\tmaybePromise.catch((error) => {\n\t\t\t\ttry {\n\t\t\t\t\tlogger.warn('callback failed', {\n\t\t\t\t\t\t...(context ?? {}),\n\t\t\t\t\t\terror,\n\t\t\t\t\t\tcb: cb.name ?? '',\n\t\t\t\t\t});\n\t\t\t\t} catch {\n\t\t\t\t\t/* ignore logger errors */\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t} catch (error) {\n\t\ttry {\n\t\t\tlogger.warn('callback failed', {\n\t\t\t\t...(context ?? {}),\n\t\t\t\terror,\n\t\t\t\tcb: cb.name ?? '',\n\t\t\t});\n\t\t} catch {\n\t\t\t/* ignore logger errors */\n\t\t}\n\t}\n}\n", "import { type Logger, type LogLevel } from './Logger';\n\nconst LEVEL_ORDER: Record<LogLevel, number> = {\n\terror: 0,\n\twarn: 1,\n\tinfo: 2,\n\tdebug: 3,\n\ttrace: 4,\n};\n\n/**\n * Outputs messages to the console based on the specified log level.\n *\n * Supports placeholder substitution in messages (e.g., `{key}`) using values from the optional\n * `context` object. Context keys not used in substitution are appended to the output as additional\n * data. Each log message is prefixed with the log level in square brackets (e.g., `[INFO]`).\n *\n * @example Const logger = new ConsoleLogger(LogLevel.DEBUG); logger.info('User {username} logged\n * in', { username: 'alice', ip: '127.0.0.1' }); // Output: [INFO] User alice logged in { ip:\n * \"127.0.0.1\" }\n */\nexport class ConsoleLogger implements Logger {\n\tprivate minLevel: LogLevel;\n\n\tconstructor(minLevel: LogLevel = 'info') {\n\t\tthis.minLevel = minLevel;\n\t}\n\n\tprivate should(level: LogLevel): boolean {\n\t\treturn LEVEL_ORDER[level] <= LEVEL_ORDER[this.minLevel];\n\t}\n\tprivate method(level: LogLevel): (msg: string, ...rest: unknown[]) => void {\n\t\tswitch (level) {\n\t\t\tcase 'error':\n\t\t\t\treturn console.error;\n\t\t\tcase 'warn':\n\t\t\t\treturn console.warn;\n\t\t\tcase 'info':\n\t\t\t\treturn console.info;\n\t\t\tcase 'debug':\n\t\t\t\treturn console.debug;\n\t\t\tcase 'trace':\n\t\t\t\treturn console.trace;\n\t\t\tdefault:\n\t\t\t\treturn console.log;\n\t\t}\n\t}\n\tprivate header(level: LogLevel, message: string): string {\n\t\treturn `[${level.toUpperCase()}] ${message}`;\n\t}\n\tprivate flattenContext(ctx?: Record<string, unknown>): Record<string, unknown> | undefined {\n\t\tif (!ctx) return undefined;\n\t\tconst out: Record<string, unknown> = {};\n\t\tfor (const [k, v] of Object.entries(ctx)) {\n\t\t\tout[k] = v instanceof Error ? { message: v.message, stack: v.stack } : v;\n\t\t}\n\t\treturn out;\n\t}\n\tprivate emit(level: LogLevel, message: string, context?: Record<string, unknown>) {\n\t\tif (!this.should(level)) return;\n\t\tconst line = this.header(level, message);\n\t\tconst ctx = this.flattenContext(context);\n\t\tconst fn = this.method(level);\n\t\tif (ctx && Object.keys(ctx).length) fn(line, ctx);\n\t\telse fn(line);\n\t}\n\n\terror(msg: string, ctx?: Record<string, unknown>) {\n\t\tthis.emit('error', msg, ctx);\n\t}\n\twarn(msg: string, ctx?: Record<string, unknown>) {\n\t\tthis.emit('warn', msg, ctx);\n\t}\n\tinfo(msg: string, ctx?: Record<string, unknown>) {\n\t\tthis.emit('info', msg, ctx);\n\t}\n\tdebug(msg: string, ctx?: Record<string, unknown>) {\n\t\tthis.emit('debug', msg, ctx);\n\t}\n\ttrace(msg: string, ctx?: Record<string, unknown>) {\n\t\tthis.emit('trace', msg, ctx);\n\t}\n\n\tlog(level: LogLevel, message: string, context?: Record<string, unknown>) {\n\t\tthis.emit(level, message, context);\n\t}\n}\n\n/**\n * Creates a timer to measure elapsed time in milliseconds.\n *\n * @example Const timer = measureTime(); // ... some code ... const duration = timer.elapsed();\n *\n * @returns An object with an `elapsed` method to retrieve the duration since the timer started.\n */\nexport function measureTime() {\n\tconst start = Date.now();\n\treturn {\n\t\telapsed: () => {\n\t\t\treturn Date.now() - start;\n\t\t},\n\t};\n}\n", "import { HttpResponseError, NetworkError, MintOperationError } from '../model/Errors';\nimport { type Logger, NULL_LOGGER } from '../logger';\nimport { type ApiError } from '../mint/types/responses';\n\n// Generic request function type so callers can do requestInstance<T>(...)\nexport type RequestFn = <T = unknown>(args: RequestOptions) => Promise<T>;\n\nexport type RequestArgs = {\n\tendpoint: string;\n\trequestBody?: Record<string, unknown>;\n\theaders?: Record<string, string>;\n\tlogger?: Logger;\n};\n\nexport type RequestOptions = RequestArgs & Omit<RequestInit, 'body' | 'headers'>;\n\nlet globalRequestOptions: Partial<RequestOptions> = {};\nlet requestLogger = NULL_LOGGER;\n\n/**\n * An object containing any custom settings that you want to apply to the global fetch method.\n *\n * @param options See possible options here:\n *   https://developer.mozilla.org/en-US/docs/Web/API/fetch#options.\n */\nexport function setGlobalRequestOptions(options: Partial<RequestOptions>): void {\n\tglobalRequestOptions = options;\n}\n\n/**\n * Allows a logger to be set.\n *\n * @param {Logger} logger The logger instance to use.\n */\nexport function setRequestLogger(logger: Logger): void {\n\trequestLogger = logger;\n}\n\nasync function _request({\n\tendpoint,\n\trequestBody,\n\theaders: requestHeaders,\n\t...options\n}: RequestOptions): Promise<unknown> {\n\tconst body = requestBody ? JSON.stringify(requestBody) : undefined;\n\tconst headers = {\n\t\t...{ Accept: 'application/json, text/plain, */*' },\n\t\t...(body ? { 'Content-Type': 'application/json' } : undefined),\n\t\t...requestHeaders,\n\t};\n\n\tlet response: Response;\n\ttry {\n\t\tresponse = await fetch(endpoint, { body, headers, ...options });\n\t} catch (err) {\n\t\t// A fetch() promise only rejects when the request fails,\n\t\t// for example, because of a badly-formed request URL or a network error.\n\t\tthrow new NetworkError(err instanceof Error ? err.message : 'Network request failed');\n\t}\n\n\tif (!response.ok) {\n\t\tlet errorData: ApiError;\n\t\ttry {\n\t\t\terrorData = (await response.json()) as ApiError;\n\t\t} catch {\n\t\t\terrorData = { error: 'bad response' };\n\t\t}\n\n\t\tif (\n\t\t\tresponse.status === 400 &&\n\t\t\t'code' in errorData &&\n\t\t\ttypeof errorData.code === 'number' &&\n\t\t\t'detail' in errorData &&\n\t\t\ttypeof errorData.detail === 'string'\n\t\t) {\n\t\t\tthrow new MintOperationError(errorData.code, errorData.detail);\n\t\t}\n\n\t\tlet errorMessage = 'HTTP request failed';\n\t\tif ('error' in errorData && typeof errorData.error === 'string') {\n\t\t\terrorMessage = errorData.error;\n\t\t} else if ('detail' in errorData && typeof errorData.detail === 'string') {\n\t\t\terrorMessage = errorData.detail;\n\t\t}\n\n\t\tthrow new HttpResponseError(errorMessage, response.status);\n\t}\n\n\ttry {\n\t\treturn await response.json();\n\t} catch (err) {\n\t\trequestLogger.error('Failed to parse HTTP response', { err });\n\t\tthrow new HttpResponseError('bad response', response.status);\n\t}\n}\n\nexport default async function request<T>(options: RequestOptions): Promise<T> {\n\tconst data = await _request({ ...options, ...globalRequestOptions });\n\treturn data as T;\n}\n", "let _WS: typeof WebSocket | undefined;\n\nif (typeof WebSocket !== 'undefined') {\n\t_WS = WebSocket;\n}\n\nexport function injectWebSocketImpl(ws: typeof WebSocket) {\n\t_WS = ws;\n}\n\nexport function getWebSocketImpl() {\n\tif (_WS === undefined) {\n\t\tthrow new Error('WebSocket implementation not initialized');\n\t}\n\treturn _WS;\n}\n", "export class Bytes {\n\tstatic fromHex(hex: string): Uint8Array {\n\t\thex = hex.trim();\n\t\tif (hex.length === 0) {\n\t\t\treturn new Uint8Array(0);\n\t\t}\n\t\tif (hex.length < 2 || hex.length & 1) {\n\t\t\tthrow new Error('Invalid hex string: odd length.');\n\t\t}\n\t\tif (hex.startsWith('0x') || hex.startsWith('0X')) {\n\t\t\thex = hex.slice(2);\n\t\t}\n\t\tconst match = hex.match(/^[0-9a-fA-F]*$/);\n\t\tif (!match) {\n\t\t\tthrow new Error('Invalid hex string: contains non-hex characters');\n\t\t}\n\t\tconst matches = hex.match(/.{1,2}/g);\n\t\tif (!matches) {\n\t\t\tthrow new Error('Invalid hex string');\n\t\t}\n\t\treturn new Uint8Array(matches.map((byte) => parseInt(byte, 16)));\n\t}\n\n\tstatic toHex(bytes: Uint8Array): string {\n\t\treturn Array.from(bytes, (byte) => byte.toString(16).padStart(2, '0')).join('');\n\t}\n\n\tstatic fromString(str: string): Uint8Array {\n\t\tstr = str.trim();\n\t\treturn new TextEncoder().encode(str);\n\t}\n\n\tstatic toString(bytes: Uint8Array): string {\n\t\treturn new TextDecoder('utf-8').decode(bytes);\n\t}\n\n\tstatic concat(...arrays: Uint8Array[]): Uint8Array {\n\t\tconst totalLength = arrays.reduce((sum, arr) => sum + arr.length, 0);\n\t\tconst result = new Uint8Array(totalLength);\n\t\tlet offset = 0;\n\t\tfor (const arr of arrays) {\n\t\t\tresult.set(arr, offset);\n\t\t\toffset += arr.length;\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic alloc(size: number): Uint8Array {\n\t\treturn new Uint8Array(size);\n\t}\n\n\tstatic writeBigUint64BE(value: bigint): Uint8Array {\n\t\tconst buffer = new ArrayBuffer(8);\n\t\tnew DataView(buffer).setBigUint64(0, value, false);\n\t\treturn new Uint8Array(buffer);\n\t}\n\n\tstatic toBase64(bytes: Uint8Array): string {\n\t\tif (typeof Buffer !== 'undefined') {\n\t\t\treturn Buffer.from(bytes).toString('base64');\n\t\t}\n\t\t// preventing stack overflow by chunking\n\t\tif (bytes.length > 32768) {\n\t\t\tlet result = '';\n\t\t\tfor (let i = 0; i < bytes.length; i += 32768) {\n\t\t\t\tconst chunk = bytes.slice(i, i + 32768);\n\t\t\t\tresult += btoa(String.fromCharCode(...chunk));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\treturn btoa(String.fromCharCode(...bytes));\n\t}\n\n\tstatic fromBase64(base64: string): Uint8Array {\n\t\tbase64 = base64.trim();\n\t\t// normalise base64url to base64 and pad\n\t\tlet normalizedBase64 = base64.replace(/-/g, '+').replace(/_/g, '/');\n\t\twhile (normalizedBase64.length % 4) {\n\t\t\tnormalizedBase64 += '=';\n\t\t}\n\t\tif (typeof Buffer !== 'undefined') {\n\t\t\treturn new Uint8Array(Buffer.from(normalizedBase64, 'base64'));\n\t\t}\n\t\treturn new Uint8Array([...atob(normalizedBase64)].map((c) => c.charCodeAt(0)));\n\t}\n\t// NOTE: MUST remain a constant-time implementation (full byte check)\n\t// because callers rely on it (e.g. deriveP2BKSecretKey).\n\tstatic equals(a: Uint8Array, b: Uint8Array): boolean {\n\t\tif (a.length !== b.length) return false;\n\t\tlet result = 0;\n\t\tfor (let i = 0; i < a.length; i++) {\n\t\t\tresult |= a[i] ^ b[i];\n\t\t}\n\t\treturn result === 0;\n\t}\n\n\tstatic compare(a: Uint8Array, b: Uint8Array): number {\n\t\tconst minLength = Math.min(a.length, b.length);\n\t\tfor (let i = 0; i < minLength; i++) {\n\t\t\tif (a[i] < b[i]) return -1;\n\t\t\tif (a[i] > b[i]) return 1;\n\t\t}\n\t\treturn a.length - b.length;\n\t}\n}\n", "import { Bytes } from './Bytes';\n\nfunction encodeUint8toBase64(uint8array: Uint8Array): string {\n\treturn Bytes.toBase64(uint8array);\n}\n\nfunction encodeUint8toBase64Url(bytes: Uint8Array): string {\n\treturn Bytes.toBase64(bytes)\n\t\t.replace(/\\+/g, '-') // Replace + with -\n\t\t.replace(/\\//g, '_') // Replace / with _\n\t\t.replace(/=+$/, ''); // Remove padding characters\n}\n\nfunction encodeBase64toUint8(base64String: string): Uint8Array {\n\treturn Bytes.fromBase64(base64String);\n}\n\nfunction encodeJsonToBase64(jsonObj: unknown): string {\n\tconst jsonString = JSON.stringify(jsonObj);\n\treturn base64urlFromBase64(Bytes.toBase64(Bytes.fromString(jsonString)));\n}\n\nfunction encodeBase64ToJson<T extends object>(base64String: string): T {\n\tconst jsonString = Bytes.toString(Bytes.fromBase64(base64urlToBase64(base64String)));\n\tconst jsonObj = JSON.parse(jsonString) as T;\n\treturn jsonObj;\n}\n\nfunction base64urlToBase64(str: string) {\n\treturn str.replace(/-/g, '+').replace(/_/g, '/').split('=')[0];\n\t// .replace(/./g, '=');\n}\n\nfunction base64urlFromBase64(str: string) {\n\treturn str.replace(/\\+/g, '-').replace(/\\//g, '_').split('=')[0];\n\t// .replace(/=/g, '.');\n}\n\nfunction isBase64String(s: string): boolean {\n\tif (typeof s !== 'string' || s.length === 0) return false;\n\n\t// Accept both base64 and base64url char sets\n\tconst base64url = /^[A-Za-z0-9\\-_]+={0,2}$/;\n\tconst base64 = /^[A-Za-z0-9+/]+={0,2}$/;\n\n\t// Quick character-set check\n\tif (!base64url.test(s) && !base64.test(s)) return false;\n\n\t// Normalize base64url to standard base64 for decoding\n\tconst normalized = s.replace(/-/g, '+').replace(/_/g, '/');\n\n\t// Padding: length must be multiple of 4. Add '=' padding if needed (but no more than 2)\n\tconst padLength = (4 - (normalized.length % 4)) % 4;\n\tif (padLength > 2) return false; // should never happen but keep safe\n\tconst padded = normalized + '='.repeat(padLength);\n\n\ttry {\n\t\tconst decoded = Bytes.fromBase64(padded);\n\n\t\t// Re-encode and compare to the original (allowing either standard or url-safe representation)\n\t\tconst reStandard = Bytes.toBase64(decoded);\n\t\tconst reUrl = reStandard.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n\n\t\t// Also compare against original normalized-without-padding variant\n\t\tconst originalNoPad = normalized.replace(/=+$/, '');\n\n\t\tif (reStandard.replace(/=+$/, '') === originalNoPad) return true;\n\t\tif (reUrl === originalNoPad) return true;\n\n\t\treturn false;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\nexport {\n\tencodeUint8toBase64,\n\tencodeUint8toBase64Url,\n\tencodeBase64toUint8,\n\tencodeJsonToBase64,\n\tencodeBase64ToJson,\n\tisBase64String,\n};\n", "/*\n * Lightweight CBOR encoder/decoder (purpose and limitations)\n *\n * Supported\n * - Major types: 0 (unsigned), 1 (negative), 2 (byte string), 3 (text string),\n *   4 (array), 5 (map), 7 (simple values & floats).\n * - Additional-info lengths: short (0..23), 1-, 2- and 4-byte length forms are\n *   encoded by the encoder. The decoder understands 8-byte length fields\n *   (additional-info 27) and will decode them into a JavaScript Number\n *   (hi * 2**32 + lo) but the encoder intentionally does not emit 8-byte\n *   integer forms (see 'Not implemented' below).\n * - Floating point: decoder supports float16/float32/float64. Encoder emits\n *   float64 for non-integers.\n * - Guardrails: explicit throws for unsupported types and sizes (e.g. huge\n *   strings/byte arrays/arrays/maps > 2**32-1, integers larger than 32-bit for\n *   encoding). DataView out-of-bounds reads are normalized to\n *   \"Unexpected end of data\" for clearer errors.\n *\n * Not implemented / intentionally out of scope\n * - Indefinite-length (streaming) containers (indefinite-length arrays,\n *   maps, byte/text strings) are not supported. Test vectors with streaming\n *   markers are skipped in the test harness.\n * - Semantic tags (major type 6) are not interpreted; tagged values are\n *   skipped in encode-roundtrip tests. Implementing tags should return a\n *   wrapper object or otherwise surface the tag + value.\n * - Big integers / bignum handling: this implementation does not return\n *   BigInt for values outside Number.isSafeInteger nor emit CBOR bignum tags\n *   (tag 2/3). Decode may parse 8-byte unsigned/negative integers into a\n *   Number which can overflow JS precision; callers who need accurate bignum\n *   support should add BigInt decoding and encoder support.\n * - Encoder does not emit float16/float32 or 8-byte integer (additional-info\n *   27) forms. It intentionally limits integer encoding to <= 32-bit and\n *   uses float64 for non-integers to keep the implementation small.\n *\n * Guidance for contributors\n * - To add streaming support, implement indefinite-length decoders that\n *   concatenate chunks until the break byte (0xff) and update decodeItem\n *   accordingly.\n * - To add BigInt/bignum support, change decode paths to return BigInt when\n *   required, add fixture representation for BigInt in tests, and emit proper\n *   tag-2/3 bignum encodings or 8-byte integer forms in the encoder.\n */\n\n/* Reference: CBOR specification (RFC 8949) https://www.rfc-editor.org/rfc/rfc8949.html */\n\ntype SimpleValue = boolean | null | undefined;\n\nexport type ResultObject = { [key: string]: ResultValue };\nexport type ResultValue = SimpleValue | number | string | Uint8Array | ResultValue[] | ResultObject;\n\ntype ResultKeyType = Extract<ResultValue, number | string>;\nexport type ValidDecodedType = Extract<ResultValue, ResultObject>;\n\nfunction isResultKeyType(value: ResultValue): value is ResultKeyType {\n\treturn typeof value === 'number' || typeof value === 'string';\n}\n\ntype DecodeResult<T extends ResultValue> = {\n\tvalue: T;\n\toffset: number;\n};\n\nexport function encodeCBOR(value: unknown): Uint8Array {\n\tconst buffer: number[] = [];\n\tencodeItem(value, buffer);\n\treturn new Uint8Array(buffer);\n}\n\nfunction encodeItem(value: unknown, buffer: number[]) {\n\tif (value === null) {\n\t\tbuffer.push(0xf6);\n\t} else if (value === undefined) {\n\t\tbuffer.push(0xf7);\n\t} else if (typeof value === 'boolean') {\n\t\tbuffer.push(value ? 0xf5 : 0xf4);\n\t} else if (typeof value === 'number') {\n\t\tencodeNumber(value, buffer);\n\t} else if (typeof value === 'string') {\n\t\tencodeString(value, buffer);\n\t} else if (Array.isArray(value)) {\n\t\tencodeArray(value, buffer);\n\t} else if (value instanceof Uint8Array) {\n\t\tencodeByteString(value, buffer);\n\t} else if (\n\t\t// Defensive: POJO only (null/array handled above)\n\t\ttypeof value === 'object' &&\n\t\tvalue !== null &&\n\t\t!Array.isArray(value)\n\t) {\n\t\tencodeObject(value as Record<string, unknown>, buffer);\n\t} else {\n\t\tthrow new Error('Unsupported type');\n\t}\n}\n\nfunction encodeUnsigned(value: number, buffer: number[]) {\n\tif (value < 24) {\n\t\tbuffer.push(value);\n\t} else if (value < 256) {\n\t\tbuffer.push(0x18, value);\n\t} else if (value < 65536) {\n\t\tbuffer.push(0x19, (value >>> 8) & 0xff, value & 0xff);\n\t} else if (value < 4294967296) {\n\t\tbuffer.push(\n\t\t\t0x1a,\n\t\t\t(value >>> 24) & 0xff,\n\t\t\t(value >>> 16) & 0xff,\n\t\t\t(value >>> 8) & 0xff,\n\t\t\tvalue & 0xff,\n\t\t);\n\t} else {\n\t\tthrow new Error('Unsupported integer size');\n\t}\n}\n\nfunction encodeSigned(value: number, buffer: number[]) {\n\t// CBOR negative integer encoding: store -1 - value as unsigned under major type 1\n\tconst unsigned = -1 - value;\n\tif (unsigned < 24) {\n\t\tbuffer.push(0x20 | unsigned);\n\t} else if (unsigned < 256) {\n\t\tbuffer.push(0x38, unsigned & 0xff);\n\t} else if (unsigned < 65536) {\n\t\tbuffer.push(0x39, (unsigned >>> 8) & 0xff, unsigned & 0xff);\n\t} else if (unsigned < 4294967296) {\n\t\tbuffer.push(\n\t\t\t0x3a,\n\t\t\t(unsigned >>> 24) & 0xff,\n\t\t\t(unsigned >>> 16) & 0xff,\n\t\t\t(unsigned >>> 8) & 0xff,\n\t\t\tunsigned & 0xff,\n\t\t);\n\t} else {\n\t\tthrow new Error('Unsupported integer size');\n\t}\n}\n\nfunction encodeFloat64(value: number, buffer: number[]) {\n\t// major type 7, additional info 27 (0xfb) followed by 8 bytes IEEE 754 big-endian\n\tconst ab = new ArrayBuffer(8);\n\tconst dv = new DataView(ab);\n\tdv.setFloat64(0, value, false);\n\tbuffer.push(0xfb);\n\tfor (let i = 0; i < 8; i++) buffer.push(dv.getUint8(i));\n}\n\nfunction encodeNumber(value: number, buffer: number[]) {\n\tif (Number.isInteger(value)) {\n\t\tif (value >= 0) {\n\t\t\t// unsigned\n\t\t\tencodeUnsigned(value, buffer);\n\t\t} else {\n\t\t\t// negative integer\n\t\t\tencodeSigned(value, buffer);\n\t\t}\n\t} else {\n\t\t// encode non-integer numbers as float64 for simplicity\n\t\tencodeFloat64(value, buffer);\n\t}\n}\n\nfunction encodeByteString(value: Uint8Array, buffer: number[]) {\n\tconst length = value.length;\n\n\tif (length < 24) {\n\t\tbuffer.push(0x40 + length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0x58, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0x59, (length >> 8) & 0xff, length & 0xff);\n\t} else if (length < 4294967296) {\n\t\tbuffer.push(\n\t\t\t0x5a,\n\t\t\t(length >>> 24) & 0xff,\n\t\t\t(length >>> 16) & 0xff,\n\t\t\t(length >>> 8) & 0xff,\n\t\t\tlength & 0xff,\n\t\t);\n\t} else {\n\t\tthrow new Error('Byte string too long to encode');\n\t}\n\n\tfor (let i = 0; i < value.length; i++) {\n\t\tbuffer.push(value[i]);\n\t}\n}\n\nfunction encodeString(value: string, buffer: number[]) {\n\tconst utf8 = new TextEncoder().encode(value);\n\tconst length = utf8.length;\n\n\tif (length < 24) {\n\t\tbuffer.push(0x60 + length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0x78, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0x79, (length >>> 8) & 0xff, length & 0xff);\n\t} else if (length < 4294967296) {\n\t\tbuffer.push(\n\t\t\t0x7a,\n\t\t\t(length >>> 24) & 0xff,\n\t\t\t(length >>> 16) & 0xff,\n\t\t\t(length >>> 8) & 0xff,\n\t\t\tlength & 0xff,\n\t\t);\n\t} else {\n\t\tthrow new Error('String too long to encode');\n\t}\n\n\tfor (let i = 0; i < utf8.length; i++) {\n\t\tbuffer.push(utf8[i]);\n\t}\n}\n\nfunction encodeArray(value: unknown[], buffer: number[]) {\n\tconst length = value.length;\n\tif (length < 24) {\n\t\tbuffer.push(0x80 | length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0x98, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0x99, (length >>> 8) & 0xff, length & 0xff);\n\t} else {\n\t\tthrow new Error('Unsupported array length');\n\t}\n\n\tfor (const item of value) {\n\t\tencodeItem(item, buffer);\n\t}\n}\n\nfunction encodeObject(value: Record<string, unknown>, buffer: number[]) {\n\tconst keys = Object.keys(value);\n\tconst length = keys.length;\n\n\t// Guardrail: we only support map lengths up to 2^32-1 (same as encodeUnsigned max)\n\tif (length >= 4294967296) {\n\t\tthrow new Error('Object has too many keys to encode');\n\t}\n\n\t// Write initial byte for major type 5 (map) and additional info based on length\n\tif (length < 24) {\n\t\tbuffer.push(0xa0 | length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0xb8, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0xb9, (length >> 8) & 0xff, length & 0xff);\n\t} else {\n\t\tbuffer.push(\n\t\t\t0xba,\n\t\t\t(length >> 24) & 0xff,\n\t\t\t(length >> 16) & 0xff,\n\t\t\t(length >> 8) & 0xff,\n\t\t\tlength & 0xff,\n\t\t);\n\t}\n\tfor (const key of keys) {\n\t\tencodeString(key, buffer);\n\t\tencodeItem(value[key], buffer);\n\t}\n}\n\nexport function decodeCBOR(data: Uint8Array): ResultValue {\n\tconst view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n\tconst result = decodeItem(view, 0);\n\treturn result.value;\n}\n\nfunction decodeItem(view: DataView, offset: number): DecodeResult<ResultValue> {\n\tif (offset >= view.byteLength) {\n\t\tthrow new Error('Unexpected end of data');\n\t}\n\tconst initialByte = view.getUint8(offset++);\n\tconst majorType = initialByte >> 5;\n\tconst additionalInfo = initialByte & 0x1f;\n\n\tswitch (majorType) {\n\t\tcase 0:\n\t\t\treturn decodeUnsigned(view, offset, additionalInfo);\n\t\tcase 1:\n\t\t\treturn decodeSigned(view, offset, additionalInfo);\n\t\tcase 2:\n\t\t\treturn decodeByteString(view, offset, additionalInfo);\n\t\tcase 3:\n\t\t\treturn decodeString(view, offset, additionalInfo);\n\t\tcase 4:\n\t\t\treturn decodeArray(view, offset, additionalInfo);\n\t\tcase 5:\n\t\t\treturn decodeMap(view, offset, additionalInfo);\n\t\tcase 7:\n\t\t\treturn decodeSimpleAndFloat(view, offset, additionalInfo);\n\t\tdefault:\n\t\t\tthrow new Error(`Unsupported major type: ${majorType}`);\n\t}\n}\n\nfunction ensureAvailable(view: DataView, offset: number, needed: number) {\n\tif (offset + needed > view.byteLength) {\n\t\tthrow new Error('Unexpected end of data');\n\t}\n}\n\nfunction decodeLength(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<number> {\n\tif (additionalInfo < 24) return { value: additionalInfo, offset };\n\tif (additionalInfo === 24) {\n\t\tensureAvailable(view, offset, 1);\n\t\treturn { value: view.getUint8(offset++), offset };\n\t}\n\tif (additionalInfo === 25) {\n\t\tensureAvailable(view, offset, 2);\n\t\tconst value = view.getUint16(offset, false);\n\t\toffset += 2;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 26) {\n\t\tensureAvailable(view, offset, 4);\n\t\tconst value = view.getUint32(offset, false);\n\t\toffset += 4;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 27) {\n\t\tensureAvailable(view, offset, 8);\n\t\tconst hi = view.getUint32(offset, false);\n\t\tconst lo = view.getUint32(offset + 4, false);\n\t\toffset += 8;\n\t\treturn { value: hi * 2 ** 32 + lo, offset };\n\t}\n\tthrow new Error(`Unsupported length: ${additionalInfo}`);\n}\n\nfunction decodeUnsigned(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<number> {\n\tconst { value, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\treturn { value, offset: newOffset };\n}\n\nfunction decodeSigned(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<number> {\n\tconst { value, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\treturn { value: -1 - value, offset: newOffset };\n}\n\nfunction decodeByteString(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<Uint8Array> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tif (newOffset + length > view.byteLength) {\n\t\tthrow new Error('Byte string length exceeds data length');\n\t}\n\tconst value = new Uint8Array(view.buffer, view.byteOffset + newOffset, length);\n\treturn { value, offset: newOffset + length };\n}\n\nfunction decodeString(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<string> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tif (newOffset + length > view.byteLength) {\n\t\tthrow new Error('String length exceeds data length');\n\t}\n\tconst bytes = new Uint8Array(view.buffer, view.byteOffset + newOffset, length);\n\tconst value = new TextDecoder().decode(bytes);\n\treturn { value, offset: newOffset + length };\n}\n\nfunction decodeArray(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<ResultValue[]> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tconst array = [];\n\tlet currentOffset = newOffset;\n\tfor (let i = 0; i < length; i++) {\n\t\tconst result = decodeItem(view, currentOffset);\n\t\tarray.push(result.value);\n\t\tcurrentOffset = result.offset;\n\t}\n\treturn { value: array, offset: currentOffset };\n}\n\nfunction decodeMap(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<Record<string, ResultValue>> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tconst map: { [key: string]: ResultValue } = {};\n\tlet currentOffset = newOffset;\n\tfor (let i = 0; i < length; i++) {\n\t\tconst keyResult = decodeItem(view, currentOffset);\n\t\tif (!isResultKeyType(keyResult.value)) {\n\t\t\tthrow new Error('Invalid key type');\n\t\t}\n\t\tconst valueResult = decodeItem(view, keyResult.offset);\n\t\tmap[keyResult.value] = valueResult.value;\n\t\tcurrentOffset = valueResult.offset;\n\t}\n\treturn { value: map, offset: currentOffset };\n}\n\nfunction decodeFloat16(uint16: number): number {\n\tconst exponent = (uint16 & 0x7c00) >> 10;\n\tconst fraction = uint16 & 0x03ff;\n\tconst sign = uint16 & 0x8000 ? -1 : 1;\n\n\tif (exponent === 0) {\n\t\treturn sign * 2 ** -14 * (fraction / 1024);\n\t} else if (exponent === 0x1f) {\n\t\treturn fraction ? NaN : sign * Infinity;\n\t}\n\treturn sign * 2 ** (exponent - 15) * (1 + fraction / 1024);\n}\n\nfunction decodeSimpleAndFloat(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<SimpleValue | number> {\n\tif (additionalInfo < 24) {\n\t\tswitch (additionalInfo) {\n\t\t\tcase 20:\n\t\t\t\treturn { value: false, offset };\n\t\t\tcase 21:\n\t\t\t\treturn { value: true, offset };\n\t\t\tcase 22:\n\t\t\t\treturn { value: null, offset };\n\t\t\tcase 23:\n\t\t\t\treturn { value: undefined, offset };\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown simple value: ${additionalInfo}`);\n\t\t}\n\t}\n\tif (additionalInfo === 24) {\n\t\tensureAvailable(view, offset, 1);\n\t\treturn { value: view.getUint8(offset++), offset };\n\t}\n\tif (additionalInfo === 25) {\n\t\tensureAvailable(view, offset, 2);\n\t\tconst value = decodeFloat16(view.getUint16(offset, false));\n\t\toffset += 2;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 26) {\n\t\tensureAvailable(view, offset, 4);\n\t\tconst value = view.getFloat32(offset, false);\n\t\toffset += 4;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 27) {\n\t\tensureAvailable(view, offset, 8);\n\t\tconst value = view.getFloat64(offset, false);\n\t\toffset += 8;\n\t\treturn { value, offset };\n\t}\n\tthrow new Error(`Unknown simple or float value: ${additionalInfo}`);\n}\n", "import { secp256k1 } from '@noble/curves/secp256k1';\nimport { Bytes, bytesToNumber, hexToNumber, numberToHexPadded64 } from '../utils';\nimport { pointFromHex } from './core';\nimport { bytesToHex, hexToBytes, utf8ToBytes } from '@noble/hashes/utils';\nimport { sha256 } from '@noble/hashes/sha2';\nimport { type WeierstrassPoint } from '@noble/curves/abstract/weierstrass';\n\n/**\n * BIP340-style domain separation tag (DST) for P2BK.\n *\n * @alpha\n */\nexport const P2BK_DST = utf8ToBytes('Cashu_P2BK_v1');\n\n/**\n * Blind a sequence of public keys using ECDH derived tweaks, one tweak per slot.\n *\n * @remarks\n * Security note: \"Ehex\" must never be reused. Doing so would create linkability and leak privacy.\n * The only exception is for SIG_ALL proofs, as all secret tags must match.\n *\n * This is the Sender side API.\n * @param pubkeys Ordered SEC1 compressed pubkeys, [data, ...pubkeys, ...refund]\n * @param keysetId Hex keyset identifier, bound into the tweak.\n * @param eBytes Optional. Fixed ephemeral secret key to use (eg for SIG_ALL / testing)\n * @returns Blinded pubkeys in the same order, and Ehex as SEC1 compressed hex, 33 bytes.\n * @throws If a blinded key is at infinity.\n * @alpha\n */\nexport function deriveP2BKBlindedPubkeys(\n\tpubkeys: string[],\n\tkeysetId: string,\n\teBytes?: Uint8Array,\n): { blinded: string[]; Ehex: string } {\n\tif (!pubkeys.length) return { blinded: [], Ehex: '' };\n\t// Create fresh ephemeral secret (e) if not supplied, and calculate pubkey (E)\n\teBytes = eBytes ?? secp256k1.utils.randomSecretKey(); // 32 bytes\n\tconst e = secp256k1.Point.Fn.fromBytes(eBytes); // bigint in [1..n-1]\n\tconst E = secp256k1.getPublicKey(eBytes, true); // SEC1 compressed (bytes)\n\tconst kid = hexToBytes(keysetId);\n\t// Blind each pubkey in turn\n\tconst blinded = pubkeys.map((pubkey, i) => {\n\t\tconst P = pointFromHex(pubkey);\n\t\tconst r = deriveP2BKBlindingTweakFromECDH(P, e, kid, i);\n\t\tconst P_ = P.add(secp256k1.Point.BASE.multiply(r));\n\t\tif (P_.equals(secp256k1.Point.ZERO)) throw new Error('Blinded key at infinity');\n\t\treturn P_.toHex(true);\n\t});\n\treturn { blinded, Ehex: bytesToHex(E) };\n}\n\n/**\n * Derive blinded secret keys that correspond to given P2BK blinded pubkeys.\n *\n * Pubkeys are processed in order, for a proof that is [data, ...pubkeys, ...refund]. Private key\n * order does not matter.\n *\n * @remarks\n * Security note, this operates on long lived secrets. JavaScript BigInt arithmetic in a JIT is not\n * guaranteed constant time. Do not expose this function on a server that holds private keys.\n *\n * This is the Receiver side API.\n * @param Ehex Ephemeral public key (E) as SEC1 hex.\n * @param privateKey Secret key or array of secret keys, hex.\n * @param blindPubKey Blinded public key or array of blinded public keys, hex.\n * @param keysetIdHex Keyset identifier as hex.\n * @returns Array of derived secret keys as 64 char hex.\n * @alpha\n */\nexport function deriveP2BKSecretKeys(\n\tEhex: string,\n\tprivateKey: string | string[],\n\tblindPubKey: string | string[],\n\tkeysetIdHex: string,\n): string[] {\n\tconst privs = Array.isArray(privateKey) ? privateKey : [privateKey];\n\tconst pubs = Array.isArray(blindPubKey) ? blindPubKey : [blindPubKey];\n\tconst out = new Set<string>();\n\tconst E = secp256k1.Point.fromHex(Ehex);\n\tconst kid = hexToBytes(keysetIdHex);\n\tfor (const privHex of privs) {\n\t\tconst p = secp256k1.Point.Fn.fromBytes(hexToBytes(privHex));\n\t\tconst P = secp256k1.getPublicKey(hexToBytes(privHex), true); // 33 bytes, validates on curve\n\t\tpubs.forEach((hexP_, i) => {\n\t\t\tconst r = deriveP2BKBlindingTweakFromECDH(E, p, kid, i);\n\t\t\tconst P_ = hexToBytes(hexP_);\n\t\t\tconst kHex = deriveP2BKSecretKey(privHex, r, P_, P);\n\t\t\tif (kHex) out.add(kHex); // add only when this priv matches this P\n\t\t});\n\t}\n\treturn Array.from(out);\n}\n\n/**\n * Derive a blinded secret key per NUT-26.\n *\n * Unblinds the pubkey (P = P_ - rG), verifies x-coord against the naturalPub x(P) == x(pG), then\n * choose skStd = (p + r) mod n if parity(P) == parity(pG), otherwise skNeg = (-p + r) mod n.\n * Returns skStd if no blindPubkey is provided.\n *\n * @remarks\n * Security note, this operates on long lived secrets. JavaScript BigInt arithmetic in a JIT is not\n * guaranteed constant time. Do not expose this function on a server that holds private keys.\n * @param privkey Unblinded private key (p), hex or bigint.\n * @param rBlind Blinding scalar (r), hex or bigint.\n * @param blindPubkey Optional. Blinded pubkey (P_) to match, 33 byte hex.\n * @param naturalPub Optional. Pubkey calculated from private key (P = pG), 33 byte hex.\n * @returns Derived blinded secret key as 64 char hex.\n * @throws If inputs are out of range, or the derived key would be zero.\n * @alpha\n */\nexport function deriveP2BKSecretKey(\n\tprivkey: string | bigint,\n\trBlind: string | bigint,\n\tblindPubkey?: Uint8Array,\n\tnaturalPub?: Uint8Array,\n): string | null {\n\t// Implementation note: must keep algorithmic constant time!\n\tconst n = secp256k1.Point.CURVE().n;\n\tconst p = typeof privkey === 'string' ? hexToNumber(privkey) : privkey;\n\tconst r = typeof rBlind === 'string' ? hexToNumber(rBlind) : rBlind;\n\tif (p <= 0n || p >= n) throw new Error('Invalid private key');\n\tif (r <= 0n || r >= n) throw new Error('Invalid scalar r');\n\t// If caller didn't provide P = pG, compute it in compressed form (33 bytes)\n\tnaturalPub = naturalPub ?? secp256k1.Point.BASE.multiply(p).toBytes(true);\n\tif (naturalPub.length !== 33) throw new Error('naturalPub must be 33 bytes');\n\t// Calculate both sk candidates for constant time (add/subtract is cheap)\n\tconst skStd: bigint = (p + r) % n;\n\tconst skNeg: bigint = (n - p + r) % n;\n\t// Return skStd if no blinded pubkey was provided to verify against\n\tif (!blindPubkey) {\n\t\tif (skStd === 0n) throw new Error('Derived secret key is zero');\n\t\treturn numberToHexPadded64(skStd);\n\t}\n\tif (blindPubkey.length !== 33) throw new Error('blindPubkey must be 33 bytes');\n\t// Decode P, compute R and unblind\n\tconst P_ = secp256k1.Point.fromHex(blindPubkey); // valid point\n\tconst R = secp256k1.Point.BASE.multiply(r); // R = rG\n\tconst P = P_.subtract(R); // P = P_ - R\n\tif (P.equals(secp256k1.Point.ZERO)) return null;\n\t// Check x only equality, using constant time compare\n\tconst xP = P.toBytes(true).slice(1);\n\tconst xNaturalPub = naturalPub.slice(1);\n\tif (!Bytes.equals(xP, xNaturalPub)) {\n\t\treturn null; // this P' is not for this privkey\n\t}\n\t// Select by parity, comparing the low bit only\n\tconst yP = P.toBytes(true)[0] & 1;\n\tconst yNaturalPub = naturalPub[0] & 1;\n\tconst out = yP === yNaturalPub ? skStd : skNeg;\n\tif (out === 0n) throw new Error('Derived secret key is zero');\n\treturn numberToHexPadded64(out);\n}\n\n/**\n * Internal helper, derive P2BK blinding tweak using ECDH.\n *\n * @remarks\n * Computes the shared point Z = scalarpoint, takes its 32 byte x coordinate Zx, then derives:\n *\n *     r = SHA - 256(P2BK_DST || Zx || keysetId || i); // all inputs as raw bytes\n *\n * If the result reduces to zero, or is >= curve order (n), retries once with an extra 0xff byte\n * appended to the message. Throws if the retry also reduces to zero.\n *\n * This function is symmetric. It can be called with either.\n *\n * - The receiver's private key (p) and the sender's ephemeral public key (E)\n * - The sender's ephemeral secret (e) and the receiver's public key (P)\n *\n * Both yield the same Z and therefore the same r thanks to the magic of ECDH!\n * @param point Ephemeral public key (E) or recipient public key (P)\n * @param scalar Private scalar (p) or ephemeral scalar (e) in [1, n  1]\n * @param keysetId Keyset identifier as raw bytes.\n * @param slotIndex Zero based slot index, only lowest 8 bits (0255) are used.\n * @returns Tweak (r) in [1, n  1]\n * @throws If r reduces to zero after the retry.\n * @alpha\n */\nfunction deriveP2BKBlindingTweakFromECDH(\n\tpoint: WeierstrassPoint<bigint>, // E or P\n\tscalar: bigint, // p or e\n\tkeysetId: Uint8Array, // kid\n\tslotIndex: number, // i\n): bigint {\n\t// Calculate x-only ECDH shared point (Zx)\n\tconst Zx = point.multiply(scalar).toBytes(true).slice(1);\n\tconst iByte = new Uint8Array([slotIndex & 0xff]);\n\t// Derive deterministic blinding factor (r):\n\tlet r = bytesToNumber(sha256(Bytes.concat(P2BK_DST, Zx, keysetId, iByte)));\n\tif (r === 0n || r >= secp256k1.Point.CURVE().n) {\n\t\t// Very unlikely to get here!\n\t\tr = bytesToNumber(sha256(Bytes.concat(P2BK_DST, Zx, keysetId, iByte, new Uint8Array([0xff]))));\n\t\tif (r === 0n || r >= secp256k1.Point.CURVE().n) {\n\t\t\tthrow new Error('P2BK: tweak derivation failed');\n\t\t}\n\t}\n\treturn r;\n}\n", "import { type PrivKey, bytesToHex, hexToBytes, randomBytes } from '@noble/curves/utils';\nimport { sha256 } from '@noble/hashes/sha2';\nimport { schnorr } from '@noble/curves/secp256k1';\nimport { type P2PKWitness, type Proof } from '../model/types';\nimport { type BlindedMessage } from './core';\nimport { deriveP2BKSecretKeys } from './NUT26';\nimport { type Logger, NULL_LOGGER } from '../logger';\n\nexport type SigFlag = 'SIG_INPUTS' | 'SIG_ALL';\n\nexport type Secret = [WellKnownSecret, SecretData];\n\nexport type WellKnownSecret = 'P2PK';\n\nexport type SecretData = {\n\tnonce: string;\n\tdata: string;\n\ttags?: string[][];\n};\n\nexport const createP2PKsecret = (pubkey: string): string => {\n\tconst newSecret: Secret = [\n\t\t'P2PK',\n\t\t{\n\t\t\tnonce: bytesToHex(randomBytes(32)),\n\t\t\tdata: pubkey,\n\t\t},\n\t];\n\treturn JSON.stringify(newSecret);\n};\n\nexport const parseP2PKSecret = (secret: string | Uint8Array): Secret => {\n\ttry {\n\t\tif (secret instanceof Uint8Array) {\n\t\t\tsecret = new TextDecoder().decode(secret);\n\t\t}\n\t\treturn JSON.parse(secret) as Secret;\n\t} catch {\n\t\tthrow new Error(\"can't parse secret\");\n\t}\n};\n\n/**\n * Signs a P2PK secret using Schnorr.\n *\n * @remarks\n * Signatures are non-deterministic because schnorr.sign() generates a new random auxiliary value\n * (auxRand) each time it is called.\n */\nexport const signP2PKSecret = (secret: string, privateKey: PrivKey): string => {\n\tconst msghash = sha256(secret);\n\tconst sig = schnorr.sign(msghash, privateKey); // auxRand is random by default\n\treturn bytesToHex(sig);\n};\n\nexport const signBlindedMessage = (B_: string, privateKey: PrivKey): string => {\n\tconst msgHash = sha256(B_);\n\tconst sig = schnorr.sign(msgHash, privateKey);\n\treturn bytesToHex(sig);\n};\n\n/**\n * Verifies a Schnorr signature on a P2PK secret.\n *\n * @param signature - The Schnorr signature (hex-encoded).\n * @param secret - The Secret to verify.\n * @param pubkey - The Cashu P2PK public key (hex-encoded, X-only or with 02/03 prefix).\n * @returns {boolean} True if the signature is valid, false otherwise.\n */\nexport const verifyP2PKSecretSignature = (\n\tsignature: string,\n\tsecret: string,\n\tpubkey: string,\n): boolean => {\n\ttry {\n\t\tconst msghash = sha256(secret);\n\t\t// Use X-only pubkey: strip 02/03 prefix if pubkey is 66 hex chars (33 bytes)\n\t\tconst pubkeyX = pubkey.length === 66 ? pubkey.slice(2) : pubkey;\n\t\tif (schnorr.verify(signature, msghash, hexToBytes(pubkeyX))) {\n\t\t\treturn true;\n\t\t}\n\t} catch (e) {\n\t\tconsole.error('verifyP2PKsecret error:', e);\n\t}\n\treturn false; // no bueno\n};\n\n/**\n * Verifies a pubkey has signed a P2PK Proof.\n *\n * @param pubkey - The Cashu P2PK public key (hex-encoded, X-only or with 02/03 prefix).\n * @param proof - A Cashu proof.\n * @returns {boolean} True if one of the signatures is theirs, false otherwise.\n */\nexport const hasP2PKSignedProof = (pubkey: string, proof: Proof): boolean => {\n\tif (!proof.witness) {\n\t\treturn false;\n\t}\n\tconst signatures = getP2PKWitnessSignatures(proof.witness);\n\t// See if any of the signatures belong to this pubkey. We need to do this\n\t// as Schnorr signatures are non-deterministic (see: signP2PKSecret)\n\treturn signatures.some((sig) => {\n\t\ttry {\n\t\t\treturn verifyP2PKSecretSignature(sig, proof.secret, pubkey);\n\t\t} catch {\n\t\t\treturn false; // Invalid signature, treat as not signed\n\t\t}\n\t});\n};\n\n/**\n * Returns the expected witness public keys from a NUT-11 P2PK secret.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {array} With the public keys or empty array.\n */\nexport function getP2PKExpectedKWitnessPubkeys(secretStr: string | Secret): string[] {\n\ttry {\n\t\t// Validate secret\n\t\tconst secret: Secret = typeof secretStr === 'string' ? parseP2PKSecret(secretStr) : secretStr;\n\t\tif (secret[0] !== 'P2PK') {\n\t\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t\t}\n\t\tconst now = Math.floor(Date.now() / 1000);\n\t\tconst locktime = getP2PKLocktime(secret);\n\t\tif (locktime > now) {\n\t\t\t// Am interpretting NUT-11 as intending pubkeys to be usable for a\n\t\t\t// 1-of-m multisig if provided, even if n_sigs is not set\n\t\t\treturn getP2PKWitnessPubkeys(secret);\n\t\t}\n\t\treturn getP2PKWitnessRefundkeys(secret);\n\t} catch {\n\t\t// do nothing\n\t}\n\treturn []; // Unlocked, malformed or expired with no refund keys\n}\n\n/**\n * Returns ALL locktime witnesses from a NUT-11 P2PK secret NB: Does not specify if they are\n * expected to sign - see: getP2PKExpectedKWitnessPubkeys()\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {array} With the public key(s or empty array.\n */\nexport function getP2PKWitnessPubkeys(secretStr: string | Secret): string[] {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseP2PKSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\tconst { data, tags } = secret[1];\n\tconst pubkeysTag = tags && tags.find((tag) => tag[0] === 'pubkeys');\n\tconst pubkeys = pubkeysTag && pubkeysTag.length > 1 ? pubkeysTag.slice(1) : [];\n\treturn [data, ...pubkeys].filter(Boolean);\n}\n\n/**\n * Returns ALL refund witnesses from a NUT-11 P2PK secret NB: Does not specify if they are expected\n * to sign - see: getP2PKExpectedKWitnessPubkeys()\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {array} With the public keys or empty array.\n */\nexport function getP2PKWitnessRefundkeys(secretStr: string | Secret): string[] {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseP2PKSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\tconst { tags } = secret[1];\n\tconst refundTag = tags && tags.find((tag) => tag[0] === 'refund');\n\treturn refundTag && refundTag.length > 1 ? refundTag.slice(1).filter(Boolean) : [];\n}\n\n/**\n * Returns the locktime from a NUT-11 P2PK secret or Infinity if no locktime.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {number} The locktime unix timestamp or Infinity (permanent lock)\n */\nexport function getP2PKLocktime(secretStr: string | Secret): number {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseP2PKSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\tconst { tags } = secret[1];\n\tconst locktimeTag = tags && tags.find((tag) => tag[0] === 'locktime');\n\treturn locktimeTag && locktimeTag.length > 1 ? parseInt(locktimeTag[1], 10) : Infinity; // Permanent lock if not set\n}\n\n/**\n * Returns the number of signatures required from a NUT-11 P2PK secret.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {number} The number of signatories (n_sigs / n_sigs_refund) or 0 if secret is unlocked.\n */\nexport function getP2PKNSigs(secretStr: string | Secret): number {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseP2PKSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\t// Check for witnesses\n\tconst witness = getP2PKExpectedKWitnessPubkeys(secret);\n\tif (!witness.length) {\n\t\treturn 0; // unlocked if no witnesses needed\n\t}\n\t// Check for Lock multisig\n\tconst { tags } = secret[1];\n\tconst now = Math.floor(Date.now() / 1000);\n\tconst locktime = getP2PKLocktime(secret);\n\tif (locktime > now) {\n\t\tconst n_sigsTag = tags && tags.find((tag) => tag[0] === 'n_sigs');\n\t\treturn n_sigsTag && n_sigsTag.length > 1 ? parseInt(n_sigsTag[1], 10) : 1; // Default: 1\n\t}\n\t// Refund multisig\n\tconst n_sigs_refundTag = tags && tags.find((tag) => tag[0] === 'n_sigs_refund');\n\treturn n_sigs_refundTag && n_sigs_refundTag.length > 1 ? parseInt(n_sigs_refundTag[1], 10) : 1; // Default: 1\n}\n\n/**\n * Returns the sigflag from a NUT-11 P2PK secret.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {string} The sigflag or 'SIG_INPUTS' (default)\n */\nexport function getP2PKSigFlag(secretStr: string | Secret): string {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseP2PKSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\tconst { tags } = secret[1];\n\tconst sigFlagTag = tags && tags.find((tag) => tag[0] === 'sigflag');\n\treturn sigFlagTag && sigFlagTag.length > 1 ? (sigFlagTag[1] as SigFlag) : 'SIG_INPUTS';\n}\n\n/**\n * Gets witness signatures as an array.\n *\n * @param witness From Proof.\n * @returns Array of witness signatures.\n */\nexport const getP2PKWitnessSignatures = (witness: string | P2PKWitness | undefined): string[] => {\n\tif (!witness) return [];\n\tif (typeof witness === 'string') {\n\t\ttry {\n\t\t\tconst parsed = JSON.parse(witness) as P2PKWitness;\n\t\t\treturn parsed.signatures || [];\n\t\t} catch (e) {\n\t\t\tconsole.error('Failed to parse witness string:', e);\n\t\t\treturn [];\n\t\t}\n\t}\n\treturn witness.signatures || [];\n};\n\n/**\n * Signs proofs with provided private key(s) if required NB: Will only sign if the proof requires a\n * signature from the key.\n *\n * @param proofs - An array of proofs to sign.\n * @param privateKey - A single private key or array of private keys.\n * @param logger - Optional logger (default: NULL_LOGGER)\n */\nexport const signP2PKProofs = (\n\tproofs: Proof[],\n\tprivateKey: string | string[],\n\tlogger: Logger = NULL_LOGGER,\n): Proof[] => {\n\treturn proofs.map((proof, index) => {\n\t\ttry {\n\t\t\tconst privateKeys: string[] = maybeDeriveP2BKPrivateKeys(privateKey, proof);\n\t\t\tlet signedProof = proof;\n\t\t\tfor (const priv of privateKeys) {\n\t\t\t\ttry {\n\t\t\t\t\tsignedProof = signP2PKProof(signedProof, priv);\n\t\t\t\t} catch (error: unknown) {\n\t\t\t\t\t// Log signature failures only - these are not fatal, just informational\n\t\t\t\t\t// as not all keys will be needed for some proofs (eg P2BK, NIP60 etc)\n\t\t\t\t\tconst message = error instanceof Error ? error.message : 'Unknown error';\n\t\t\t\t\tlogger.warn(`Proof #${index + 1}: ${message}`);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn signedProof;\n\t\t} catch (error: unknown) {\n\t\t\t// General errors (eg from deriveP2BKSecretKey)\n\t\t\tconst message = error instanceof Error ? error.message : 'Unknown error';\n\t\t\tlogger.error(`Proof #${index + 1}: ${message}`);\n\t\t\tthrow new Error(`Failed signing proof #${index + 1}: ${message}`);\n\t\t}\n\t});\n};\n\n/**\n * Signs a single proof with the provided private key if required NB: Will only sign if the proof\n * requires a signature from the key.\n *\n * @param proof - A proof to sign.\n * @param privateKey - A single private key.\n * @throws Error if signature is not required or proof is already signed.\n */\nexport const signP2PKProof = (proof: Proof, privateKey: string): Proof => {\n\t// Check secret is P2PK\n\tconst parsed: Secret = parseP2PKSecret(proof.secret);\n\tif (parsed[0] !== 'P2PK') {\n\t\tthrow new Error('not a P2PK secret');\n\t}\n\t// Check if the private key is required to sign by checking its\n\t// X-only pubkey (no 02/03 prefix) against the expected witness pubkeys\n\t// NB: Nostr pubkeys prepend 02 by convention, ignoring actual Y-parity\n\tconst pubkey = bytesToHex(schnorr.getPublicKey(privateKey)); // x-only\n\tconst witnesses = getP2PKExpectedKWitnessPubkeys(parsed);\n\tif (!witnesses.length || !witnesses.some((w) => w.includes(pubkey))) {\n\t\tthrow new Error(`Signature not required from [02|03]${pubkey}`);\n\t}\n\t// Check if the public key has already signed\n\tconst signatures = getP2PKWitnessSignatures(proof.witness);\n\tconst alreadySigned = signatures.some((sig) => {\n\t\ttry {\n\t\t\treturn verifyP2PKSecretSignature(sig, proof.secret, pubkey);\n\t\t} catch {\n\t\t\treturn false; // Invalid signature, treat as not signed\n\t\t}\n\t});\n\tif (alreadySigned) {\n\t\tthrow new Error(`Proof already signed by [02|03]${pubkey}`);\n\t}\n\t// Add new signature\n\tconst signature = signP2PKSecret(proof.secret, privateKey);\n\treturn { ...proof, witness: { signatures: [...signatures, signature] } };\n};\n\nexport const verifyP2PKSig = (proof: Proof): boolean => {\n\tif (!proof.witness) {\n\t\tthrow new Error('could not verify signature, no witness provided');\n\t}\n\n\tconst parsedSecret: Secret = parseP2PKSecret(proof.secret);\n\tconst witnesses = getP2PKExpectedKWitnessPubkeys(parsedSecret);\n\tif (!witnesses.length) {\n\t\tthrow new Error('no signatures required, proof is unlocked');\n\t}\n\tlet signatories = 0;\n\tconst requiredSigs = getP2PKNSigs(parsedSecret);\n\tconst signatures = getP2PKWitnessSignatures(proof.witness);\n\t// Loop through witnesses to see if any of the signatures belong to them.\n\t// We need to do this as Schnorr signatures are non-deterministic\n\t// (see: signP2PKSecret), so we count the number of valid witnesses,\n\t// not the number of valid signatures\n\tfor (const pubkey of witnesses) {\n\t\tconst hasSigned = signatures.some((sig) => {\n\t\t\ttry {\n\t\t\t\treturn verifyP2PKSecretSignature(sig, proof.secret, pubkey);\n\t\t\t} catch {\n\t\t\t\treturn false; // Invalid signature, treat as not signed\n\t\t\t}\n\t\t});\n\t\tif (hasSigned) {\n\t\t\tsignatories++;\n\t\t}\n\t}\n\treturn signatories >= requiredSigs;\n};\n\nexport const verifyP2PKSigOutput = (output: BlindedMessage, publicKey: string): boolean => {\n\tif (!output.witness?.signatures || output.witness.signatures.length === 0) {\n\t\tthrow new Error('could not verify signature, no witness signatures provided');\n\t}\n\treturn schnorr.verify(\n\t\toutput.witness.signatures[0],\n\t\tsha256(output.B_.toHex(true)),\n\t\tpublicKey.slice(2),\n\t);\n};\n\nexport const getSignedOutput = (output: BlindedMessage, privateKey: PrivKey): BlindedMessage => {\n\tconst B_ = output.B_.toHex(true);\n\tconst signature = signBlindedMessage(B_, privateKey);\n\toutput.witness = { signatures: [signature] };\n\treturn output;\n};\n\nexport const getSignedOutputs = (\n\toutputs: BlindedMessage[],\n\tprivateKey: string,\n): BlindedMessage[] => {\n\treturn outputs.map((o) => getSignedOutput(o, privateKey));\n};\n\n/**\n * Derives blinded secret keys for a P2BK proof.\n *\n * @remarks\n * Calculates the deterministic blinding factor for each P2PK pubkey (data, pubkeys, refund) and\n * calling our parity-aware derivation.\n * @param privateKey Secret key (or array of secret keys)\n * @param proof The proof.\n * @returns Deduplicated list of derived secret keys (hex, 64 chars)\n * @alpha\n */\nexport function maybeDeriveP2BKPrivateKeys(privateKey: string | string[], proof: Proof): string[] {\n\tconst privs = Array.isArray(privateKey) ? privateKey : [privateKey];\n\tconst Ehex: string | undefined = proof?.p2pk_e;\n\tif (!Ehex) {\n\t\treturn Array.from(new Set(privs));\n\t}\n\t// Extract pubkeys and keyset ID from proof\n\tconst secret = parseP2PKSecret(proof.secret);\n\tconst pubs = [...getP2PKWitnessPubkeys(secret), ...getP2PKWitnessRefundkeys(secret)];\n\tconst kid = proof.id; // keyset id is hex\n\treturn deriveP2BKSecretKeys(Ehex, privs, pubs, kid);\n}\n", "import { type WeierstrassPoint } from '@noble/curves/abstract/weierstrass';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { sha256 } from '@noble/hashes/sha2';\nimport { type PrivKey, randomBytes, bytesToHex, hexToBytes } from '@noble/curves/utils';\nimport { Bytes, bytesToNumber, hexToNumber, encodeBase64toUint8 } from '../utils';\nimport { type P2PKWitness } from '../model/types';\nimport { getSignedOutput } from './NUT11';\n\nexport type BlindSignature = {\n\tC_: WeierstrassPoint<bigint>;\n\tamount: number;\n\tid: string;\n};\n\nexport type BlindedMessage = {\n\tB_: WeierstrassPoint<bigint>;\n\tr: bigint;\n\tsecret: Uint8Array;\n\twitness?: P2PKWitness;\n};\n\nexport type DLEQ = {\n\ts: Uint8Array; // signature\n\te: Uint8Array; // challenge\n\tr?: bigint; // optional: blinding factor\n};\n\nexport type RawProof = {\n\tC: WeierstrassPoint<bigint>;\n\tsecret: Uint8Array;\n\tamount: number;\n\tid: string;\n\twitness?: P2PKWitness;\n};\n\nexport type SerializedProof = {\n\tC: string;\n\tsecret: string;\n\tamount: number;\n\tid: string;\n\twitness?: string;\n};\n\nconst DOMAIN_SEPARATOR = hexToBytes('536563703235366b315f48617368546f43757276655f43617368755f');\n\nexport function hashToCurve(secret: Uint8Array): WeierstrassPoint<bigint> {\n\tconst msgToHash = sha256(Bytes.concat(DOMAIN_SEPARATOR, secret));\n\tconst counter = new Uint32Array(1);\n\tconst maxIterations = 2 ** 16;\n\tfor (let i = 0; i < maxIterations; i++) {\n\t\tconst counterBytes = new Uint8Array(counter.buffer);\n\t\tconst hash = sha256(Bytes.concat(msgToHash, counterBytes));\n\t\ttry {\n\t\t\treturn pointFromHex(bytesToHex(Bytes.concat(new Uint8Array([0x02]), hash)));\n\t\t} catch {\n\t\t\tcounter[0]++;\n\t\t}\n\t}\n\tthrow new Error('No valid point found');\n}\n\nexport function hash_e(pubkeys: Array<WeierstrassPoint<bigint>>): Uint8Array {\n\tconst hexStrings = pubkeys.map((p) => p.toHex(false));\n\tconst e_ = hexStrings.join('');\n\treturn sha256(new TextEncoder().encode(e_));\n}\n\nexport function pointFromBytes(bytes: Uint8Array) {\n\treturn secp256k1.Point.fromHex(bytesToHex(bytes));\n}\n\nexport function pointFromHex(hex: string) {\n\treturn secp256k1.Point.fromHex(hex);\n}\n\nexport const getKeysetIdInt = (keysetId: string): bigint => {\n\tlet keysetIdInt: bigint;\n\tif (/^[a-fA-F0-9]+$/.test(keysetId)) {\n\t\tkeysetIdInt = hexToNumber(keysetId) % BigInt(2 ** 31 - 1);\n\t} else {\n\t\t//legacy keyset compatibility\n\t\tkeysetIdInt = bytesToNumber(encodeBase64toUint8(keysetId)) % BigInt(2 ** 31 - 1);\n\t}\n\treturn keysetIdInt;\n};\n\nexport function createRandomSecretKey() {\n\treturn secp256k1.utils.randomSecretKey();\n}\n\nexport function createBlindSignature(\n\tB_: WeierstrassPoint<bigint>,\n\tprivateKey: Uint8Array,\n\tamount: number,\n\tid: string,\n): BlindSignature {\n\tconst C_: WeierstrassPoint<bigint> = B_.multiply(bytesToNumber(privateKey));\n\treturn { C_, amount, id };\n}\n\nexport function createRandomBlindedMessage(privateKey?: PrivKey): BlindedMessage {\n\treturn blindMessage(\n\t\trandomBytes(32),\n\t\tbytesToNumber(secp256k1.utils.randomSecretKey()),\n\t\tprivateKey,\n\t);\n}\n\nexport function blindMessage(secret: Uint8Array, r?: bigint, privateKey?: PrivKey): BlindedMessage {\n\tconst Y = hashToCurve(secret);\n\tif (!r) {\n\t\tr = bytesToNumber(secp256k1.utils.randomSecretKey());\n\t}\n\tconst rG = secp256k1.Point.BASE.multiply(r);\n\tconst B_ = Y.add(rG);\n\tif (privateKey !== undefined) {\n\t\treturn getSignedOutput({ B_, r, secret }, privateKey);\n\t}\n\treturn { B_, r, secret };\n}\n\nexport function unblindSignature(\n\tC_: WeierstrassPoint<bigint>,\n\tr: bigint,\n\tA: WeierstrassPoint<bigint>,\n): WeierstrassPoint<bigint> {\n\tconst C = C_.subtract(A.multiply(r));\n\treturn C;\n}\n\nexport function constructProofFromPromise(\n\tpromise: BlindSignature,\n\tr: bigint,\n\tsecret: Uint8Array,\n\tkey: WeierstrassPoint<bigint>,\n): RawProof {\n\tconst A = key;\n\tconst C = unblindSignature(promise.C_, r, A);\n\tconst proof = {\n\t\tid: promise.id,\n\t\tamount: promise.amount,\n\t\tsecret,\n\t\tC,\n\t};\n\treturn proof;\n}\n\nexport const serializeProof = (proof: RawProof): SerializedProof => {\n\treturn {\n\t\tamount: proof.amount,\n\t\tC: proof.C.toHex(true),\n\t\tid: proof.id,\n\t\tsecret: new TextDecoder().decode(proof.secret),\n\t\twitness: JSON.stringify(proof.witness),\n\t};\n};\n\nexport const deserializeProof = (proof: SerializedProof): RawProof => {\n\treturn {\n\t\tamount: proof.amount,\n\t\tC: pointFromHex(proof.C),\n\t\tid: proof.id,\n\t\tsecret: new TextEncoder().encode(proof.secret),\n\t\twitness: proof.witness ? (JSON.parse(proof.witness) as P2PKWitness) : undefined,\n\t};\n};\n", "import { type WeierstrassPoint } from '@noble/curves/abstract/weierstrass';\nimport { bytesToHex, hexToBytes } from '@noble/curves/utils';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { type RawProof, createRandomSecretKey, hashToCurve } from './core';\nimport { HDKey } from '@scure/bip32';\nimport { deriveKeysetId, bytesToNumber } from '../utils';\n\nconst DERIVATION_PATH = \"m/0'/0'/0'\";\n\nexport type RawMintKeys = { [k: string]: Uint8Array };\n\nexport type SerializedMintKeys = {\n\t[k: string]: string;\n};\n\nexport type Enumerate<N extends number, Acc extends number[] = []> = Acc['length'] extends N\n\t? Acc[number]\n\t: Enumerate<N, [...Acc, Acc['length']]>;\n\nexport type IntRange<F extends number, T extends number> = Exclude<Enumerate<T>, Enumerate<F>>;\n\nexport type KeysetPair = {\n\tkeysetId: string;\n\tpubKeys: RawMintKeys;\n\tprivKeys: RawMintKeys;\n};\n\nexport function serializeMintKeys(mintKeys: RawMintKeys): SerializedMintKeys {\n\tconst serializedMintKeys: SerializedMintKeys = {};\n\tObject.keys(mintKeys).forEach((p) => {\n\t\tserializedMintKeys[p] = bytesToHex(mintKeys[p]);\n\t});\n\treturn serializedMintKeys;\n}\n\nexport function deserializeMintKeys(serializedMintKeys: SerializedMintKeys): RawMintKeys {\n\tconst mintKeys: RawMintKeys = {};\n\tObject.keys(serializedMintKeys).forEach((p) => {\n\t\tmintKeys[p] = hexToBytes(serializedMintKeys[p]);\n\t});\n\treturn mintKeys;\n}\n\nexport function getPubKeyFromPrivKey(privKey: Uint8Array) {\n\treturn secp256k1.getPublicKey(privKey, true);\n}\n\nexport function createNewMintKeys(pow2height: IntRange<0, 65>, seed?: Uint8Array): KeysetPair {\n\tlet counter = 0n;\n\tconst pubKeys: RawMintKeys = {};\n\tconst privKeys: RawMintKeys = {};\n\tlet masterKey;\n\tif (seed) {\n\t\tmasterKey = HDKey.fromMasterSeed(seed);\n\t}\n\twhile (counter < pow2height) {\n\t\tconst index: string = (2n ** counter).toString();\n\t\tif (masterKey) {\n\t\t\tconst k = masterKey.derive(`${DERIVATION_PATH}/${counter}`).privateKey;\n\t\t\tif (k) {\n\t\t\t\tprivKeys[index] = k;\n\t\t\t} else {\n\t\t\t\tthrow new Error(`Could not derive Private key from: ${DERIVATION_PATH}/${counter}`);\n\t\t\t}\n\t\t} else {\n\t\t\tprivKeys[index] = createRandomSecretKey();\n\t\t}\n\n\t\tpubKeys[index] = getPubKeyFromPrivKey(privKeys[index]);\n\t\tcounter++;\n\t}\n\tconst keysetId = deriveKeysetId(serializeMintKeys(pubKeys));\n\treturn { pubKeys, privKeys, keysetId };\n}\n\nexport function verifyProof(proof: RawProof, privKey: Uint8Array): boolean {\n\tconst Y: WeierstrassPoint<bigint> = hashToCurve(proof.secret);\n\tconst aY: WeierstrassPoint<bigint> = Y.multiply(bytesToNumber(privKey));\n\treturn aY.equals(proof.C);\n}\n", "import { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha2';\nimport { getKeysetIdInt } from './core';\nimport { HDKey } from '@scure/bip32';\nimport { Bytes, isBase64String } from '../utils';\n\nconst STANDARD_DERIVATION_PATH = `m/129372'/0'`;\n\nenum DerivationType {\n\tSECRET = 0,\n\tBLINDING_FACTOR = 1,\n}\n\nexport const deriveSecret = (seed: Uint8Array, keysetId: string, counter: number): Uint8Array => {\n\tconst isValidHex = /^[a-fA-F0-9]+$/.test(keysetId);\n\tif (!isValidHex && isBase64String(keysetId)) {\n\t\treturn derive_deprecated(seed, keysetId, counter, DerivationType.SECRET);\n\t}\n\n\tif (isValidHex && keysetId.startsWith('00')) {\n\t\treturn derive_deprecated(seed, keysetId, counter, DerivationType.SECRET);\n\t} else if (isValidHex && keysetId.startsWith('01')) {\n\t\treturn derive(seed, keysetId, counter, DerivationType.SECRET);\n\t}\n\tthrow new Error(`Unrecognized keyset ID version ${keysetId.slice(0, 2)}`);\n};\n\nexport const deriveBlindingFactor = (\n\tseed: Uint8Array,\n\tkeysetId: string,\n\tcounter: number,\n): Uint8Array => {\n\tconst isValidHex = /^[a-fA-F0-9]+$/.test(keysetId);\n\tif (!isValidHex && isBase64String(keysetId)) {\n\t\treturn derive_deprecated(seed, keysetId, counter, DerivationType.BLINDING_FACTOR);\n\t}\n\n\tif (isValidHex && keysetId.startsWith('00')) {\n\t\treturn derive_deprecated(seed, keysetId, counter, DerivationType.BLINDING_FACTOR);\n\t} else if (isValidHex && keysetId.startsWith('01')) {\n\t\treturn derive(seed, keysetId, counter, DerivationType.BLINDING_FACTOR);\n\t}\n\tthrow new Error(`Unrecognized keyset ID version ${keysetId.slice(0, 2)}`);\n};\n\nconst derive = (\n\tseed: Uint8Array,\n\tkeysetId: string,\n\tcounter: number,\n\tsecretOrBlinding: DerivationType,\n): Uint8Array => {\n\tlet message = Bytes.concat(\n\t\tBytes.fromString('Cashu_KDF_HMAC_SHA256'),\n\t\tBytes.fromHex(keysetId),\n\t\tBytes.writeBigUint64BE(BigInt(counter)),\n\t);\n\n\tswitch (secretOrBlinding) {\n\t\tcase DerivationType.SECRET:\n\t\t\tmessage = Bytes.concat(message, Bytes.fromHex('00'));\n\t\t\tbreak;\n\t\tcase DerivationType.BLINDING_FACTOR:\n\t\t\tmessage = Bytes.concat(message, Bytes.fromHex('01'));\n\t}\n\n\t// Step 2: Compute HMAC-SHA256\n\treturn hmac(sha256, seed, message);\n};\n\nconst derive_deprecated = (\n\tseed: Uint8Array,\n\tkeysetId: string,\n\tcounter: number,\n\tsecretOrBlinding: DerivationType,\n): Uint8Array => {\n\tconst hdkey = HDKey.fromMasterSeed(seed);\n\tconst keysetIdInt = getKeysetIdInt(keysetId);\n\tconst derivationPath = `${STANDARD_DERIVATION_PATH}/${keysetIdInt}'/${counter}'/${secretOrBlinding}`;\n\tconst derived = hdkey.derive(derivationPath);\n\tif (derived.privateKey === null) {\n\t\tthrow new Error('Could not derive private key');\n\t}\n\treturn derived.privateKey;\n};\n", "import { type DLEQ, hash_e, hashToCurve, createRandomSecretKey } from './core';\nimport { bytesToNumber } from '../utils';\nimport { type WeierstrassPoint } from '@noble/curves/abstract/weierstrass';\nimport { numberToBytesBE } from '@noble/curves/utils';\nimport { secp256k1 } from '@noble/curves/secp256k1';\n\nfunction arraysEqual(arr1: Uint8Array, arr2: Uint8Array) {\n\tif (arr1.length !== arr2.length) return false;\n\tfor (let i = 0; i < arr1.length; i++) {\n\t\tif (arr1[i] !== arr2[i]) return false;\n\t}\n\treturn true;\n}\n\nexport const verifyDLEQProof = (\n\tdleq: DLEQ,\n\tB_: WeierstrassPoint<bigint>,\n\tC_: WeierstrassPoint<bigint>,\n\tA: WeierstrassPoint<bigint>,\n) => {\n\tconst sG = secp256k1.Point.BASE.multiply(secp256k1.Point.Fn.fromBytes(dleq.s));\n\tconst eA = A.multiply(bytesToNumber(dleq.e));\n\tconst sB_ = B_.multiply(bytesToNumber(dleq.s));\n\tconst eC_ = C_.multiply(bytesToNumber(dleq.e));\n\tconst R_1 = sG.subtract(eA); // R1 = sG - eA\n\tconst R_2 = sB_.subtract(eC_); // R2 = sB' - eC'\n\tconst hash = hash_e([R_1, R_2, A, C_]); // e == hash(R1, R2, A, C')\n\treturn arraysEqual(hash, dleq.e);\n};\n\nexport const verifyDLEQProof_reblind = (\n\tsecret: Uint8Array, // secret\n\tdleq: DLEQ,\n\tC: WeierstrassPoint<bigint>, // unblinded e-cash signature point\n\tA: WeierstrassPoint<bigint>, // mint public key point\n) => {\n\tif (dleq.r === undefined) throw new Error('verifyDLEQProof_reblind: Undefined blinding factor');\n\tconst Y = hashToCurve(secret);\n\tconst C_ = C.add(A.multiply(dleq.r)); // Re-blind the e-cash signature\n\tconst bG = secp256k1.Point.BASE.multiply(dleq.r);\n\tconst B_ = Y.add(bG); // Re-blind the message\n\treturn verifyDLEQProof(dleq, B_, C_, A);\n};\n\n/**\n * !!! WARNING !!! Not recommended for production use, due to non-constant time operations See:\n * https://github.com/cashubtc/cashu-crypto-ts/pull/2 for more details See:\n * https://en.wikipedia.org/wiki/Timing_attack for information about timing attacks.\n */\nexport const createDLEQProof = (B_: WeierstrassPoint<bigint>, a: Uint8Array): DLEQ => {\n\tconst r = secp256k1.Point.Fn.fromBytes(createRandomSecretKey()); // r <- random (Uint8Array)\n\tconst R_1 = secp256k1.Point.BASE.multiply(r); // R1 = rG\n\tconst R_2 = B_.multiply(r); // R2 = rB_\n\tconst scalar_a = secp256k1.Point.Fn.fromBytes(a);\n\tconst C_ = B_.multiply(scalar_a); // C_ = aB_\n\tconst A = secp256k1.Point.BASE.multiply(scalar_a); // A = aG\n\tconst e = hash_e([R_1, R_2, A, C_]); // e = hash(R1, R2, A, C_)\n\tconst scalar_e = secp256k1.Point.Fn.fromBytes(e);\n\t// Use field operations for constant-time addition and multiplication\n\tconst s_scalar = secp256k1.Point.Fn.add(r, secp256k1.Point.Fn.mul(scalar_e, scalar_a));\n\tconst s = numberToBytesBE(s_scalar, 32); // s = (r + e * a) mod n\n\treturn { s, e };\n};\n", "import { schnorr } from '@noble/curves/secp256k1';\nimport { type SerializedBlindedMessage } from '../model/types';\nimport { bytesToHex, hexToBytes } from '@noble/hashes/utils';\nimport { sha256 } from '@noble/hashes/sha2';\n\nfunction constructMessage(quote: string, blindedMessages: SerializedBlindedMessage[]): Uint8Array {\n\tlet message = quote;\n\tfor (const blindedMessage of blindedMessages) {\n\t\tmessage += blindedMessage.B_;\n\t}\n\tconst msgbytes = new TextEncoder().encode(message);\n\treturn sha256(msgbytes);\n}\n\nexport function signMintQuote(\n\tprivkey: string,\n\tquote: string,\n\tblindedMessages: SerializedBlindedMessage[],\n): string {\n\tconst message = constructMessage(quote, blindedMessages);\n\tconst privkeyBytes = hexToBytes(privkey);\n\tconst signature = schnorr.sign(message, privkeyBytes);\n\treturn bytesToHex(signature);\n}\n\nexport function verifyMintQuoteSignature(\n\tpubkey: string,\n\tquote: string,\n\tblindedMessages: SerializedBlindedMessage[],\n\tsignature: string,\n): boolean {\n\tconst sigbytes = hexToBytes(signature);\n\tlet pubkeyBytes = hexToBytes(pubkey);\n\tif (pubkeyBytes.length !== 33) return false;\n\tpubkeyBytes = pubkeyBytes.slice(1);\n\tconst message = constructMessage(quote, blindedMessages);\n\treturn schnorr.verify(sigbytes, message, pubkeyBytes);\n}\n", "import { encodeBase64toUint8, decodeCBOR, encodeCBOR, Bytes } from '../utils';\nimport type {\n\tRawPaymentRequest,\n\tRawTransport,\n\tNUT10Option,\n\tPaymentRequestTransport,\n\tPaymentRequestTransportType,\n} from '../wallet/types';\n\nexport class PaymentRequest {\n\tconstructor(\n\t\tpublic transport?: PaymentRequestTransport[],\n\t\tpublic id?: string,\n\t\tpublic amount?: number,\n\t\tpublic unit?: string,\n\t\tpublic mints?: string[],\n\t\tpublic description?: string,\n\t\tpublic singleUse: boolean = false,\n\t\tpublic nut10?: NUT10Option,\n\t\tpublic nut26: boolean = false,\n\t) {}\n\n\ttoRawRequest() {\n\t\tconst rawRequest: RawPaymentRequest = {};\n\t\tif (this.transport) {\n\t\t\trawRequest.t = this.transport.map((t: PaymentRequestTransport) => ({\n\t\t\t\tt: t.type,\n\t\t\t\ta: t.target,\n\t\t\t\tg: t.tags,\n\t\t\t}));\n\t\t}\n\t\tif (this.id) {\n\t\t\trawRequest.i = this.id;\n\t\t}\n\t\tif (this.amount) {\n\t\t\trawRequest.a = this.amount;\n\t\t}\n\t\tif (this.unit) {\n\t\t\trawRequest.u = this.unit;\n\t\t}\n\t\tif (this.mints) {\n\t\t\trawRequest.m = this.mints;\n\t\t}\n\t\tif (this.description) {\n\t\t\trawRequest.d = this.description;\n\t\t}\n\t\tif (this.singleUse) {\n\t\t\trawRequest.s = this.singleUse;\n\t\t}\n\t\tif (this.nut10) {\n\t\t\trawRequest.nut10 = {\n\t\t\t\tk: this.nut10.kind,\n\t\t\t\td: this.nut10.data,\n\t\t\t\tt: this.nut10.tags,\n\t\t\t};\n\t\t}\n\t\tif (this.nut26) {\n\t\t\trawRequest.nut26 = this.nut26;\n\t\t}\n\t\treturn rawRequest;\n\t}\n\n\ttoEncodedRequest() {\n\t\tconst rawRequest: RawPaymentRequest = this.toRawRequest();\n\t\tconst data = encodeCBOR(rawRequest);\n\t\tconst encodedData = Bytes.toBase64(data);\n\t\treturn 'creq' + 'A' + encodedData;\n\t}\n\n\tgetTransport(type: PaymentRequestTransportType) {\n\t\treturn this.transport?.find((t: PaymentRequestTransport) => t.type === type);\n\t}\n\n\tstatic fromRawRequest(rawPaymentRequest: RawPaymentRequest): PaymentRequest {\n\t\tconst transports = rawPaymentRequest.t\n\t\t\t? rawPaymentRequest.t.map((t: RawTransport) => ({\n\t\t\t\t\ttype: t.t,\n\t\t\t\t\ttarget: t.a,\n\t\t\t\t\ttags: t.g,\n\t\t\t\t}))\n\t\t\t: undefined;\n\t\tconst nut10 = rawPaymentRequest.nut10\n\t\t\t? {\n\t\t\t\t\tkind: rawPaymentRequest.nut10.k,\n\t\t\t\t\tdata: rawPaymentRequest.nut10.d,\n\t\t\t\t\ttags: rawPaymentRequest.nut10.t,\n\t\t\t\t}\n\t\t\t: undefined;\n\t\treturn new PaymentRequest(\n\t\t\ttransports,\n\t\t\trawPaymentRequest.i,\n\t\t\trawPaymentRequest.a,\n\t\t\trawPaymentRequest.u,\n\t\t\trawPaymentRequest.m,\n\t\t\trawPaymentRequest.d,\n\t\t\trawPaymentRequest.s,\n\t\t\tnut10,\n\t\t\trawPaymentRequest.nut26,\n\t\t);\n\t}\n\n\tstatic fromEncodedRequest(encodedRequest: string): PaymentRequest {\n\t\tif (!encodedRequest.startsWith('creq')) {\n\t\t\tthrow new Error('unsupported pr: invalid prefix');\n\t\t}\n\t\tconst version = encodedRequest[4];\n\t\tif (version !== 'A') {\n\t\t\tthrow new Error('unsupported pr version');\n\t\t}\n\t\tconst encodedData = encodedRequest.slice(5);\n\t\tconst data = encodeBase64toUint8(encodedData);\n\t\tconst decoded = decodeCBOR(data) as RawPaymentRequest;\n\t\treturn this.fromRawRequest(decoded);\n\t}\n}\n", "import { type DLEQ, pointFromHex, verifyDLEQProof_reblind } from '../crypto';\nimport { bytesToHex, hexToBytes } from '@noble/curves/utils';\nimport { sha256 } from '@noble/hashes/sha2';\nimport {\n\tencodeBase64ToJson,\n\tencodeBase64toUint8,\n\tencodeJsonToBase64,\n\tencodeUint8toBase64Url,\n\tisBase64String,\n} from './base64';\nimport { decodeCBOR, encodeCBOR } from './cbor';\nimport { PaymentRequest } from '../model/PaymentRequest';\nimport type {\n\tTokenMetadata,\n\tDeprecatedToken,\n\tKeys,\n\tMintKeys,\n\tMintKeyset,\n\tProof,\n\tSerializedDLEQ,\n\tToken,\n\tTokenV4Template,\n\tV4DLEQTemplate,\n\tV4InnerToken,\n\tV4ProofTemplate,\n} from '../model/types';\nimport { Bytes } from './Bytes';\nimport { type Keyset } from '../wallet';\n\n/**\n * Splits the amount into denominations of the provided keyset.\n *\n * @remarks\n * Partial splits will be filled up to value using minimum splits required. Sorting is only applied\n * if a fill was made - exact custom splits are always returned in the same order.\n * @param value Amount to split.\n * @param keyset Keys to look up split amounts.\n * @param split? Optional custom split amounts.\n * @param order? Optional order for split amounts (if fill was required)\n * @returns Array of split amounts.\n * @throws Error if split sum is greater than value or mint does not have keys for requested split.\n */\nexport function splitAmount(\n\tvalue: number,\n\tkeyset: Keys,\n\tsplit?: number[],\n\torder?: 'desc' | 'asc',\n): number[] {\n\tif (split) {\n\t\tconst totalSplitAmount = sumArray(split);\n\n\t\t// Special case: explicit \"zero-total\" outputs (restore or NUT-08 blanks)\n\t\tif (value === 0 && totalSplitAmount === 0) {\n\t\t\treturn split;\n\t\t}\n\n\t\t// Normal positive-value paths: ignore zeros for validation and totals\n\t\tconst positive = split.filter((amt) => amt > 0);\n\t\tconst totalPositive = sumArray(positive);\n\t\tif (totalPositive > value) {\n\t\t\tthrow new Error(`Split is greater than total amount: ${totalPositive} > ${value}`);\n\t\t}\n\t\tif (positive.some((amt) => !hasCorrespondingKey(amt, keyset))) {\n\t\t\tthrow new Error('Provided amount preferences do not match the amounts of the mint keyset.');\n\t\t}\n\n\t\t// if caller supplied an exact custom split, preserve their order\n\t\tif (totalPositive === value) {\n\t\t\treturn positive;\n\t\t}\n\n\t\t// Work only with validated positive amounts from here on\n\t\tsplit = positive;\n\t\tvalue -= totalPositive;\n\t} else {\n\t\tsplit = [];\n\t}\n\n\t// Denomination fill for the remaining value\n\tconst sortedKeyAmounts = getKeysetAmounts(keyset, 'desc');\n\tif (!sortedKeyAmounts || sortedKeyAmounts.length === 0) {\n\t\tthrow new Error('Cannot split amount, keyset is inactive or contains no keys');\n\t}\n\tfor (const amt of sortedKeyAmounts) {\n\t\tif (amt <= 0) continue;\n\t\t// Calculate how many of amt fit into remaining value\n\t\tconst requireCount = Math.floor(value / amt);\n\t\t// Add them to the split and reduce the target value by added amounts\n\t\tsplit.push(...Array<number>(requireCount).fill(amt));\n\t\tvalue -= amt * requireCount;\n\t\t// Break early once target is satisfied\n\t\tif (value === 0) break;\n\t}\n\tif (value !== 0) {\n\t\tthrow new Error(`Unable to split remaining amount: ${value}`);\n\t}\n\n\t// Only sort when we performed a fill and it was requested\n\t// Exact custom splits were returned unsorted earlier\n\tif (order) {\n\t\treturn split.sort((a, b) => (order === 'desc' ? b - a : a - b));\n\t}\n\treturn split;\n}\n\n/**\n * Creates a list of amounts to keep based on the proofs we have and the proofs we want to reach.\n *\n * @param proofsWeHave Complete set of proofs stored (from current mint)\n * @param amountToKeep Amount to keep.\n * @param keys Keys of current keyset.\n * @param targetCount The target number of proofs to reach.\n * @returns An array of amounts to keep.\n */\nexport function getKeepAmounts(\n\tproofsWeHave: Proof[],\n\tamountToKeep: number,\n\tkeys: Keys,\n\ttargetCount: number,\n): number[] {\n\t// determines amounts we need to reach the targetCount for each amount based on the amounts of the proofs we have\n\t// it tries to select amounts so that the proofs we have and the proofs we want reach the targetCount\n\tconst amountsWeWant: number[] = [];\n\tconst amountsWeHave = proofsWeHave.map((p: Proof) => p.amount);\n\tconst sortedKeyAmounts = getKeysetAmounts(keys, 'asc');\n\tsortedKeyAmounts.forEach((amt) => {\n\t\tconst countWeHave = amountsWeHave.filter((a) => a === amt).length;\n\t\tconst countWeWant = Math.max(targetCount - countWeHave, 0);\n\t\tfor (let i = 0; i < countWeWant; ++i) {\n\t\t\tif (amountsWeWant.reduce((a, b) => a + b, 0) + amt > amountToKeep) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tamountsWeWant.push(amt);\n\t\t}\n\t});\n\t// use splitAmount to fill the rest between the sum of amountsWeHave and amountToKeep\n\tconst amountDiff = amountToKeep - amountsWeWant.reduce((a, b) => a + b, 0);\n\tif (amountDiff) {\n\t\tconst remainingAmounts = splitAmount(amountDiff, keys);\n\t\tremainingAmounts.forEach((amt: number) => {\n\t\t\tamountsWeWant.push(amt);\n\t\t});\n\t}\n\treturn amountsWeWant.sort((a, b) => a - b);\n}\n/**\n * Returns the amounts in the keyset sorted by the order specified.\n *\n * @param keyset To search in.\n * @param order Order to sort the amounts in.\n * @returns The amounts in the keyset sorted by the order specified.\n */\nexport function getKeysetAmounts(keyset: Keys, order: 'asc' | 'desc' = 'desc'): number[] {\n\tif (order == 'desc') {\n\t\treturn Object.keys(keyset)\n\t\t\t.map((k: string) => parseInt(k))\n\t\t\t.sort((a: number, b: number) => b - a);\n\t}\n\treturn Object.keys(keyset)\n\t\t.map((k: string) => parseInt(k))\n\t\t.sort((a: number, b: number) => a - b);\n}\n\n/**\n * Checks if the provided amount is in the keyset.\n *\n * @param amount Amount to check.\n * @param keyset To search in.\n * @returns True if the amount is in the keyset, false otherwise.\n */\nexport function hasCorrespondingKey(amount: number, keyset: Keys): boolean {\n\treturn amount in keyset;\n}\n\n/**\n * Converts a bytes array to a number.\n *\n * @param bytes To convert to number.\n * @returns Number.\n */\nexport function bytesToNumber(bytes: Uint8Array): bigint {\n\treturn hexToNumber(bytesToHex(bytes));\n}\n\n/**\n * Converts a hex string to a number.\n *\n * @param hex To convert to number.\n * @returns Number.\n */\nexport function hexToNumber(hex: string): bigint {\n\treturn BigInt(`0x${hex}`);\n}\n\n/**\n * Converts a number to a hex string of 64 characters.\n *\n * @param number (bigint) to conver to hex.\n * @returns Hex string start-padded to 64 characters.\n */\nexport function numberToHexPadded64(number: bigint): string {\n\treturn number.toString(16).padStart(64, '0');\n}\n\nexport function isValidHex(str: string) {\n\treturn /^[a-f0-9]*$/i.test(str);\n}\n\n/**\n * Checks wether a proof or a list of proofs contains a non-hex id.\n *\n * @param p Proof or list of proofs.\n * @returns Boolean.\n */\nexport function hasNonHexId(p: Proof | Proof[]) {\n\tif (Array.isArray(p)) {\n\t\treturn p.some((proof) => !isValidHex(proof.id));\n\t}\n\treturn !isValidHex(p.id);\n}\n\n//used for json serialization\nexport function bigIntStringify<T>(_key: unknown, value: T) {\n\treturn typeof value === 'bigint' ? value.toString() : value;\n}\n\n/**\n * Helper function to encode a v3 cashu token.\n *\n * @param token To encode.\n * @returns Encoded token.\n */\nexport function getEncodedTokenV3(token: Token, removeDleq?: boolean): string {\n\tif (!hasNonHexId(token.proofs)) {\n\t\ttoken.proofs = convertToShortKeysetId(token.proofs);\n\t}\n\tif (removeDleq) {\n\t\ttoken.proofs = stripDleq(token.proofs);\n\t}\n\tconst v3TokenObj: DeprecatedToken = { token: [{ mint: token.mint, proofs: token.proofs }] };\n\tif (token.unit) {\n\t\tv3TokenObj.unit = token.unit;\n\t}\n\tif (token.memo) {\n\t\tv3TokenObj.memo = token.memo;\n\t}\n\tconst prefix = 'cashu';\n\tconst version = 'A';\n\treturn prefix + version + encodeJsonToBase64(v3TokenObj);\n}\n\n/*\n * Convert a keyset ID into short form\n */\nfunction convertToShortKeysetId(proofs: Proof[]) {\n\treturn proofs.map((p) => {\n\t\tconst newP = { ...p };\n\t\tnewP.id = newP.id.slice(0, 16);\n\t\treturn newP;\n\t});\n}\n\n/**\n * Helper function to encode a cashu token (defaults to v4 if keyset id allows it)\n *\n * @param token\n * @param [opts]\n */\nexport function getEncodedToken(\n\ttoken: Token,\n\topts?: { version?: 3 | 4; removeDleq?: boolean },\n): string {\n\t// Find out if it's a base64 keyset\n\tconst nonHex = hasNonHexId(token.proofs);\n\tif (nonHex || opts?.version === 3) {\n\t\tif (opts?.version === 4) {\n\t\t\tthrow new Error('can not encode to v4 token if proofs contain non-hex keyset id');\n\t\t}\n\t\treturn getEncodedTokenV3(token, opts?.removeDleq);\n\t}\n\treturn getEncodedTokenV4(token, opts?.removeDleq);\n}\n\nexport function getEncodedTokenV4(token: Token, removeDleq?: boolean): string {\n\tif (removeDleq) {\n\t\ttoken.proofs = stripDleq(token.proofs);\n\t}\n\t// Make sure each DLEQ has its blinding factor\n\ttoken.proofs.forEach((p) => {\n\t\tif (p.dleq && p.dleq.r == undefined) {\n\t\t\tthrow new Error('Missing blinding factor in included DLEQ proof');\n\t\t}\n\t});\n\tconst nonHex = hasNonHexId(token.proofs);\n\tif (nonHex) {\n\t\tthrow new Error('can not encode to v4 token if proofs contain non-hex keyset id');\n\t}\n\t// Map keyset IDs to short IDs\n\ttoken.proofs = convertToShortKeysetId(token.proofs);\n\n\tconst tokenTemplate = templateFromToken(token);\n\n\tconst encodedData = encodeCBOR(tokenTemplate);\n\tconst prefix = 'cashu';\n\tconst version = 'B';\n\tconst base64Data = encodeUint8toBase64Url(encodedData);\n\treturn prefix + version + base64Data;\n}\n\nfunction templateFromToken(token: Token): TokenV4Template {\n\tconst idMap: { [id: string]: Proof[] } = {};\n\tconst mint = token.mint;\n\tfor (let i = 0; i < token.proofs.length; i++) {\n\t\tconst proof = token.proofs[i];\n\t\tif (idMap[proof.id]) {\n\t\t\tidMap[proof.id].push(proof);\n\t\t} else {\n\t\t\tidMap[proof.id] = [proof];\n\t\t}\n\t}\n\tconst tokenTemplate: TokenV4Template = {\n\t\tm: mint,\n\t\tu: token.unit || 'sat',\n\t\tt: Object.keys(idMap).map(\n\t\t\t(id: string): V4InnerToken => ({\n\t\t\t\ti: hexToBytes(id),\n\t\t\t\tp: idMap[id].map(\n\t\t\t\t\t(p: Proof): V4ProofTemplate => ({\n\t\t\t\t\t\ta: p.amount,\n\t\t\t\t\t\ts: p.secret,\n\t\t\t\t\t\tc: hexToBytes(p.C),\n\t\t\t\t\t\t...(p.dleq && {\n\t\t\t\t\t\t\td: {\n\t\t\t\t\t\t\t\te: hexToBytes(p.dleq.e),\n\t\t\t\t\t\t\t\ts: hexToBytes(p.dleq.s),\n\t\t\t\t\t\t\t\tr: hexToBytes(p.dleq.r ?? '00'),\n\t\t\t\t\t\t\t} as V4DLEQTemplate,\n\t\t\t\t\t\t}),\n\t\t\t\t\t\t...(p.p2pk_e && {\n\t\t\t\t\t\t\tpe: hexToBytes(p.p2pk_e),\n\t\t\t\t\t\t}),\n\t\t\t\t\t\t...(p.witness && {\n\t\t\t\t\t\t\tw: JSON.stringify(p.witness),\n\t\t\t\t\t\t}),\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t}),\n\t\t),\n\t} as TokenV4Template;\n\tif (token.memo) {\n\t\ttokenTemplate.d = token.memo;\n\t}\n\treturn tokenTemplate;\n}\n\nfunction tokenFromTemplate(template: TokenV4Template): Token {\n\tconst proofs: Proof[] = [];\n\ttemplate.t.forEach((t) =>\n\t\tt.p.forEach((p) => {\n\t\t\tproofs.push({\n\t\t\t\tsecret: p.s,\n\t\t\t\tC: bytesToHex(p.c),\n\t\t\t\tamount: p.a,\n\t\t\t\tid: bytesToHex(t.i),\n\t\t\t\t...(p.d && {\n\t\t\t\t\tdleq: {\n\t\t\t\t\t\tr: bytesToHex(p.d.r),\n\t\t\t\t\t\ts: bytesToHex(p.d.s),\n\t\t\t\t\t\te: bytesToHex(p.d.e),\n\t\t\t\t\t} as SerializedDLEQ,\n\t\t\t\t}),\n\t\t\t\t...(p.pe && {\n\t\t\t\t\tp2pk_e: bytesToHex(p.pe),\n\t\t\t\t}),\n\t\t\t\t...(p.w && {\n\t\t\t\t\twitness: p.w,\n\t\t\t\t}),\n\t\t\t});\n\t\t}),\n\t);\n\tconst decodedToken: Token = { mint: template.m, proofs, unit: template.u || 'sat' };\n\tif (template.d) {\n\t\tdecodedToken.memo = template.d;\n\t}\n\treturn decodedToken;\n}\n\n/**\n * Helper function to decode cashu tokens into object.\n *\n * @param token An encoded cashu token (cashuAey...)\n * @returns Cashu token object.\n */\nexport function getDecodedToken(tokenString: string, keysets?: MintKeyset[] | Keyset[]) {\n\t// remove prefixes\n\tconst token = removePrefix(tokenString);\n\tconst tokenObj = handleTokens(token);\n\ttokenObj.proofs = mapShortKeysetIds(tokenObj.proofs, keysets);\n\treturn tokenObj;\n}\n\n/**\n * Returns the metadata of a cashu token.\n *\n * @param token An encoded cashu token (cashuAey...)\n * @returns Token metadata.\n */\nexport function getTokenMetadata(token: string): TokenMetadata {\n\ttoken = removePrefix(token);\n\tconst tokenObj = handleTokens(token);\n\treturn {\n\t\tunit: tokenObj.unit || 'sat',\n\t\tmint: tokenObj.mint,\n\t\tamount: sumProofs(tokenObj.proofs),\n\t\t...(tokenObj.memo && { memo: tokenObj.memo }),\n\t\tincompleteProofs: tokenObj.proofs.map((p) => ({\n\t\t\tsecret: p.secret,\n\t\t\tC: p.C,\n\t\t\tamount: p.amount,\n\t\t\t...(p.dleq && {\n\t\t\t\tdleq: p.dleq,\n\t\t\t}),\n\t\t\t...(p.witness && {\n\t\t\t\twitness: p.witness,\n\t\t\t}),\n\t\t})),\n\t};\n}\n\n/**\n * Helper function to decode different versions of cashu tokens into an object.\n *\n * @param token An encoded cashu token (cashuAey...)\n * @returns Cashu Token object.\n */\nexport function handleTokens(token: string): Token {\n\tconst version = token.slice(0, 1);\n\tconst encodedToken = token.slice(1);\n\tif (version === 'A') {\n\t\tconst parsedV3Token = encodeBase64ToJson<DeprecatedToken>(encodedToken);\n\t\tif (parsedV3Token.token.length > 1) {\n\t\t\tthrow new Error('Multi entry token are not supported');\n\t\t}\n\t\tconst entry = parsedV3Token.token[0];\n\t\tconst tokenObj: Token = {\n\t\t\tmint: entry.mint,\n\t\t\tproofs: entry.proofs,\n\t\t\tunit: parsedV3Token.unit || 'sat',\n\t\t};\n\t\tif (parsedV3Token.memo) {\n\t\t\ttokenObj.memo = parsedV3Token.memo;\n\t\t}\n\t\treturn tokenObj;\n\t} else if (version === 'B') {\n\t\tconst uInt8Token = encodeBase64toUint8(encodedToken);\n\t\tconst tokenData = decodeCBOR(uInt8Token) as TokenV4Template;\n\t\treturn tokenFromTemplate(tokenData);\n\t}\n\tthrow new Error('Token version is not supported');\n}\n\n/**\n * Returns the keyset id of a set of keys.\n *\n * @param keys Keys object to derive keyset id from.\n * @param unit (optional) the unit of the keyset.\n * @param expiry (optional) expiry of the keyset.\n * @param versionByte (optional) version of the keyset ID. Default is 0.\n * @param isDeprecatedBase64 (optional) true if the keyset ID should be derived as a deprecated v0\n *   base64 keyset ID.\n * @returns Keyset id of the keys.\n * @throws If keyset versionByte is not valid.\n */\nexport function deriveKeysetId(\n\tkeys: Keys,\n\tunit?: string,\n\texpiry?: number,\n\tversionByte: number = 0,\n\tisDeprecatedBase64: boolean = false,\n) {\n\tif (isDeprecatedBase64) {\n\t\tconst pubkeysConcat = Object.entries(keys)\n\t\t\t.sort((a: [string, string], b: [string, string]) => +a[0] - +b[0])\n\t\t\t.map(([, pubKey]: [unknown, string]) => pubKey)\n\t\t\t.reduce((prev: string, curr: string) => prev + curr, '');\n\t\tconst hash = sha256(pubkeysConcat);\n\t\tconst b64 = Bytes.toBase64(hash);\n\t\treturn b64.slice(0, 12);\n\t}\n\n\tlet pubkeysConcat = Object.entries(keys)\n\t\t.sort((a: [string, string], b: [string, string]) => +a[0] - +b[0])\n\t\t.map(([, pubKey]: [unknown, string]) => hexToBytes(pubKey))\n\t\t.reduce((prev: Uint8Array, curr: Uint8Array) => mergeUInt8Arrays(prev, curr), new Uint8Array());\n\n\tlet hash;\n\tlet hashHex;\n\tswitch (versionByte) {\n\t\tcase 0:\n\t\t\thash = sha256(pubkeysConcat);\n\t\t\thashHex = Bytes.toHex(hash).slice(0, 14);\n\t\t\treturn '00' + hashHex;\n\t\tcase 1:\n\t\t\tif (!unit) {\n\t\t\t\tthrow new Error('Cannot compute keyset ID version 01: unit is required.');\n\t\t\t}\n\t\t\tpubkeysConcat = mergeUInt8Arrays(pubkeysConcat, Bytes.fromString('unit:' + unit));\n\t\t\tif (expiry) {\n\t\t\t\tpubkeysConcat = mergeUInt8Arrays(\n\t\t\t\t\tpubkeysConcat,\n\t\t\t\t\tBytes.fromString('final_expiry:' + expiry.toString()),\n\t\t\t\t);\n\t\t\t}\n\t\t\thash = sha256(pubkeysConcat);\n\t\t\thashHex = Bytes.toHex(hash);\n\t\t\treturn '01' + hashHex;\n\t\tdefault:\n\t\t\tthrow new Error(`Unrecognized keyset ID version: ${versionByte}`);\n\t}\n}\n\nexport function mergeUInt8Arrays(a1: Uint8Array, a2: Uint8Array): Uint8Array {\n\t// sum of individual array lengths\n\tconst mergedArray = new Uint8Array(a1.length + a2.length);\n\tmergedArray.set(a1);\n\tmergedArray.set(a2, a1.length);\n\treturn mergedArray;\n}\n\nexport function sortProofsById(proofs: Proof[]) {\n\treturn proofs.sort((a: Proof, b: Proof) => a.id.localeCompare(b.id));\n}\n\nexport function isObj(v: unknown): v is object {\n\treturn typeof v === 'object';\n}\n\nexport function checkResponse(data: { error?: string; detail?: string }) {\n\tif (!isObj(data)) return;\n\tif ('error' in data && data.error) {\n\t\tthrow new Error(data.error);\n\t}\n\tif ('detail' in data && data.detail) {\n\t\tthrow new Error(data.detail);\n\t}\n}\n\nexport function joinUrls(...parts: string[]): string {\n\treturn parts.map((part: string) => part.replace(/(^\\/+|\\/+$)/g, '')).join('/');\n}\n\nexport function sanitizeUrl(url: string): string {\n\treturn url.replace(/\\/$/, '');\n}\n\nexport function sumProofs(proofs: Proof[]) {\n\treturn proofs.reduce((acc: number, proof: Proof) => acc + proof.amount, 0);\n}\n\nexport function decodePaymentRequest(paymentRequest: string) {\n\treturn PaymentRequest.fromEncodedRequest(paymentRequest);\n}\n\nexport class MessageNode {\n\tprivate _value: string;\n\tprivate _next: MessageNode | null;\n\n\tpublic get value(): string {\n\t\treturn this._value;\n\t}\n\tpublic set value(message: string) {\n\t\tthis._value = message;\n\t}\n\tpublic get next(): MessageNode | null {\n\t\treturn this._next;\n\t}\n\tpublic set next(node: MessageNode | null) {\n\t\tthis._next = node;\n\t}\n\n\tconstructor(message: string) {\n\t\tthis._value = message;\n\t\tthis._next = null;\n\t}\n}\n\nexport class MessageQueue {\n\tprivate _first: MessageNode | null;\n\tprivate _last: MessageNode | null;\n\n\tpublic get first(): MessageNode | null {\n\t\treturn this._first;\n\t}\n\tpublic set first(messageNode: MessageNode | null) {\n\t\tthis._first = messageNode;\n\t}\n\tpublic get last(): MessageNode | null {\n\t\treturn this._last;\n\t}\n\tpublic set last(messageNode: MessageNode | null) {\n\t\tthis._last = messageNode;\n\t}\n\tprivate _size: number;\n\tpublic get size(): number {\n\t\treturn this._size;\n\t}\n\tpublic set size(v: number) {\n\t\tthis._size = v;\n\t}\n\n\tconstructor() {\n\t\tthis._first = null;\n\t\tthis._last = null;\n\t\tthis._size = 0;\n\t}\n\tenqueue(message: string): boolean {\n\t\tconst newNode = new MessageNode(message);\n\t\tif (this._size === 0 || !this._last) {\n\t\t\tthis._first = newNode;\n\t\t\tthis._last = newNode;\n\t\t} else {\n\t\t\tthis._last.next = newNode;\n\t\t\tthis._last = newNode;\n\t\t}\n\t\tthis._size++;\n\t\treturn true;\n\t}\n\tdequeue(): string | null {\n\t\tif (this._size === 0 || !this._first) return null;\n\n\t\tconst prev = this._first;\n\t\tthis._first = prev.next;\n\t\tprev.next = null;\n\n\t\tthis._size--;\n\t\treturn prev.value;\n\t}\n}\n/**\n * Removes all traces of DLEQs from a list of proofs.\n *\n * @param proofs The list of proofs that dleq should be stripped from.\n */\nexport function stripDleq(proofs: Proof[]): Array<Omit<Proof, 'dleq'>> {\n\treturn proofs.map((p) => {\n\t\tconst newP = { ...p };\n\t\tdelete newP['dleq'];\n\t\treturn newP;\n\t});\n}\n\n/**\n * Check that the keyset hashes to the specified ID.\n *\n * @deprecated Now part of Keyset class.\n * @param keys The keyset to be verified.\n * @returns True if the verification was successful, false otherwise.\n * @throws Error if the keyset ID version is unrecognized.\n */\nexport function verifyKeysetId(keys: MintKeys): boolean {\n\tconst isBase64 = isBase64String(keys.id);\n\tconst isValidHex = /^[a-fA-F0-9]+$/.test(keys.id);\n\tconst versionByte = isValidHex ? hexToBytes(keys.id)[0] : 0;\n\treturn (\n\t\tderiveKeysetId(\n\t\t\tkeys.keys,\n\t\t\tkeys.unit,\n\t\t\tkeys.final_expiry,\n\t\t\tversionByte,\n\t\t\tisBase64 && !isValidHex,\n\t\t) === keys.id\n\t);\n}\n\n/**\n * Maps the short keyset IDs stored in the token to actual keyset IDs that were fetched from the\n * Mint.\n */\nfunction mapShortKeysetIds(proofs: Proof[], keysets?: MintKeyset[] | Keyset[]): Proof[] {\n\tconst newProofs = [];\n\tfor (const proof of proofs) {\n\t\tlet idBytes;\n\t\ttry {\n\t\t\tidBytes = hexToBytes(proof.id);\n\t\t} catch {\n\t\t\t// Base64 keysets don't need conversion\n\t\t\tnewProofs.push(proof);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (idBytes[0] === 0x00) {\n\t\t\tnewProofs.push(proof);\n\t\t} else if (idBytes[0] === 0x01) {\n\t\t\tif (!keysets) {\n\t\t\t\tthrow new Error('A short keyset ID v2 was encountered, but got no keysets to map it to.');\n\t\t\t}\n\t\t\t// Look for a match: prefix(keyset ID) == short ID\n\t\t\tlet found = false;\n\t\t\tfor (const keyset of keysets) {\n\t\t\t\tif (proof.id === keyset.id.slice(0, proof.id.length)) {\n\t\t\t\t\tproof.id = keyset.id;\n\t\t\t\t\tnewProofs.push(proof);\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Couldn't map short keyset ID ${proof.id} to any known keysets of the current Mint`,\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(`Unknown keyset ID version: ${idBytes[0]}`);\n\t\t}\n\t}\n\n\treturn newProofs;\n}\n\n/**\n * Checks that the proof has a valid DLEQ proof according to keyset `keys`\n *\n * @param proof The proof subject to verification.\n * @param keyset The Mint's keyset to be used for verification.\n * @returns True if verification succeeded, false otherwise.\n * @throws Error if @param proof does not match any key in @param keyset.\n */\nexport function hasValidDleq(proof: Proof, keyset: MintKeys | Keyset): boolean {\n\tif (proof.dleq == undefined) {\n\t\treturn false;\n\t}\n\tconst dleq = {\n\t\te: hexToBytes(proof.dleq.e),\n\t\ts: hexToBytes(proof.dleq.s),\n\t\tr: hexToNumber(proof.dleq.r ?? '00'),\n\t} as DLEQ;\n\tif (!hasCorrespondingKey(proof.amount, keyset.keys)) {\n\t\tthrow new Error(`undefined key for amount ${proof.amount}`);\n\t}\n\tconst key = keyset.keys[proof.amount];\n\treturn verifyDLEQProof_reblind(\n\t\tnew TextEncoder().encode(proof.secret),\n\t\tdleq,\n\t\tpointFromHex(proof.C),\n\t\tpointFromHex(key),\n\t);\n}\n\nfunction concatByteArrays(...arrays: Uint8Array[]): Uint8Array {\n\tconst totalLength = arrays.reduce((a, c) => a + c.length, 0);\n\tconst byteArray = new Uint8Array(totalLength);\n\tlet pointer = 0;\n\tfor (let i = 0; i < arrays.length; i++) {\n\t\tbyteArray.set(arrays[i], pointer);\n\t\tpointer = pointer + arrays[i].length;\n\t}\n\treturn byteArray;\n}\n\nexport function getEncodedTokenBinary(token: Token): Uint8Array {\n\tconst utf8Encoder = new TextEncoder();\n\tconst template = templateFromToken(token);\n\tconst binaryTemplate = encodeCBOR(template);\n\tconst prefix = utf8Encoder.encode('craw');\n\tconst version = utf8Encoder.encode('B');\n\treturn concatByteArrays(prefix, version, binaryTemplate);\n}\n\nexport function getDecodedTokenBinary(bytes: Uint8Array): Token {\n\tconst utfDecoder = new TextDecoder();\n\tconst prefix = utfDecoder.decode(bytes.slice(0, 4));\n\tconst version = utfDecoder.decode(new Uint8Array([bytes[4]]));\n\tif (prefix !== 'craw' || version !== 'B') {\n\t\tthrow new Error('not a valid binary token');\n\t}\n\tconst binaryToken = bytes.slice(5);\n\tconst decoded = decodeCBOR(binaryToken) as TokenV4Template;\n\treturn tokenFromTemplate(decoded);\n}\n\nfunction sumArray(arr: number[]) {\n\treturn arr.reduce((a, c) => a + c, 0);\n}\n\n/**\n * Utility function for deep equality comparison of objects.\n */\nexport function deepEqual<T>(a: T, b: T): boolean {\n\tif (a === b) return true;\n\tif (a == null || b == null) return false;\n\tif (typeof a !== 'object' || typeof b !== 'object') return false;\n\n\tif (Array.isArray(a) && Array.isArray(b)) {\n\t\tif (a.length !== b.length) return false;\n\t\treturn a.every((item, index) => deepEqual(item, b[index]));\n\t}\n\n\tif (Array.isArray(a) || Array.isArray(b)) return false;\n\n\tconst keysA = Object.keys(a) as Array<keyof T>;\n\tconst keysB = Object.keys(b) as Array<keyof T>;\n\tif (keysA.length !== keysB.length) return false;\n\n\treturn keysA.every((key) => keysB.includes(key) && deepEqual(a[key], b[key]));\n}\n\nfunction removePrefix(token: string): string {\n\tconst uriPrefixes = ['web+cashu://', 'cashu://', 'cashu:', 'cashu'];\n\turiPrefixes.forEach((prefix: string) => {\n\t\tif (!token.startsWith(prefix)) {\n\t\t\treturn;\n\t\t}\n\t\ttoken = token.slice(prefix.length);\n\t});\n\treturn token;\n}\n", "import { MessageQueue } from '../utils';\nimport { type JsonRpcMessage, type JsonRpcReqParams, type RpcSubId } from '../model/types';\nimport { type OnOpenError, type OnOpenSuccess } from '../wallet/types/websocket';\nimport { getWebSocketImpl } from './ws';\nimport { type Logger, NULL_LOGGER } from '../logger';\n\n// Internal interface for RPC listeners\ninterface RpcListener {\n\tcallback: () => void;\n\terrorCallback: (e: Error) => void;\n}\n\nexport class ConnectionManager {\n\tprivate static instance: ConnectionManager;\n\tprivate connectionMap: Map<string, WSConnection> = new Map();\n\n\tstatic getInstance() {\n\t\tif (!ConnectionManager.instance) {\n\t\t\tConnectionManager.instance = new ConnectionManager();\n\t\t}\n\t\treturn ConnectionManager.instance;\n\t}\n\n\tgetConnection(url: string, logger?: Logger): WSConnection {\n\t\tif (this.connectionMap.has(url)) {\n\t\t\treturn this.connectionMap.get(url) as WSConnection;\n\t\t}\n\t\tconst newConn = new WSConnection(url, logger);\n\t\tthis.connectionMap.set(url, newConn);\n\t\treturn newConn;\n\t}\n}\n\nexport class WSConnection {\n\tpublic readonly url: URL;\n\tprivate readonly _WS: typeof WebSocket;\n\tprivate ws: WebSocket | undefined;\n\tprivate connectionPromise: Promise<void> | undefined;\n\tprivate subListeners: { [subId: string]: Array<(payload: unknown) => void> } = {};\n\tprivate rpcListeners: { [rpcSubId: string]: RpcListener } = {};\n\tprivate messageQueue: MessageQueue;\n\tprivate handlingInterval?: number;\n\tprivate rpcId = 0;\n\tprivate _logger: Logger;\n\tprivate onCloseCallbacks: Array<(e: CloseEvent) => void> = [];\n\n\tconstructor(url: string, logger?: Logger) {\n\t\tthis._WS = getWebSocketImpl();\n\t\tthis.url = new URL(url);\n\t\tthis.messageQueue = new MessageQueue();\n\t\tthis._logger = logger ?? NULL_LOGGER;\n\t}\n\n\tconnect() {\n\t\tif (!this.connectionPromise) {\n\t\t\tthis.connectionPromise = new Promise((resolve: OnOpenSuccess, reject: OnOpenError) => {\n\t\t\t\ttry {\n\t\t\t\t\tthis.ws = new this._WS(this.url.toString());\n\t\t\t\t\tthis.onCloseCallbacks = [];\n\t\t\t\t} catch (err: unknown) {\n\t\t\t\t\treject(err instanceof Error ? err : new Error(String(err)));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.ws.onopen = () => {\n\t\t\t\t\tresolve();\n\t\t\t\t};\n\t\t\t\tthis.ws.onerror = () => {\n\t\t\t\t\treject(new Error('Failed to open WebSocket'));\n\t\t\t\t};\n\t\t\t\tthis.ws.onmessage = (e: MessageEvent) => {\n\t\t\t\t\tthis.messageQueue.enqueue(e.data as string);\n\t\t\t\t\tif (!this.handlingInterval) {\n\t\t\t\t\t\tthis.handlingInterval = setInterval(\n\t\t\t\t\t\t\tthis.handleNextMessage.bind(this),\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t) as unknown as number;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tthis.ws.onclose = (e: CloseEvent) => {\n\t\t\t\t\tthis.connectionPromise = undefined;\n\t\t\t\t\tthis.onCloseCallbacks.forEach((cb) => cb(e));\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\t\treturn this.connectionPromise;\n\t}\n\n\tsendRequest(method: 'subscribe', params: JsonRpcReqParams): void;\n\tsendRequest(method: 'unsubscribe', params: { subId: string }): void;\n\tsendRequest(method: 'subscribe' | 'unsubscribe', params: Partial<JsonRpcReqParams>) {\n\t\tif (this.ws?.readyState !== 1) {\n\t\t\tif (method === 'unsubscribe') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._logger.error('Attempted sendRequest, but socket was not open');\n\t\t\tthrow new Error('Socket not open');\n\t\t}\n\t\tconst id = this.rpcId;\n\t\tthis.rpcId++;\n\t\tconst message = JSON.stringify({ jsonrpc: '2.0', method, params, id });\n\t\tthis.ws?.send(message);\n\t}\n\n\t/**\n\t * @deprecated Use cancelSubscription for JSONRPC compliance.\n\t */\n\tcloseSubscription(subId: string) {\n\t\tthis.ws?.send(JSON.stringify(['CLOSE', subId]));\n\t}\n\n\taddSubListener<TPayload = unknown>(subId: string, callback: (payload: TPayload) => void) {\n\t\t(this.subListeners[subId] = this.subListeners[subId] || []).push(\n\t\t\tcallback as (payload: unknown) => void,\n\t\t);\n\t}\n\n\tprivate addRpcListener(\n\t\tcallback: () => void,\n\t\terrorCallback: (e: Error) => void,\n\t\tid: Exclude<RpcSubId, null>,\n\t) {\n\t\tthis.rpcListeners[id] = { callback, errorCallback };\n\t}\n\n\tprivate removeRpcListener(id: Exclude<RpcSubId, null>) {\n\t\tdelete this.rpcListeners[id];\n\t}\n\n\tprivate removeListener<TPayload = unknown>(subId: string, callback: (payload: TPayload) => void) {\n\t\tif (!this.subListeners[subId]) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.subListeners[subId].length === 1) {\n\t\t\tdelete this.subListeners[subId];\n\t\t\treturn;\n\t\t}\n\t\tthis.subListeners[subId] = this.subListeners[subId].filter(\n\t\t\t(fn) => fn !== (callback as (payload: unknown) => void),\n\t\t);\n\t}\n\n\tasync ensureConnection() {\n\t\tif (this.ws?.readyState !== 1) {\n\t\t\tawait this.connect();\n\t\t}\n\t}\n\n\tprivate handleNextMessage() {\n\t\tif (this.messageQueue.size === 0) {\n\t\t\tclearInterval(this.handlingInterval);\n\t\t\tthis.handlingInterval = undefined;\n\t\t\treturn;\n\t\t}\n\t\tconst message = this.messageQueue.dequeue() as string;\n\t\tlet parsed;\n\t\ttry {\n\t\t\tparsed = JSON.parse(message) as JsonRpcMessage;\n\t\t\tif ('result' in parsed && parsed.id != undefined) {\n\t\t\t\tif (this.rpcListeners[parsed.id]) {\n\t\t\t\t\tthis.rpcListeners[parsed.id].callback();\n\t\t\t\t\tthis.removeRpcListener(parsed.id);\n\t\t\t\t}\n\t\t\t} else if ('error' in parsed && parsed.id != undefined) {\n\t\t\t\tif (this.rpcListeners[parsed.id]) {\n\t\t\t\t\tthis.rpcListeners[parsed.id].errorCallback(new Error(parsed.error.message));\n\t\t\t\t\tthis.removeRpcListener(parsed.id);\n\t\t\t\t}\n\t\t\t} else if ('method' in parsed) {\n\t\t\t\tif ('id' in parsed) {\n\t\t\t\t\t// Do nothing as mints should not send requests\n\t\t\t\t} else {\n\t\t\t\t\tconst subId = parsed.params?.subId;\n\t\t\t\t\tif (!subId) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (this.subListeners[subId]?.length > 0) {\n\t\t\t\t\t\tconst notification = parsed;\n\t\t\t\t\t\tthis.subListeners[subId].forEach((cb) => cb(notification.params?.payload));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tthis._logger.error('Error doing handleNextMessage', { e });\n\t\t\treturn;\n\t\t}\n\t}\n\n\tcreateSubscription<TPayload = unknown>(\n\t\tparams: Omit<JsonRpcReqParams, 'subId'>,\n\t\tcallback: (payload: TPayload) => void,\n\t\terrorCallback: (e: Error) => void,\n\t): string {\n\t\tif (this.ws?.readyState !== 1) {\n\t\t\tthis._logger.error('Attempted createSubscription, but socket was not open');\n\t\t\tthrow new Error('Socket is not open');\n\t\t}\n\t\tconst subId = (Math.random() + 1).toString(36).substring(7);\n\t\tthis.addRpcListener(\n\t\t\t() => {\n\t\t\t\tthis.addSubListener(subId, callback);\n\t\t\t},\n\t\t\terrorCallback,\n\t\t\tthis.rpcId,\n\t\t);\n\t\tthis.sendRequest('subscribe', { ...params, subId });\n\t\tthis.rpcId++;\n\t\treturn subId;\n\t}\n\n\t/**\n\t * Cancels a subscription, sending an unsubscribe request and handling responses.\n\t *\n\t * @param subId The subscription ID to cancel.\n\t * @param callback The original payload callback to remove.\n\t * @param errorCallback Optional callback for unsubscribe errors (defaults to logging).\n\t */\n\tcancelSubscription<TPayload = unknown>(\n\t\tsubId: string,\n\t\tcallback: (payload: TPayload) => void,\n\t\terrorCallback?: (e: Error) => void,\n\t) {\n\t\tthis.removeListener(subId, callback);\n\t\tthis.addRpcListener(\n\t\t\t() => {\n\t\t\t\tthis._logger.info('Unsubscribed {subId}', { subId });\n\t\t\t},\n\t\t\terrorCallback || ((e: Error) => this._logger.error('Unsubscribe failed', { e })),\n\t\t\tthis.rpcId,\n\t\t);\n\t\tthis.sendRequest('unsubscribe', { subId });\n\t}\n\n\tget activeSubscriptions() {\n\t\treturn Object.keys(this.subListeners);\n\t}\n\n\tclose() {\n\t\tif (this.ws) {\n\t\t\tthis.ws?.close();\n\t\t}\n\t}\n\n\tonClose(callback: (e: CloseEvent) => void) {\n\t\tthis.onCloseCallbacks.push(callback);\n\t}\n}\n", "import type { PartialMeltQuoteResponse } from '../mint/types';\nimport { MeltQuoteState } from '../mint/types';\nimport type { Logger } from '../logger';\n\nexport type MeltQuoteResponsePaidDeprecated = {\n\tpaid?: boolean;\n};\n\nexport function handleMeltQuoteResponseDeprecated(\n\tresponse: PartialMeltQuoteResponse & MeltQuoteResponsePaidDeprecated,\n\tlogger: Logger,\n): PartialMeltQuoteResponse {\n\t// if the response MeltQuoteResponse has a \"paid\" flag, we monkey patch it to the state enum\n\tif (!response.state) {\n\t\tlogger.warn(\n\t\t\t\"Field 'state' not found in MeltQuoteResponse. Update NUT-05 of mint: https://github.com/cashubtc/nuts/pull/136)\",\n\t\t);\n\t\tif (typeof response.paid === 'boolean') {\n\t\t\tresponse.state = response.paid ? MeltQuoteState.PAID : MeltQuoteState.UNPAID;\n\t\t}\n\t}\n\treturn response;\n}\n", "import type { PartialMintQuoteResponse } from '../mint/types';\nimport { MintQuoteState } from '../mint/types';\nimport type { Logger } from '../logger';\n\nexport type MintQuoteResponsePaidDeprecated = {\n\tpaid?: boolean;\n};\n\nexport function handleMintQuoteResponseDeprecated(\n\tresponse: PartialMintQuoteResponse & MintQuoteResponsePaidDeprecated,\n\tlogger: Logger,\n): PartialMintQuoteResponse {\n\t// if the response MeltQuoteResponse has a \"paid\" flag, we monkey patch it to the state enum\n\tif (!response.state) {\n\t\tlogger.warn(\n\t\t\t\"Field 'state' not found in MintQuoteResponse. Update NUT-04 of mint: https://github.com/cashubtc/nuts/pull/141)\",\n\t\t);\n\t\tif (typeof response.paid === 'boolean') {\n\t\t\tresponse.state = response.paid ? MintQuoteState.PAID : MintQuoteState.UNPAID;\n\t\t}\n\t}\n\treturn response;\n}\n", "import type { MintContactInfo, GetInfoResponse } from '../mint/types';\nimport type { Logger } from '../logger';\n\nexport function handleMintInfoContactFieldDeprecated(data: GetInfoResponse, logger: Logger) {\n\t// Monkey patch old contact field [\"email\", \"me@mail.com\"] Array<[string, string]>; to new contact field [{method: \"email\", info: \"me@mail.com\"}] Array<MintContactInfo>\n\t// This is to maintain backwards compatibility with older versions of the mint\n\tif (Array.isArray(data?.contact) && data?.contact.length > 0) {\n\t\tdata.contact = data.contact.map((contact: MintContactInfo) => {\n\t\t\tif (\n\t\t\t\tArray.isArray(contact) &&\n\t\t\t\tcontact.length === 2 &&\n\t\t\t\ttypeof contact[0] === 'string' &&\n\t\t\t\ttypeof contact[1] === 'string'\n\t\t\t) {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t`Mint returned deprecated 'contact' field: Update NUT-06: https://github.com/cashubtc/nuts/pull/117`,\n\t\t\t\t);\n\t\t\t\treturn { method: contact[0], info: contact[1] } as MintContactInfo;\n\t\t\t}\n\t\t\treturn contact;\n\t\t});\n\t}\n\treturn data;\n}\n", "import {\n\ttype GetInfoResponse,\n\ttype MPPMethod,\n\ttype SwapMethod,\n\ttype WebSocketSupport,\n} from '../mint/types';\n\ntype Method = 'GET' | 'POST';\ntype Endpoint = { method: Method; path: string };\n\ntype ProtectedIndex = {\n\tcache: Record<string, boolean>; // \"METHOD /v1/foo\"\n\texact: Array<{ method: Method; path: string }>;\n\tregex: Array<{ method: Method; regex: RegExp }>;\n};\n\nexport class MintInfo {\n\t// Full mint info response\n\tprivate readonly _mintInfo: GetInfoResponse;\n\t// NUT-22, Blind-auth protected endpoints\n\tprivate readonly _protected22?: ProtectedIndex;\n\t// NUT-21, Clear-auth protected endpoints\n\tprivate readonly _protected21?: ProtectedIndex;\n\t// detects regex intent\n\tprivate readonly REGEX_METACHAR = /[\\\\^$.*+?()[\\]{}|]/;\n\n\tconstructor(info: GetInfoResponse) {\n\t\tthis._mintInfo = info;\n\n\t\tconst pe22 = this.toEndpoints(info?.nuts?.[22]?.protected_endpoints);\n\t\tthis._protected22 = this.buildIndex(pe22);\n\n\t\tconst pe21 = this.toEndpoints(info?.nuts?.[21]?.protected_endpoints);\n\t\tthis._protected21 = this.buildIndex(pe21);\n\t}\n\n\tisSupported(num: 4 | 5): { disabled: boolean; params: SwapMethod[] };\n\tisSupported(num: 7 | 8 | 9 | 10 | 11 | 12 | 14 | 20): { supported: boolean };\n\tisSupported(num: 17): { supported: boolean; params?: WebSocketSupport[] };\n\tisSupported(num: 15): { supported: boolean; params?: MPPMethod[] };\n\tisSupported(num: number) {\n\t\tswitch (num) {\n\t\t\tcase 4:\n\t\t\tcase 5: {\n\t\t\t\treturn this.checkMintMelt(num);\n\t\t\t}\n\t\t\tcase 7:\n\t\t\tcase 8:\n\t\t\tcase 9:\n\t\t\tcase 10:\n\t\t\tcase 11:\n\t\t\tcase 12:\n\t\t\tcase 14:\n\t\t\tcase 20: {\n\t\t\t\treturn this.checkGenericNut(num);\n\t\t\t}\n\t\t\tcase 17: {\n\t\t\t\treturn this.checkNut17();\n\t\t\t}\n\t\t\tcase 15: {\n\t\t\t\treturn this.checkNut15();\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error('nut is not supported by cashu-ts');\n\t\t\t}\n\t\t}\n\t}\n\n\trequiresBlindAuthToken(method: 'GET' | 'POST', path: string): boolean {\n\t\treturn this.matchesProtected(this._protected22, method, path);\n\t}\n\n\trequiresClearAuthToken(method: 'GET' | 'POST', path: string): boolean {\n\t\treturn this.matchesProtected(this._protected21, method, path);\n\t}\n\n\tprivate matchesProtected(idx: ProtectedIndex | undefined, method: Method, path: string): boolean {\n\t\tif (!idx) return false;\n\n\t\tconst cacheKey = `${method} ${path}`;\n\t\tconst cached = idx.cache[cacheKey];\n\t\tif (typeof cached === 'boolean') return cached;\n\n\t\tconst exactHit = idx.exact.some((e) => e.method === method && e.path === path);\n\t\tconst regexHit = exactHit\n\t\t\t? false\n\t\t\t: idx.regex.some((e) => e.method === method && e.regex.test(path));\n\n\t\tconst res = exactHit || regexHit;\n\t\tidx.cache[cacheKey] = res;\n\t\treturn res;\n\t}\n\n\tprivate checkGenericNut(num: 7 | 8 | 9 | 10 | 11 | 12 | 14 | 20) {\n\t\treturn this._mintInfo.nuts[num]?.supported ? { supported: true } : { supported: false };\n\t}\n\n\tprivate checkMintMelt(num: 4 | 5) {\n\t\tconst mintMeltInfo = this._mintInfo.nuts[num];\n\t\tif (mintMeltInfo && mintMeltInfo.methods.length > 0 && !mintMeltInfo.disabled) {\n\t\t\treturn { disabled: false, params: mintMeltInfo.methods };\n\t\t}\n\t\treturn { disabled: true, params: mintMeltInfo?.methods ?? [] };\n\t}\n\n\tprivate checkNut17() {\n\t\tif (this._mintInfo.nuts[17] && this._mintInfo.nuts[17].supported.length > 0) {\n\t\t\treturn { supported: true, params: this._mintInfo.nuts[17].supported };\n\t\t}\n\t\treturn { supported: false };\n\t}\n\n\tprivate checkNut15() {\n\t\tif (this._mintInfo.nuts[15] && this._mintInfo.nuts[15].methods.length > 0) {\n\t\t\treturn { supported: true, params: this._mintInfo.nuts[15].methods };\n\t\t}\n\t\treturn { supported: false };\n\t}\n\n\t// ---------- private helpers ----------\n\n\tprivate toEndpoints(maybe: unknown): Endpoint[] {\n\t\tif (!Array.isArray(maybe)) return [];\n\t\tconst out: Endpoint[] = [];\n\t\tfor (const e of maybe) {\n\t\t\tif (e && typeof e === 'object') {\n\t\t\t\tconst rec = e as Record<string, unknown>;\n\t\t\t\tconst mm = rec.method;\n\t\t\t\tconst pp = rec.path;\n\t\t\t\tif (typeof mm === 'string' && typeof pp === 'string') {\n\t\t\t\t\tconst method = mm.toUpperCase();\n\t\t\t\t\tif (method === 'GET' || method === 'POST') {\n\t\t\t\t\t\tout.push({ method, path: pp });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn out;\n\t}\n\n\tprivate buildIndex(endpoints?: Endpoint[]): ProtectedIndex | undefined {\n\t\tif (!endpoints || endpoints.length === 0) return undefined;\n\n\t\tconst exact: ProtectedIndex['exact'] = [];\n\t\tconst regex: ProtectedIndex['regex'] = [];\n\t\tconst metachar = this.REGEX_METACHAR;\n\n\t\tfor (const e of endpoints) {\n\t\t\tconst looksRegex = e.path.startsWith('^') || e.path.endsWith('$') || metachar.test(e.path);\n\t\t\tif (looksRegex) {\n\t\t\t\ttry {\n\t\t\t\t\tregex.push({ method: e.method, regex: new RegExp(e.path) });\n\t\t\t\t\tcontinue;\n\t\t\t\t} catch {\n\t\t\t\t\t// fall back to exact on malformed patterns\n\t\t\t\t}\n\t\t\t}\n\t\t\texact.push({ method: e.method, path: e.path });\n\t\t}\n\n\t\t// plain object avoids the unsafe any from Object.create(null)\n\t\tconst cache: Record<string, boolean> = {};\n\t\treturn { cache, exact, regex };\n\t}\n\n\t// ---------- getters ----------\n\n\tget contact() {\n\t\treturn this._mintInfo.contact;\n\t}\n\tget description() {\n\t\treturn this._mintInfo.description;\n\t}\n\tget description_long() {\n\t\treturn this._mintInfo.description_long;\n\t}\n\tget name() {\n\t\treturn this._mintInfo.name;\n\t}\n\tget pubkey() {\n\t\treturn this._mintInfo.pubkey;\n\t}\n\tget nuts() {\n\t\treturn this._mintInfo.nuts;\n\t}\n\tget version() {\n\t\treturn this._mintInfo.version;\n\t}\n\tget motd() {\n\t\treturn this._mintInfo.motd;\n\t}\n\n\t/**\n\t * @deprecated Use supportsNut04Description(method, unit)\n\t */\n\tget supportsBolt12Description(): boolean {\n\t\treturn this.supportsNut04Description('bolt12');\n\t}\n\n\t/**\n\t * Checks if the mint supports creating invoices/offers with a description for the specified\n\t * payment method.\n\t *\n\t * @param method - The payment method to check ('bolt11' or 'bolt12')\n\t * @returns True if the mint supports description for the method, false otherwise.\n\t */\n\tsupportsNut04Description(method: 'bolt11' | 'bolt12', unit?: string): boolean {\n\t\treturn this._mintInfo.nuts[4]?.methods.some(\n\t\t\t(met) =>\n\t\t\t\tmet.method === method &&\n\t\t\t\t(unit ? met.unit === unit : true) &&\n\t\t\t\t(met.options?.description === true || met.description === true),\n\t\t);\n\t}\n}\n", "import { randomBytes } from '@noble/curves/utils';\nimport { type Logger, NULL_LOGGER, safeCallback } from '../logger';\nimport type { GetInfoResponse } from '../mint/types';\nimport { Bytes, encodeUint8toBase64Url } from '../utils';\nimport { sha256 } from '@noble/hashes/sha2';\n\nexport type OIDCConfig = {\n\tissuer: string;\n\tauthorization_endpoint?: string;\n\ttoken_endpoint: string;\n\tdevice_authorization_endpoint?: string;\n};\n\nexport type TokenResponse = {\n\taccess_token?: string;\n\ttoken_type?: string;\n\texpires_in?: number;\n\trefresh_token?: string;\n\tid_token?: string;\n\tscope?: string;\n\terror?: string;\n\terror_description?: string;\n};\n\nexport type DeviceStartResponse = {\n\tdevice_code: string;\n\tuser_code: string;\n\tverification_uri: string;\n\tverification_uri_complete?: string;\n\tinterval?: number;\n\texpires_in?: number;\n};\n\nexport type OIDCAuthOptions = {\n\tclientId?: string;\n\tscope?: string;\n\tlogger?: Logger;\n\tonTokens?: (t: TokenResponse) => void | Promise<void>;\n};\n\nexport class OIDCAuth {\n\tprivate readonly discoveryUrl: string;\n\tprivate readonly logger: Logger;\n\n\tprivate clientId: string;\n\tprivate scope: string;\n\tprivate config?: OIDCConfig;\n\tprivate onTokens?: (t: TokenResponse) => void | Promise<void>;\n\n\t// External listeners, notified after onTokens fires\n\tprivate tokenListeners: Array<(t: TokenResponse) => void | Promise<void>> = [];\n\n\tstatic fromMintInfo(info: { nuts: GetInfoResponse['nuts'] }, opts?: OIDCAuthOptions): OIDCAuth {\n\t\tconst n21 = info?.nuts?.['21'];\n\t\tif (!n21?.openid_discovery) {\n\t\t\tthrow new Error('OIDCAuth: mint does not advertise NUT-21 openid_discovery');\n\t\t}\n\t\tconst clientId = opts?.clientId ?? n21.client_id ?? 'cashu-client';\n\t\treturn new OIDCAuth(n21.openid_discovery, { ...opts, clientId });\n\t}\n\n\tconstructor(discoveryUrl: string, opts?: OIDCAuthOptions) {\n\t\tthis.discoveryUrl = discoveryUrl;\n\t\tthis.logger = opts?.logger ?? NULL_LOGGER;\n\t\tthis.clientId = opts?.clientId ?? 'cashu-client';\n\t\tthis.scope = opts?.scope ?? 'openid';\n\t\tthis.onTokens = opts?.onTokens;\n\t}\n\n\tsetClient(id: string): void {\n\t\tthis.clientId = id;\n\t}\n\n\tsetScope(scope?: string): void {\n\t\tthis.scope = scope ?? 'openid';\n\t}\n\n\t/**\n\t * Subscribe to token updates. Listeners are called after the primary onTokens callback.\n\t */\n\taddTokenListener(fn: (t: TokenResponse) => void | Promise<void>): void {\n\t\tthis.tokenListeners.push(fn);\n\t}\n\n\t// ---- Discovery ----\n\n\tasync loadConfig(): Promise<OIDCConfig> {\n\t\tif (this.config) return this.config;\n\t\tconst res = await fetch(this.discoveryUrl, {\n\t\t\tmethod: 'GET',\n\t\t\theaders: { Accept: 'application/json' },\n\t\t});\n\t\tconst text = await res.text();\n\t\tlet json: unknown;\n\t\ttry {\n\t\t\tjson = text ? JSON.parse(text) : undefined;\n\t\t} catch (err) {\n\t\t\tthis.logger.warn('OIDCAuth: bad discovery JSON', { err });\n\t\t}\n\t\tif (!res.ok || !json) {\n\t\t\tthrow new Error('OIDCAuth: invalid discovery document');\n\t\t}\n\t\tconst cfg = json as OIDCConfig;\n\t\tif (typeof cfg.token_endpoint !== 'string' || cfg.token_endpoint.length === 0) {\n\t\t\tthrow new Error('OIDCAuth: invalid discovery document, missing token_endpoint');\n\t\t}\n\t\tthis.config = cfg;\n\t\treturn cfg;\n\t}\n\n\t// --- Authorization Code with PKCE ---\n\n\t/**\n\t * Generate a PKCE verifier and S256 challenge.\n\t *\n\t * - Verifier: base64url of random bytes, length >= 43, RFC 7636 compliant.\n\t * - Challenge: base64url(sha256(verifier))\n\t */\n\tgeneratePKCE(): { verifier: string; challenge: string } {\n\t\t// 48 bytes->base64url is typically 64 chars without padding, comfortably >= 43\n\t\tconst rnd = randomBytes(48);\n\t\tconst verifier = encodeUint8toBase64Url(rnd);\n\n\t\t// RFC 7636, challenge = BASE64URL-ENCODE( SHA256( ASCII(verifier) ) )\n\t\tconst vBytes = Bytes.fromString(verifier);\n\t\tconst chBytes = sha256(vBytes);\n\t\tconst challenge = encodeUint8toBase64Url(chBytes);\n\n\t\treturn { verifier, challenge };\n\t}\n\n\t/**\n\t * Build an Authorization Code + PKCE URL.\n\t */\n\tasync buildAuthCodeUrl(input: {\n\t\tredirectUri: string;\n\t\tcodeChallenge: string;\n\t\tcodeChallengeMethod?: 'S256' | 'plain'; // default S256\n\t\tstate?: string; // optional state to pass back to redirectUrl\n\t\tscope?: string; // default this.scope\n\t}): Promise<string> {\n\t\tconst cfg = await this.loadConfig();\n\t\tconst scope = input.scope ?? this.scope;\n\t\tconst params = new URLSearchParams({\n\t\t\tresponse_type: 'code',\n\t\t\tclient_id: this.clientId,\n\t\t\tredirect_uri: input.redirectUri,\n\t\t\tscope,\n\t\t\tcode_challenge_method: input.codeChallengeMethod ?? 'S256',\n\t\t\tcode_challenge: input.codeChallenge,\n\t\t});\n\t\tif (input.state) params.set('state', input.state);\n\n\t\tif (!cfg.authorization_endpoint) {\n\t\t\tthrow new Error('OIDCAuth: discovery lacks authorization_endpoint');\n\t\t}\n\t\treturn `${cfg.authorization_endpoint}?${params.toString()}`;\n\t}\n\n\t/**\n\t * Exchange an auth code for tokens, using the PKCE verifier.\n\t */\n\tasync exchangeAuthCode(input: { code: string; redirectUri: string; codeVerifier: string }) {\n\t\tconst cfg = await this.loadConfig();\n\t\tconst form = this.toForm({\n\t\t\tgrant_type: 'authorization_code',\n\t\t\tcode: input.code,\n\t\t\tredirect_uri: input.redirectUri,\n\t\t\tclient_id: this.clientId,\n\t\t\tcode_verifier: input.codeVerifier,\n\t\t});\n\t\tconst tok = await this.postFormStrict<TokenResponse>(cfg.token_endpoint, form);\n\t\tthis.handleTokens(tok);\n\t\treturn tok;\n\t}\n\n\t// ---- Device Code (recommended for CLIs) ----\n\n\tasync deviceStart(): Promise<DeviceStartResponse> {\n\t\tconst cfg = await this.loadConfig();\n\t\tconst ep = cfg.device_authorization_endpoint;\n\t\tif (!ep) throw new Error('OIDCAuth: provider lacks device_authorization_endpoint');\n\n\t\tconst form = this.toForm({ client_id: this.clientId, scope: this.scope });\n\t\treturn this.postFormStrict<DeviceStartResponse>(ep, form);\n\t}\n\n\tasync devicePoll(device_code: string, intervalSec = 5): Promise<TokenResponse> {\n\t\tconst cfg = await this.loadConfig();\n\t\t// Clamp to a sensible minimum to avoid hot loops\n\t\tlet delay = Math.max(1, intervalSec);\n\t\twhile (true) {\n\t\t\tawait this.sleep(delay * 1000);\n\t\t\tconst form = this.toForm({\n\t\t\t\tgrant_type: 'urn:ietf:params:oauth:grant-type:device_code',\n\t\t\t\tdevice_code,\n\t\t\t\tclient_id: this.clientId,\n\t\t\t});\n\t\t\tconst res = await this.postFormLoose<TokenResponse>(cfg.token_endpoint, form);\n\t\t\tif (res.access_token) {\n\t\t\t\tthis.handleTokens(res);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\tconst err = (res.error ?? '').toString();\n\t\t\tif (err === 'authorization_pending') continue;\n\t\t\tif (err === 'slow_down') {\n\t\t\t\tdelay = Math.max(delay + 5, delay * 2);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst msg = res.error_description || err || 'device authorization failed';\n\t\t\tthrow new Error(`OIDCAuth: ${msg}`);\n\t\t}\n\t}\n\n\t/**\n\t * One call convenience for Device Code flow.\n\t *\n\t * @remarks\n\t * Polling interval will be the MAX of intervalSec and Mint interval.\n\t * @param intervalSec Desired polling interval in seconds.\n\t * @returns The start fields and helpers to poll or cancel.\n\t */\n\tasync startDeviceAuth(intervalSec: number = 5): Promise<\n\t\tDeviceStartResponse & {\n\t\t\tpoll: () => Promise<TokenResponse>;\n\t\t\tcancel: () => void;\n\t\t}\n\t> {\n\t\tconst start = await this.deviceStart();\n\t\tconst interval = Math.max(start.interval ?? 1, intervalSec);\n\t\tlet aborted = false;\n\n\t\tconst poll = async (): Promise<TokenResponse> => {\n\t\t\tconst cfg = await this.loadConfig();\n\t\t\tlet delay = Math.max(1, interval);\n\t\t\twhile (true) {\n\t\t\t\tif (aborted) throw new Error('OIDCAuth: device polling cancelled');\n\t\t\t\tawait this.sleep(delay * 1000);\n\t\t\t\tconst form = this.toForm({\n\t\t\t\t\tgrant_type: 'urn:ietf:params:oauth:grant-type:device_code',\n\t\t\t\t\tdevice_code: start.device_code,\n\t\t\t\t\tclient_id: this.clientId,\n\t\t\t\t});\n\t\t\t\tconst res = await this.postFormLoose<TokenResponse>(cfg.token_endpoint, form);\n\t\t\t\tif (res.access_token) {\n\t\t\t\t\tthis.handleTokens(res);\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tconst err = (res.error ?? '').toString();\n\t\t\t\tif (err === 'authorization_pending') continue;\n\t\t\t\tif (err === 'slow_down') {\n\t\t\t\t\tdelay = Math.max(delay + 5, delay * 2);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst msg = res.error_description || err || 'device authorization failed';\n\t\t\t\tthrow new Error(`OIDCAuth: ${msg}`);\n\t\t\t}\n\t\t};\n\n\t\tconst cancel = (): void => {\n\t\t\taborted = true;\n\t\t};\n\n\t\treturn { ...start, poll, cancel };\n\t}\n\n\t// ---- Refresh ----\n\n\tasync refresh(refresh_token: string): Promise<TokenResponse> {\n\t\tconst cfg = await this.loadConfig();\n\t\tconst form = this.toForm({\n\t\t\tgrant_type: 'refresh_token',\n\t\t\trefresh_token,\n\t\t\tclient_id: this.clientId,\n\t\t});\n\t\tconst tok = await this.postFormStrict<TokenResponse>(cfg.token_endpoint, form);\n\t\tthis.handleTokens(tok);\n\t\treturn tok;\n\t}\n\n\t// ---- ROPC (discouraged, but some mints allow it) ----\n\n\tasync passwordGrant(username: string, password: string): Promise<TokenResponse> {\n\t\tconst cfg = await this.loadConfig();\n\t\tconst form = this.toForm({\n\t\t\tgrant_type: 'password',\n\t\t\tclient_id: this.clientId,\n\t\t\tusername,\n\t\t\tpassword,\n\t\t\tscope: this.scope,\n\t\t});\n\t\tconst tok = await this.postFormStrict<TokenResponse>(cfg.token_endpoint, form);\n\t\tthis.handleTokens(tok);\n\t\treturn tok;\n\t}\n\n\t// ---- internals ----\n\n\t/**\n\t * Fire and forget token fan out. Any listener errors are logged inside safeCallback. Nothing\n\t * thrown here will come from listeners.\n\t */\n\tprivate handleTokens(t: TokenResponse): void {\n\t\tif (!t.access_token) {\n\t\t\tconst msg = t.error_description || t.error || 'token response missing access_token';\n\t\t\tthrow new Error(`OIDCAuth: ${msg}`);\n\t\t}\n\t\t// Schedule on microtask queue so we never block the caller and we avoid sync throws leaking.\n\t\tqueueMicrotask(() =>\n\t\t\tsafeCallback(this.onTokens, t, this.logger, { where: 'OIDCAuth.handleTokens' }),\n\t\t);\n\n\t\tfor (const listener of this.tokenListeners) {\n\t\t\tqueueMicrotask(() =>\n\t\t\t\tsafeCallback(listener, t, this.logger, {\n\t\t\t\t\twhere: 'OIDCAuth.handleTokens.listener',\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate toForm(params: Record<string, string>): string {\n\t\tconst enc = (v: string) => encodeURIComponent(v).replace(/%20/g, '+');\n\t\treturn Object.entries(params)\n\t\t\t.map(([k, v]) => `${enc(k)}=${enc(v)}`)\n\t\t\t.join('&');\n\t}\n\n\t// Strict, throws on non 2xx\n\tprivate async postFormStrict<TSuccess extends object>(\n\t\tendpoint: string,\n\t\tformBody: string,\n\t): Promise<TSuccess> {\n\t\ttry {\n\t\t\tthis.logger.debug('OIDCAuth Request', { formBody });\n\t\t\tconst res = await fetch(endpoint, {\n\t\t\t\tmethod: 'POST',\n\t\t\t\theaders: {\n\t\t\t\t\t'Content-Type': 'application/x-www-form-urlencoded',\n\t\t\t\t\tAccept: 'application/json',\n\t\t\t\t},\n\t\t\t\tbody: formBody,\n\t\t\t});\n\t\t\tconst text = await res.text();\n\t\t\tlet json: unknown;\n\t\t\ttry {\n\t\t\t\tjson = text ? JSON.parse(text) : undefined;\n\t\t\t} catch (err) {\n\t\t\t\tthis.logger.warn('OIDCAuth: bad JSON (strict)', { err });\n\t\t\t}\n\t\t\tif (!res.ok) {\n\t\t\t\tconst err = (json ?? {}) as TokenResponse;\n\t\t\t\tconst msg = err.error_description || err.error || `HTTP ${res.status}`;\n\t\t\t\tthrow new Error(`OIDCAuth: ${msg}`);\n\t\t\t}\n\t\t\tthis.logger.debug('OIDCAuth Response', { json });\n\t\t\treturn (json ?? {}) as TSuccess;\n\t\t} catch (err) {\n\t\t\tthis.logger.error('OIDCAuth: postFormStrict failed', { err });\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\t// Loose, returns JSON payload even on non 2xx\n\tprivate async postFormLoose<T extends object>(\n\t\tendpoint: string,\n\t\tformBody: string,\n\t): Promise<T | TokenResponse> {\n\t\ttry {\n\t\t\tthis.logger.debug('OIDCAuth Request', { formBody });\n\t\t\tconst res = await fetch(endpoint, {\n\t\t\t\tmethod: 'POST',\n\t\t\t\theaders: {\n\t\t\t\t\t'Content-Type': 'application/x-www-form-urlencoded',\n\t\t\t\t\tAccept: 'application/json',\n\t\t\t\t},\n\t\t\t\tbody: formBody,\n\t\t\t});\n\t\t\tconst text = await res.text();\n\t\t\tlet json: unknown;\n\t\t\ttry {\n\t\t\t\tjson = text ? JSON.parse(text) : undefined;\n\t\t\t} catch (err) {\n\t\t\t\tthis.logger.warn('OIDCAuth: bad JSON (loose)', { err });\n\t\t\t}\n\t\t\tthis.logger.debug('OIDCAuth Response', { json });\n\t\t\treturn (json ?? {}) as T | TokenResponse;\n\t\t} catch (err) {\n\t\t\tthis.logger.error('OIDCAuth: postFormLoose network error', { err });\n\t\t\treturn { error: 'network_error', error_description: String(err) };\n\t\t}\n\t}\n\n\tprivate sleep(ms: number): Promise<void> {\n\t\treturn new Promise<void>((resolve) => setTimeout(resolve, ms));\n\t}\n}\n", "/**\n * Cashu Mint Class.\n *\n * @remarks\n * You should ordinarily not need to instantiate a Mint, as it will be auto-instantiated by the\n * Wallet class when you pass in the mint url.\n */\nimport type {\n\tGetInfoResponse,\n\tPartialMintQuoteResponse,\n\tMeltQuoteResponse,\n\tPartialMeltQuoteResponse,\n\tBolt12MintQuoteResponse,\n\tBolt12MeltQuoteResponse,\n\tCheckStateResponse,\n\tPostRestoreResponse,\n\tSwapResponse,\n\tCheckStatePayload,\n\tPostRestorePayload,\n\tMintResponse,\n\tApiError,\n} from './types';\nimport type { MintActiveKeys, MintAllKeysets } from '../model/types/keyset';\nimport type {\n\tMintQuotePayload,\n\tMintPayload,\n\tMeltQuotePayload,\n\tMeltPayload,\n\tSwapPayload,\n\tBolt12MintQuotePayload,\n} from '../wallet/types';\nimport { MeltQuoteState } from './types';\nimport request, {\n\tConnectionManager,\n\ttype WSConnection,\n\tsetRequestLogger,\n\ttype RequestFn,\n\ttype RequestOptions,\n} from '../transport';\nimport { isObj, joinUrls, sanitizeUrl } from '../utils';\nimport {\n\ttype MeltQuoteResponsePaidDeprecated,\n\thandleMeltQuoteResponseDeprecated,\n} from '../legacy/nut-05';\nimport {\n\ttype MintQuoteResponsePaidDeprecated,\n\thandleMintQuoteResponseDeprecated,\n} from '../legacy/nut-04';\nimport { handleMintInfoContactFieldDeprecated } from '../legacy/nut-06';\nimport { MintInfo } from '../model/MintInfo';\nimport { type Logger, NULL_LOGGER } from '../logger';\nimport type { AuthProvider } from '../auth/AuthProvider';\nimport { OIDCAuth, type OIDCAuthOptions } from '../auth/OIDCAuth';\n\n/**\n * Class represents Cashu Mint API.\n *\n * @remarks\n * This class contains lower-level functions that are implemented by Wallet.\n */\nclass Mint {\n\tprivate ws?: WSConnection;\n\tprivate _mintUrl: string;\n\tprivate _request: RequestFn;\n\tprivate _logger: Logger;\n\tprivate _mintInfo?: MintInfo;\n\tprivate _authProvider?: AuthProvider;\n\n\t/**\n\t * @param mintUrl Requires mint URL to create this object.\n\t * @param customRequest Optional, for custom network communication with the mint.\n\t * @param authTokenGetter Optional. Function to obtain a NUT-22 BlindedAuthToken (e.g. from a\n\t *   database or localstorage)\n\t */\n\tconstructor(\n\t\tmintUrl: string,\n\t\toptions?: {\n\t\t\tcustomRequest?: RequestFn;\n\t\t\tauthProvider?: AuthProvider;\n\t\t\tlogger?: Logger;\n\t\t},\n\t) {\n\t\tthis._mintUrl = sanitizeUrl(mintUrl);\n\t\tthis._request = options?.customRequest ?? request;\n\t\tthis._authProvider = options?.authProvider;\n\t\tthis._logger = options?.logger ?? NULL_LOGGER;\n\t\tsetRequestLogger(this._logger);\n\t}\n\n\tget mintUrl() {\n\t\treturn this._mintUrl;\n\t}\n\n\t/**\n\t * Create an OIDC client using this mints NUT-21 metadata.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const oidc = await mint.oidcAuth({ onTokens: (t) => authMgr.setCAT(t.access_token!) });\n\t * const start = await oidc.deviceStart();\n\t * // show start.user_code / start.verification_uri to the user\n\t * const token = await oidc.devicePoll(start.device_code, start.interval ?? 5);\n\t * // token.access_token is your CAT\n\t * ```\n\t */\n\tasync oidcAuth(opts?: OIDCAuthOptions): Promise<OIDCAuth> {\n\t\tconst n21 = (await this.getLazyMintInfo()).nuts['21'];\n\t\tif (!n21?.openid_discovery) {\n\t\t\tthrow new Error('Mint: no NUT-21 openid_discovery');\n\t\t}\n\t\treturn new OIDCAuth(n21.openid_discovery, {\n\t\t\t...opts,\n\t\t\tclientId: opts?.clientId ?? n21.client_id ?? 'cashu-client',\n\t\t});\n\t}\n\n\t/**\n\t * Fetches mint's info at the /info endpoint.\n\t *\n\t * @param customRequest Optional override for the request function.\n\t * @returns The mint's information response.\n\t */\n\tasync getInfo(customRequest?: RequestFn): Promise<GetInfoResponse> {\n\t\tconst requestInstance = customRequest ?? this._request;\n\t\tconst response = await requestInstance<GetInfoResponse>({\n\t\t\tendpoint: joinUrls(this._mintUrl, '/v1/info'),\n\t\t});\n\t\tconst data = handleMintInfoContactFieldDeprecated(response, this._logger);\n\t\treturn data;\n\t}\n\n\t/**\n\t * Lazily fetches and caches the mint's info if not already loaded.\n\t *\n\t * @returns The parsed MintInfo object.\n\t */\n\tasync getLazyMintInfo(): Promise<MintInfo> {\n\t\tif (this._mintInfo) {\n\t\t\treturn this._mintInfo;\n\t\t}\n\t\tconst data = await this.getInfo();\n\t\tthis._mintInfo = new MintInfo(data);\n\t\treturn this._mintInfo;\n\t}\n\n\t/**\n\t * Performs a swap operation with ecash inputs and outputs.\n\t *\n\t * @param swapPayload Payload containing inputs and outputs.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Signed outputs.\n\t */\n\tasync swap(swapPayload: SwapPayload, customRequest?: RequestFn): Promise<SwapResponse> {\n\t\tconst data = await this.requestWithAuth<SwapResponse>(\n\t\t\t'POST',\n\t\t\t'/v1/swap',\n\t\t\t{ requestBody: swapPayload },\n\t\t\tcustomRequest,\n\t\t);\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tconst errDetail = isObj(data) && 'detail' in data ? (data as ApiError).detail : undefined;\n\t\t\tthrow new Error(errDetail ?? 'bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Requests a new mint quote from the mint.\n\t *\n\t * @param mintQuotePayload Payload for creating a new mint quote.\n\t * @param customRequest Optional override for the request function.\n\t * @returns A new mint quote containing a payment request for the specified amount and unit.\n\t */\n\tasync createMintQuoteBolt11(\n\t\tmintQuotePayload: MintQuotePayload,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<PartialMintQuoteResponse> {\n\t\tconst response = await this.requestWithAuth<\n\t\t\tPartialMintQuoteResponse & MintQuoteResponsePaidDeprecated\n\t\t>('POST', '/v1/mint/quote/bolt11', { requestBody: mintQuotePayload }, customRequest);\n\t\tconst data = handleMintQuoteResponseDeprecated(response, this._logger);\n\t\treturn data;\n\t}\n\n\t/**\n\t * Requests a new BOLT12 mint quote from the mint using Lightning Network offers.\n\t *\n\t * @param mintQuotePayload Payload containing amount, unit, optional description, and required\n\t *   pubkey.\n\t * @param customRequest Optional override for the request function.\n\t * @returns A mint quote containing a BOLT12 offer.\n\t */\n\tasync createMintQuoteBolt12(\n\t\tmintQuotePayload: Bolt12MintQuotePayload,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<Bolt12MintQuoteResponse> {\n\t\tconst response = await this.requestWithAuth<Bolt12MintQuoteResponse>(\n\t\t\t'POST',\n\t\t\t'/v1/mint/quote/bolt12',\n\t\t\t{ requestBody: mintQuotePayload },\n\t\t\tcustomRequest,\n\t\t);\n\t\treturn response;\n\t}\n\n\t/**\n\t * Gets an existing mint quote from the mint.\n\t *\n\t * @param quote Quote ID.\n\t * @param customRequest Optional override for the request function.\n\t * @returns The status of the mint quote, including payment details and state.\n\t */\n\tasync checkMintQuoteBolt11(\n\t\tquote: string,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<PartialMintQuoteResponse> {\n\t\tconst response = await this.requestWithAuth<\n\t\t\tPartialMintQuoteResponse & MintQuoteResponsePaidDeprecated\n\t\t>('GET', `/v1/mint/quote/bolt11/${quote}`, {}, customRequest);\n\n\t\tconst data = handleMintQuoteResponseDeprecated(response, this._logger);\n\t\treturn data;\n\t}\n\n\t/**\n\t * Gets an existing BOLT12 mint quote from the mint.\n\t *\n\t * @param quote Quote ID to check.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Updated quote with current payment and issuance amounts.\n\t */\n\tasync checkMintQuoteBolt12(\n\t\tquote: string,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<Bolt12MintQuoteResponse> {\n\t\tconst response = await this.requestWithAuth<Bolt12MintQuoteResponse>(\n\t\t\t'GET',\n\t\t\t`/v1/mint/quote/bolt12/${quote}`,\n\t\t\t{},\n\t\t\tcustomRequest,\n\t\t);\n\t\treturn response;\n\t}\n\n\t/**\n\t * Mints new tokens by requesting blind signatures on the provided outputs.\n\t *\n\t * @param mintPayload Payload containing the outputs to get blind signatures on.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Serialized blinded signatures.\n\t */\n\tasync mintBolt11(mintPayload: MintPayload, customRequest?: RequestFn): Promise<MintResponse> {\n\t\tconst data = await this.requestWithAuth<MintResponse>(\n\t\t\t'POST',\n\t\t\t'/v1/mint/bolt11',\n\t\t\t{ requestBody: mintPayload },\n\t\t\tcustomRequest,\n\t\t);\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tconst errDetail = isObj(data) && 'detail' in data ? (data as ApiError).detail : undefined;\n\t\t\tthrow new Error(errDetail ?? 'bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Mints new tokens using a BOLT12 quote by requesting blind signatures on the provided outputs.\n\t *\n\t * @param mintPayload Payload containing the quote ID and outputs to get blind signatures on.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Serialized blinded signatures for the requested outputs.\n\t */\n\tasync mintBolt12(mintPayload: MintPayload, customRequest?: RequestFn): Promise<MintResponse> {\n\t\tconst data = await this.requestWithAuth<MintResponse>(\n\t\t\t'POST',\n\t\t\t'/v1/mint/bolt12',\n\t\t\t{ requestBody: mintPayload },\n\t\t\tcustomRequest,\n\t\t);\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tconst errDetail = isObj(data) && 'detail' in data ? (data as ApiError).detail : undefined;\n\t\t\tthrow new Error(errDetail ?? 'bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Requests a new melt quote from the mint.\n\t *\n\t * @param meltQuotePayload Payload for creating a new melt quote.\n\t * @param customRequest Optional override for the request function.\n\t * @returns The melt quote response.\n\t */\n\tasync createMeltQuoteBolt11(\n\t\tmeltQuotePayload: MeltQuotePayload,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<PartialMeltQuoteResponse> {\n\t\tconst response = await this.requestWithAuth<\n\t\t\tPartialMeltQuoteResponse & MeltQuoteResponsePaidDeprecated\n\t\t>('POST', '/v1/melt/quote/bolt11', { requestBody: meltQuotePayload }, customRequest);\n\n\t\tconst data = handleMeltQuoteResponseDeprecated(response, this._logger);\n\n\t\tif (\n\t\t\t!isObj(data) ||\n\t\t\ttypeof data?.amount !== 'number' ||\n\t\t\ttypeof data?.fee_reserve !== 'number' ||\n\t\t\ttypeof data?.quote !== 'string'\n\t\t) {\n\t\t\tconst errDetail = isObj(data) && 'detail' in data ? (data as ApiError).detail : undefined;\n\t\t\tthrow new Error(errDetail ?? 'bad response');\n\t\t}\n\t\treturn data;\n\t}\n\n\t/**\n\t * Requests a new BOLT12 melt quote from the mint for paying a Lightning Network offer. For\n\t * amount-less offers, specify the amount in options.amountless.amount_msat.\n\t *\n\t * @param meltQuotePayload Payload containing the BOLT12 offer to pay and unit.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Melt quote with amount, fee reserve, and payment state.\n\t */\n\tasync createMeltQuoteBolt12(\n\t\tmeltQuotePayload: MeltQuotePayload,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<Bolt12MeltQuoteResponse> {\n\t\tconst response = await this.requestWithAuth<Bolt12MeltQuoteResponse>(\n\t\t\t'POST',\n\t\t\t'/v1/melt/quote/bolt12',\n\t\t\t{ requestBody: meltQuotePayload },\n\t\t\tcustomRequest,\n\t\t);\n\t\treturn response;\n\t}\n\n\t/**\n\t * Gets an existing melt quote.\n\t *\n\t * @param quote Quote ID.\n\t * @param customRequest Optional override for the request function.\n\t * @returns The melt quote response.\n\t */\n\tasync checkMeltQuoteBolt11(\n\t\tquote: string,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<PartialMeltQuoteResponse> {\n\t\tconst response = await this.requestWithAuth<\n\t\t\tMeltQuoteResponse & MeltQuoteResponsePaidDeprecated\n\t\t>('GET', `/v1/melt/quote/bolt11/${quote}`, {}, customRequest);\n\n\t\tconst data = handleMeltQuoteResponseDeprecated(response, this._logger);\n\n\t\tif (\n\t\t\t!isObj(data) ||\n\t\t\ttypeof data?.amount !== 'number' ||\n\t\t\ttypeof data?.fee_reserve !== 'number' ||\n\t\t\ttypeof data?.quote !== 'string' ||\n\t\t\ttypeof data?.state !== 'string' ||\n\t\t\t!Object.values(MeltQuoteState).includes(data.state)\n\t\t) {\n\t\t\tconst errDetail = isObj(data) && 'detail' in data ? (data as ApiError).detail : undefined;\n\t\t\tthrow new Error(errDetail ?? 'bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Gets an existing BOLT12 melt quote from the mint. Returns current payment state (UNPAID,\n\t * PENDING, or PAID) and payment preimage if paid.\n\t *\n\t * @param quote Quote ID to check.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Updated quote with current payment state and preimage if available.\n\t */\n\tasync checkMeltQuoteBolt12(\n\t\tquote: string,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<Bolt12MeltQuoteResponse> {\n\t\tconst response = await this.requestWithAuth<Bolt12MeltQuoteResponse>(\n\t\t\t'GET',\n\t\t\t`/v1/melt/quote/bolt12/${quote}`,\n\t\t\t{},\n\t\t\tcustomRequest,\n\t\t);\n\t\treturn response;\n\t}\n\n\t/**\n\t * Requests the mint to pay for a Bolt11 payment request by providing ecash as inputs to be spent.\n\t * The inputs contain the amount and the fee_reserves for a Lightning payment. The payload can\n\t * also contain blank outputs in order to receive back overpaid Lightning fees.\n\t *\n\t * @param meltPayload The melt payload containing inputs and optional outputs.\n\t * @param options.customRequest Optional override for the request function.\n\t * @param options.preferAsync Optional override to set 'respond-async' header.\n\t * @returns The melt response.\n\t */\n\tasync meltBolt11(\n\t\tmeltPayload: MeltPayload,\n\t\toptions?: {\n\t\t\tcustomRequest?: RequestFn;\n\t\t\tpreferAsync?: boolean;\n\t\t},\n\t): Promise<PartialMeltQuoteResponse> {\n\t\tconst headers: Record<string, string> = {\n\t\t\t...(options?.preferAsync ? { Prefer: 'respond-async' } : {}),\n\t\t};\n\t\tconst response = await this.requestWithAuth<\n\t\t\tMeltQuoteResponse & MeltQuoteResponsePaidDeprecated\n\t\t>(\n\t\t\t'POST',\n\t\t\t'/v1/melt/bolt11',\n\t\t\t{\n\t\t\t\trequestBody: meltPayload,\n\t\t\t\theaders,\n\t\t\t},\n\t\t\toptions?.customRequest,\n\t\t);\n\n\t\tconst data = handleMeltQuoteResponseDeprecated(response, this._logger);\n\n\t\tif (\n\t\t\t!isObj(data) ||\n\t\t\ttypeof data?.state !== 'string' ||\n\t\t\t!Object.values(MeltQuoteState).includes(data.state)\n\t\t) {\n\t\t\tconst errDetail = isObj(data) && 'detail' in data ? (data as ApiError).detail : undefined;\n\t\t\tthrow new Error(errDetail ?? 'bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Requests the mint to pay a BOLT12 offer by providing ecash inputs to be spent. The inputs must\n\t * cover the amount plus fee reserves. Optional outputs can be included to receive change for\n\t * overpaid Lightning fees.\n\t *\n\t * @param meltPayload Payload containing quote ID, inputs, and optional outputs for change.\n\t * @param options.customRequest Optional override for the request function.\n\t * @param options.preferAsync Optional override to set 'respond-async' header.\n\t * @returns Payment result with state and optional change signatures.\n\t */\n\tasync meltBolt12(\n\t\tmeltPayload: MeltPayload,\n\t\toptions?: {\n\t\t\tcustomRequest?: RequestFn;\n\t\t\tpreferAsync?: boolean;\n\t\t},\n\t): Promise<Bolt12MeltQuoteResponse> {\n\t\tconst headers: Record<string, string> = {\n\t\t\t...(options?.preferAsync ? { Prefer: 'respond-async' } : {}),\n\t\t};\n\t\tconst data = await this.requestWithAuth<Bolt12MeltQuoteResponse>(\n\t\t\t'POST',\n\t\t\t'/v1/melt/bolt12',\n\t\t\t{\n\t\t\t\trequestBody: meltPayload,\n\t\t\t\theaders,\n\t\t\t},\n\t\t\toptions?.customRequest,\n\t\t);\n\t\treturn data;\n\t}\n\n\t/**\n\t * Checks if specific proofs have already been redeemed.\n\t *\n\t * @param checkPayload The payload containing proofs to check.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Redeemed and unredeemed ordered list of booleans.\n\t */\n\tasync check(\n\t\tcheckPayload: CheckStatePayload,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<CheckStateResponse> {\n\t\tconst data = await this.requestWithAuth<CheckStateResponse>(\n\t\t\t'POST',\n\t\t\t'/v1/checkstate',\n\t\t\t{ requestBody: checkPayload },\n\t\t\tcustomRequest,\n\t\t);\n\n\t\tif (!isObj(data) || !Array.isArray(data?.states)) {\n\t\t\tconst errDetail = isObj(data) && 'detail' in data ? (data as ApiError).detail : undefined;\n\t\t\tthrow new Error(errDetail ?? 'bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Get the mint's public keys.\n\t *\n\t * @param keysetId Optional param to get the keys for a specific keyset. If not specified, the\n\t *   keys from all active keysets are fetched.\n\t * @param mintUrl Optional alternative mint URL to use for this request.\n\t * @param customRequest Optional override for the request function.\n\t * @returns The mint's public keys.\n\t */\n\tasync getKeys(\n\t\tkeysetId?: string,\n\t\tmintUrl?: string,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<MintActiveKeys> {\n\t\tconst targetUrl = mintUrl || this._mintUrl;\n\t\t// backwards compatibility for base64 encoded keyset ids\n\t\tif (keysetId) {\n\t\t\t// make the keysetId url safe\n\t\t\tkeysetId = keysetId.replace(/\\//g, '_').replace(/\\+/g, '-');\n\t\t}\n\t\tconst requestInstance = customRequest ?? this._request;\n\t\tconst data = await requestInstance<MintActiveKeys>({\n\t\t\tendpoint: keysetId\n\t\t\t\t? joinUrls(targetUrl, '/v1/keys', keysetId)\n\t\t\t\t: joinUrls(targetUrl, '/v1/keys'),\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data.keysets)) {\n\t\t\tconst errDetail = isObj(data) && 'detail' in data ? (data as ApiError).detail : undefined;\n\t\t\tthrow new Error(errDetail ?? 'bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Get the mint's keysets in no specific order.\n\t *\n\t * @param customRequest Optional override for the request function.\n\t * @returns All the mint's past and current keysets.\n\t */\n\tasync getKeySets(customRequest?: RequestFn): Promise<MintAllKeysets> {\n\t\tconst requestInstance = customRequest ?? this._request;\n\t\treturn requestInstance<MintAllKeysets>({ endpoint: joinUrls(this._mintUrl, '/v1/keysets') });\n\t}\n\n\t/**\n\t * Restores proofs from the provided blinded messages.\n\t *\n\t * @param restorePayload The payload containing outputs to restore.\n\t * @param customRequest Optional override for the request function.\n\t * @returns The restore response with outputs and signatures.\n\t */\n\tasync restore(\n\t\trestorePayload: PostRestorePayload,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<PostRestoreResponse> {\n\t\tconst requestInstance = customRequest ?? this._request;\n\t\tconst data = await requestInstance<PostRestoreResponse>({\n\t\t\tendpoint: joinUrls(this._mintUrl, '/v1/restore'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: restorePayload,\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.outputs) || !Array.isArray(data?.signatures)) {\n\t\t\tconst errDetail = isObj(data) && 'detail' in data ? (data as ApiError).detail : undefined;\n\t\t\tthrow new Error(errDetail ?? 'bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Tries to establish a websocket connection with the websocket mint url according to NUT-17.\n\t */\n\tasync connectWebSocket() {\n\t\tif (this.ws) {\n\t\t\tawait this.ws.ensureConnection();\n\t\t} else {\n\t\t\tconst mintUrl = new URL(this._mintUrl);\n\t\t\tconst wsSegment = 'v1/ws';\n\t\t\tif (mintUrl.pathname) {\n\t\t\t\tif (mintUrl.pathname.endsWith('/')) {\n\t\t\t\t\tmintUrl.pathname += wsSegment;\n\t\t\t\t} else {\n\t\t\t\t\tmintUrl.pathname += '/' + wsSegment;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.ws = ConnectionManager.getInstance().getConnection(\n\t\t\t\t`${mintUrl.protocol === 'https:' ? 'wss' : 'ws'}://${mintUrl.host}${mintUrl.pathname}`,\n\t\t\t);\n\t\t\ttry {\n\t\t\t\tawait this.ws.connect();\n\t\t\t} catch (e) {\n\t\t\t\tthis._logger.error('Failed to connect to WebSocket...', { e });\n\t\t\t\tthrow new Error('Failed to connect to WebSocket...');\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Closes a websocket connection.\n\t */\n\tdisconnectWebSocket() {\n\t\tif (this.ws) {\n\t\t\tthis.ws.close();\n\t\t}\n\t}\n\n\tget webSocketConnection() {\n\t\treturn this.ws;\n\t}\n\n\t/**\n\t * Returns the Clear Authentication Token (CAT) to use in the 'Clear-auth' header, or undefined if\n\t * not required for the given path and method.\n\t *\n\t * @param method The method to call on the path.\n\t * @param path The API path to check for blind auth requirement.\n\t * @returns The blind auth token if required, otherwise undefined.\n\t */\n\tprivate async handleClearAuth(method: 'GET' | 'POST', path: string): Promise<string | undefined> {\n\t\tif (!this._authProvider) return undefined;\n\t\tconst info = await this.getLazyMintInfo();\n\t\tif (!info.requiresClearAuthToken(method, path)) return undefined;\n\t\tthis._logger.error('Clear Authentication Token...', { cat: this._authProvider.getCAT() });\n\t\treturn this._authProvider.getCAT();\n\t}\n\n\t/**\n\t * Returns a serialized Blind Authentication Token (BAT) to use in the 'Blind-auth' header, or\n\t * undefined if not required for the given path and method.\n\t *\n\t * @param method The method to call on the path.\n\t * @param path The API path to check for blind auth requirement.\n\t * @returns The blind auth token if required, otherwise undefined.\n\t */\n\tprivate async handleBlindAuth(method: 'GET' | 'POST', path: string): Promise<string | undefined> {\n\t\tif (!this._authProvider) return undefined;\n\t\tconst info = await this.getLazyMintInfo();\n\t\tif (!info.requiresBlindAuthToken(method, path)) return undefined;\n\t\tconst bat = await this._authProvider.getBlindAuthToken({ method, path });\n\t\tthis._logger.error('Blind Authentication Token...', { bat });\n\t\treturn bat;\n\t}\n\n\tprivate async requestWithAuth<T>(\n\t\tmethod: 'GET' | 'POST',\n\t\tpath: string,\n\t\tinit: Omit<RequestOptions, 'endpoint' | 'method' | 'headers' | 'requestBody'> & {\n\t\t\trequestBody?: Record<string, unknown>;\n\t\t\theaders?: Record<string, string>;\n\t\t} = {},\n\t\tcustomRequest?: RequestFn,\n\t): Promise<T> {\n\t\tconst requestInstance = customRequest ?? this._request;\n\t\t// Get BAT/CAT token if this endpoint is protected\n\t\tconst bat = await this.handleBlindAuth(method, path);\n\t\tconst cat = await this.handleClearAuth(method, path);\n\t\tconst headers: Record<string, string> = {\n\t\t\t...(init.headers ?? {}),\n\t\t\t...(bat ? { 'Blind-auth': bat } : {}),\n\t\t\t...(cat ? { 'Clear-auth': cat } : {}),\n\t\t};\n\t\treturn requestInstance<T>({\n\t\t\t...init,\n\t\t\tendpoint: joinUrls(this._mintUrl, path),\n\t\t\tmethod,\n\t\t\theaders,\n\t\t});\n\t}\n}\n\nexport { Mint };\n", "import { isValidHex, deriveKeysetId } from '../utils';\nimport { type MintKeyset, type MintKeys } from '../model/types';\nimport { hexToBytes } from '@noble/curves/utils';\n\nexport class Keyset {\n\tprivate _id: string;\n\tprivate _unit: string;\n\tprivate _active: boolean;\n\tprivate _keys: Record<number, string> = {};\n\tprivate _input_fee_ppk?: number;\n\tprivate _final_expiry?: number;\n\n\tconstructor(\n\t\tid: string,\n\t\tunit: string,\n\t\tactive: boolean,\n\t\tinput_fee_ppk?: number,\n\t\tfinal_expiry?: number,\n\t) {\n\t\tthis._id = id;\n\t\tthis._unit = unit;\n\t\tthis._active = active;\n\t\tthis._input_fee_ppk = input_fee_ppk;\n\t\tthis._final_expiry = final_expiry;\n\t}\n\n\tget id(): string {\n\t\treturn this._id;\n\t}\n\n\tget unit(): string {\n\t\treturn this._unit;\n\t}\n\n\tget isActive(): boolean {\n\t\treturn this._active;\n\t}\n\n\tget fee(): number {\n\t\treturn this._input_fee_ppk ?? 0;\n\t}\n\n\tget expiry(): number | undefined {\n\t\treturn this._final_expiry;\n\t}\n\n\tget hasKeys(): boolean {\n\t\treturn Object.keys(this._keys).length > 0;\n\t}\n\n\tget hasHexId(): boolean {\n\t\treturn isValidHex(this._id);\n\t}\n\n\tget keys(): Record<number, string> {\n\t\treturn this._keys;\n\t}\n\n\tset keys(keys: Record<number, string>) {\n\t\tthis._keys = keys;\n\t}\n\n\t/**\n\t * For compat with v2 MintKeyset type.\n\t */\n\tget active(): boolean {\n\t\treturn this._active;\n\t}\n\n\t/**\n\t * For compat with v2 MintKeyset type.\n\t */\n\tget input_fee_ppk(): number {\n\t\treturn this._input_fee_ppk ?? 0;\n\t}\n\n\t/**\n\t * For compat with v2 MintKeyset type.\n\t */\n\tget final_expiry(): number | undefined {\n\t\treturn this._final_expiry;\n\t}\n\n\t/**\n\t * To Mint API MintKeyset format.\n\t *\n\t * @returns MintKeyset object.\n\t */\n\ttoMintKeyset(): MintKeyset {\n\t\treturn {\n\t\t\tid: this._id,\n\t\t\tunit: this._unit,\n\t\t\tactive: this._active,\n\t\t\tinput_fee_ppk: this._input_fee_ppk,\n\t\t\tfinal_expiry: this._final_expiry,\n\t\t};\n\t}\n\n\t/**\n\t * To Mint API MintKeys format.\n\t *\n\t * @returns MintKeys object.\n\t */\n\ttoMintKeys(): MintKeys | null {\n\t\tif (!this.hasKeys) {\n\t\t\treturn null;\n\t\t}\n\t\treturn {\n\t\t\tid: this._id,\n\t\t\tunit: this._unit,\n\t\t\tkeys: this._keys,\n\t\t};\n\t}\n\n\t/**\n\t * Verifies that the keyset's ID matches the derived ID from its keys, unit, and expiry.\n\t *\n\t * @returns True if verification succeeds, false otherwise (e.g., no keys or mismatch).\n\t */\n\tverify(): boolean {\n\t\tif (!this.hasKeys) {\n\t\t\treturn false;\n\t\t}\n\t\tconst versionByte = hexToBytes(this._id)[0];\n\t\tconst derivedId = deriveKeysetId(this._keys, this._unit, this._final_expiry, versionByte);\n\t\treturn derivedId === this._id;\n\t}\n}\n", "import { Keyset } from './Keyset';\nimport { Mint } from '../mint';\nimport type { MintKeyset, MintKeys, MintAllKeysets, MintActiveKeys } from '../model/types/keyset';\n\n/**\n * Manages the unit-specific keysets for a Mint.\n *\n * @remarks\n * Will ONLY load keysets in the Keychain unit.\n */\nexport class KeyChain {\n\tprivate mint: Mint;\n\tprivate unit: string;\n\tprivate keysets: { [id: string]: Keyset } = {};\n\n\tconstructor(\n\t\tmint: string | Mint,\n\t\tunit: string,\n\t\tcachedKeysets?: MintKeyset[],\n\t\tcachedKeys?: MintKeys[] | MintKeys,\n\t) {\n\t\tthis.mint = typeof mint === 'string' ? new Mint(mint) : mint;\n\t\tthis.unit = unit;\n\t\tif (cachedKeysets && cachedKeys) {\n\t\t\t// Normalize and preload if both are provided\n\t\t\tconst arrayOfKeys = Array.isArray(cachedKeys) ? cachedKeys : [cachedKeys];\n\t\t\tthis.buildKeychain(cachedKeysets, arrayOfKeys);\n\t\t}\n\t}\n\n\t/**\n\t * Single entry point to load or refresh keysets and keys for the unit.\n\t *\n\t * @remarks\n\t * Fetches in parallel, filters by unit, assigns keys.\n\t * @param forceRefresh If true, refetch even if loaded.\n\t */\n\tasync init(forceRefresh?: boolean): Promise<void> {\n\t\t// Skip if already loaded, unless force\n\t\tif (Object.keys(this.keysets).length > 0 && !forceRefresh) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fetch keys and keysets in parallel\n\t\tconst [allKeysetsResponse, allKeysResponse]: [MintAllKeysets, MintActiveKeys] =\n\t\t\tawait Promise.all([this.mint.getKeySets(), this.mint.getKeys()]);\n\n\t\tthis.buildKeychain(allKeysetsResponse.keysets, allKeysResponse.keysets);\n\n\t\t// Smoke test (will throw if init was unsuccessful)\n\t\tthis.getCheapestKeyset();\n\t}\n\n\t/**\n\t * Builds keychain from Mint Keyset and Keys data.\n\t *\n\t * @param allKeysets Keyset data from mint.getKeySets() API.\n\t * @param allKeys Keys data from mint.getKeys() API.\n\t */\n\tprivate buildKeychain(allKeysets: MintKeyset[], allKeys: MintKeys[]): void {\n\t\t// Clear existing keysets to avoid stale data\n\t\tthis.keysets = {};\n\n\t\t// Filter and create Keysets for unit\n\t\tconst unitKeysets = allKeysets.filter((k: MintKeyset) => k.unit === this.unit);\n\t\tunitKeysets.forEach((k: MintKeyset) => {\n\t\t\tthis.keysets[k.id] = new Keyset(k.id, k.unit, k.active, k.input_fee_ppk, k.final_expiry);\n\t\t});\n\n\t\t// Create map of keys filtered by unit for fast lookup\n\t\tconst keysMap = new Map<string, MintKeys>(\n\t\t\tallKeys.filter((k) => k.unit === this.unit).map((k) => [k.id, k]),\n\t\t);\n\n\t\t// Assign keys and validate active hex keysets\n\t\t// Note: Non-hex and inactive keysets should not have keys\n\t\tObject.values(this.keysets).forEach((keyset) => {\n\t\t\tif (!keyset.hasHexId || !keyset.isActive) return;\n\t\t\tconst mk = keysMap.get(keyset.id);\n\t\t\tif (mk) {\n\t\t\t\tkeyset.keys = mk.keys;\n\t\t\t\tif (!keyset.verify()) {\n\t\t\t\t\tthrow new Error(`Keyset verification failed for ID ${keyset.id}`);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Get a keyset by ID or the cheapest keyset if no ID is provided.\n\t *\n\t * @param id Optional keyset ID.\n\t * @returns Keyset with keys.\n\t * @throws If keyset not found or uninitialized.\n\t */\n\tgetKeyset(id?: string): Keyset {\n\t\tconst keyset = id ? this.keysets[id] : this.getCheapestKeyset();\n\t\tif (!keyset) {\n\t\t\tthrow new Error(`Keyset '${id}' not found`);\n\t\t}\n\t\treturn keyset;\n\t}\n\n\t/**\n\t * Get the cheapest active keyset.\n\t *\n\t * @remarks\n\t * Selects active keyset with lowest fee and hex ID.\n\t * @returns Active Keyset.\n\t * @throws If none found or uninitialized.\n\t */\n\tgetCheapestKeyset(): Keyset {\n\t\tif (Object.keys(this.keysets).length === 0) {\n\t\t\tthrow new Error('KeyChain not initialized');\n\t\t}\n\t\tconst activeKeysets = Object.values(this.keysets).filter(\n\t\t\t(k) => k.isActive && k.hasHexId && k.hasKeys,\n\t\t);\n\t\tif (activeKeysets.length === 0) {\n\t\t\tthrow new Error('No active keyset found');\n\t\t}\n\t\treturn activeKeysets.sort((a, b) => a.fee - b.fee)[0];\n\t}\n\n\t/**\n\t * Get list of all keysets for the unit.\n\t *\n\t * @returns Array of Keysets.\n\t * @throws If uninitialized.\n\t */\n\tgetKeysets(): Keyset[] {\n\t\tif (Object.keys(this.keysets).length === 0) {\n\t\t\tthrow new Error('KeyChain not initialized');\n\t\t}\n\t\treturn Object.values(this.keysets);\n\t}\n\n\t/**\n\t * Extract the Mint API data from the keychain.\n\t *\n\t * @remarks\n\t * Useful for instantiating new wallets / keychains without repeatedly calling the mint API.\n\t */\n\tgetCache(): {\n\t\tkeysets: MintKeyset[];\n\t\tkeys: MintKeys[];\n\t\tunit: string;\n\t\tmintUrl: string;\n\t} {\n\t\tconst allKeysets = this.getKeysets();\n\t\tconst allKeys = allKeysets\n\t\t\t.filter((k) => k.hasKeys)\n\t\t\t.map((k) => k.toMintKeys())\n\t\t\t.filter((mk): mk is MintKeys => mk !== null);\n\t\treturn {\n\t\t\tkeysets: allKeysets.map((k) => k.toMintKeyset()),\n\t\t\tkeys: allKeys,\n\t\t\tunit: this.unit,\n\t\t\tmintUrl: this.mint.mintUrl,\n\t\t};\n\t}\n}\n", "import { type SerializedBlindedMessage } from './types/index';\nimport { type WeierstrassPoint } from '@noble/curves/abstract/weierstrass';\n\nclass BlindedMessage {\n\tamount: number;\n\tB_: WeierstrassPoint<bigint>;\n\tid: string;\n\tconstructor(amount: number, B_: WeierstrassPoint<bigint>, id: string) {\n\t\tthis.amount = amount;\n\t\tthis.B_ = B_;\n\t\tthis.id = id;\n\t}\n\tgetSerializedBlindedMessage(): SerializedBlindedMessage {\n\t\treturn { amount: this.amount, B_: this.B_.toHex(true), id: this.id };\n\t}\n}\nexport { BlindedMessage };\n", "import {\n\ttype MintKeys,\n\ttype Proof,\n\ttype SerializedBlindedMessage,\n\ttype SerializedBlindedSignature,\n\ttype SerializedDLEQ,\n} from './types';\nimport { type P2PKOptions, type Keyset } from '../wallet';\nimport {\n\tblindMessage,\n\tconstructProofFromPromise,\n\tderiveP2BKBlindedPubkeys,\n\tderiveBlindingFactor,\n\tderiveSecret,\n\tpointFromHex,\n\tserializeProof,\n\ttype DLEQ,\n} from '../crypto';\nimport { BlindedMessage } from './BlindedMessage';\nimport { bytesToHex, hexToBytes, randomBytes } from '@noble/hashes/utils';\nimport { bytesToNumber, numberToHexPadded64, splitAmount } from '../utils';\n\nexport interface OutputDataLike {\n\tblindedMessage: SerializedBlindedMessage;\n\tblindingFactor: bigint;\n\tsecret: Uint8Array;\n\n\ttoProof: (signature: SerializedBlindedSignature, keyset: MintKeys | Keyset) => Proof;\n}\n\nexport type OutputDataFactory = (amount: number, keys: MintKeys | Keyset) => OutputDataLike;\n\n/**\n * Core P2PK tags that must not be settable in additional tags.\n *\n * @internal\n */\nexport const RESERVED_P2PK_TAGS = new Set([\n\t'locktime',\n\t'pubkeys',\n\t'n_sigs',\n\t'refund',\n\t'n_sigs_refund',\n]);\n\n/**\n * Asserts P2PK Tag key is valid.\n *\n * @param key Tag Key.\n * @throws If not a string, or is a reserved string.\n */\nexport function assertValidTagKey(key: string) {\n\tif (!key || typeof key !== 'string') throw new Error('tag key must be a non empty string');\n\tif (RESERVED_P2PK_TAGS.has(key)) {\n\t\tthrow new Error(`additionalTags must not use reserved key \"${key}\"`);\n\t}\n}\n\n/**\n * Maximum secret length.\n *\n * @remarks\n * Based on the Nutshell default mint_max_secret_length.\n * @internal\n */\nexport const MAX_SECRET_LENGTH = 1024;\n\nexport function isOutputDataFactory(\n\tvalue: OutputData[] | OutputDataFactory,\n): value is OutputDataFactory {\n\treturn typeof value === 'function';\n}\n\n// Holds the map of Pubkey blinding factors for a given OutputData\n// This avoids changing the shape of the OutputDataLike interface\nconst EPHEMERAL_E = new WeakMap<OutputData, string>(); // one-shot\nfunction setEphemeralE(target: OutputData, Ehex?: string) {\n\tif (Ehex) EPHEMERAL_E.set(target, Ehex);\n}\nfunction takeEphemeralE(target: OutputData): string | undefined {\n\tconst e = EPHEMERAL_E.get(target);\n\tif (!e) return;\n\tEPHEMERAL_E.delete(target); // one-shot to avoid leakage\n\treturn e;\n}\n\nexport class OutputData implements OutputDataLike {\n\tblindedMessage: SerializedBlindedMessage;\n\tblindingFactor: bigint;\n\tsecret: Uint8Array;\n\n\tconstructor(\n\t\tblindedMessage: SerializedBlindedMessage,\n\t\tblindingFactor: bigint,\n\t\tsecret: Uint8Array,\n\t) {\n\t\tthis.secret = secret;\n\t\tthis.blindingFactor = blindingFactor;\n\t\tthis.blindedMessage = blindedMessage;\n\t}\n\n\ttoProof(sig: SerializedBlindedSignature, keyset: MintKeys | Keyset) {\n\t\tlet dleq: DLEQ | undefined;\n\t\tif (sig.dleq) {\n\t\t\tdleq = {\n\t\t\t\ts: hexToBytes(sig.dleq.s),\n\t\t\t\te: hexToBytes(sig.dleq.e),\n\t\t\t\tr: this.blindingFactor,\n\t\t\t};\n\t\t}\n\t\tconst blindSignature = {\n\t\t\tid: sig.id,\n\t\t\tamount: sig.amount,\n\t\t\tC_: pointFromHex(sig.C_),\n\t\t\tdleq: dleq,\n\t\t};\n\t\tconst A = pointFromHex(keyset.keys[sig.amount]);\n\t\tconst proof = constructProofFromPromise(blindSignature, this.blindingFactor, this.secret, A);\n\t\tconst serializedProof = {\n\t\t\t...serializeProof(proof),\n\t\t\t...(dleq && {\n\t\t\t\tdleq: {\n\t\t\t\t\ts: bytesToHex(dleq.s),\n\t\t\t\t\te: bytesToHex(dleq.e),\n\t\t\t\t\tr: numberToHexPadded64(dleq.r ?? BigInt(0)),\n\t\t\t\t} as SerializedDLEQ,\n\t\t\t}),\n\t\t} as Proof;\n\n\t\t// Add P2BK (Pay to Blinded Key) blinding factors if needed\n\t\tconst Ehex = takeEphemeralE(this);\n\t\tif (Ehex) serializedProof.p2pk_e = Ehex;\n\n\t\treturn serializedProof;\n\t}\n\n\tstatic createP2PKData(\n\t\tp2pk: P2PKOptions,\n\t\tamount: number,\n\t\tkeyset: MintKeys | Keyset,\n\t\tcustomSplit?: number[],\n\t) {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a) => this.createSingleP2PKData(p2pk, a, keyset.id));\n\t}\n\n\tstatic createSingleP2PKData(p2pk: P2PKOptions, amount: number, keysetId: string) {\n\t\t// normalise keys and clamp required signature counts to available keys\n\t\tconst lockKeys: string[] = Array.isArray(p2pk.pubkey) ? p2pk.pubkey : [p2pk.pubkey];\n\t\tconst refundKeys: string[] = p2pk.refundKeys ?? [];\n\t\tconst reqLock = Math.max(1, Math.min(p2pk.requiredSignatures ?? 1, lockKeys.length));\n\t\tconst reqRefund = Math.max(\n\t\t\t1,\n\t\t\tMath.min(p2pk.requiredRefundSignatures ?? 1, refundKeys.length || 1),\n\t\t);\n\n\t\t// Init vars\n\t\tlet data = lockKeys[0];\n\t\tlet pubkeys = lockKeys.slice(1);\n\t\tlet refund = refundKeys;\n\n\t\t// Optional key blinding (P2BK)\n\t\tlet Ehex: string | undefined;\n\t\tif (p2pk.blindKeys) {\n\t\t\tconst ordered = [data, ...pubkeys, ...refundKeys];\n\t\t\tconst { blinded, Ehex: _E } = deriveP2BKBlindedPubkeys(ordered, keysetId);\n\t\t\tdata = blinded[0];\n\t\t\tpubkeys = blinded.slice(1, lockKeys.length);\n\t\t\trefund = blinded.slice(lockKeys.length);\n\t\t\tEhex = _E;\n\t\t}\n\n\t\t// build P2PK Tags (NUT-11)\n\t\tconst tags: string[][] = [];\n\n\t\tconst ts = p2pk.locktime ?? NaN;\n\t\tif (Number.isSafeInteger(ts) && ts >= 0) {\n\t\t\ttags.push(['locktime', String(ts)]);\n\t\t}\n\n\t\tif (pubkeys.length > 0) {\n\t\t\ttags.push(['pubkeys', ...pubkeys]);\n\t\t\tif (reqLock > 1) {\n\t\t\t\ttags.push(['n_sigs', String(reqLock)]);\n\t\t\t}\n\t\t}\n\n\t\tif (refund.length > 0) {\n\t\t\ttags.push(['refund', ...refund]);\n\t\t\tif (reqRefund > 1) {\n\t\t\t\ttags.push(['n_sigs_refund', String(reqRefund)]);\n\t\t\t}\n\t\t}\n\n\t\t// Append additional tags if any\n\t\tif (p2pk.additionalTags?.length) {\n\t\t\tconst normalized = p2pk.additionalTags.map(([k, ...vals]) => {\n\t\t\t\tassertValidTagKey(k); // Validate key\n\t\t\t\treturn [k, ...vals.map(String)]; // all to strings\n\t\t\t});\n\t\t\ttags.push(...normalized);\n\t\t}\n\n\t\t// Construct secret\n\t\tconst newSecret: [string, { nonce: string; data: string; tags: string[][] }] = [\n\t\t\t'P2PK',\n\t\t\t{\n\t\t\t\tnonce: bytesToHex(randomBytes(32)),\n\t\t\t\tdata: data,\n\t\t\t\ttags,\n\t\t\t},\n\t\t];\n\n\t\t// blind the message\n\t\tconst parsed = JSON.stringify(newSecret);\n\n\t\t// Check secret length, counting Unicode code points\n\t\t// Same semantics as Nutshell python: len(str)\n\t\tconst charCount = [...parsed].length;\n\t\tif (charCount > MAX_SECRET_LENGTH) {\n\t\t\tthrow new Error(`Secret too long (${charCount} characters), maximum is ${MAX_SECRET_LENGTH}`);\n\t\t}\n\t\t// blind the message\n\t\tconst secretBytes = new TextEncoder().encode(parsed);\n\t\tconst { r, B_ } = blindMessage(secretBytes);\n\n\t\t// create OutputData\n\t\tconst od = new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tsecretBytes,\n\t\t);\n\n\t\t// stash Ehex - we add it to Proof later @see: toProof()\n\t\tif (p2pk.blindKeys && Ehex) setEphemeralE(od, Ehex);\n\n\t\treturn od;\n\t}\n\n\tstatic createRandomData(amount: number, keyset: MintKeys | Keyset, customSplit?: number[]) {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a) => this.createSingleRandomData(a, keyset.id));\n\t}\n\n\tstatic createSingleRandomData(amount: number, keysetId: string) {\n\t\tconst randomHex = bytesToHex(randomBytes(32));\n\t\tconst secretBytes = new TextEncoder().encode(randomHex);\n\t\tconst { r, B_ } = blindMessage(secretBytes);\n\t\treturn new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tsecretBytes,\n\t\t);\n\t}\n\n\tstatic createDeterministicData(\n\t\tamount: number,\n\t\tseed: Uint8Array,\n\t\tcounter: number,\n\t\tkeyset: MintKeys | Keyset,\n\t\tcustomSplit?: number[],\n\t): OutputData[] {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a, i) =>\n\t\t\tthis.createSingleDeterministicData(a, seed, counter + i, keyset.id),\n\t\t);\n\t}\n\n\tstatic createSingleDeterministicData(\n\t\tamount: number,\n\t\tseed: Uint8Array,\n\t\tcounter: number,\n\t\tkeysetId: string,\n\t) {\n\t\tconst secretBytes = deriveSecret(seed, keysetId, counter);\n\t\tconst secretBytesAsHex = bytesToHex(secretBytes);\n\t\tconst utf8SecretBytes = new TextEncoder().encode(secretBytesAsHex);\n\t\tconst deterministicR = bytesToNumber(deriveBlindingFactor(seed, keysetId, counter));\n\t\tconst { r, B_ } = blindMessage(utf8SecretBytes, deterministicR);\n\t\treturn new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tutf8SecretBytes,\n\t\t);\n\t}\n\n\t/**\n\t * Calculates the sum of amounts in an array of OutputDataLike objects.\n\t *\n\t * @param outputs Array of OutputDataLike objects.\n\t * @returns The total sum of amounts.\n\t */\n\tstatic sumOutputAmounts(outputs: OutputDataLike[]): number {\n\t\treturn outputs.reduce((sum, output) => sum + output.blindedMessage.amount, 0);\n\t}\n}\n", "import { assertValidTagKey, OutputData } from '../model/OutputData';\nimport { type P2PKOptions, type P2PKTag } from './types/config';\n\n// Accept 33 byte compressed (02|03...), or 32 byte x-only,\n// normalised to lowercase 33 byte with 02 prefix for x only\nfunction normalisePubkey(pk: string): string {\n\tconst hex = pk.toLowerCase();\n\tif (hex.length === 66 && (hex.startsWith('02') || hex.startsWith('03'))) return hex;\n\tif (hex.length === 64) return `02${hex}`;\n\tthrow new Error(\n\t\t`Invalid pubkey, expected 33 byte compressed or 32 byte x only, got length ${hex.length}`,\n\t);\n}\n\nfunction toUnixSeconds(input: Date | number): number {\n\tif (input instanceof Date) return Math.floor(input.getTime() / 1000);\n\treturn input < 1e12 ? Math.floor(input) : Math.floor(input / 1000); // > 1e12 = ms\n}\n\nexport class P2PKBuilder {\n\t// A Set enforces uniqueness and preserves insertion order, which means\n\t// the first added lock key also becomes primary (data) pubkey\n\tprivate lockSet = new Set<string>();\n\tprivate refundSet = new Set<string>();\n\tprivate locktime?: number;\n\tprivate nSigs?: number;\n\tprivate nSigsRefund?: number;\n\tprivate extraTags: P2PKTag[] = [];\n\tprivate _blindKeys?: boolean;\n\n\taddLockPubkey(pk: string | string[]) {\n\t\tconst arr = Array.isArray(pk) ? pk : [pk];\n\t\tfor (const k of arr) this.lockSet.add(normalisePubkey(k));\n\t\treturn this;\n\t}\n\n\taddRefundPubkey(pk: string | string[]) {\n\t\tconst arr = Array.isArray(pk) ? pk : [pk];\n\t\tfor (const k of arr) this.refundSet.add(normalisePubkey(k));\n\t\treturn this;\n\t}\n\n\tlockUntil(when: Date | number) {\n\t\tthis.locktime = toUnixSeconds(when);\n\t\treturn this;\n\t}\n\n\trequireLockSignatures(n: number) {\n\t\tthis.nSigs = Math.max(1, Math.trunc(n));\n\t\treturn this;\n\t}\n\n\trequireRefundSignatures(n: number) {\n\t\tthis.nSigsRefund = Math.max(1, Math.trunc(n));\n\t\treturn this;\n\t}\n\n\taddTag(key: string, values?: string[] | string) {\n\t\tassertValidTagKey(key); //  Validate key\n\t\tconst vals = values === undefined ? [] : Array.isArray(values) ? values : [values];\n\t\tthis.extraTags.push([key, ...vals.map(String)]); // all to strings\n\t\treturn this;\n\t}\n\n\taddTags(tags: P2PKTag[]) {\n\t\tfor (const [k, ...vals] of tags) this.addTag(k, vals);\n\t\treturn this;\n\t}\n\t/**\n\t * @alpha\n\t */\n\tblindKeys() {\n\t\tthis._blindKeys = true;\n\t\treturn this;\n\t}\n\n\ttoOptions(): P2PKOptions {\n\t\tconst locks = Array.from(this.lockSet);\n\t\tconst refunds = Array.from(this.refundSet);\n\n\t\tif (locks.length === 0) throw new Error('At least one lock pubkey is required');\n\t\tif (refunds.length > 0 && this.locktime === undefined) {\n\t\t\tthrow new Error(\n\t\t\t\t'Refund pubkeys require a locktime, add lockUntil(...) or remove refund keys',\n\t\t\t);\n\t\t}\n\n\t\tconst total = locks.length + refunds.length;\n\t\tif (total > 10)\n\t\t\tthrow new Error(`Too many pubkeys, ${total} provided, maximum allowed is 10 in total`);\n\n\t\t// Clamp required signatures to available keys\n\t\tconst reqLock = this.nSigs ? Math.min(Math.max(1, this.nSigs), locks.length) : undefined;\n\t\tconst reqRefund = this.nSigsRefund\n\t\t\t? Math.min(Math.max(1, this.nSigsRefund), Math.max(1, refunds.length))\n\t\t\t: undefined;\n\n\t\tconst pubkey: string | string[] = locks.length === 1 ? locks[0] : locks;\n\n\t\tconst p2pk: P2PKOptions = {\n\t\t\tpubkey,\n\t\t\t...(this.locktime !== undefined ? { locktime: this.locktime } : {}),\n\t\t\t...(refunds.length ? { refundKeys: refunds } : {}),\n\t\t\t...(reqLock && reqLock > 1 ? { requiredSignatures: reqLock } : {}),\n\t\t\t...(reqRefund && reqRefund > 1 ? { requiredRefundSignatures: reqRefund } : {}),\n\t\t\t...(this.extraTags.length ? { additionalTags: this.extraTags.slice() } : {}),\n\t\t\t...(this._blindKeys ? { blindKeys: true } : {}),\n\t\t};\n\n\t\t// Ensure the secret is valid (not too long etc)\n\t\tconst smokeTest = OutputData.createSingleP2PKData(p2pk, 1, 'deedbeef');\n\t\tvoid smokeTest; // intentionally unused\n\n\t\treturn p2pk;\n\t}\n\n\tstatic fromOptions(opts: P2PKOptions): P2PKBuilder {\n\t\tconst b = new P2PKBuilder();\n\t\tconst locks = Array.isArray(opts.pubkey) ? opts.pubkey : [opts.pubkey];\n\t\tb.addLockPubkey(locks);\n\t\tif (opts.locktime !== undefined) b.lockUntil(opts.locktime);\n\t\tif (opts.refundKeys?.length) b.addRefundPubkey(opts.refundKeys);\n\t\tif (opts.requiredSignatures !== undefined) b.requireLockSignatures(opts.requiredSignatures);\n\t\tif (opts.requiredRefundSignatures !== undefined)\n\t\t\tb.requireRefundSignatures(opts.requiredRefundSignatures);\n\t\tif (opts.additionalTags?.length) b.addTags(opts.additionalTags);\n\t\tif (opts.blindKeys) b.blindKeys();\n\t\treturn b;\n\t}\n}\n", "// Minimal types to avoid importing the whole wallet, keeps this module independent\nimport type { Proof } from '../model/types/proof';\nimport { fail, failIf, failIfNullish, type Logger, NULL_LOGGER, measureTime } from '../logger';\nimport { type SendResponse } from './types';\nimport { type KeyChain } from './KeyChain';\n\nexport type SelectProofs = (\n\tproofs: Proof[],\n\tamountToSend: number,\n\tkeyChain: KeyChain,\n\tincludeFees?: boolean,\n\texactMatch?: boolean,\n\tlogger?: Logger,\n) => SendResponse;\n\nexport const selectProofsRGLI: SelectProofs = (\n\tproofs: Proof[],\n\tamountToSend: number,\n\tkeyChain: KeyChain,\n\tincludeFees: boolean = false,\n\texactMatch: boolean = false,\n\t_logger: Logger = NULL_LOGGER,\n): SendResponse => {\n\t// Init vars\n\tconst MAX_TRIALS = 60; // 40-80 is optimal (per RGLI paper)\n\tconst MAX_OVRPCT = 0; // Acceptable close match overage (percent)\n\tconst MAX_OVRAMT = 0; // Acceptable close match overage (absolute)\n\tconst MAX_TIMEMS = 1000; // Halt new trials if over time (in ms)\n\tconst MAX_P2SWAP = 5000; // Max number of Phase 2 improvement swaps\n\tconst timer = measureTime(); // start the clock\n\tlet bestSubset: ProofWithFee[] | null = null;\n\tlet bestDelta = Infinity;\n\tlet bestAmount = 0;\n\tlet bestFeePPK = 0;\n\n\t/**\n\t * Helper Functions.\n\t */\n\tinterface ProofWithFee {\n\t\tproof: Proof;\n\t\texFee: number;\n\t\tppkfee: number;\n\t}\n\t// Looks up fee for a proof\n\tconst feeForProof = (proof: Proof): number => {\n\t\ttry {\n\t\t\treturn keyChain.getKeyset(proof.id).fee;\n\t\t} catch (e) {\n\t\t\tfail(`Could not get fee. No keyset found for keyset id: ${proof.id}`, _logger, {\n\t\t\t\terror: e,\n\t\t\t\tkeychain: keyChain.getKeysets(),\n\t\t\t});\n\t\t}\n\t};\n\t// Calculate net amount after fees\n\tconst sumExFees = (amount: number, feePPK: number): number => {\n\t\treturn amount - (includeFees ? Math.ceil(feePPK / 1000) : 0);\n\t};\n\t// Shuffle array for randomization\n\tconst shuffleArray = <T>(array: T[]): T[] => {\n\t\tconst shuffled = [...array];\n\t\tfor (let i = shuffled.length - 1; i > 0; i--) {\n\t\t\tconst j = Math.floor(Math.random() * (i + 1));\n\t\t\t[shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n\t\t}\n\t\treturn shuffled;\n\t};\n\t// Performs a binary search on a sorted (ascending) array of ProofWithFee objects by exFee.\n\t// If lessOrEqual=true, returns the rightmost index where exFee <= value\n\t// If lessOrEqual=false, returns the leftmost index where exFee >= value\n\tconst binarySearchIndex = (\n\t\tarr: ProofWithFee[],\n\t\tvalue: number,\n\t\tlessOrEqual: boolean,\n\t): number | null => {\n\t\tlet left = 0,\n\t\t\tright = arr.length - 1,\n\t\t\tresult: number | null = null;\n\t\twhile (left <= right) {\n\t\t\tconst mid = Math.floor((left + right) / 2);\n\t\t\tconst midValue = arr[mid].exFee;\n\t\t\tif (lessOrEqual ? midValue <= value : midValue >= value) {\n\t\t\t\tresult = mid;\n\t\t\t\tif (lessOrEqual) left = mid + 1;\n\t\t\t\telse right = mid - 1;\n\t\t\t} else {\n\t\t\t\tif (lessOrEqual) right = mid - 1;\n\t\t\t\telse left = mid + 1;\n\t\t\t}\n\t\t}\n\t\treturn lessOrEqual ? result : left < arr.length ? left : null;\n\t};\n\t// Insert into array of ProofWithFee objects sorted by exFee\n\tconst insertSorted = (arr: ProofWithFee[], obj: ProofWithFee): void => {\n\t\tconst value = obj.exFee;\n\t\tlet left = 0,\n\t\t\tright = arr.length;\n\t\twhile (left < right) {\n\t\t\tconst mid = Math.floor((left + right) / 2);\n\t\t\tif (arr[mid].exFee < value) left = mid + 1;\n\t\t\telse right = mid;\n\t\t}\n\t\tarr.splice(left, 0, obj);\n\t};\n\t// \"Delta\" is the excess over amountToSend including fees\n\t// plus a tiebreaker to favour lower PPK keysets\n\t// NB: Solutions under amountToSend are invalid (delta: Infinity)\n\tconst calculateDelta = (amount: number, feePPK: number): number => {\n\t\tconst netSum = sumExFees(amount, feePPK);\n\t\tif (netSum < amountToSend) return Infinity; // no good\n\t\treturn amount + feePPK / 1000 - amountToSend;\n\t};\n\n\t/**\n\t * Pre-processing.\n\t */\n\tlet totalAmount = 0;\n\tlet totalFeePPK = 0;\n\tconst proofWithFees = proofs.map((p) => {\n\t\tconst ppkfee = feeForProof(p);\n\t\tconst exFee = includeFees ? p.amount - ppkfee / 1000 : p.amount;\n\t\tconst obj = { proof: p, exFee, ppkfee };\n\t\t// Sum all economical proofs (filtered below)\n\t\tif (!includeFees || exFee > 0) {\n\t\t\ttotalAmount += p.amount;\n\t\t\ttotalFeePPK += ppkfee;\n\t\t}\n\t\treturn obj;\n\t});\n\n\t// Filter uneconomical proofs (totals computed above)\n\tlet spendableProofs = includeFees ? proofWithFees.filter((obj) => obj.exFee > 0) : proofWithFees;\n\n\t// Sort by exFee ascending\n\tspendableProofs.sort((a, b) => a.exFee - b.exFee);\n\n\t// Remove proofs too large to be useful and adjust totals\n\t// Exact Match: Keep proofs where exFee <= amountToSend\n\t// Close Match: Keep proofs where exFee <= nextBiggerExFee\n\tif (spendableProofs.length > 0) {\n\t\tlet endIndex;\n\t\tif (exactMatch) {\n\t\t\tconst rightIndex = binarySearchIndex(spendableProofs, amountToSend, true);\n\t\t\tendIndex = rightIndex !== null ? rightIndex + 1 : 0;\n\t\t} else {\n\t\t\tconst biggerIndex = binarySearchIndex(spendableProofs, amountToSend, false);\n\t\t\tif (biggerIndex !== null) {\n\t\t\t\tconst nextBiggerExFee = spendableProofs[biggerIndex].exFee;\n\t\t\t\tconst rightIndex = binarySearchIndex(spendableProofs, nextBiggerExFee, true);\n\t\t\t\tfailIfNullish(rightIndex, 'Unexpected null rightIndex in binary search', _logger);\n\t\t\t\tendIndex = rightIndex + 1;\n\t\t\t} else {\n\t\t\t\t// Keep all proofs if all exFee < amountToSend\n\t\t\t\tendIndex = spendableProofs.length;\n\t\t\t}\n\t\t}\n\t\t// Adjust totals for removed proofs\n\t\tfor (let i = endIndex; i < spendableProofs.length; i++) {\n\t\t\ttotalAmount -= spendableProofs[i].proof.amount;\n\t\t\ttotalFeePPK -= spendableProofs[i].ppkfee;\n\t\t}\n\t\tspendableProofs = spendableProofs.slice(0, endIndex);\n\t}\n\n\t// Validate using precomputed totals\n\tconst totalNetSum = sumExFees(totalAmount, totalFeePPK);\n\tif (amountToSend <= 0 || amountToSend > totalNetSum) {\n\t\treturn { keep: proofs, send: [] };\n\t}\n\n\t// Max acceptable amount for non-exact matches\n\tconst maxOverAmount = Math.min(\n\t\tMath.ceil(amountToSend * (1 + MAX_OVRPCT / 100)),\n\t\tamountToSend + MAX_OVRAMT,\n\t\ttotalNetSum,\n\t);\n\n\t/**\n\t * RGLI algorithm: Runs multiple trials (up to MAX_TRIALS) Each trial starts with randomized\n\t * greedy subset (S) and then tries to improve that subset to get a valid solution. NOTE: Fees are\n\t * dynamic, based on number of proofs (PPK), so we perform all calculations based on net amounts.\n\t */\n\tfor (let trial = 0; trial < MAX_TRIALS; trial++) {\n\t\t// PHASE 1: Randomized Greedy Selection\n\t\t// Add proofs up to amountToSend (after adjusting for fees)\n\t\t// for exact match or the first amount over target otherwise\n\t\tconst S: ProofWithFee[] = [];\n\t\tlet amount = 0;\n\t\tlet feePPK = 0;\n\t\tfor (const obj of shuffleArray(spendableProofs)) {\n\t\t\tconst newAmount = amount + obj.proof.amount;\n\t\t\tconst newFeePPK = feePPK + obj.ppkfee;\n\t\t\tconst netSum = sumExFees(newAmount, newFeePPK);\n\t\t\tif (exactMatch && netSum > amountToSend) break;\n\t\t\tS.push(obj);\n\t\t\tamount = newAmount;\n\t\t\tfeePPK = newFeePPK;\n\t\t\tif (netSum >= amountToSend) break;\n\t\t}\n\n\t\t// PHASE 2: Local Improvement\n\t\t// Examine all the amounts found in the first phase, and find the\n\t\t// amount not in the current solution (others), which would get us\n\t\t// closest to the amountToSend.\n\n\t\t// Calculate the \"others\" array (note: spendableProofs is sorted ASC)\n\t\t// Using set.has() for filtering gives faster lookups: O(n+m)\n\t\t// Using array.includes() would be way slower: O(n*m)\n\t\tconst SSet = new Set(S);\n\t\tconst others = spendableProofs.filter((obj) => !SSet.has(obj));\n\t\t// Generate a random order for accessing the trial subset ('S')\n\t\tconst indices = shuffleArray(Array.from({ length: S.length }, (_, i) => i)).slice(\n\t\t\t0,\n\t\t\tMAX_P2SWAP,\n\t\t);\n\t\tfor (const i of indices) {\n\t\t\t// Exact or acceptable close match solution found?\n\t\t\tconst netSum = sumExFees(amount, feePPK);\n\t\t\tif (\n\t\t\t\tnetSum === amountToSend ||\n\t\t\t\t(!exactMatch && netSum >= amountToSend && netSum <= maxOverAmount)\n\t\t\t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Get details for proof being replaced (objP), and temporarily\n\t\t\t// calculate the subset amount/fee with that proof removed.\n\t\t\tconst objP = S[i];\n\t\t\tconst tempAmount = amount - objP.proof.amount;\n\t\t\tconst tempFeePPK = feePPK - objP.ppkfee;\n\t\t\tconst tempNetSum = sumExFees(tempAmount, tempFeePPK);\n\t\t\tconst target = amountToSend - tempNetSum;\n\n\t\t\t// Find a better replacement proof (objQ) and swap it in\n\t\t\t// Exact match can only replace larger to close on the target\n\t\t\t// Close match can replace larger or smaller as needed, but will\n\t\t\t// not replace larger unless it closes on the target\n\t\t\tconst qIndex = binarySearchIndex(others, target, exactMatch);\n\t\t\tif (qIndex !== null) {\n\t\t\t\tconst objQ = others[qIndex];\n\t\t\t\tif (!exactMatch || objQ.exFee > objP.exFee) {\n\t\t\t\t\tif (target >= 0 || objQ.exFee <= objP.exFee) {\n\t\t\t\t\t\tS[i] = objQ;\n\t\t\t\t\t\tamount = tempAmount + objQ.proof.amount;\n\t\t\t\t\t\tfeePPK = tempFeePPK + objQ.ppkfee;\n\t\t\t\t\t\tothers.splice(qIndex, 1);\n\t\t\t\t\t\tinsertSorted(others, objP);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Update best solution\n\t\tconst delta = calculateDelta(amount, feePPK);\n\t\tif (delta < bestDelta) {\n\t\t\t_logger.debug(\n\t\t\t\t`selectProofsToSend: best solution found in trial #${trial} - amount: ${amount}, delta: ${delta}`,\n\t\t\t);\n\t\t\tbestSubset = [...S].sort((a, b) => b.exFee - a.exFee); // copy & sort\n\t\t\tbestDelta = delta;\n\t\t\tbestAmount = amount;\n\t\t\tbestFeePPK = feePPK;\n\n\t\t\t// \"PHASE 3\": Final check to make sure we haven't overpaid fees\n\t\t\t// and see if we can improve the solution. This is an adaptation\n\t\t\t// to the original RGLI, which helps us identify close match and\n\t\t\t// optimal fee solutions more consistently\n\t\t\tconst tempS = [...bestSubset]; // copy\n\t\t\twhile (tempS.length > 1 && bestDelta > 0) {\n\t\t\t\tconst objP = tempS.pop() as ProofWithFee;\n\t\t\t\tconst tempAmount = amount - objP.proof.amount;\n\t\t\t\tconst tempFeePPK = feePPK - objP.ppkfee;\n\t\t\t\tconst tempDelta = calculateDelta(tempAmount, tempFeePPK);\n\t\t\t\tif (tempDelta == Infinity) break;\n\t\t\t\tif (tempDelta < bestDelta) {\n\t\t\t\t\tbestSubset = [...tempS];\n\t\t\t\t\tbestDelta = tempDelta;\n\t\t\t\t\tbestAmount = tempAmount;\n\t\t\t\t\tbestFeePPK = tempFeePPK;\n\t\t\t\t\tamount = tempAmount;\n\t\t\t\t\tfeePPK = tempFeePPK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Check if solution is acceptable\n\t\tif (bestSubset && bestDelta < Infinity) {\n\t\t\tconst bestSum = sumExFees(bestAmount, bestFeePPK);\n\t\t\tif (\n\t\t\t\tbestSum === amountToSend ||\n\t\t\t\t(!exactMatch && bestSum >= amountToSend && bestSum <= maxOverAmount)\n\t\t\t) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// Time limit reached?\n\t\tif (timer.elapsed() > MAX_TIMEMS) {\n\t\t\tfailIf(\n\t\t\t\texactMatch,\n\t\t\t\t'Proof selection took too long. Try again with a smaller proof set.',\n\t\t\t\t_logger,\n\t\t\t);\n\t\t\t_logger.warn('Proof selection took too long. Returning best selection so far.');\n\t\t\tbreak;\n\t\t}\n\t}\n\t// Return Result\n\tif (bestSubset && bestDelta < Infinity) {\n\t\tconst bestProofs = bestSubset.map((obj) => obj.proof);\n\t\tconst bestSubsetSet = new Set(bestProofs);\n\t\tconst keep = proofs.filter((p) => !bestSubsetSet.has(p));\n\t\t_logger.info(`Proof selection took ${timer.elapsed()}ms`);\n\t\treturn { keep, send: bestProofs };\n\t}\n\treturn { keep: proofs, send: [] };\n};\n", "/**\n * Usable counters in range is [start, start+count-1]\n *\n * @example // Start: 5, count: 3 => 5,6,7.\n */\nexport interface CounterRange {\n\tstart: number;\n\tcount: number;\n}\n\n// CounterSource.ts\nexport interface CounterSource {\n\t/**\n\t * Reserve n counters for a keyset.\n\t *\n\t * N may be 0. In that case the call MUST NOT mutate state and MUST return { start: currentNext,\n\t * count: 0 }, effectively a read only peek of the cursor.\n\t */\n\treserve(keysetId: string, n: number): Promise<CounterRange>;\n\t/**\n\t * Monotonic bump, ensure the next counter is at least minNext.\n\t */\n\tadvanceToAtLeast(keysetId: string, minNext: number): Promise<void>;\n\t/**\n\t * Optional introspection.\n\t */\n\tsnapshot?(): Promise<Record<string, number>>;\n\t/**\n\t * Optional hard set, useful for tests or migrations.\n\t */\n\tsetNext?(keysetId: string, next: number): Promise<void>;\n}\n\n/**\n * Counter summary for an operation.\n *\n * - `keysetId` - of the transaction.\n * - `start` - beginning of reservation.\n * - `count` - number of reservations.\n * - `next` - counter available after reservation.\n *\n * @example // Start: 5, Count: 3 => 5,6,7. Next: 8.\n */\nexport type OperationCounters = {\n\tkeysetId: string;\n\tstart: number;\n\tcount: number;\n\tnext: number;\n};\n\n/**\n * In memory implementation with per keyset locks for atomic counters.\n */\nexport class EphemeralCounterSource implements CounterSource {\n\tprivate next = new Map<string, number>();\n\tprivate locks = new Map<string, Promise<void>>();\n\n\tconstructor(initial?: Record<string, number>) {\n\t\tif (initial) {\n\t\t\tfor (const [k, v] of Object.entries(initial)) this.next.set(k, v);\n\t\t}\n\t}\n\n\tprivate async withLock<T>(k: string, fn: () => T | Promise<T>): Promise<T> {\n\t\tconst prev = this.locks.get(k) ?? Promise.resolve();\n\t\tlet release!: () => void;\n\t\tconst p = new Promise<void>((resolve) => (release = resolve));\n\t\tconst chain = prev.then(() => p);\n\t\tthis.locks.set(k, chain);\n\t\ttry {\n\t\t\tawait prev;\n\t\t\treturn await fn();\n\t\t} finally {\n\t\t\trelease();\n\t\t\tif (this.locks.get(k) === chain) {\n\t\t\t\tthis.locks.delete(k);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync reserve(keysetId: string, n: number): Promise<CounterRange> {\n\t\tif (n < 0) throw new Error('reserve called with negative count');\n\t\treturn this.withLock(keysetId, () => {\n\t\t\tconst cur = this.next.get(keysetId) ?? 0;\n\t\t\tif (n === 0) return { start: cur, count: 0 }; // report current, do not move\n\t\t\tthis.next.set(keysetId, cur + n);\n\t\t\treturn { start: cur, count: n };\n\t\t});\n\t}\n\n\tasync advanceToAtLeast(keysetId: string, minNext: number): Promise<void> {\n\t\tawait this.withLock(keysetId, () => {\n\t\t\tconst cur = this.next.get(keysetId) ?? 0;\n\t\t\tif (minNext > cur) this.next.set(keysetId, minNext);\n\t\t});\n\t}\n\n\tasync setNext(keysetId: string, next: number): Promise<void> {\n\t\tawait this.withLock(keysetId, () => {\n\t\t\tif (next < 0) throw new Error('setNext: negative next not allowed');\n\t\t\tthis.next.set(keysetId, next);\n\t\t});\n\t}\n\n\tsnapshot(): Promise<Record<string, number>> {\n\t\treturn Promise.resolve(Object.fromEntries(this.next.entries()));\n\t}\n}\n", "import {\n\ttype MeltQuoteResponse,\n\ttype MintQuoteResponse,\n\ttype Bolt12MeltQuoteResponse,\n\ttype Bolt12MintQuoteResponse,\n} from '../mint/types';\nimport { type OutputData, type OutputDataFactory } from '../model/OutputData';\nimport type { Proof } from '../model/types/proof';\nimport type { Token } from '../model/types/token';\nimport {\n\ttype OutputType,\n\ttype OutputConfig,\n\ttype SendConfig,\n\ttype ReceiveConfig,\n\ttype MintProofsConfig,\n\ttype P2PKOptions,\n\ttype OnCountersReserved,\n\ttype MeltProofsConfig,\n} from './types';\nimport type { Wallet } from './Wallet';\n\n/**\n * Fluent operations builder for a Wallet instance.\n *\n * @remarks\n * Provides chainable builders for sending, receiving, and minting. Each builder is single use. If\n * you do not customise an output side, the wallets policy defaults apply.\n */\nexport class WalletOps {\n\tconstructor(private wallet: Wallet) {}\n\tsend(amount: number, proofs: Proof[]) {\n\t\treturn new SendBuilder(this.wallet, amount, proofs);\n\t}\n\treceive(token: Token | string) {\n\t\treturn new ReceiveBuilder(this.wallet, token);\n\t}\n\tmintBolt11(amount: number, quote: string | MintQuoteResponse) {\n\t\treturn new MintBuilder<'bolt11'>(this.wallet, 'bolt11', amount, quote);\n\t}\n\tmintBolt12(amount: number, quote: Bolt12MintQuoteResponse) {\n\t\treturn new MintBuilder<'bolt12'>(this.wallet, 'bolt12', amount, quote);\n\t}\n\tmeltBolt11(quote: MeltQuoteResponse, proofs: Proof[]) {\n\t\treturn new MeltBuilder(this.wallet, 'bolt11', quote, proofs);\n\t}\n\tmeltBolt12(quote: Bolt12MeltQuoteResponse, proofs: Proof[]) {\n\t\treturn new MeltBuilder(this.wallet, 'bolt12', quote, proofs);\n\t}\n}\n\n/**\n * Builder for composing a send or swap.\n *\n * @remarks\n * If you only customise the send side, keep is omitted so the wallet may still attempt an offline\n * exact match selection where possible.\n * @example\n *\n *     const { keep, send } = await wallet.ops\n *     \t.send(5, proofs)\n *     \t.asDeterministic() // counter 0 means auto reserve via CounterSource\n *     \t.keepAsRandom()\n *     \t.includeFees(true) // sender pays receivers future spend fee\n *     \t.run();\n */\nexport class SendBuilder {\n\tprivate sendOT?: OutputType;\n\tprivate keepOT?: OutputType;\n\tprivate config: SendConfig = {};\n\tprivate offlineExact?: { requireDleq: boolean };\n\tprivate offlineClose?: { requireDleq: boolean };\n\n\tconstructor(\n\t\tprivate wallet: Wallet,\n\t\tprivate amount: number,\n\t\tprivate proofs: Proof[],\n\t) {}\n\n\t/**\n\t * Use random blinding for the sent outputs.\n\t *\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasRandom(denoms?: number[]) {\n\t\tthis.sendOT = { type: 'random', denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use deterministic outputs for the sent proofs.\n\t *\n\t * @param counter Starting counter. Zero means auto reserve using the wallets CounterSource.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasDeterministic(counter = 0, denoms?: number[]) {\n\t\tthis.sendOT = { type: 'deterministic', counter, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use P2PK locked outputs for the sent proofs.\n\t *\n\t * @param options NUT 11 options like pubkey and locktime.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasP2PK(options: P2PKOptions, denoms?: number[]) {\n\t\tthis.sendOT = { type: 'p2pk', options, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use a factory to generate OutputData for the sent proofs.\n\t *\n\t * @param factory OutputDataFactory used to produce blinded messages.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasFactory(factory: OutputDataFactory, denoms?: number[]) {\n\t\tthis.sendOT = { type: 'factory', factory, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Provide pre created OutputData for the sent proofs.\n\t *\n\t * @param data Fully formed OutputData. Their amounts must sum to the send amount, otherwise the\n\t *   wallet will throw.\n\t */\n\tasCustom(data: OutputData[]) {\n\t\tthis.sendOT = { type: 'custom', data };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use random blinding for change outputs.\n\t *\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tkeepAsRandom(denoms?: number[]) {\n\t\tthis.keepOT = { type: 'random', denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use deterministic outputs for change.\n\t *\n\t * @param counter Starting counter. Zero means auto reserve using the wallets CounterSource.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tkeepAsDeterministic(counter = 0, denoms?: number[]) {\n\t\tthis.keepOT = { type: 'deterministic', counter, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use P2PK locked change (NUT 11).\n\t *\n\t * @param options Locking options applied to the kept proofs.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tkeepAsP2PK(options: P2PKOptions, denoms?: number[]) {\n\t\tthis.keepOT = { type: 'p2pk', options, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use a factory to generate OutputData for change.\n\t *\n\t * @param factory OutputDataFactory used to produce blinded messages.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tkeepAsFactory(factory: OutputDataFactory, denoms?: number[]) {\n\t\tthis.keepOT = { type: 'factory', factory, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Provide pre created OutputData for change.\n\t *\n\t * @param data Fully formed OutputData for the keep (change) amount.\n\t */\n\tkeepAsCustom(data: OutputData[]) {\n\t\tthis.keepOT = { type: 'custom', data };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Make the sender cover the receivers future spend fee.\n\t *\n\t * @param on When true, include fees in the sent amount. Default true if called.\n\t */\n\tincludeFees(on = true) {\n\t\tthis.config.includeFees = on;\n\t\treturn this;\n\t}\n\t/**\n\t * Use a specific keyset for the operation.\n\t *\n\t * @param id Keyset id to use for mint keys and fee lookup.\n\t */\n\tkeyset(id: string) {\n\t\tthis.config.keysetId = id;\n\t\treturn this;\n\t} /**\n\t * Provide existing proofs to help optimise denomination selection.\n\t *\n\t * @remarks\n\t * Has no effect if denominations (custom split) was specified.\n\t * @param p Proofs currently held by the wallet, used to hit denomination targets.\n\t */\n\tproofsWeHave(p: Proof[]) {\n\t\tthis.config.proofsWeHave = p;\n\t\treturn this;\n\t}\n\t/**\n\t * Receive a callback once counters are atomically reserved for deterministic outputs.\n\t *\n\t * @param cb Called with OperationCounters when counters are reserved.\n\t */\n\tonCountersReserved(cb: OnCountersReserved) {\n\t\tthis.config.onCountersReserved = cb;\n\t\treturn this;\n\t}\n\t/**\n\t * Force a pure offline, exact match selection. No mint calls are made. If an exact match cannot\n\t * be found, this throws.\n\t *\n\t * @param requireDleq Only consider proofs with a DLEQ when true.\n\t */\n\tofflineExactOnly(requireDleq = false) {\n\t\tthis.offlineExact = { requireDleq };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Force a pure offline selection that allows a close match, overspend permitted per wallet RGLI.\n\t * No mint calls are made. Returns the best offline subset found, or throws if funds are\n\t * insufficient.\n\t *\n\t * @param requireDleq Only consider proofs with a DLEQ when true.\n\t */\n\tofflineCloseMatch(requireDleq = false) {\n\t\tthis.offlineClose = { requireDleq };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Execute the send or swap.\n\t *\n\t * @returns The split result with kept and sent proofs.\n\t */\n\tasync run() {\n\t\t// If an offline mode is requested, forbid custom OutputTypes,\n\t\t// because offline uses existing proofs and cannot honour new outputs.\n\t\tif ((this.offlineExact || this.offlineClose) && (this.sendOT || this.keepOT)) {\n\t\t\tthrow new Error(\n\t\t\t\t'Offline selection cannot be combined with custom output types. Remove send/keep output configuration, or use an online swap.',\n\t\t\t);\n\t\t}\n\n\t\t// Strict offline, exact match only\n\t\tif (this.offlineExact) {\n\t\t\treturn this.wallet.sendOffline(this.amount, this.proofs, {\n\t\t\t\tincludeFees: this.config.includeFees,\n\t\t\t\texactMatch: true,\n\t\t\t\trequireDleq: this.offlineExact.requireDleq,\n\t\t\t});\n\t\t}\n\n\t\t// Offline close match, may overshoot\n\t\tif (this.offlineClose) {\n\t\t\treturn this.wallet.sendOffline(this.amount, this.proofs, {\n\t\t\t\tincludeFees: this.config.includeFees,\n\t\t\t\texactMatch: false,\n\t\t\t\trequireDleq: this.offlineClose.requireDleq,\n\t\t\t});\n\t\t}\n\n\t\t// Construct an OutputConfig using default send if no customizations\n\t\tconst outputConfig: OutputConfig = {\n\t\t\tsend: this.sendOT ?? this.wallet.defaultOutputType(),\n\t\t\t...(this.keepOT ? { keep: this.keepOT } : {}),\n\t\t};\n\t\treturn this.wallet.send(this.amount, this.proofs, this.config, outputConfig);\n\t}\n}\n\n/**\n * Builder for receiving a token.\n *\n * @remarks\n * If you do not call a type method, the wallets policy default is used.\n * @example\n *\n *     const proofs = await wallet.ops\n *     \t.receive(token)\n *     \t.asDeterministic() // counter 0 auto reserves\n *     \t.requireDleq(true)\n *     \t.run();\n */\nexport class ReceiveBuilder {\n\tprivate outputType?: OutputType;\n\tprivate config: ReceiveConfig = {};\n\n\tconstructor(\n\t\tprivate wallet: Wallet,\n\t\tprivate token: Token | string,\n\t) {}\n\n\t/**\n\t * Use random blinding for the received outputs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasRandom(denoms?: number[]) {\n\t\tthis.outputType = { type: 'random', denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use deterministic outputs for the received proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param counter Starting counter. Zero means auto reserve using the wallets CounterSource.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasDeterministic(counter = 0, denoms?: number[]) {\n\t\tthis.outputType = { type: 'deterministic', counter, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use P2PK locked outputs for the received proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param options NUT 11 options like pubkey and locktime.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasP2PK(options: P2PKOptions, denoms?: number[]) {\n\t\tthis.outputType = { type: 'p2pk', options, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use a factory to generate OutputData for received proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param factory OutputDataFactory used to produce blinded messages.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasFactory(factory: OutputDataFactory, denoms?: number[]) {\n\t\tthis.outputType = { type: 'factory', factory, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Provide pre created OutputData for received proofs.\n\t *\n\t * @param data Fully formed OutputData for the final amount.\n\t */\n\tasCustom(data: OutputData[]) {\n\t\tthis.outputType = { type: 'custom', data };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a specific keyset for the operation.\n\t *\n\t * @param id Keyset id to use for mint keys and fee lookup.\n\t */\n\tkeyset(id: string) {\n\t\tthis.config.keysetId = id;\n\t\treturn this;\n\t}\n\t/**\n\t * Require all incoming proofs to have a valid DLEQ for the selected keyset.\n\t *\n\t * @param on When true, proofs without DLEQ are rejected.\n\t */\n\trequireDleq(on = true) {\n\t\tthis.config.requireDleq = on;\n\t\treturn this;\n\t}\n\t/**\n\t * Private key used to sign P2PK locked incoming proofs.\n\t *\n\t * @param k Single key or array of multisig keys.\n\t */\n\tprivkey(k: string | string[]) {\n\t\tthis.config.privkey = k;\n\t\treturn this;\n\t}\n\t/**\n\t * Provide existing proofs to help optimise denomination selection.\n\t *\n\t * @remarks\n\t * Has no effect if denominations (custom split) was specified.\n\t * @param p Proofs currently held by the wallet, used to hit denomination targets.\n\t */\n\tproofsWeHave(p: Proof[]) {\n\t\tthis.config.proofsWeHave = p;\n\t\treturn this;\n\t}\n\t/**\n\t * Receive a callback once counters are atomically reserved for deterministic outputs.\n\t *\n\t * @param cb Called with OperationCounters when counters are reserved.\n\t */\n\tonCountersReserved(cb: OnCountersReserved) {\n\t\tthis.config.onCountersReserved = cb;\n\t\treturn this;\n\t}\n\n\tasync run() {\n\t\treturn this.wallet.receive(this.token, this.config, this.outputType);\n\t}\n}\n\n/**\n * Builder for minting proofs from a quote.\n *\n * @remarks\n * Bolt12 requires privkey by default, bolt11 only for locked quotes. The compiler will throw an\n * error if bolt12 and privkey() is omitted: MintBuilder<\"bolt12\", false>' is not assignable...\n * @example\n *\n *     const proofs = await wallet.ops\n *     \t.mint(100, quote)\n *     \t.asDeterministic() // counter 0 auto reserves\n *     \t.onCountersReserved((info) => console.log(info))\n *     \t.privkey('sk')\n *     \t.run();\n */\nexport class MintBuilder<\n\tM extends 'bolt11' | 'bolt12',\n\tHasPrivKey extends boolean = M extends 'bolt12' ? false : true,\n> {\n\tprivate outputType?: OutputType;\n\tprivate config: MintProofsConfig = {};\n\n\t// phantom field to satisfy linter (erased at emit)\n\tprivate readonly _hasPrivkey!: HasPrivKey;\n\n\tconstructor(\n\t\tprivate wallet: Wallet,\n\t\tprivate method: M,\n\t\tprivate amount: number,\n\t\tprivate quote: string | MintQuoteResponse | Bolt12MintQuoteResponse,\n\t) {\n\t\tvoid this._hasPrivkey; // intentionally unused (phantom field)\n\t}\n\n\t/**\n\t * Use random blinding for the minted proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasRandom(denoms?: number[]) {\n\t\tthis.outputType = { type: 'random', denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use deterministic outputs for the minted proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param counter Starting counter. Zero means auto reserve using the wallets CounterSource.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasDeterministic(counter = 0, denoms?: number[]) {\n\t\tthis.outputType = { type: 'deterministic', counter, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use P2PK locked outputs for the minted proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param options NUT 11 options like pubkey and locktime.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasP2PK(options: P2PKOptions, denoms?: number[]) {\n\t\tthis.outputType = { type: 'p2pk', options, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use a factory to generate OutputData for minted proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param factory OutputDataFactory used to produce blinded messages.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasFactory(factory: OutputDataFactory, denoms?: number[]) {\n\t\tthis.outputType = { type: 'factory', factory, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Provide pre created OutputData for minted proofs.\n\t *\n\t * @param data Fully formed OutputData for the final amount.\n\t */\n\tasCustom(data: OutputData[]) {\n\t\tthis.outputType = { type: 'custom', data };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a specific keyset for the operation.\n\t *\n\t * @param id Keyset id to use for mint keys and fee lookup.\n\t */\n\tkeyset(id: string) {\n\t\tthis.config.keysetId = id;\n\t\treturn this;\n\t}\n\t/**\n\t * Private key to sign locked mint quotes.\n\t *\n\t * @param k Private key for locked quotes.\n\t */\n\tprivkey(k: string): MintBuilder<M, true> {\n\t\t// For bolt11 - privkey is sent in the config\n\t\t// For bolt12 - privkey is sent positionally in run()\n\t\tthis.config.privkey = k;\n\t\treturn this as MintBuilder<M, true>;\n\t}\n\t/**\n\t * Provide existing proofs to help optimise denomination selection.\n\t *\n\t * @remarks\n\t * Has no effect if denominations (custom split) was specified.\n\t * @param p Proofs currently held by the wallet, used to hit denomination targets.\n\t */\n\tproofsWeHave(p: Proof[]) {\n\t\tthis.config.proofsWeHave = p;\n\t\treturn this;\n\t}\n\t/**\n\t * Receive a callback once counters are atomically reserved for deterministic outputs.\n\t *\n\t * @param cb Called with OperationCounters when counters are reserved.\n\t */\n\tonCountersReserved(cb: OnCountersReserved) {\n\t\tthis.config.onCountersReserved = cb;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Execute minting against the quote.\n\t *\n\t * @remarks\n\t * This method can only be called for bolt12 quotes when .privkey() is set.\n\t * @returns The newly minted proofs.\n\t */\n\tasync run(this: MintBuilder<M, true>) {\n\t\t// BOLT 11\n\t\tif (this.method === 'bolt11') {\n\t\t\tconst bolt11 = this.quote as MintQuoteResponse;\n\t\t\tif (bolt11.pubkey && !this.config.privkey) {\n\t\t\t\tthrow new Error('privkey is required for locked BOLT11 mint quotes');\n\t\t\t}\n\t\t\treturn this.wallet.mintProofsBolt11(this.amount, bolt11, this.config, this.outputType);\n\t\t}\n\n\t\t// BOLT 12\n\t\tconst bolt12 = this.quote as Bolt12MintQuoteResponse;\n\t\tif (!this.config.privkey) {\n\t\t\tthrow new Error('privkey is required for BOLT12 mint quotes');\n\t\t}\n\t\treturn this.wallet.mintProofsBolt12(\n\t\t\tthis.amount,\n\t\t\tbolt12,\n\t\t\tthis.config.privkey,\n\t\t\tthis.config,\n\t\t\tthis.outputType,\n\t\t);\n\t}\n}\n\n/**\n * Builder for melting proofs to pay a Lightning invoice or BOLT12 offer.\n *\n * @remarks\n * Supports both BOLT11 and BOLT12. You can optionally receive a callback when NUT-08 blanks are\n * created for async melts.\n * @example\n *\n * ```typescript\n * // Basic BOLT11 melt\n * await wallet.ops.meltBolt11(quote, proofs).run();\n *\n * // BOLT12 melt with deterministic change and NUT-08 blanks callback\n * await wallet.ops\n * \t.meltBolt12(quote12, proofs)\n * \t.asDeterministic() // counter 0 auto reserves\n * \t.onChangeOutputsCreated((blanks) => {\n * \t\t// Persist blanks and retry later with wallet.completeMelt(blanks)\n * \t})\n * \t.onCountersReserved((info) => console.log('Reserved', info))\n * \t.run();\n * ```\n */\nexport class MeltBuilder {\n\tprivate outputType?: OutputType;\n\tprivate config: MeltProofsConfig = {};\n\n\tconstructor(\n\t\tprivate wallet: Wallet,\n\t\tprivate method: 'bolt11' | 'bolt12',\n\t\tprivate quote: MeltQuoteResponse,\n\t\tprivate proofs: Proof[],\n\t) {}\n\n\t/**\n\t * Use random blinding for change outputs.\n\t *\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasRandom(denoms?: number[]) {\n\t\tthis.outputType = { type: 'random', denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use deterministic outputs for change.\n\t *\n\t * @param counter Starting counter. Zero means auto reserve using the wallets CounterSource.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasDeterministic(counter = 0, denoms?: number[]) {\n\t\tthis.outputType = { type: 'deterministic', counter, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use P2PK-locked change (NUT-11).\n\t *\n\t * @param options NUT-11 locking options (e.g., pubkey, locktime).\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasP2PK(options: P2PKOptions, denoms?: number[]) {\n\t\tthis.outputType = { type: 'p2pk', options, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a factory to generate OutputData for change.\n\t *\n\t * @param factory Factory used to produce blinded messages.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasFactory(factory: OutputDataFactory, denoms?: number[]) {\n\t\tthis.outputType = { type: 'factory', factory, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Provide pre-created OutputData for change.\n\t *\n\t * @param data Fully formed OutputData for the change amount.\n\t */\n\tasCustom(data: OutputData[]) {\n\t\tthis.outputType = { type: 'custom', data };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a specific keyset for the melt operation.\n\t *\n\t * @param id Keyset id to use for mint keys and fee lookup.\n\t */\n\tkeyset(id: string) {\n\t\tthis.config.keysetId = id;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Receive a callback once counters are atomically reserved for deterministic outputs.\n\t *\n\t * @param cb Called with OperationCounters when counters are reserved.\n\t */\n\tonCountersReserved(cb: OnCountersReserved) {\n\t\tthis.config.onCountersReserved = cb;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Receive a callback when NUT-08 blanks (0-sat change outputs) are created for async melts.\n\t *\n\t * @remarks\n\t * You can persist these blanks and later call `wallet.completeMelt(blanks)` to finalize and\n\t * recover change once the invoice/offer is paid.\n\t * @param cb Callback invoked with the created blanks payload.\n\t */\n\tonChangeOutputsCreated(cb: NonNullable<MeltProofsConfig['onChangeOutputsCreated']>) {\n\t\tthis.config.onChangeOutputsCreated = cb;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Execute the melt against the quote.\n\t *\n\t * @returns The melt result: `{ quote, change }`.\n\t */\n\tasync run() {\n\t\t// BOLT11\n\t\tif (this.method === 'bolt11') {\n\t\t\treturn this.wallet.meltProofsBolt11(this.quote, this.proofs, this.config, this.outputType);\n\t\t}\n\n\t\t// BOLT 12\n\t\treturn this.wallet.meltProofsBolt12(this.quote, this.proofs, this.config, this.outputType);\n\t}\n}\n", "import type { Wallet } from './Wallet';\nimport type { Proof, ProofState } from '../model/types';\nimport {\n\tMintQuoteState,\n\tMeltQuoteState,\n\ttype MintQuoteResponse,\n\ttype MeltQuoteResponse,\n} from '../mint/types';\nimport type { MeltBlanks, SubscriptionCanceller } from './types';\nimport { hashToCurve } from '../crypto';\nimport { type OperationCounters } from './CounterSource';\nimport { safeCallback } from '../logger';\n\nexport type CancellerLike = SubscriptionCanceller | Promise<SubscriptionCanceller>;\n\nexport type SubscribeOpts = { signal?: AbortSignal };\n\ntype ErrorWithCause = Error & { cause?: unknown };\n\nfunction safeStringify(obj: unknown): string {\n\tconst seen = new WeakSet<object>();\n\ttry {\n\t\treturn JSON.stringify(obj, (_k: string, v: unknown) => {\n\t\t\tif (typeof v === 'object' && v !== null) {\n\t\t\t\tif (seen.has(v)) return '[Circular]';\n\t\t\t\tseen.add(v);\n\t\t\t}\n\t\t\treturn v; // returning `unknown` is fine\n\t\t});\n\t} catch {\n\t\treturn Object.prototype.toString.call(obj);\n\t}\n}\n\nfunction normalizeError(err: unknown): Error {\n\tif (err instanceof Error) return err;\n\tconst message = typeof err === 'string' ? err : safeStringify(err);\n\tconst e: ErrorWithCause = new Error(message);\n\te.cause = err;\n\treturn e;\n}\n\nfunction makeAbortError(): Error {\n\tconst e = new Error('Aborted');\n\tObject.defineProperty(e, 'name', { value: 'AbortError' });\n\treturn e;\n}\n\nfunction cancelSafely(c: CancellerLike | null | undefined): void {\n\tif (!c) return;\n\tvoid Promise.resolve(c)\n\t\t.then((fn) => {\n\t\t\ttry {\n\t\t\t\tfn();\n\t\t\t} catch {\n\t\t\t\t/* ignore canceller errors */\n\t\t\t}\n\t\t\treturn;\n\t\t})\n\t\t.catch(() => {\n\t\t\t/* ignore awaiting-canceller errors */\n\t\t});\n}\n\nexport class WalletEvents {\n\tconstructor(private wallet: Wallet) {}\n\n\t// Callbacks registered for Counters Reserved events\n\tprivate countersReservedHandlers = new Set<(payload: OperationCounters) => void>();\n\n\t// Callbacks registered for Melt blanks created events\n\tprivate meltBlanksHandlers = new Set<(payload: MeltBlanks) => void>();\n\n\t// Binds an abort signal to each subscription canceller\n\tprivate withAbort(\n\t\tsignal: AbortSignal | undefined,\n\t\tcancel: SubscriptionCanceller,\n\t): SubscriptionCanceller {\n\t\tif (!signal) return cancel;\n\t\tif (signal.aborted) {\n\t\t\tcancel();\n\t\t\treturn () => {\n\t\t\t\t/* noop */\n\t\t\t};\n\t\t}\n\t\tconst onAbort = () => cancel();\n\t\tsignal.addEventListener('abort', onAbort, { once: true });\n\t\treturn () => {\n\t\t\tsignal.removeEventListener('abort', onAbort);\n\t\t\tcancel();\n\t\t};\n\t}\n\n\t// Subscribe to a quote-paid event and resolve when it fires.\n\t// Supports AbortSignal and timeout, and always cleans up.\n\tprivate waitUntilPaid<T>(\n\t\tsubscribeFn: (\n\t\t\tid: string,\n\t\t\tcb: (p: T) => void, // called when the entity becomes PAID\n\t\t\terr: (e: Error) => void, // called if the subscription itself errors\n\t\t\topts?: { signal?: AbortSignal },\n\t\t) => Promise<SubscriptionCanceller>,\n\t\tid: string, // identifier of the mint/melt/etc. to watch\n\t\topts?: SubscribeOpts & { timeoutMs?: number },\n\t\ttimeoutMsg = 'Timeout waiting for paid',\n\t): Promise<T> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlet cancelP: Promise<SubscriptionCanceller> | null = null; // handle to unsub later\n\t\t\tlet to: ReturnType<typeof setTimeout> | null = null; // optional timeout timer\n\n\t\t\t// Common cleanup: cancels subscription, clears timer, detaches abort listener.\n\t\t\t// If an error is provided, rejects the promise with it.\n\t\t\tconst cleanup = (err?: unknown) => {\n\t\t\t\tcancelSafely(cancelP);\n\t\t\t\tif (to) {\n\t\t\t\t\tclearTimeout(to);\n\t\t\t\t\tto = null;\n\t\t\t\t}\n\t\t\t\tif (opts?.signal) opts.signal.removeEventListener('abort', onAbort);\n\t\t\t\tif (err) reject(normalizeError(err));\n\t\t\t};\n\n\t\t\t// Abort handler produces a standardized AbortError and rejects.\n\t\t\tconst onAbort = () => cleanup(makeAbortError());\n\n\t\t\t// Hook up AbortSignal if provided.\n\t\t\tif (opts?.signal) {\n\t\t\t\tif (opts.signal.aborted) return onAbort(); // already aborted\n\t\t\t\topts.signal.addEventListener('abort', onAbort, { once: true });\n\t\t\t}\n\n\t\t\t// Start a timeout if requested.\n\t\t\tif (opts?.timeoutMs && opts.timeoutMs > 0) {\n\t\t\t\tto = setTimeout(() => cleanup(new Error(timeoutMsg)), opts.timeoutMs);\n\t\t\t}\n\n\t\t\t// Subscribe to the actual event. Canceller returned is saved to cancelP.\n\t\t\tcancelP = subscribeFn(\n\t\t\t\tid,\n\t\t\t\t(p) => {\n\t\t\t\t\tcleanup(); // clean up resources\n\t\t\t\t\tresolve(p); // resolve promise with payload\n\t\t\t\t},\n\t\t\t\t(e) => cleanup(e), // reject if subscription itself errors\n\t\t\t\t{ signal: opts?.signal }, // delegate abort to subscription as well\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * Register a callback that fires whenever deterministic counters are reserved.\n\t *\n\t * Timing: the callback is invoked synchronously _after_ a successful reservation and _before_ the\n\t * enclosing wallet method returns. The wallet does **not** await your callback, it is\n\t * fire-and-forget.\n\t *\n\t * Responsibility for async work is on the consumer. If your handler calls an async function (e.g.\n\t * persisting `start + count` to storage), make sure to handle errors inside it to avoid unhandled\n\t * rejections.\n\t *\n\t * Typical use: persist `start + count` for the `keysetId` so counters survive restarts.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * wallet.on.countersReserved(({ keysetId, start, count, next }) => {\n\t * \tsaveNextToDb(keysetId, start + count); // handle async errors inside saveNextToDb\n\t * });\n\t * ```\n\t *\n\t * @param cb Handler called with { keysetId, start, count }.\n\t * @returns A function that unsubscribes the handler.\n\t */\n\tpublic countersReserved(\n\t\tcb: (payload: OperationCounters) => void,\n\t\topts?: SubscribeOpts,\n\t): SubscriptionCanceller {\n\t\tthis.countersReservedHandlers.add(cb);\n\t\tconst cancel = () => this.countersReservedHandlers.delete(cb);\n\t\treturn this.withAbort(opts?.signal, cancel);\n\t}\n\t/**\n\t * @internal\n\t */\n\tpublic _emitCountersReserved(payload: OperationCounters) {\n\t\tfor (const h of this.countersReservedHandlers) {\n\t\t\tsafeCallback(h, payload, this.wallet.logger, { event: 'countersReserved' });\n\t\t}\n\t}\n\n\t/**\n\t * Register a callback fired whenever NUT-08 blanks are created during a melt.\n\t *\n\t * Called synchronously right after blanks are prepared (before the melt request), and the wallet\n\t * does not await your handler.\n\t *\n\t * Typical use: persist `payload` so you can later call `wallet.completeMelt(payload)`.\n\t */\n\tpublic meltBlanksCreated(\n\t\tcb: (payload: MeltBlanks) => void,\n\t\topts?: SubscribeOpts,\n\t): SubscriptionCanceller {\n\t\tthis.meltBlanksHandlers.add(cb);\n\t\tconst cancel = () => this.meltBlanksHandlers.delete(cb);\n\t\treturn this.withAbort(opts?.signal, cancel);\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tpublic _emitMeltBlanksCreated(payload: MeltBlanks) {\n\t\tfor (const h of this.meltBlanksHandlers) {\n\t\t\tsafeCallback(h, payload, this.wallet.logger, { event: 'meltBlanksCreated' });\n\t\t}\n\t}\n\n\t/**\n\t * Register a callback to be called whenever a mint quote's state changes.\n\t *\n\t * @param quoteIds List of mint quote IDs that should be subscribed to.\n\t * @param callback Callback function that will be called whenever a mint quote state changes.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync mintQuoteUpdates(\n\t\tids: string[],\n\t\tcb: (p: MintQuoteResponse) => void,\n\t\terr: (e: Error) => void,\n\t\topts?: SubscribeOpts,\n\t): Promise<SubscriptionCanceller> {\n\t\tawait this.wallet.mint.connectWebSocket();\n\t\tconst ws = this.wallet.mint.webSocketConnection;\n\t\tif (!ws) throw new Error('Failed to establish WebSocket connection.');\n\n\t\tconst uniq = Array.from(new Set(ids));\n\t\tconst subId = ws.createSubscription({ kind: 'bolt11_mint_quote', filters: uniq }, cb, err);\n\t\tconst cancel = () => ws.cancelSubscription(subId, cb);\n\t\treturn this.withAbort(opts?.signal, cancel);\n\t}\n\n\t/**\n\t * Register a callback to be called when a single mint quote gets paid.\n\t *\n\t * @param quoteId Mint quote id that should be subscribed to.\n\t * @param callback Callback function that will be called when this mint quote gets paid.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync mintQuotePaid(\n\t\tid: string,\n\t\tcb: (p: MintQuoteResponse) => void,\n\t\terr: (e: Error) => void,\n\t\topts?: SubscribeOpts,\n\t): Promise<SubscriptionCanceller> {\n\t\treturn this.mintQuoteUpdates(\n\t\t\t[id],\n\t\t\t(p) => {\n\t\t\t\tif (p.state === MintQuoteState.PAID) cb(p);\n\t\t\t},\n\t\t\terr,\n\t\t\topts,\n\t\t);\n\t}\n\n\t/**\n\t * Register a callback to be called whenever a melt quotes state changes.\n\t *\n\t * @param quoteId Melt quote id that should be subscribed to.\n\t * @param callback Callback function that will be called when this melt quote gets paid.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync meltQuoteUpdates(\n\t\tids: string[],\n\t\tcb: (p: MeltQuoteResponse) => void,\n\t\terr: (e: Error) => void,\n\t\topts?: SubscribeOpts,\n\t): Promise<SubscriptionCanceller> {\n\t\tawait this.wallet.mint.connectWebSocket();\n\t\tconst ws = this.wallet.mint.webSocketConnection;\n\t\tif (!ws) throw new Error('Failed to establish WebSocket connection.');\n\n\t\tconst uniq = Array.from(new Set(ids));\n\t\tconst subId = ws.createSubscription({ kind: 'bolt11_melt_quote', filters: uniq }, cb, err);\n\t\tconst cancel = () => ws.cancelSubscription(subId, cb);\n\t\treturn this.withAbort(opts?.signal, cancel);\n\t}\n\n\t/**\n\t * Register a callback to be called when a single melt quote gets paid.\n\t *\n\t * @param quoteIds List of melt quote IDs that should be subscribed to.\n\t * @param callback Callback function that will be called whenever a melt quote state changes.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync meltQuotePaid(\n\t\tid: string,\n\t\tcb: (p: MeltQuoteResponse) => void,\n\t\terr: (e: Error) => void,\n\t\topts?: SubscribeOpts,\n\t): Promise<SubscriptionCanceller> {\n\t\treturn this.meltQuoteUpdates(\n\t\t\t[id],\n\t\t\t(p) => {\n\t\t\t\tif (p.state === MeltQuoteState.PAID) cb(p);\n\t\t\t},\n\t\t\terr,\n\t\t\topts,\n\t\t);\n\t}\n\n\t/**\n\t * Register a callback to be called whenever a subscribed proof state changes.\n\t *\n\t * @param proofs List of proofs that should be subscribed to.\n\t * @param callback Callback function that will be called whenever a proof's state changes.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync proofStateUpdates(\n\t\tproofs: Proof[],\n\t\tcb: (payload: ProofState & { proof: Proof }) => void,\n\t\terr: (e: Error) => void,\n\t\topts?: SubscribeOpts,\n\t): Promise<SubscriptionCanceller> {\n\t\tawait this.wallet.mint.connectWebSocket();\n\t\tconst ws = this.wallet.mint.webSocketConnection;\n\t\tif (!ws) throw new Error('Failed to establish WebSocket connection.');\n\n\t\tconst enc = new TextEncoder();\n\t\tconst proofMap: Record<string, Proof> = {};\n\t\tfor (const p of proofs) {\n\t\t\tconst y = hashToCurve(enc.encode(p.secret)).toHex(true);\n\t\t\tproofMap[y] = p;\n\t\t}\n\t\tconst ys = Object.keys(proofMap);\n\n\t\tconst handler = (payload: ProofState) => {\n\t\t\tcb({ ...payload, proof: proofMap[payload.Y] });\n\t\t};\n\t\tconst subId = ws.createSubscription({ kind: 'proof_state', filters: ys }, handler, err);\n\t\tconst cancel = () => ws.cancelSubscription(subId, handler);\n\n\t\treturn this.withAbort(opts?.signal, cancel);\n\t}\n\n\t/**\n\t * Resolve once a mint quote transitions to PAID, with automatic unsubscription, optional abort\n\t * signal, and optional timeout.\n\t *\n\t * The underlying subscription is always cancelled after resolution or rejection, including on\n\t * timeout or abort.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const ac = new AbortController();\n\t * // Cancel if the user navigates away\n\t * window.addEventListener('beforeunload', () => ac.abort(), { once: true });\n\t *\n\t * try {\n\t * \tconst paid = await wallet.on.onceMintPaid(quoteId, {\n\t * \t\tsignal: ac.signal,\n\t * \t\ttimeoutMs: 60_000,\n\t * \t});\n\t * \tconsole.log('Mint paid, amount', paid.amount);\n\t * } catch (e) {\n\t * \tif ((e as Error).name === 'AbortError') {\n\t * \t\tconsole.log('User aborted');\n\t * \t} else {\n\t * \t\tconsole.error('Mint not paid', e);\n\t * \t}\n\t * }\n\t * ```\n\t *\n\t * @param id Mint quote id to watch.\n\t * @param opts Optional controls.\n\t * @param opts.signal AbortSignal to cancel the wait early.\n\t * @param opts.timeoutMs Milliseconds to wait before rejecting with a timeout error.\n\t * @returns A promise that resolves with the latest `MintQuoteResponse` once PAID.\n\t */\n\tonceMintPaid(\n\t\tid: string,\n\t\topts?: { signal?: AbortSignal; timeoutMs?: number },\n\t): Promise<MintQuoteResponse> {\n\t\treturn this.waitUntilPaid<MintQuoteResponse>(\n\t\t\tthis.mintQuotePaid.bind(this),\n\t\t\tid,\n\t\t\topts,\n\t\t\t'Timeout waiting for mint paid',\n\t\t);\n\t}\n\n\t/**\n\t * Resolve when ANY of several mint quotes is PAID, cancelling the rest.\n\t *\n\t * Subscribes to all distinct ids, resolves with `{ id, quote }` for the first PAID, and cancels\n\t * all remaining subscriptions.\n\t *\n\t * Errors from individual subscriptions are ignored by default so a single noisy stream does not\n\t * abort the whole race. Set `failOnError: true` to reject on the first error instead. If all\n\t * subscriptions error and none paid, the promise rejects with the last seen error.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Race multiple quotes obtained from splitting a large top up\n\t * const { id, quote } = await wallet.on.onceAnyMintPaid(batchQuoteIds, {\n\t * \ttimeoutMs: 120_000,\n\t * });\n\t * console.log('First top up paid', id, quote.preimage?.length);\n\t * ```\n\t *\n\t * @param ids Array of mint quote ids (duplicates are ignored).\n\t * @param opts Optional controls.\n\t * @param opts.signal AbortSignal to cancel the wait early.\n\t * @param opts.timeoutMs Milliseconds to wait before rejecting with a timeout error.\n\t * @param opts.failOnError When true, reject on first error. Default false.\n\t * @returns A promise resolving to the id that won and its `MintQuoteResponse`.\n\t */\n\tonceAnyMintPaid(\n\t\tids: string[],\n\t\topts?: { signal?: AbortSignal; timeoutMs?: number; failOnError?: boolean },\n\t): Promise<{ id: string; quote: MintQuoteResponse }> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst unique = Array.from(new Set(ids));\n\t\t\tconst cancels: Map<string, CancellerLike> = new Map();\n\t\t\tlet to: ReturnType<typeof setTimeout> | null = null;\n\t\t\tlet lastError: unknown = null;\n\t\t\tlet fullyRegistered = false;\n\n\t\t\tconst cleanup = (err?: unknown) => {\n\t\t\t\tfor (const c of cancels.values()) cancelSafely(c);\n\t\t\t\tcancels.clear();\n\t\t\t\tif (to) {\n\t\t\t\t\tclearTimeout(to);\n\t\t\t\t\tto = null;\n\t\t\t\t}\n\t\t\t\tif (opts?.signal) opts.signal.removeEventListener('abort', onAbort);\n\t\t\t\tif (err) reject(normalizeError(err));\n\t\t\t};\n\n\t\t\tconst onAbort = () => cleanup(makeAbortError());\n\n\t\t\tif (opts?.signal) {\n\t\t\t\tif (opts.signal.aborted) return onAbort();\n\t\t\t\topts.signal.addEventListener('abort', onAbort, { once: true });\n\t\t\t}\n\t\t\tif (opts?.timeoutMs && opts.timeoutMs > 0) {\n\t\t\t\tto = setTimeout(\n\t\t\t\t\t() => cleanup(new Error('Timeout waiting for any mint paid')),\n\t\t\t\t\topts.timeoutMs,\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (unique.length === 0) return cleanup(new Error('No quote ids provided'));\n\n\t\t\tfor (const quoteId of unique) {\n\t\t\t\tconst c = this.mintQuotePaid(\n\t\t\t\t\tquoteId,\n\t\t\t\t\t(p) => {\n\t\t\t\t\t\tcleanup();\n\t\t\t\t\t\tresolve({ id: quoteId, quote: p });\n\t\t\t\t\t},\n\t\t\t\t\t(e) => {\n\t\t\t\t\t\tif (opts?.failOnError) {\n\t\t\t\t\t\t\tcleanup(e);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastError = e;\n\t\t\t\t\t\tconst thisCanceller = cancels.get(quoteId);\n\t\t\t\t\t\tif (thisCanceller) {\n\t\t\t\t\t\t\tcancelSafely(thisCanceller);\n\t\t\t\t\t\t\tcancels.delete(quoteId);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Only decide to fail once we've finished installing all subs\n\t\t\t\t\t\tif (fullyRegistered && cancels.size === 0) {\n\t\t\t\t\t\t\tcleanup(lastError ?? new Error('No subscriptions remaining'));\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t\tcancels.set(quoteId, c);\n\t\t\t}\n\t\t\tfullyRegistered = true;\n\t\t});\n\t}\n\n\t/**\n\t * Resolve once a melt quote transitions to PAID, with automatic unsubscription, optional abort\n\t * signal, and optional timeout.\n\t *\n\t * Mirrors onceMintPaid, but for melts.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * try {\n\t * \tconst paid = await wallet.on.onceMeltPaid(meltId, { timeoutMs: 45_000 });\n\t * \tconsole.log('Invoice paid by mint, paid msat', paid.paid ?? 0);\n\t * } catch (e) {\n\t * \tconsole.error('Payment did not complete in time', e);\n\t * }\n\t * ```\n\t *\n\t * @param id Melt quote id to watch.\n\t * @param opts Optional controls.\n\t * @param opts.signal AbortSignal to cancel the wait early.\n\t * @param opts.timeoutMs Milliseconds to wait before rejecting with a timeout error.\n\t * @returns A promise that resolves with the `MeltQuoteResponse` once PAID.\n\t */\n\tonceMeltPaid(\n\t\tid: string,\n\t\topts?: { signal?: AbortSignal; timeoutMs?: number },\n\t): Promise<MeltQuoteResponse> {\n\t\treturn this.waitUntilPaid<MeltQuoteResponse>(\n\t\t\tthis.meltQuotePaid.bind(this),\n\t\t\tid,\n\t\t\topts,\n\t\t\t'Timeout waiting for melt paid',\n\t\t);\n\t}\n\n\t/**\n\t * Async iterable that yields proof state updates for the provided proofs.\n\t *\n\t * Adds a bounded buffer option:\n\t *\n\t * - If `maxBuffer` is set and the queue is full when a new payload arrives, either drop the oldest\n\t *   queued payload (`drop: 'oldest'`, default) or the incoming payload (`drop: 'newest'`). In\n\t *   both cases `onDrop` is invoked with the dropped payload.\n\t *\n\t * The stream ends and cleans up on abort or on the wallet error callback. Errors from the wallet\n\t * are treated as a graceful end for this iterator.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const ac = new AbortController();\n\t * try {\n\t * \tfor await (const update of wallet.on.proofStatesStream(myProofs)) {\n\t * \t\tif (update.state === CheckStateEnum.SPENT) {\n\t * \t\t\tconsole.warn('Spent proof', update.proof.id);\n\t * \t\t}\n\t * \t}\n\t * } catch (e) {\n\t * \tif ((e as Error).name !== 'AbortError') {\n\t * \t\tconsole.error('Stream error', e);\n\t * \t}\n\t * }\n\t * ```\n\t *\n\t * @param proofs The proofs to subscribe to. Only `secret` is required.\n\t * @param opts Optional controls.\n\t * @param opts.signal AbortSignal that stops the stream when aborted.\n\t * @param opts.maxBuffer Maximum number of queued items before applying the drop strategy.\n\t * @param opts.drop Overflow strategy when `maxBuffer` is reached, 'oldest' | 'newest'. Default\n\t *   'oldest'.\n\t * @param opts.onDrop Callback invoked with the payload that was dropped.\n\t * @returns An async iterable of update payloads.\n\t */\n\tproofStatesStream<T = unknown>(\n\t\tproofs: Proof[],\n\t\topts?: {\n\t\t\tsignal?: AbortSignal;\n\t\t\tmaxBuffer?: number;\n\t\t\tdrop?: 'oldest' | 'newest';\n\t\t\tonDrop?: (payload: T) => void;\n\t\t},\n\t): AsyncIterable<T> {\n\t\treturn async function* (this: WalletEvents) {\n\t\t\tconst queue: T[] = [];\n\t\t\tlet done = false;\n\t\t\tlet notify: (() => void) | null = null;\n\n\t\t\tconst max = opts?.maxBuffer && opts.maxBuffer > 0 ? opts.maxBuffer : Infinity;\n\t\t\tconst dropMode: 'oldest' | 'newest' = opts?.drop ?? 'oldest';\n\n\t\t\tconst wake = () => {\n\t\t\t\tconst n = notify;\n\t\t\t\tnotify = null;\n\t\t\t\tif (n) n();\n\t\t\t};\n\n\t\t\tconst push = (payload: T) => {\n\t\t\t\tif (queue.length >= max) {\n\t\t\t\t\tif (dropMode === 'oldest') {\n\t\t\t\t\t\tconst dropped = queue.shift();\n\t\t\t\t\t\tif (dropped !== undefined) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\topts?.onDrop?.(dropped);\n\t\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t\t/* noop */\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqueue.push(payload);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\topts?.onDrop?.(payload);\n\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t/* noop */\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn; // drop newest\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push(payload);\n\t\t\t\t}\n\t\t\t\twake();\n\t\t\t};\n\n\t\t\tconst cancelP: Promise<SubscriptionCanceller> = this.proofStateUpdates(\n\t\t\t\tproofs,\n\t\t\t\t(payload: ProofState & { proof: Proof }) => {\n\t\t\t\t\t// Accept wallet payload type and expose as generic T to consumer\n\t\t\t\t\tpush(payload as unknown as T);\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\tdone = true;\n\t\t\t\t\twake();\n\t\t\t\t},\n\t\t\t\t{ signal: opts?.signal },\n\t\t\t);\n\n\t\t\tconst onAbort = () => {\n\t\t\t\tdone = true;\n\t\t\t\twake();\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\tif (opts?.signal) {\n\t\t\t\t\tif (opts.signal.aborted) onAbort();\n\t\t\t\t\telse opts.signal.addEventListener('abort', onAbort, { once: true });\n\t\t\t\t}\n\t\t\t\twhile (!done || queue.length) {\n\t\t\t\t\twhile (queue.length) yield queue.shift()!;\n\t\t\t\t\tif (done) break;\n\t\t\t\t\tawait new Promise<void>((resolve) => (notify = resolve));\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tcancelSafely(cancelP);\n\t\t\t\tif (opts?.signal) opts.signal.removeEventListener('abort', onAbort);\n\t\t\t}\n\t\t}.call(this);\n\t}\n\n\t/**\n\t * Create a composite canceller that can collect many subscriptions and dispose them all in one\n\t * call.\n\t *\n\t * Accepts both a `SubscriptionCanceller` and a `Promise<SubscriptionCanceller>`. When the\n\t * composite canceller is called, all collected cancellations are invoked. Errors from individual\n\t * cancellers are caught and ignored.\n\t *\n\t * The returned function also has an `.add()` method to register more cancellers, and a\n\t * `.cancelled` boolean property for debugging.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const cancelAll = wallet.on.group();\n\t * cancelAll.add(wallet.on.mintQuotes(ids, onUpdate, onErr));\n\t * cancelAll.add(asyncSubscribeElsewhere());\n\t *\n\t * // later\n\t * cancelAll(); // disposes everything\n\t * ```\n\t *\n\t * @returns Composite canceller function with `.add()` and `.cancelled` members.\n\t */\n\tgroup(): SubscriptionCanceller & {\n\t\tadd: (c: CancellerLike) => CancellerLike;\n\t\tcancelled: boolean;\n\t} {\n\t\tconst cancels: CancellerLike[] = [];\n\t\tlet cancelled = false;\n\n\t\tconst cancelAll = (() => {\n\t\t\tif (cancelled) return;\n\t\t\tcancelled = true;\n\t\t\twhile (cancels.length) cancelSafely(cancels.pop());\n\t\t}) as SubscriptionCanceller & {\n\t\t\tadd: (c: CancellerLike) => CancellerLike;\n\t\t\tcancelled: boolean;\n\t\t};\n\n\t\tcancelAll.add = (c: CancellerLike) => {\n\t\t\tif (cancelled) {\n\t\t\t\t// already cancelled, immediately dispose newly added subscription\n\t\t\t\tcancelSafely(c);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t\tcancels.push(c);\n\t\t\treturn c;\n\t\t};\n\n\t\tObject.defineProperty(cancelAll, 'cancelled', {\n\t\t\tget: () => cancelled,\n\t\t\tenumerable: true,\n\t\t});\n\n\t\treturn cancelAll;\n\t}\n}\n", "import type { CounterSource } from './CounterSource';\n\n/**\n * Developer friendly view of the wallet's deterministic output counters.\n */\nexport class WalletCounters {\n\tconstructor(private readonly src: CounterSource) {}\n\t/**\n\t * Returns the \"next\" counter for a specified keyset.\n\t */\n\tasync peekNext(keysetId: string): Promise<number> {\n\t\tconst r = await this.src.reserve(keysetId, 0);\n\t\treturn r.start;\n\t}\n\n\t/**\n\t * Bumps the counter if it is behind `minNext` (no-op if ahead).\n\t */\n\tasync advanceToAtLeast(keysetId: string, minNext: number): Promise<void> {\n\t\t// Mandatory on CounterSource\n\t\tawait this.src.advanceToAtLeast(keysetId, minNext);\n\t}\n\n\t/**\n\t * Hard-sets the cursor (useful for tests or migrations).\n\t *\n\t * @throws If the CounterSource does not support setNext()\n\t */\n\tasync setNext(keysetId: string, next: number): Promise<void> {\n\t\t// Optional capability\n\t\tif (typeof this.src.setNext === 'function') {\n\t\t\tawait this.src.setNext(keysetId, next);\n\t\t\treturn;\n\t\t}\n\t\tthrow new Error('CounterSource does not support setNext()');\n\t}\n\t/**\n\t * Returns the current \"next\" per keyset (what will be reserved next).\n\t *\n\t * @throws If the CounterSource does not support snapshot()\n\t */\n\tasync snapshot(): Promise<Record<string, number>> {\n\t\t// Optional capability\n\t\tif (typeof this.src.snapshot === 'function') {\n\t\t\treturn await this.src.snapshot();\n\t\t}\n\t\tthrow new Error('CounterSource does not support snapshot()');\n\t}\n}\n", "/**\n * Entries of CheckStateResponse with state of the proof.\n */\nexport type ProofState = {\n\tY: string;\n\tstate: CheckStateEnum;\n\twitness: string | null;\n};\n\n/**\n * Enum for the state of a proof.\n */\nexport const CheckStateEnum = {\n\tUNSPENT: 'UNSPENT',\n\tPENDING: 'PENDING',\n\tSPENT: 'SPENT',\n} as const;\nexport type CheckStateEnum = (typeof CheckStateEnum)[keyof typeof CheckStateEnum];\n", "/**\n * Cashu Wallet Class.\n *\n * @remarks\n * This is the instantiation point for the Cashu-TS library.\n */\n\nimport {\n\ttype MeltBlanks,\n\ttype OutputType,\n\ttype OutputConfig,\n\ttype SendConfig,\n\ttype SendOfflineConfig,\n\ttype ReceiveConfig,\n\ttype MintProofsConfig,\n\ttype MeltProofsConfig,\n\ttype MeltPayload,\n\ttype MeltQuotePayload,\n\ttype MintPayload,\n\ttype MintQuotePayload,\n\ttype MPPOption,\n\ttype MeltQuoteOptions,\n\ttype SwapTransaction,\n\ttype Bolt12MintQuotePayload,\n\ttype SwapPayload,\n\ttype MeltProofsResponse,\n\ttype SendResponse,\n\ttype RestoreConfig,\n\ttype SecretsPolicy,\n} from './types';\nimport {\n\ttype CounterSource,\n\tEphemeralCounterSource,\n\ttype OperationCounters,\n\ttype CounterRange,\n} from './CounterSource';\n\nimport { signMintQuote, signP2PKProofs, hashToCurve } from '../crypto';\nimport { Mint } from '../mint';\nimport { MintInfo } from '../model/MintInfo';\nimport { KeyChain } from './KeyChain';\nimport { type Keyset } from './Keyset';\nimport { WalletOps } from './WalletOps';\nimport { WalletEvents } from './WalletEvents';\nimport { WalletCounters } from './WalletCounters';\nimport { selectProofsRGLI, type SelectProofs } from './SelectProofs';\nimport { type Logger, NULL_LOGGER, fail, failIf, failIfNullish, safeCallback } from '../logger';\n\n// shared primitives and options\nimport type { Proof } from '../model/types/proof';\nimport type { Token } from '../model/types/token';\nimport type { SerializedBlindedSignature } from '../model/types/blinded';\nimport { CheckStateEnum, type ProofState } from '../model/types/proof-state';\nimport type { MintKeys, MintKeyset } from '../model/types/keyset';\n\n// mint wire DTOs and enums\nimport type {\n\tGetInfoResponse,\n\tMintQuoteResponse,\n\tMeltQuoteResponse,\n\tPartialMintQuoteResponse,\n\tPartialMeltQuoteResponse,\n\tLockedMintQuoteResponse,\n\tBolt12MintQuoteResponse,\n\tBolt12MeltQuoteResponse,\n} from '../mint/types';\n\n// model helpers\nimport { OutputData, type OutputDataLike } from '../model/OutputData';\n\nimport {\n\tgetDecodedToken,\n\tgetKeepAmounts,\n\thasValidDleq,\n\tsplitAmount,\n\tsumProofs,\n\tsanitizeUrl,\n} from '../utils';\nimport { type AuthProvider } from '../auth/AuthProvider';\n\nconst PENDING_KEYSET_ID = '__PENDING__';\n\n/**\n * Class that represents a Cashu wallet.\n *\n * @remarks\n * This class should act as the entry point for this library. Can be instantiated with a mint\n * instance or mint url.\n * @example\n *\n * ```typescript\n * import { Wallet } from '@cashu/cashu-ts';\n * const wallet = new Wallet('http://localhost:3338', { unit: 'sat' });\n * await wallet.loadMint(); // Initialize mint info, keysets, and keys\n * // Wallet is now ready to use, eg:\n * const proofs = [...]; // your array of unspent proofs\n * const { keep, send } = await wallet.send(32, proofs);\n * ```\n */\nclass Wallet {\n\t/**\n\t * Mint instance - allows direct calls to the mint.\n\t */\n\tpublic readonly mint: Mint;\n\t/**\n\t * KeyChain instance - contains wallet keysets/keys.\n\t */\n\tpublic readonly keyChain: KeyChain;\n\t/**\n\t * Entry point for the builder.\n\t *\n\t * @example\n\t *\n\t *     const { keep, send } = await wallet.ops\n\t *     \t.send(5, proofs)\n\t *     \t.asDeterministic() // counter: 0 = auto\n\t *     \t.keepAsRandom()\n\t *     \t.includeFees(true)\n\t *     \t.run();\n\t *\n\t *     const proofs = await wallet.ops\n\t *     \t.receive(token)\n\t *     \t.asDeterministic()\n\t *     \t.keyset(wallet.keysetId)\n\t *     \t.run();\n\t */\n\tpublic readonly ops: WalletOps;\n\t/**\n\t * Convenience wrapper for events.\n\t */\n\tpublic readonly on: WalletEvents;\n\t/**\n\t * Developer-friendly counters API.\n\t */\n\tpublic readonly counters: WalletCounters;\n\tprivate _seed: Uint8Array | undefined = undefined;\n\tprivate _unit = 'sat';\n\tprivate _mintInfo: MintInfo | undefined = undefined;\n\tprivate _denominationTarget = 3;\n\tprivate _secretsPolicy: SecretsPolicy = 'auto';\n\tprivate _counterSource: CounterSource;\n\tprivate _boundKeysetId: string = PENDING_KEYSET_ID;\n\tprivate _selectProofs: SelectProofs;\n\tprivate _logger: Logger;\n\n\t/**\n\t * Create a wallet for a given mint and unit. Call `loadMint` before use.\n\t *\n\t * Binding, if `options.keysetId` is omitted, the wallet binds to the cheapest active keyset for\n\t * this unit during `loadMint`. The keychain only loads keysets for this unit.\n\t *\n\t * Caching, to preload, provide both `keysets` and `keys`, otherwise the cache is ignored.\n\t *\n\t * Deterministic secrets, pass `bip39seed` and optionally `secretsPolicy`. Deterministic outputs\n\t * reserve counters from `counterSource`, or an ephemeral in memory source if not supplied.\n\t * `initialCounter` applies only with a supplied `keysetId` and the ephemeral source.\n\t *\n\t * Splitting, `denominationTarget` guides proof splits, default is 3. Override coin selection with\n\t * `selectProofs` if needed. Logging defaults to a null logger.\n\t *\n\t * @param mint Mint instance or URL.\n\t * @param options Optional settings.\n\t * @param options.unit Wallet unit, default 'sat'.\n\t * @param options.keysetId Bind to this keyset id, else bind on `loadMint`.\n\t * @param options.bip39seed BIP39 seed for deterministic secrets.\n\t * @param options.secretsPolicy Secrets policy, default 'auto'.\n\t * @param options.counterSource Counter source for deterministic outputs. If provided, this takes\n\t *   precedence over counterInit. Use when you need persistence across processes or devices.\n\t * @param options.counterInit Seed values for the built-in EphemeralCounterSource. Ignored if\n\t *   counterSource is also provided.\n\t * @param options.keys Cached keys for this unit, only used when `keysets` is also provided.\n\t * @param options.keysets Cached keysets for this unit, only used when `keys` is also provided.\n\t * @param options.mintInfo Optional cached mint info.\n\t * @param options.denominationTarget Target proofs per denomination, default 3.\n\t * @param options.selectProofs Custom proof selection function.\n\t * @param options.logger Logger instance, default null logger.\n\t */\n\tconstructor(\n\t\tmint: Mint | string,\n\t\toptions?: {\n\t\t\tunit?: string;\n\t\t\tauthProvider?: AuthProvider;\n\t\t\tkeysetId?: string; // if omitted, wallet binds to cheapest in loadMint\n\t\t\tbip39seed?: Uint8Array;\n\t\t\tsecretsPolicy?: SecretsPolicy; // optional, auto\n\t\t\tcounterSource?: CounterSource; // optional, otherwise ephemeral\n\t\t\tcounterInit?: Record<string, number>; // optional, starting \"next\" per keyset\n\t\t\tkeys?: MintKeys[] | MintKeys;\n\t\t\tkeysets?: MintKeyset[];\n\t\t\tmintInfo?: GetInfoResponse;\n\t\t\tdenominationTarget?: number;\n\t\t\tselectProofs?: SelectProofs; // optional override\n\t\t\tlogger?: Logger;\n\t\t},\n\t) {\n\t\tthis.ops = new WalletOps(this);\n\t\tthis.on = new WalletEvents(this);\n\t\tthis._logger = options?.logger ?? NULL_LOGGER; // init early (seed can throw)\n\t\tthis._selectProofs = options?.selectProofs ?? selectProofsRGLI; // vital\n\t\tthis.mint =\n\t\t\ttypeof mint === 'string'\n\t\t\t\t? new Mint(mint, { authProvider: options?.authProvider, logger: this._logger })\n\t\t\t\t: mint;\n\t\tthis._unit = options?.unit ?? this._unit;\n\t\tthis._boundKeysetId = options?.keysetId ?? this._boundKeysetId;\n\t\tif (options?.bip39seed) {\n\t\t\tthis.failIf(\n\t\t\t\t!(options.bip39seed instanceof Uint8Array),\n\t\t\t\t'bip39seed must be a valid Uint8Array',\n\t\t\t\t{\n\t\t\t\t\tbip39seed: options.bip39seed,\n\t\t\t\t},\n\t\t\t);\n\t\t\tthis._seed = options.bip39seed;\n\t\t}\n\t\tthis._secretsPolicy = options?.secretsPolicy ?? this._secretsPolicy;\n\t\tif (options?.counterSource) {\n\t\t\tthis._counterSource = options.counterSource;\n\t\t} else {\n\t\t\tthis._counterSource = new EphemeralCounterSource(options?.counterInit);\n\t\t}\n\t\tthis.counters = new WalletCounters(this._counterSource);\n\t\tthis.keyChain = new KeyChain(this.mint, this._unit, options?.keysets, options?.keys);\n\t\tthis._mintInfo = options?.mintInfo ? new MintInfo(options.mintInfo) : this._mintInfo;\n\t\tthis._denominationTarget = options?.denominationTarget ?? this._denominationTarget;\n\t}\n\n\t// Convenience wrappers for \"log and throw\"\n\tprivate fail(message: string, context?: Record<string, unknown>): never {\n\t\treturn fail(message, this._logger, context);\n\t}\n\tprivate failIf(\n\t\tcondition: boolean,\n\t\tmessage: string,\n\t\tcontext?: Record<string, unknown>,\n\t): asserts condition is false {\n\t\treturn failIf(condition, message, this._logger, context);\n\t}\n\tprivate failIfNullish<T>(\n\t\tvalue: T,\n\t\tmessage: string,\n\t\tcontext?: Record<string, unknown>,\n\t): asserts value is Exclude<T, null | undefined> {\n\t\treturn failIfNullish(value, message, this._logger, context);\n\t}\n\tprivate safeCallback<T>(\n\t\tcb: ((p: T) => void) | undefined,\n\t\tpayload: T,\n\t\tcontext?: Record<string, unknown>,\n\t): void {\n\t\tsafeCallback(cb, payload, this._logger, context);\n\t}\n\n\t/**\n\t * Load mint information, keysets, and keys. Must be called before using other methods.\n\t *\n\t * @param forceRefresh If true, re-fetches data even if cached.\n\t * @throws If fetching mint info, keysets, or keys fails.\n\t */\n\tasync loadMint(forceRefresh?: boolean): Promise<void> {\n\t\tconst promises = [];\n\n\t\t// Load mint info\n\t\tif (!this._mintInfo || forceRefresh) {\n\t\t\tpromises.push(\n\t\t\t\tthis.mint.getInfo().then((info) => {\n\t\t\t\t\tthis._mintInfo = new MintInfo(info);\n\t\t\t\t\treturn null;\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\t// Load KeyChain\n\t\tpromises.push(this.keyChain.init(forceRefresh).then(() => null));\n\n\t\tawait Promise.all(promises);\n\t\tthis._logger.debug('KeyChain', { keychain: this.keyChain.getCache() });\n\n\t\tif (this._boundKeysetId === PENDING_KEYSET_ID) {\n\t\t\tthis._boundKeysetId = this.keyChain.getCheapestKeyset().id;\n\t\t} else {\n\t\t\t// Ensure the bound id is still present and keyed\n\t\t\tconst k = this.keyChain.getKeyset(this._boundKeysetId);\n\t\t\tthis.failIf(!k.hasKeys, 'Wallet keyset has no keys after refresh', { keyset: k.id });\n\t\t}\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Getters\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * Get the wallet's unit.\n\t *\n\t * @returns The unit (e.g., 'sat').\n\t */\n\tget unit(): string {\n\t\treturn this._unit;\n\t}\n\n\t/**\n\t * Get information about the mint.\n\t *\n\t * @remarks\n\t * Returns cached mint info. Call `loadMint` first to initialize the wallet.\n\t * @returns Mint info.\n\t * @throws If mint info is not initialized.\n\t */\n\tgetMintInfo(): MintInfo {\n\t\tthis.failIfNullish(this._mintInfo, 'Mint info not initialized; call loadMint first');\n\t\treturn this._mintInfo;\n\t}\n\n\t/**\n\t * The keyset ID bound to this wallet instance.\n\t */\n\tget keysetId(): string {\n\t\tthis.failIf(this._boundKeysetId === PENDING_KEYSET_ID, 'Wallet not initialised, call loadMint');\n\t\treturn this._boundKeysetId;\n\t}\n\n\t/**\n\t * Gets the requested keyset or the keyset bound to the wallet.\n\t *\n\t * @remarks\n\t * This method enforces wallet policies. If `id` is omitted, it returns the keyset bound to this\n\t * wallet, including validation that:\n\t *\n\t * - The keyset exists in the keychain,\n\t * - The unit matches the wallet's unit,\n\t * - Keys are loaded for that keyset.\n\t *\n\t * Contrast with `keyChain.getKeyset(id?)`, which, when called without an id, returns the cheapest\n\t * active keyset for the unit, ignoring the wallet binding.\n\t * @param id Optional keyset id to resolve. If omitted, the wallet's bound keyset is used.\n\t * @returns The resolved `Keyset`.\n\t * @throws If the keyset is not found, has no keys, or its unit differs from the wallet.\n\t */\n\tpublic getKeyset(id?: string): Keyset {\n\t\tconst keyset = this.keyChain.getKeyset(id ?? this.keysetId);\n\t\tthis.failIf(keyset.unit !== this._unit, 'Keyset unit does not match wallet unit', {\n\t\t\tkeyset: keyset.id,\n\t\t\tunit: keyset.unit,\n\t\t\twalletUnit: this._unit,\n\t\t});\n\t\tthis.failIf(!keyset.hasKeys, 'Keyset has no keys loaded', { keyset: keyset.id });\n\t\treturn keyset;\n\t}\n\n\tpublic get logger(): Logger {\n\t\treturn this._logger;\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Counters\n\t// -----------------------------------------------------------------\n\n\tprivate async reserveFor(keysetId: string, totalOutputs: number): Promise<CounterRange> {\n\t\tif (totalOutputs <= 0) return { start: 0, count: 0 };\n\t\treturn this._counterSource.reserve(keysetId, totalOutputs);\n\t}\n\n\tprivate countersNeeded(ot: OutputType): number {\n\t\tif (ot.type !== 'deterministic' || ot.counter !== 0) return 0;\n\t\treturn (ot.denominations ?? []).length;\n\t}\n\n\tprivate async addCountersToOutputTypes(\n\t\tkeysetId: string,\n\t\t...outputTypes: OutputType[]\n\t): Promise<{ outputTypes: OutputType[]; used?: OperationCounters }> {\n\t\tconst total = outputTypes.reduce((n, ot) => n + this.countersNeeded(ot), 0);\n\t\tif (total === 0) return { outputTypes };\n\n\t\tconst range = await this.reserveFor(keysetId, total);\n\t\tlet cursor = range.start;\n\n\t\tconst patched = outputTypes.map((ot): OutputType => {\n\t\t\tif (ot.type === 'deterministic' && ot.counter === 0) {\n\t\t\t\tconst need = (ot.denominations ?? []).length;\n\t\t\t\tif (need > 0) {\n\t\t\t\t\tconst patched: typeof ot = { ...ot, counter: cursor };\n\t\t\t\t\tcursor += need;\n\t\t\t\t\treturn patched;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ot;\n\t\t});\n\n\t\t// Fire event after successful reservation (wallet does not await handlers)\n\t\tconst used = {\n\t\t\tkeysetId,\n\t\t\tstart: range.start,\n\t\t\tcount: range.count,\n\t\t\tnext: range.start + range.count,\n\t\t} as OperationCounters;\n\t\tthis.on._emitCountersReserved(used);\n\t\treturn { outputTypes: patched, used };\n\t}\n\n\t/**\n\t * Bind this wallet to a specific keyset id.\n\t *\n\t * @remarks\n\t * This changes the default keyset used by all operations that do not explicitly pass a keysetId.\n\t * The method validates that the keyset exists in the keychain, matches the wallet unit, and has\n\t * keys loaded.\n\t *\n\t * Typical uses:\n\t *\n\t * 1. After loadMint, to pin the wallet to a particular active keyset.\n\t * 2. After a refresh, to rebind deliberately rather than falling back to cheapest.\n\t *\n\t * @param id The keyset identifier to bind to.\n\t * @throws If keyset not found, if it has no keys loaded, or if its unit is not the wallet unit.\n\t */\n\tpublic bindKeyset(id: string): void {\n\t\tconst ks = this.keyChain.getKeyset(id);\n\t\tthis.failIf(ks.unit !== this._unit, 'Keyset unit does not match wallet unit', {\n\t\t\tkeyset: ks.id,\n\t\t\tunit: ks.unit,\n\t\t\twalletUnit: this._unit,\n\t\t});\n\t\tthis.failIf(!ks.hasKeys, 'Keyset has no keys loaded', { keyset: ks.id });\n\t\tthis._boundKeysetId = ks.id;\n\t\tthis._logger.debug('Wallet bound to keyset', {\n\t\t\tkeysetId: ks.id,\n\t\t\tunit: ks.unit,\n\t\t\tfeePPK: ks.fee,\n\t\t});\n\t}\n\n\t/**\n\t * Creates a new Wallet bound to a different keyset, sharing the same CounterSource.\n\t *\n\t * Use this to operate on multiple keysets concurrently without mutating your original wallet.\n\t * Counters remain monotonic across instances because the same CounterSource is reused.\n\t *\n\t * Do NOT pass a fresh CounterSource for the same seed unless you know exactly why. Reusing\n\t * counters can recreate secrets that a mint will reject.\n\t *\n\t * @param id The keyset identifier to bind to.\n\t * @throws If keyset not found, if it has no keys loaded, or if its unit is not the wallet unit.\n\t */\n\tpublic withKeyset(id: string, opts?: { counterSource?: CounterSource }): Wallet {\n\t\treturn new Wallet(this.mint, {\n\t\t\tkeysetId: id,\n\t\t\tbip39seed: this._seed,\n\t\t\tsecretsPolicy: this._secretsPolicy,\n\t\t\tlogger: this._logger,\n\t\t\tcounterSource: opts?.counterSource ?? this._counterSource,\n\t\t\t...this.keyChain.getCache(),\n\t\t});\n\t}\n\n\t/**\n\t * Returns the default OutputType for this wallet, based on its configured secrets policy\n\t * (options?.secretsPolicy) and seed state.\n\t *\n\t * - If the secrets policy is 'random', returns { type: 'random' }.\n\t * - If the policy is 'deterministic', requires a seed and returns { type: 'deterministic', counter:\n\t *   0 }. Counter 0 is a flag meaning \"auto-increment from current state\".\n\t * - If no explicit policy is set, falls back to:\n\t *\n\t *   - Deterministic if a seed is present.\n\t *   - Random if no seed is present.\n\t *\n\t * @returns An OutputType object describing the default output strategy.\n\t * @throws Error if the policy is 'deterministic' but no seed has been set.\n\t */\n\tpublic defaultOutputType(): OutputType {\n\t\tif (this._secretsPolicy === 'random') return { type: 'random' };\n\t\tif (this._secretsPolicy === 'deterministic') {\n\t\t\tthis.failIfNullish(this._seed, 'Deterministic policy requires a seed');\n\t\t\treturn { type: 'deterministic', counter: 0 }; // 0 = auto flag\n\t\t}\n\t\treturn this._seed ? { type: 'deterministic', counter: 0 } : { type: 'random' };\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Output Creation\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * Configures output denominations with fee adjustments and optimization.\n\t *\n\t * @remarks\n\t * If 'custom' outputType, data outputs MUST sum to the amount. Other outputTypes may supply\n\t * denominations. If no denominations are passed in, they will be calculated based on proofsWeHave\n\t * or the default split. If partial denominations are passed in, the balance will be added using\n\t * default split. Additional denominations to cover fees will then be added if required.\n\t * @param amount The total amount for outputs.\n\t * @param keyset The mint keyset.\n\t * @param outputType The output configuration.\n\t * @param includeFees Whether to include swap fees in the output amount.\n\t * @param proofsWeHave Optional proofs for optimizing denomination splitting.\n\t * @returns OutputType with required denominations.\n\t */\n\tprivate configureOutputs(\n\t\tamount: number,\n\t\tkeyset: Keyset,\n\t\toutputType: OutputType,\n\t\tincludeFees: boolean = false,\n\t\tproofsWeHave: Proof[] = [],\n\t): OutputType {\n\t\tlet newAmount = amount;\n\n\t\t// Custom outputs don't have automatic optimizations or fee inclusion)\n\t\tif (outputType.type === 'custom') {\n\t\t\tthis.failIf(includeFees, 'The custom OutputType does not support automatic fee inclusion');\n\n\t\t\t// Validate sum early, as no denominations to fill\n\t\t\tconst customTotal = OutputData.sumOutputAmounts(outputType.data);\n\t\t\tthis.failIf(\n\t\t\t\tcustomTotal !== amount,\n\t\t\t\t`Custom output data total (${customTotal}) does not match amount (${amount})`,\n\t\t\t);\n\t\t\treturn outputType;\n\t\t}\n\n\t\t// Start with any denominations provided.\n\t\t// Note: These MAY be partial (\"give me a [16,8], anything for the rest\")\n\t\t// We will complete the denomination set before we are done.\n\t\tlet denominations = outputType.denominations ?? [];\n\n\t\t// If no denominations, but proofsWeHave was provided - optimize\n\t\t// to get around _denominationTarget proofs of each denomination.\n\t\tif (denominations.length === 0 && proofsWeHave.length > 0) {\n\t\t\tdenominations = getKeepAmounts(\n\t\t\t\tproofsWeHave,\n\t\t\t\tnewAmount,\n\t\t\t\tkeyset.keys,\n\t\t\t\tthis._denominationTarget,\n\t\t\t);\n\t\t}\n\n\t\t// Fill in any missing denominations with default split.\n\t\t// NOTE: If we have to fill, the result will be in ASC order.\n\t\t// Original order is only maintained for exact denomination sets.\n\t\tdenominations = splitAmount(newAmount, keyset.keys, denominations);\n\n\t\t// If includeFees, we create additional output amounts to cover the\n\t\t// fee the receiver will pay when they spend the proofs (ie sender pays fees)\n\t\tif (includeFees) {\n\t\t\tlet receiveFee = this.getFeesForKeyset(denominations.length, keyset.id);\n\t\t\tlet receiveFeeAmounts = splitAmount(receiveFee, keyset.keys);\n\t\t\twhile (\n\t\t\t\tthis.getFeesForKeyset(denominations.length + receiveFeeAmounts.length, keyset.id) >\n\t\t\t\treceiveFee\n\t\t\t) {\n\t\t\t\treceiveFee++;\n\t\t\t\treceiveFeeAmounts = splitAmount(receiveFee, keyset.keys);\n\t\t\t}\n\t\t\tnewAmount += receiveFee;\n\t\t\tdenominations = [...denominations, ...receiveFeeAmounts];\n\t\t}\n\t\treturn { ...outputType, denominations };\n\t}\n\n\t/**\n\t * Sum total implied by a prepared OutputType. Note: Empty denomination is valid (e.g: zero\n\t * change).\n\t */\n\tprivate preparedTotal(ot: OutputType): number {\n\t\tif (ot.type === 'custom') return OutputData.sumOutputAmounts(ot.data);\n\t\tconst denoms = ot.denominations ?? [];\n\t\treturn denoms.reduce((a, b) => a + b, 0);\n\t}\n\n\t/**\n\t * Generates blinded messages based on the specified output type.\n\t *\n\t * @param amount The total amount for outputs.\n\t * @param keyset The mint keys.\n\t * @param outputType The output configuration.\n\t * @returns Prepared output data.\n\t */\n\tprivate createOutputData(\n\t\tamount: number,\n\t\tkeyset: Keyset,\n\t\toutputType: OutputType,\n\t): OutputDataLike[] {\n\t\t// we can accept zero (for blanks) or positive values\n\t\tthis.failIf(amount < 0, 'Amount was negative', { amount });\n\t\tif (\n\t\t\t// 'custom' OutputType has no denominations. Every other OutputType does.\n\t\t\t// so let's sanity check those were filled properly (eg: configureOutputs)\n\t\t\t'custom' != outputType.type &&\n\t\t\toutputType.denominations &&\n\t\t\toutputType.denominations.length > 0\n\t\t) {\n\t\t\tconst splitSum = outputType.denominations.reduce((sum, a) => sum + a, 0);\n\t\t\tthis.failIf(splitSum !== amount, 'Denominations do not sum to the expected amount', {\n\t\t\t\tsplitSum,\n\t\t\t\texpected: amount,\n\t\t\t});\n\t\t}\n\t\tlet outputData: OutputDataLike[];\n\t\tswitch (outputType.type) {\n\t\t\tcase 'random':\n\t\t\t\toutputData = OutputData.createRandomData(amount, keyset, outputType.denominations);\n\t\t\t\tbreak;\n\t\t\tcase 'deterministic':\n\t\t\t\tthis.failIfNullish(\n\t\t\t\t\tthis._seed,\n\t\t\t\t\t'Deterministic outputs require a seed configured in the wallet',\n\t\t\t\t);\n\t\t\t\toutputData = OutputData.createDeterministicData(\n\t\t\t\t\tamount,\n\t\t\t\t\tthis._seed,\n\t\t\t\t\toutputType.counter,\n\t\t\t\t\tkeyset,\n\t\t\t\t\toutputType.denominations,\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'p2pk':\n\t\t\t\toutputData = OutputData.createP2PKData(\n\t\t\t\t\toutputType.options,\n\t\t\t\t\tamount,\n\t\t\t\t\tkeyset,\n\t\t\t\t\toutputType.denominations,\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'factory': {\n\t\t\t\tconst factorySplit = splitAmount(amount, keyset.keys, outputType.denominations);\n\t\t\t\toutputData = factorySplit.map((a) => outputType.factory(a, keyset));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'custom': {\n\t\t\t\toutputData = outputType.data;\n\t\t\t\tconst customTotal = OutputData.sumOutputAmounts(outputData);\n\t\t\t\tthis.failIf(\n\t\t\t\t\tcustomTotal !== amount,\n\t\t\t\t\t`Custom output data total (${customTotal}) does not match amount (${amount})`,\n\t\t\t\t);\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthis.fail('Invalid OutputType');\n\t\t\t}\n\t\t}\n\t\treturn outputData;\n\t}\n\n\t/**\n\t * Creates a swap transaction with sorted outputs for privacy. This prevents a mint working out\n\t * which proofs will be sent or kept.\n\t *\n\t * @param inputs Prepared input proofs.\n\t * @param keepOutputs Outputs to keep (change or receiver's proofs).\n\t * @param sendOutputs Outputs to send (optional, default empty for receive/mint).\n\t * @returns Swap transaction with payload and metadata for processing signatures.\n\t */\n\tprivate createSwapTransaction(\n\t\tinputs: Proof[],\n\t\tkeepOutputs: OutputDataLike[],\n\t\tsendOutputs: OutputDataLike[] = [],\n\t): SwapTransaction {\n\t\t// Prepare inputs for mint\n\t\tinputs = this._prepareInputsForMint(inputs);\n\n\t\t// Sort ASC by amount for privacy, but keep indices to return order afterwards\n\t\tconst mergedBlindingData = [...keepOutputs, ...sendOutputs];\n\t\tconst indices = mergedBlindingData\n\t\t\t.map((_, i) => i)\n\t\t\t.sort(\n\t\t\t\t(a, b) =>\n\t\t\t\t\tmergedBlindingData[a].blindedMessage.amount - mergedBlindingData[b].blindedMessage.amount,\n\t\t\t);\n\t\tconst keepVector: boolean[] = [\n\t\t\t...Array.from({ length: keepOutputs.length }, () => true),\n\t\t\t...Array.from({ length: sendOutputs.length }, () => false),\n\t\t];\n\t\tconst sortedOutputData: OutputDataLike[] = indices.map((i) => mergedBlindingData[i]);\n\t\tconst sortedKeepVector: boolean[] = indices.map((i) => keepVector[i]);\n\t\tconst outputs = sortedOutputData.map((d) => d.blindedMessage);\n\t\tthis._logger.debug('createSwapTransaction:', {\n\t\t\tindices,\n\t\t\tsortedKeepVector,\n\t\t\t// outputs, // <-- removed for security\n\t\t});\n\t\tconst payload: SwapPayload = {\n\t\t\tinputs,\n\t\t\toutputs,\n\t\t};\n\t\treturn {\n\t\t\tpayload,\n\t\t\toutputData: sortedOutputData,\n\t\t\tkeepVector: sortedKeepVector,\n\t\t\tsortedIndices: indices,\n\t\t};\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Send and Receive\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * Receive a token (swaps with mint for new proofs)\n\t *\n\t * @example\n\t *\n\t * ```typescript\n\t * const result = await wallet.receive(\n\t * \ttoken,\n\t * \t{ includeFees: true },\n\t * \t{ type: 'deterministic', counter: 0 },\n\t * );\n\t * ```\n\t *\n\t * @param token Token string or decoded token.\n\t * @param config Optional receive config.\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns Newly minted proofs.\n\t */\n\tasync receive(\n\t\ttoken: Token | string,\n\t\tconfig?: ReceiveConfig,\n\t\toutputType?: OutputType,\n\t): Promise<Proof[]> {\n\t\tconst { keysetId, privkey, requireDleq, proofsWeHave, onCountersReserved } = config || {};\n\t\toutputType = outputType ?? this.defaultOutputType(); // Fallback to policy\n\n\t\t// Decode and validate token\n\t\tconst decodedToken = typeof token === 'string' ? this.decodeToken(token) : token;\n\t\tconst tokenMintUrl = sanitizeUrl(decodedToken.mint);\n\t\tthis.failIf(tokenMintUrl !== this.mint.mintUrl, 'Token belongs to a different mint', {\n\t\t\ttoken: tokenMintUrl,\n\t\t\twallet: this.mint.mintUrl,\n\t\t});\n\t\tthis.failIf(decodedToken.unit !== this._unit, 'Token is not in wallet unit', {\n\t\t\ttoken: decodedToken.unit,\n\t\t\twallet: this._unit,\n\t\t});\n\n\t\t// Extract token proofs\n\t\tlet proofs: Proof[] = [];\n\t\t({ proofs } = decodedToken);\n\t\tconst totalAmount = sumProofs(proofs);\n\t\tif (totalAmount === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// Sign proofs if needed\n\t\tif (privkey) {\n\t\t\tproofs = this.signP2PKProofs(proofs, privkey);\n\t\t}\n\n\t\t// Check DLEQs if needed\n\t\tconst keyset = this.getKeyset(keysetId); // specified or wallet keyset\n\t\tif (requireDleq) {\n\t\t\tfor (const p of proofs) {\n\t\t\t\tconst ks = this.keyChain.getKeyset(p.id);\n\t\t\t\tif (!hasValidDleq(p, ks)) {\n\t\t\t\t\tthis.fail('Token contains proofs with invalid or missing DLEQ');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Shape receive output type and denominations\n\t\tconst netAmount = totalAmount - this.getFeesForProofs(proofs);\n\t\tlet receiveOT = this.configureOutputs(\n\t\t\tnetAmount,\n\t\t\tkeyset,\n\t\t\toutputType,\n\t\t\tfalse, // includeFees is not applicable for receive\n\t\t\tproofsWeHave,\n\t\t);\n\n\t\t// Assign counter atomically if OutputType is deterministic\n\t\t// and the counter is zero (auto-assign)\n\t\tconst autoCounters = await this.addCountersToOutputTypes(keyset.id, receiveOT);\n\t\t[receiveOT] = autoCounters.outputTypes;\n\t\tif (autoCounters.used) {\n\t\t\tthis.safeCallback(onCountersReserved, autoCounters.used, { op: 'receive' });\n\t\t}\n\t\tthis._logger.debug('receive counter', { counter: autoCounters.used, receiveOT });\n\n\t\t// Create outputs and execute swap\n\t\tconst outputs = this.createOutputData(this.preparedTotal(receiveOT), keyset, receiveOT);\n\t\tconst swapTransaction = this.createSwapTransaction(proofs, outputs, []);\n\t\tconst { signatures } = await this.mint.swap(swapTransaction.payload);\n\n\t\t// Construct and return proofs\n\t\tconst proofsReceived = swapTransaction.outputData.map((d, i) =>\n\t\t\td.toProof(signatures[i], keyset),\n\t\t);\n\t\tconst orderedProofs: Proof[] = [];\n\t\tswapTransaction.sortedIndices.forEach((s, o) => {\n\t\t\torderedProofs[s] = proofsReceived[o];\n\t\t});\n\t\tthis._logger.debug('RECEIVE COMPLETED', { amounts: orderedProofs.map((p) => p.amount) });\n\t\treturn orderedProofs;\n\t}\n\n\t/**\n\t * Sends proofs of a given amount from provided proofs.\n\t *\n\t * @remarks\n\t * If proofs are P2PK-locked to your public key, call signP2PKProofs first to sign them. The\n\t * default config uses exact match selection, and does not includeFees or requireDleq. Because the\n\t * send is offline, the user will unlock the signed proofs when they receive them online.\n\t * @param amount Amount to send.\n\t * @param proofs Array of proofs (must sum >= amount; pre-sign if P2PK-locked).\n\t * @param config Optional parameters for the send.\n\t * @returns SendResponse with keep/send proofs.\n\t * @throws Throws if the send cannot be completed offline.\n\t */\n\tsendOffline(amount: number, proofs: Proof[], config?: SendOfflineConfig): SendResponse {\n\t\tconst { requireDleq = false, includeFees = false, exactMatch = true } = config || {};\n\t\tif (requireDleq) {\n\t\t\t// Only use proofs that have a DLEQ\n\t\t\tproofs = proofs.filter((p: Proof) => p.dleq != undefined);\n\t\t}\n\t\tthis.failIf(sumProofs(proofs) < amount, 'Not enough funds available to send');\n\n\t\tconst { keep, send } = this.selectProofsToSend(proofs, amount, includeFees, exactMatch);\n\t\t// Ensure witnesses are serialized, strip DLEQ if not required\n\t\tconst sendPrepared = this._prepareInputsForMint(send, requireDleq);\n\t\treturn { keep, send: sendPrepared };\n\t}\n\n\t/**\n\t * Send proofs with online swap if necessary.\n\t *\n\t * @remarks\n\t * If proofs are P2PK-locked to your public key, call signP2PKProofs first to sign them.\n\t * @example\n\t *\n\t * ```typescript\n\t * // Simple send\n\t * const result = await wallet.send(5, proofs);\n\t *\n\t * // With a SendConfig\n\t * const result = await wallet.send(5, proofs, { includeFees: true });\n\t *\n\t * // With Custom output configuration\n\t * const customConfig: OutputConfig = {\n\t * \tsend: { type: 'p2pk', options: { pubkey: '...' } },\n\t * \tkeep: { type: 'deterministic', counter: 0 },\n\t * };\n\t * const customResult = await wallet.send(5, proofs, { includeFees: true }, customConfig);\n\t * ```\n\t *\n\t * @param amount Amount to send (receiver gets this net amount).\n\t * @param proofs Array of proofs to split.\n\t * @param config Optional parameters for the swap.\n\t * @returns SendResponse with keep/send proofs.\n\t * @throws Throws if the send cannot be completed offline or if funds are insufficient.\n\t */\n\tasync send(\n\t\tamount: number,\n\t\tproofs: Proof[],\n\t\tconfig?: SendConfig,\n\t\toutputConfig?: OutputConfig,\n\t): Promise<SendResponse> {\n\t\tconst { keysetId, includeFees = false, onCountersReserved } = config || {};\n\t\t// Fallback to policy defaults if no outputConfig\n\t\toutputConfig = outputConfig ?? {\n\t\t\tsend: this.defaultOutputType(),\n\t\t\tkeep: this.defaultOutputType(),\n\t\t};\n\n\t\t// First, let's see if we can avoid a swap (and fees)\n\t\t// by trying an exact match offline selection, including fees if\n\t\t// we are giving the receiver the amount + their fee to receive\n\t\t// In Wallet.ts, near send()\n\n\t\ttry {\n\t\t\t// Offline exact-match only allowed for plain-random defaults; deterministic implies swap.\n\t\t\tconst wantsDeterministicByPolicy = this.defaultOutputType().type === 'deterministic';\n\t\t\tconst isPlainRandom = (ot?: OutputType) =>\n\t\t\t\t!ot || (ot.type === 'random' && (!ot.denominations || ot.denominations.length === 0));\n\n\t\t\tif (\n\t\t\t\tkeysetId ||\n\t\t\t\twantsDeterministicByPolicy ||\n\t\t\t\t!isPlainRandom(outputConfig.send) ||\n\t\t\t\t(outputConfig.keep && !isPlainRandom(outputConfig.keep))\n\t\t\t) {\n\t\t\t\t// Explain why we must fall back to swap\n\t\t\t\tconst reasons: string[] = [];\n\t\t\t\tif (keysetId) reasons.push('keysetId override');\n\t\t\t\tif (wantsDeterministicByPolicy) reasons.push('wallet default is deterministic');\n\t\t\t\tif (!isPlainRandom(outputConfig.send)) reasons.push('non-default send output type');\n\t\t\t\tif (outputConfig.keep && !isPlainRandom(outputConfig.keep))\n\t\t\t\t\treasons.push('non-default keep output type');\n\n\t\t\t\tthrow new Error(`Options require a swap: ${reasons.join(', ')}`);\n\t\t\t}\n\n\t\t\t// Proceed with offline exact-match attempt\n\t\t\tconst { keep, send } = this.sendOffline(amount, proofs, {\n\t\t\t\tincludeFees,\n\t\t\t\texactMatch: true,\n\t\t\t\trequireDleq: false, // safety\n\t\t\t});\n\t\t\tconst expectedFee = includeFees ? this.getFeesForProofs(send) : 0;\n\n\t\t\tif (sumProofs(send) === amount + expectedFee) {\n\t\t\t\tthis._logger.info('Successful exactMatch offline selection!');\n\t\t\t\treturn { keep, send };\n\t\t\t}\n\t\t} catch (e: unknown) {\n\t\t\tconst message = e instanceof Error ? e.message : 'Unknown error';\n\t\t\tthis._logger.debug('ExactMatch offline selection failed.', { e: message });\n\t\t}\n\n\t\t// Fetch keys\n\t\tconst keyset = this.getKeyset(keysetId); // specified or wallet keyset\n\n\t\t// Shape SEND output type and denominations\n\t\tlet sendOT = this.configureOutputs(\n\t\t\tamount,\n\t\t\tkeyset,\n\t\t\toutputConfig.send ?? this.defaultOutputType(),\n\t\t\tincludeFees,\n\t\t);\n\t\tconst sendAmount = this.preparedTotal(sendOT);\n\n\t\t// Select the subset of proofs needed to cover the swap (sendTarget + swap fee)\n\t\tconst { keep: unselectedProofs, send: selectedProofs } = this.selectProofsToSend(\n\t\t\tproofs,\n\t\t\tsendAmount,\n\t\t\ttrue, // Include fees to cover swap fee\n\t\t);\n\t\t// this._logger.debug('PROOFS SELECTED', {\n\t\t// \tunselectedProofs: unselectedProofs.map(p=>p.amount),\n\t\t// \tselectedProofs: selectedProofs.map(p=>p.amount),\n\t\t// });\n\t\tif (selectedProofs.length === 0) {\n\t\t\tthrow new Error('Not enough funds available to send');\n\t\t}\n\n\t\t// Calculate our expected change from the swap (and sanity check!)\n\t\tconst selectedSum = sumProofs(selectedProofs);\n\t\tconst swapFee = this.getFeesForProofs(selectedProofs);\n\t\tconst changeAmount = selectedSum - swapFee - sendAmount;\n\t\tthis.failIf(changeAmount < 0, 'Not enough funds available for swap', {\n\t\t\tselectedSum,\n\t\t\tswapFee,\n\t\t\tsendAmount,\n\t\t\tchangeAmount,\n\t\t});\n\n\t\t// Shape KEEP (change) output type and denominations\n\t\t// No includeFees, as we are the receiver of the change\n\t\tlet keepOT = this.configureOutputs(\n\t\t\tchangeAmount,\n\t\t\tkeyset,\n\t\t\toutputConfig.keep ?? this.defaultOutputType(),\n\t\t\tfalse,\n\t\t\tconfig?.proofsWeHave,\n\t\t);\n\t\tconst keepAmount = this.preparedTotal(keepOT);\n\n\t\t// Assign counters atomically if either/both OutputTypes are deterministic\n\t\t// and the counter is zero (auto-assign)\n\t\tconst autoCounters = await this.addCountersToOutputTypes(keyset.id, sendOT, keepOT);\n\t\t[sendOT, keepOT] = autoCounters.outputTypes;\n\t\tif (autoCounters.used) {\n\t\t\tthis.safeCallback(onCountersReserved, autoCounters.used, { op: 'send' });\n\t\t}\n\t\tthis._logger.debug('send counters', { counter: autoCounters.used, sendOT, keepOT });\n\n\t\t// Create the output data\n\t\tconst sendOutputs = this.createOutputData(sendAmount, keyset, sendOT);\n\t\tconst keepOutputs = this.createOutputData(keepAmount, keyset, keepOT);\n\n\t\t// Execute swap\n\t\tconst swapTransaction = this.createSwapTransaction(selectedProofs, keepOutputs, sendOutputs);\n\t\tconst { signatures } = await this.mint.swap(swapTransaction.payload);\n\n\t\t// Construct proofs\n\t\tconst swapProofs = swapTransaction.outputData.map((d, i) => d.toProof(signatures[i], keyset));\n\t\tconst reorderedProofs = Array(swapProofs.length);\n\t\tconst reorderedKeepVector = Array(swapTransaction.keepVector.length);\n\t\tswapTransaction.sortedIndices.forEach((s, i) => {\n\t\t\treorderedKeepVector[s] = swapTransaction.keepVector[i];\n\t\t\treorderedProofs[s] = swapProofs[i];\n\t\t});\n\t\tconst keepProofs: Proof[] = [];\n\t\tconst sendProofs: Proof[] = [];\n\t\treorderedProofs.forEach((p: Proof, i) => {\n\t\t\tif (reorderedKeepVector[i]) {\n\t\t\t\tkeepProofs.push(p);\n\t\t\t} else {\n\t\t\t\tsendProofs.push(p);\n\t\t\t}\n\t\t});\n\t\tthis._logger.debug('SEND COMPLETED', {\n\t\t\tunselectedProofs: unselectedProofs.map((p) => p.amount),\n\t\t\tkeepProofs: keepProofs.map((p) => p.amount),\n\t\t\tsendProofs: sendProofs.map((p) => p.amount),\n\t\t});\n\t\treturn {\n\t\t\tkeep: [...keepProofs, ...unselectedProofs],\n\t\t\tsend: sendProofs,\n\t\t};\n\t}\n\t/**\n\t * Swap is an alias of send.\n\t */\n\tpublic readonly swap = this.send.bind(this);\n\n\t// -----------------------------------------------------------------\n\t// Section: Transaction Helpers\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * Selects proofs to send based on amount and fee inclusion.\n\t *\n\t * @remarks\n\t * Uses an adapted Randomized Greedy with Local Improvement (RGLI) algorithm, which has a time\n\t * complexity O(n log n) and space complexity O(n).\n\t * @param proofs Array of Proof objects available to select from.\n\t * @param amountToSend The target amount to send.\n\t * @param includeFees Optional boolean to include fees; Default: false.\n\t * @param exactMatch Optional boolean to require exact match; Default: false.\n\t * @returns SendResponse containing proofs to keep and proofs to send.\n\t * @throws Throws an error if an exact match cannot be found within MAX_TIMEMS.\n\t * @see https://crypto.ethz.ch/publications/files/Przyda02.pdf\n\t */\n\tselectProofsToSend(\n\t\tproofs: Proof[],\n\t\tamountToSend: number,\n\t\tincludeFees = false,\n\t\texactMatch = false,\n\t): SendResponse {\n\t\tconst { keep, send } = this._selectProofs(\n\t\t\tproofs,\n\t\t\tamountToSend,\n\t\t\tthis.keyChain,\n\t\t\tincludeFees,\n\t\t\texactMatch,\n\t\t);\n\t\treturn { keep, send };\n\t}\n\n\t/**\n\t * Prepares proofs for sending by signing P2PK-locked proofs.\n\t *\n\t * @remarks\n\t * Call this method before operations like send if the proofs are P2PK-locked and need unlocking.\n\t * This is a public wrapper for signing.\n\t * @param proofs The proofs to sign.\n\t * @param privkey The private key for signing.\n\t * @returns Signed proofs.\n\t */\n\tsignP2PKProofs(proofs: Proof[], privkey: string | string[]): Proof[] {\n\t\treturn signP2PKProofs(proofs, privkey);\n\t}\n\n\t/**\n\t * Calculates the fees based on inputs (proofs)\n\t *\n\t * @param proofs Input proofs to calculate fees for.\n\t * @returns Fee amount.\n\t * @throws Throws an error if the proofs keyset is unknown.\n\t */\n\tgetFeesForProofs(proofs: Proof[]): number {\n\t\tconst sumPPK = proofs.reduce((a, c) => a + this.getProofFeePPK(c), 0);\n\t\treturn Math.ceil(sumPPK / 1000);\n\t}\n\n\t/**\n\t * Returns the current fee PPK for a proof according to the cached keyset.\n\t *\n\t * @param proof {Proof} A single proof.\n\t * @returns FeePPK {number} The feePPK for the selected proof.\n\t * @throws Throws an error if the proofs keyset is unknown.\n\t */\n\tprivate getProofFeePPK(proof: Proof): number {\n\t\ttry {\n\t\t\t// We need the proof's keyset so use keyChain here\n\t\t\t// We must NOT fallback to wallet's keyset\n\t\t\treturn this.keyChain.getKeyset(proof.id).fee;\n\t\t} catch (e) {\n\t\t\tthis.fail(`Could not get fee. No keyset found for keyset id: ${proof.id}`, {\n\t\t\t\te,\n\t\t\t\tkeychain: this.keyChain.getKeysets(),\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Calculates the fees based on inputs for a given keyset.\n\t *\n\t * @param nInputs Number of inputs.\n\t * @param keysetId KeysetId used to lookup `input_fee_ppk`\n\t * @returns Fee amount.\n\t */\n\tgetFeesForKeyset(nInputs: number, keysetId: string): number {\n\t\ttry {\n\t\t\t// We must NOT fallback to wallet's keyset\n\t\t\tconst feePPK = this.keyChain.getKeyset(keysetId).fee;\n\t\t\treturn Math.floor(Math.max((nInputs * feePPK + 999) / 1000, 0));\n\t\t} catch (e) {\n\t\t\tthis.fail(`No keyset found with ID ${keysetId}`, { e });\n\t\t}\n\t}\n\n\t/**\n\t * Prepares inputs for a mint operation.\n\t *\n\t * @remarks\n\t * Internal method; strips DLEQ (NUT-12) and p2pk_e (NUT-26) for privacy and serializes witnesses.\n\t * Returns an array of new proof objects - does not mutate the originals.\n\t * @param proofs The proofs to prepare.\n\t * @param keepDleq Optional boolean to keep DLEQ (default: false, strips for privacy).\n\t * @returns Prepared proofs for mint payload.\n\t */\n\tprivate _prepareInputsForMint(proofs: Proof[], keepDleq: boolean = false): Proof[] {\n\t\treturn proofs.map((p) => {\n\t\t\tconst witness =\n\t\t\t\tp.witness && typeof p.witness !== 'string' ? JSON.stringify(p.witness) : p.witness;\n\t\t\tconst { dleq, p2pk_e, ...rest } = p; // isolate dleq and p2pk_e\n\t\t\tvoid p2pk_e; // intentionally unused (linter)\n\t\t\t// New proof object\n\t\t\treturn keepDleq && dleq ? { ...rest, dleq, witness } : { ...rest, witness };\n\t\t});\n\t}\n\n\t/**\n\t * Decodes a string token.\n\t *\n\t * @remarks\n\t * Rehydrates a token from the space-saving CBOR format, including mapping short keyset ids to\n\t * their full representation.\n\t * @param token The token in string format (cashuB...)\n\t * @returns Token object.\n\t */\n\tpublic decodeToken(token: string): Token {\n\t\tconst keysets = this.keyChain.getKeysets();\n\t\treturn getDecodedToken(token, keysets);\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Restore\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * Restores batches of deterministic proofs until no more signatures are returned from the mint.\n\t *\n\t * @param [gapLimit=300] The amount of empty counters that should be returned before restoring\n\t *   ends (defaults to 300). Default is `300`\n\t * @param [batchSize=100] The amount of proofs that should be restored at a time (defaults to\n\t *   100). Default is `100`\n\t * @param [counter=0] The counter that should be used as a starting point (defaults to 0). Default\n\t *   is `0`\n\t * @param [keysetId] Which keysetId to use for the restoration. If none is passed the instance's\n\t *   default one will be used.\n\t */\n\tasync batchRestore(\n\t\tgapLimit = 300,\n\t\tbatchSize = 100,\n\t\tcounter = 0,\n\t\tkeysetId?: string,\n\t): Promise<{ proofs: Proof[]; lastCounterWithSignature?: number }> {\n\t\tconst requiredEmptyBatches = Math.ceil(gapLimit / batchSize);\n\t\tconst restoredProofs: Proof[] = [];\n\n\t\tlet lastCounterWithSignature: undefined | number;\n\t\tlet emptyBatchesFound = 0;\n\n\t\twhile (emptyBatchesFound < requiredEmptyBatches) {\n\t\t\tconst restoreRes = await this.restore(counter, batchSize, { keysetId });\n\t\t\tif (restoreRes.proofs.length > 0) {\n\t\t\t\temptyBatchesFound = 0;\n\t\t\t\trestoredProofs.push(...restoreRes.proofs);\n\t\t\t\tlastCounterWithSignature = restoreRes.lastCounterWithSignature;\n\t\t\t} else {\n\t\t\t\temptyBatchesFound++;\n\t\t\t}\n\t\t\tcounter += batchSize;\n\t\t}\n\t\treturn { proofs: restoredProofs, lastCounterWithSignature };\n\t}\n\n\t/**\n\t * Regenerates.\n\t *\n\t * @param start Set starting point for count (first cycle for each keyset should usually be 0)\n\t * @param count Set number of blinded messages that should be generated.\n\t * @param options.keysetId Set a custom keysetId to restore from. @see `keyChain)`\n\t */\n\tasync restore(\n\t\tstart: number,\n\t\tcount: number,\n\t\tconfig?: RestoreConfig,\n\t): Promise<{ proofs: Proof[]; lastCounterWithSignature?: number }> {\n\t\tconst { keysetId } = config || {};\n\t\tconst keyset = this.getKeyset(keysetId); // specified or wallet keyset\n\t\tthis.failIfNullish(this._seed, 'Cashu Wallet must be initialized with a seed to use restore');\n\n\t\t// create deterministic blank outputs for unknown restore amounts\n\t\t// Note: zero amount + zero denomination passes splitAmount validation\n\t\tconst zeros = Array(count).fill(0);\n\t\tconst outputData = OutputData.createDeterministicData(0, this._seed, start, keyset, zeros);\n\n\t\tconst { outputs, signatures } = await this.mint.restore({\n\t\t\toutputs: outputData.map((d) => d.blindedMessage),\n\t\t});\n\n\t\tconst signatureMap: { [sig: string]: SerializedBlindedSignature } = {};\n\t\toutputs.forEach((o, i) => (signatureMap[o.B_] = signatures[i]));\n\n\t\tconst restoredProofs: Proof[] = [];\n\t\tlet lastCounterWithSignature: number | undefined;\n\n\t\tfor (let i = 0; i < outputData.length; i++) {\n\t\t\tconst matchingSig = signatureMap[outputData[i].blindedMessage.B_];\n\t\t\tif (matchingSig) {\n\t\t\t\tlastCounterWithSignature = start + i;\n\t\t\t\toutputData[i].blindedMessage.amount = matchingSig.amount;\n\t\t\t\trestoredProofs.push(outputData[i].toProof(matchingSig, keyset));\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tproofs: restoredProofs,\n\t\t\tlastCounterWithSignature,\n\t\t};\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Create Mint Quote\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * @deprecated Use createMintQuoteBolt11()\n\t */\n\tasync createMintQuote(amount: number, description?: string): Promise<MintQuoteResponse> {\n\t\treturn this.createMintQuoteBolt11(amount, description);\n\t}\n\n\t/**\n\t * Requests a mint quote from the mint. Response returns a Lightning payment request for the\n\t * requested given amount and unit.\n\t *\n\t * @param amount Amount requesting for mint.\n\t * @param description Optional description for the mint quote.\n\t * @param pubkey Optional public key to lock the quote to.\n\t * @returns The mint will return a mint quote with a Lightning invoice for minting tokens of the\n\t *   specified amount and unit.\n\t */\n\tasync createMintQuoteBolt11(amount: number, description?: string): Promise<MintQuoteResponse> {\n\t\t// Check if mint supports description for bolt11\n\t\tif (description) {\n\t\t\tconst mintInfo = this.getMintInfo();\n\t\t\tif (!mintInfo.supportsNut04Description('bolt11', this._unit)) {\n\t\t\t\tthis.fail('Mint does not support description for bolt11');\n\t\t\t}\n\t\t}\n\n\t\tconst mintQuotePayload: MintQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\tamount: amount,\n\t\t\tdescription: description,\n\t\t};\n\t\tconst res = await this.mint.createMintQuoteBolt11(mintQuotePayload);\n\t\treturn { ...res, amount: res.amount || amount, unit: res.unit || this._unit };\n\t}\n\n\t/**\n\t * Requests a mint quote from the mint that is locked to a public key.\n\t *\n\t * @param amount Amount requesting for mint.\n\t * @param pubkey Public key to lock the quote to.\n\t * @param description Optional description for the mint quote.\n\t * @returns The mint will return a mint quote with a Lightning invoice for minting tokens of the\n\t *   specified amount and unit. The quote will be locked to the specified `pubkey`.\n\t */\n\tasync createLockedMintQuote(\n\t\tamount: number,\n\t\tpubkey: string,\n\t\tdescription?: string,\n\t): Promise<LockedMintQuoteResponse> {\n\t\tconst { supported } = this.getMintInfo().isSupported(20);\n\t\tthis.failIf(!supported, 'Mint does not support NUT-20');\n\t\tconst mintQuotePayload: MintQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\tamount: amount,\n\t\t\tdescription: description,\n\t\t\tpubkey: pubkey,\n\t\t};\n\t\tconst res = await this.mint.createMintQuoteBolt11(mintQuotePayload);\n\t\tthis.failIf(typeof res.pubkey !== 'string', 'Mint returned unlocked mint quote');\n\t\tconst resPubkey = res.pubkey!;\n\t\treturn {\n\t\t\t...res,\n\t\t\tpubkey: resPubkey,\n\t\t\tamount: res.amount || amount,\n\t\t\tunit: res.unit || this._unit,\n\t\t};\n\t}\n\n\t/**\n\t * Requests a mint quote from the mint. Response returns a Lightning BOLT12 offer for the\n\t * requested given amount and unit.\n\t *\n\t * @param pubkey Public key to lock the quote to.\n\t * @param options.amount BOLT12 offer amount requesting for mint. If not specified, the offer will\n\t *   be amountless.\n\t * @param options.description Description for the mint quote.\n\t * @returns The mint will return a mint quote with a BOLT12 offer for minting tokens of the\n\t *   specified amount and unit.\n\t */\n\tasync createMintQuoteBolt12(\n\t\tpubkey: string,\n\t\toptions?: {\n\t\t\tamount?: number;\n\t\t\tdescription?: string;\n\t\t},\n\t): Promise<Bolt12MintQuoteResponse> {\n\t\t// Check if mint supports description for bolt12\n\t\tconst mintInfo = this.getMintInfo();\n\t\tif (options?.description && !mintInfo.supportsNut04Description('bolt12', this._unit)) {\n\t\t\tthis.fail('Mint does not support description for bolt12');\n\t\t}\n\n\t\tconst mintQuotePayload: Bolt12MintQuotePayload = {\n\t\t\tpubkey: pubkey,\n\t\t\tunit: this._unit,\n\t\t\tamount: options?.amount,\n\t\t\tdescription: options?.description,\n\t\t};\n\n\t\treturn this.mint.createMintQuoteBolt12(mintQuotePayload);\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Check Mint Quote\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * @deprecated Use checkMintQuoteBolt11()\n\t */\n\tasync checkMintQuote(\n\t\tquote: string | MintQuoteResponse,\n\t): Promise<MintQuoteResponse | PartialMintQuoteResponse> {\n\t\treturn this.checkMintQuoteBolt11(quote);\n\t}\n\n\t/**\n\t * Gets an existing mint quote from the mint.\n\t *\n\t * @param quote Quote ID.\n\t * @returns The mint will create and return a Lightning invoice for the specified amount.\n\t */\n\tasync checkMintQuoteBolt11(\n\t\tquote: string | MintQuoteResponse,\n\t): Promise<MintQuoteResponse | PartialMintQuoteResponse> {\n\t\tconst quoteId = typeof quote === 'string' ? quote : quote.quote;\n\t\tconst baseRes = await this.mint.checkMintQuoteBolt11(quoteId);\n\t\tif (typeof quote === 'string') {\n\t\t\treturn baseRes;\n\t\t}\n\t\treturn { ...baseRes, amount: baseRes.amount || quote.amount, unit: baseRes.unit || quote.unit };\n\t}\n\n\t/**\n\t * Gets an existing BOLT12 mint quote from the mint.\n\t *\n\t * @param quote Quote ID.\n\t * @returns The latest mint quote for the given quote ID.\n\t */\n\tasync checkMintQuoteBolt12(quote: string): Promise<Bolt12MintQuoteResponse> {\n\t\treturn this.mint.checkMintQuoteBolt12(quote);\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Mint Proofs\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * @deprecated Use mintProofsBolt11()\n\t */\n\tasync mintProofs(\n\t\tamount: number,\n\t\tquote: string | MintQuoteResponse,\n\t\tconfig?: MintProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<Proof[]> {\n\t\treturn this._mintProofs('bolt11', amount, quote, config, outputType);\n\t}\n\n\t/**\n\t * Mint proofs for a bolt11 quote.\n\t *\n\t * @param amount Amount to mint.\n\t * @param quote Mint quote ID or object (bolt11).\n\t * @param config Optional parameters (e.g. privkey for locked quotes).\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns Minted proofs.\n\t */\n\tasync mintProofsBolt11(\n\t\tamount: number,\n\t\tquote: string | MintQuoteResponse,\n\t\tconfig?: MintProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<Proof[]> {\n\t\treturn this._mintProofs('bolt11', amount, quote, config, outputType);\n\t}\n\n\t/**\n\t * Mints proofs for a bolt12 quote.\n\t *\n\t * @param amount Amount to mint.\n\t * @param quote Bolt12 mint quote.\n\t * @param privkey Private key to unlock the quote.\n\t * @param config Optional parameters (e.g. keysetId).\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns Minted proofs.\n\t */\n\tasync mintProofsBolt12(\n\t\tamount: number,\n\t\tquote: Bolt12MintQuoteResponse,\n\t\tprivkey: string,\n\t\tconfig?: { keysetId?: string },\n\t\toutputType?: OutputType,\n\t): Promise<Proof[]> {\n\t\treturn this._mintProofs('bolt12', amount, quote, { ...config, privkey }, outputType);\n\t}\n\n\t/**\n\t * Internal helper for minting proofs with bolt11 or bolt12.\n\t *\n\t * @remarks\n\t * Handles blinded messages, signatures, and proof construction. Use public methods like\n\t * mintProofs or helpers for API access.\n\t * @param method 'bolt11' or 'bolt12'.\n\t * @param amount Amount to mint (must be positive).\n\t * @param quote Quote ID or object.\n\t * @param config Optional (privkey, keysetId).\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns Minted proofs.\n\t * @throws If params are invalid or mint returns errors.\n\t */\n\tprivate async _mintProofs<T extends 'bolt11' | 'bolt12'>(\n\t\tmethod: T,\n\t\tamount: number,\n\t\tquote: string | (T extends 'bolt11' ? MintQuoteResponse : Bolt12MintQuoteResponse),\n\t\tconfig?: MintProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<Proof[]> {\n\t\toutputType = outputType ?? this.defaultOutputType(); // Fallback to policy\n\t\tconst { privkey, keysetId, proofsWeHave, onCountersReserved } = config ?? {};\n\t\tthis.failIf(amount <= 0, 'Invalid mint amount: must be positive', { amount });\n\n\t\t// Shape output type and denominations for our proofs\n\t\t// we are receiving, so no includeFees.\n\t\tconst keyset = this.getKeyset(keysetId); // specified or wallet keyset\n\t\tlet mintOT = this.configureOutputs(\n\t\t\tamount,\n\t\t\tkeyset,\n\t\t\toutputType,\n\t\t\tfalse, // no fees\n\t\t\tproofsWeHave,\n\t\t);\n\t\tconst mintAmount = this.preparedTotal(mintOT);\n\n\t\t// Assign counters atomically if OutputType is deterministic\n\t\t// and the counter is zero (auto-assign)\n\t\tconst autoCounters = await this.addCountersToOutputTypes(keyset.id, mintOT);\n\t\t[mintOT] = autoCounters.outputTypes;\n\t\tif (autoCounters.used) {\n\t\t\tthis.safeCallback(onCountersReserved, autoCounters.used, { op: 'mintProofs' });\n\t\t}\n\t\tthis._logger.debug('mint counter', { counter: autoCounters.used, mintOT });\n\n\t\t// Create outputs and mint payload\n\t\tconst outputs = this.createOutputData(mintAmount, keyset, mintOT);\n\t\tconst blindedMessages = outputs.map((d) => d.blindedMessage);\n\t\tconst mintPayload: MintPayload = {\n\t\t\toutputs: blindedMessages,\n\t\t\tquote: typeof quote === 'string' ? quote : quote.quote,\n\t\t};\n\n\t\t// Sign payload if the quote carries a public key\n\t\tif (typeof quote !== 'string' && quote.pubkey) {\n\t\t\tthis.failIf(!privkey, 'Can not sign locked quote without private key');\n\t\t\tconst mintQuoteSignature = signMintQuote(privkey!, quote.quote, blindedMessages);\n\t\t\tmintPayload.signature = mintQuoteSignature;\n\t\t}\n\t\t// Mint proofs\n\t\tlet signatures;\n\t\tif (method === 'bolt12') {\n\t\t\t({ signatures } = await this.mint.mintBolt12(mintPayload));\n\t\t} else {\n\t\t\t({ signatures } = await this.mint.mintBolt11(mintPayload));\n\t\t}\n\t\tthis.failIf(\n\t\t\tsignatures.length !== outputs.length,\n\t\t\t`Mint returned ${signatures.length} signatures, expected ${outputs.length}`,\n\t\t);\n\n\t\tthis._logger.debug('MINT COMPLETED', { amounts: outputs.map((o) => o.blindedMessage.amount) });\n\t\treturn outputs.map((d, i) => d.toProof(signatures[i], keyset));\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Create Melt Quote\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * @deprecated Use createMeltQuoteBolt11.\n\t */\n\tasync createMeltQuote(invoice: string): Promise<MeltQuoteResponse> {\n\t\treturn this.createMeltQuoteBolt11(invoice);\n\t}\n\n\t/**\n\t * Requests a melt quote from the mint. Response returns amount and fees for a given unit in order\n\t * to pay a Lightning invoice.\n\t *\n\t * @param invoice LN invoice that needs to get a fee estimate.\n\t * @returns The mint will create and return a melt quote for the invoice with an amount and fee\n\t *   reserve.\n\t */\n\tasync createMeltQuoteBolt11(invoice: string): Promise<MeltQuoteResponse> {\n\t\tconst meltQuotePayload: MeltQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\trequest: invoice,\n\t\t};\n\t\tconst meltQuote = await this.mint.createMeltQuoteBolt11(meltQuotePayload);\n\t\treturn {\n\t\t\t...meltQuote,\n\t\t\tunit: meltQuote.unit || this._unit,\n\t\t\trequest: meltQuote.request || invoice,\n\t\t};\n\t}\n\n\t/**\n\t * Requests a melt quote from the mint. Response returns amount and fees for a given unit in order\n\t * to pay a BOLT12 offer.\n\t *\n\t * @param offer BOLT12 offer that needs to get a fee estimate.\n\t * @param amountMsat Amount in millisatoshis for amount-less offers. If this is defined and the\n\t *   offer has an amount, they **MUST** be equal.\n\t * @returns The mint will create and return a melt quote for the offer with an amount and fee\n\t *   reserve.\n\t */\n\tasync createMeltQuoteBolt12(\n\t\toffer: string,\n\t\tamountMsat?: number,\n\t): Promise<Bolt12MeltQuoteResponse> {\n\t\treturn this.mint.createMeltQuoteBolt12({\n\t\t\tunit: this._unit,\n\t\t\trequest: offer,\n\t\t\toptions: amountMsat\n\t\t\t\t? {\n\t\t\t\t\t\tamountless: {\n\t\t\t\t\t\t\tamount_msat: amountMsat,\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t: undefined,\n\t\t});\n\t}\n\n\t/**\n\t * Requests a multi path melt quote from the mint.\n\t *\n\t * @remarks\n\t * Uses NUT-15 Partial multi-path payments for BOLT11.\n\t * @param invoice LN invoice that needs to get a fee estimate.\n\t * @param partialAmount The partial amount of the invoice's total to be paid by this instance.\n\t * @returns The mint will create and return a melt quote for the invoice with an amount and fee\n\t *   reserve.\n\t * @see https://github.com/cashubtc/nuts/blob/main/15.md\n\t */\n\tasync createMultiPathMeltQuote(\n\t\tinvoice: string,\n\t\tmillisatPartialAmount: number,\n\t): Promise<MeltQuoteResponse> {\n\t\tconst { supported, params } = this.getMintInfo().isSupported(15);\n\t\tthis.failIf(!supported, 'Mint does not support NUT-15');\n\t\tthis.failIf(\n\t\t\t!params?.some((p) => p.method === 'bolt11' && p.unit === this._unit),\n\t\t\t`Mint does not support MPP for bolt11 and ${this._unit}`,\n\t\t);\n\t\tconst mppOption: MPPOption = {\n\t\t\tamount: millisatPartialAmount,\n\t\t};\n\t\tconst meltOptions: MeltQuoteOptions = {\n\t\t\tmpp: mppOption,\n\t\t};\n\t\tconst meltQuotePayload: MeltQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\trequest: invoice,\n\t\t\toptions: meltOptions,\n\t\t};\n\t\tconst meltQuote = await this.mint.createMeltQuoteBolt11(meltQuotePayload);\n\t\treturn { ...meltQuote, request: invoice, unit: this._unit };\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Check Melt Quote\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * @deprecated Use checkMeltQuoteBolt11()\n\t */\n\tasync checkMeltQuote(\n\t\tquote: string | MeltQuoteResponse,\n\t): Promise<MeltQuoteResponse | PartialMeltQuoteResponse> {\n\t\treturn this.checkMeltQuoteBolt11(quote);\n\t}\n\n\t/**\n\t * Returns an existing bolt11 melt quote from the mint.\n\t *\n\t * @param quote ID of the melt quote.\n\t * @returns The mint will return an existing melt quote.\n\t */\n\tasync checkMeltQuoteBolt11(\n\t\tquote: string | MeltQuoteResponse,\n\t): Promise<MeltQuoteResponse | PartialMeltQuoteResponse> {\n\t\tconst quoteId = typeof quote === 'string' ? quote : quote.quote;\n\t\tconst meltQuote = await this.mint.checkMeltQuoteBolt11(quoteId);\n\t\tif (typeof quote === 'string') {\n\t\t\treturn meltQuote;\n\t\t}\n\t\treturn { ...meltQuote, request: quote.request, unit: quote.unit };\n\t}\n\n\t/**\n\t * Returns an existing bolt12 melt quote from the mint.\n\t *\n\t * @param quote ID of the melt quote.\n\t * @returns The mint will return an existing melt quote.\n\t */\n\tasync checkMeltQuoteBolt12(quote: string): Promise<Bolt12MeltQuoteResponse> {\n\t\treturn this.mint.checkMeltQuoteBolt12(quote);\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Melt Proofs\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * @deprecated Use meltProofsBolt11()\n\t */\n\tasync meltProofs(\n\t\tmeltQuote: MeltQuoteResponse,\n\t\tproofsToSend: Proof[],\n\t\tconfig?: MeltProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<MeltProofsResponse> {\n\t\treturn this._meltProofs('bolt11', meltQuote, proofsToSend, config, outputType);\n\t}\n\n\t/**\n\t * Melt proofs for a bolt11 melt quote.\n\t *\n\t * @remarks\n\t * ProofsToSend must be at least amount+fee_reserve from the melt quote. This function does not\n\t * perform coin selection!.\n\t * @param meltQuote ID of the melt quote.\n\t * @param proofsToSend Proofs to melt.\n\t * @param config Optional parameters.\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns MeltProofsResponse with quote and change proofs.\n\t */\n\tasync meltProofsBolt11(\n\t\tmeltQuote: MeltQuoteResponse,\n\t\tproofsToSend: Proof[],\n\t\tconfig?: MeltProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<MeltProofsResponse> {\n\t\treturn this._meltProofs('bolt11', meltQuote, proofsToSend, config, outputType);\n\t}\n\n\t/**\n\t * Melt proofs for a bolt12 melt quote, returns change proofs using specified outputType.\n\t *\n\t * @remarks\n\t * ProofsToSend must be at least amount+fee_reserve from the melt quote. This function does not\n\t * perform coin selection!.\n\t * @param meltQuote ID of the melt quote.\n\t * @param proofsToSend Proofs to melt.\n\t * @param config Optional parameters.\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns MeltProofsResponse with quote and change proofs.\n\t */\n\tasync meltProofsBolt12(\n\t\tmeltQuote: Bolt12MeltQuoteResponse,\n\t\tproofsToSend: Proof[],\n\t\tconfig?: MeltProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<MeltProofsResponse> {\n\t\treturn this._meltProofs('bolt12', meltQuote, proofsToSend, config, outputType);\n\t}\n\n\t/**\n\t * Melt proofs for a given melt quote created with the bolt11 or bolt12 method.\n\t *\n\t * @remarks\n\t * Creates NUT-08 blanks (1-sat) for Lightning fee return. Get these by setting a\n\t * config.onChangeOutputsCreated callback for async melting. @see completeMelt.\n\t * @param method Payment method of the quote.\n\t * @param meltQuote The bolt11 or bolt12 melt quote.\n\t * @param proofsToSend Proofs to melt.\n\t * @param config Optional (keysetId, onChangeOutputsCreated).\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns MeltProofsResponse.\n\t * @throws If params are invalid or mint returns errors.\n\t * @see https://github.com/cashubtc/nuts/blob/main/08.md.\n\t */\n\tprivate async _meltProofs<T extends 'bolt11' | 'bolt12'>(\n\t\tmethod: T,\n\t\tmeltQuote: T extends 'bolt11' ? MeltQuoteResponse : Bolt12MeltQuoteResponse,\n\t\tproofsToSend: Proof[],\n\t\tconfig?: MeltProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<MeltProofsResponse> {\n\t\toutputType = outputType ?? this.defaultOutputType(); // Fallback to policy\n\t\tconst { keysetId, onChangeOutputsCreated, onCountersReserved } = config || {};\n\t\tconst keyset = this.getKeyset(keysetId); // specified or wallet keyset\n\t\tconst sendAmount = sumProofs(proofsToSend);\n\n\t\t// feeReserve is the overage above the invoice/offer amount.\n\t\t// In the common case where selected proofs = amount + fee_reserve,\n\t\t// this equals the quotes fee_reserve. If you overshoot more,\n\t\t// the extra also becomes NUT-08 lightning fee change.\n\t\tconst feeReserve = sendAmount - meltQuote.amount;\n\t\tlet outputData: OutputDataLike[] = [];\n\n\t\t// bolt11 does not allow partial payment, and although bolt12 could, mints\n\t\t// like CDK forbids it. So let's fail loudly up front...\n\t\tthis.failIf(feeReserve < 0, 'Not enough proofs to cover amount + fee reserve', {\n\t\t\tsendAmount,\n\t\t\tquoteAmount: meltQuote.amount,\n\t\t});\n\n\t\t// Create NUT-08 blanks for return of Lightning fee change\n\t\t// Note: zero amount + zero denomination passes splitAmount validation\n\t\tif (feeReserve > 0) {\n\t\t\tlet count = Math.ceil(Math.log2(feeReserve)) || 1;\n\t\t\tif (count < 0) count = 0; // Prevents: -Infinity\n\t\t\tconst denominations: number[] = count ? new Array<number>(count).fill(0) : [];\n\t\t\tthis._logger.debug('Creating NUT-08 blanks for fee reserve', {\n\t\t\t\tfeeReserve,\n\t\t\t\tdenominations,\n\t\t\t});\n\n\t\t\t// Build effective OutputType and merge denominations\n\t\t\tif (outputType.type === 'custom') {\n\t\t\t\tthis.fail('Custom OutputType not supported for melt change (must be 0-sat blanks)');\n\t\t\t}\n\t\t\tlet meltOT: OutputType = { ...outputType, denominations };\n\t\t\t// Assign counter atomically if OutputType is deterministic\n\t\t\t// and the counter is zero (auto-assign)\n\t\t\tconst autoCounters = await this.addCountersToOutputTypes(keyset.id, meltOT);\n\t\t\t[meltOT] = autoCounters.outputTypes;\n\t\t\tif (autoCounters.used) {\n\t\t\t\tthis.safeCallback(onCountersReserved, autoCounters.used, { op: 'meltProofs' });\n\t\t\t}\n\t\t\tthis._logger.debug('melt counter', { counter: autoCounters.used, meltOT });\n\n\t\t\t// Generate the blank outputs (no fees as we are receiving change)\n\t\t\t// Remember, zero amount + zero denomination passes splitAmount validation\n\t\t\toutputData = this.createOutputData(0, keyset, meltOT);\n\t\t}\n\n\t\t// Prepare proofs for mint\n\t\tproofsToSend = this._prepareInputsForMint(proofsToSend);\n\n\t\tconst meltPayload: MeltPayload = {\n\t\t\tquote: meltQuote.quote,\n\t\t\tinputs: proofsToSend,\n\t\t\toutputs: outputData.map((d) => d.blindedMessage),\n\t\t};\n\n\t\t// Fire event(s) after blanks creation\n\t\tif (outputData.length > 0) {\n\t\t\tconst blanks: MeltBlanks = {\n\t\t\t\tmethod,\n\t\t\t\tpayload: meltPayload,\n\t\t\t\toutputData,\n\t\t\t\tkeyset,\n\t\t\t\tquote: meltQuote,\n\t\t\t};\n\t\t\tthis.safeCallback(onChangeOutputsCreated, blanks, { op: 'meltProofs' });\n\t\t\tthis.on._emitMeltBlanksCreated(blanks); // global callback\n\t\t}\n\n\t\t// Proceed with melt, setting preferredAsync header if an onChangeOutputsCreated callback was used\n\t\tlet meltResponse;\n\t\tconst preferAsync: boolean = typeof onChangeOutputsCreated === 'function';\n\t\tif (method === 'bolt12') {\n\t\t\tmeltResponse = await this.mint.meltBolt12(meltPayload, { preferAsync });\n\t\t} else {\n\t\t\tmeltResponse = await this.mint.meltBolt11(meltPayload, { preferAsync });\n\t\t}\n\n\t\t// Sanity check mint didn't send too many signatures before mapping\n\t\t// Should not happen, except in case of a broken or malicious mint\n\t\tthis.failIf(\n\t\t\t(meltResponse.change?.length ?? 0) > outputData.length,\n\t\t\t`Mint returned ${meltResponse.change?.length ?? 0} signatures, but only ${outputData.length} blanks were provided`,\n\t\t);\n\n\t\t// Construct change if provided (empty if pending/not paid; shorter ok if less overfee)\n\t\tconst change = meltResponse.change?.map((s, i) => outputData[i].toProof(s, keyset)) ?? [];\n\t\tthis._logger.debug('MELT COMPLETED', { changeAmounts: change.map((p) => p.amount) });\n\t\treturn { quote: { ...meltResponse, unit: meltQuote.unit, request: meltQuote.request }, change };\n\t}\n\n\t/**\n\t * Completes a pending melt by re-calling the melt endpoint and constructing change proofs.\n\t *\n\t * @remarks\n\t * Use with blanks from onChangeOutputsCreated to retry pending melts. Works for Bolt11/Bolt12.\n\t * Returns change proofs if paid, else empty change.\n\t * @param blanks The blanks from onChangeOutputsCreated.\n\t * @returns Updated MeltProofsResponse.\n\t * @throws If melt fails or signatures don't match output count.\n\t */\n\tasync completeMelt<T extends MeltQuoteResponse>(\n\t\tblanks: MeltBlanks<T>,\n\t): Promise<MeltProofsResponse> {\n\t\tconst meltResponse =\n\t\t\tblanks.method === 'bolt12'\n\t\t\t\t? await this.mint.meltBolt12(blanks.payload)\n\t\t\t\t: await this.mint.meltBolt11(blanks.payload);\n\n\t\t// Check for too many signatures before mapping\n\t\tthis.failIf(\n\t\t\t(meltResponse.change?.length ?? 0) > blanks.outputData.length,\n\t\t\t`Mint returned ${meltResponse.change?.length ?? 0} signatures, but only ${blanks.outputData.length} blanks were provided`,\n\t\t);\n\n\t\t// Construct change (shorter ok)\n\t\tconst change =\n\t\t\tmeltResponse.change?.map((s, i) => blanks.outputData[i].toProof(s, blanks.keyset)) ?? [];\n\n\t\tthis._logger.debug('COMPLETE MELT', { changeAmounts: change.map((p) => p.amount) });\n\t\treturn {\n\t\t\tquote: { ...meltResponse, unit: blanks.quote.unit, request: blanks.quote.request },\n\t\t\tchange,\n\t\t};\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Proof States\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * Get an array of the states of proofs from the mint (as an array of CheckStateEnum's)\n\t *\n\t * @param proofs (only the `secret` field is required)\n\t * @returns NUT-07 state for each proof, in same order.\n\t */\n\tasync checkProofsStates(proofs: Array<Pick<Proof, 'secret'>>): Promise<ProofState[]> {\n\t\tconst enc = new TextEncoder();\n\t\tconst Ys = proofs.map((p: Pick<Proof, 'secret'>) =>\n\t\t\thashToCurve(enc.encode(p.secret)).toHex(true),\n\t\t);\n\t\t// TODO: Replace this with a value from the info endpoint of the mint eventually\n\t\tconst BATCH_SIZE = 100;\n\t\tconst states: ProofState[] = [];\n\t\tfor (let i = 0; i < Ys.length; i += BATCH_SIZE) {\n\t\t\tconst YsSlice = Ys.slice(i, i + BATCH_SIZE);\n\t\t\tconst { states: batchStates } = await this.mint.check({\n\t\t\t\tYs: YsSlice,\n\t\t\t});\n\t\t\tconst stateMap: { [y: string]: ProofState } = {};\n\t\t\tbatchStates.forEach((s) => {\n\t\t\t\tstateMap[s.Y] = s;\n\t\t\t});\n\t\t\tfor (let j = 0; j < YsSlice.length; j++) {\n\t\t\t\tconst state = stateMap[YsSlice[j]];\n\t\t\t\tthis.failIfNullish(state, 'Could not find state for proof with Y: ' + YsSlice[j]);\n\t\t\t\tstates.push(state);\n\t\t\t}\n\t\t}\n\t\treturn states;\n\t}\n\n\t/**\n\t * Groups proofs by their corresponding state, preserving order within each group.\n\t *\n\t * @param proofs (only the `secret` field is required)\n\t * @returns An object with arrays of proofs grouped by CheckStateEnum state.\n\t */\n\tasync groupProofsByState(\n\t\tproofs: Proof[],\n\t): Promise<{ unspent: Proof[]; pending: Proof[]; spent: Proof[] }> {\n\t\tconst states: ProofState[] = await this.checkProofsStates(proofs);\n\t\tconst result = {\n\t\t\tunspent: [] as Proof[],\n\t\t\tpending: [] as Proof[],\n\t\t\tspent: [] as Proof[],\n\t\t};\n\t\tfor (let i = 0; i < states.length; i++) {\n\t\t\tconst proof = proofs[i];\n\t\t\tswitch (states[i].state) {\n\t\t\t\tcase CheckStateEnum.UNSPENT:\n\t\t\t\t\tresult.unspent.push(proof);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CheckStateEnum.PENDING:\n\t\t\t\t\tresult.pending.push(proof);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CheckStateEnum.SPENT:\n\t\t\t\t\tresult.spent.push(proof);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n\nexport { Wallet };\n", "import { type Proof } from '../../model/types/proof';\n\nexport type RawTransport = {\n\tt: PaymentRequestTransportType; // type\n\ta: string; // target\n\tg?: string[][]; // tags\n};\n\nexport type RawNUT10Option = {\n\tk: string; // kind\n\td: string; // data\n\tt: string[][]; // tags\n};\n\nexport type RawPaymentRequest = {\n\ti?: string; // id\n\ta?: number; // amount\n\tu?: string; // unit\n\ts?: boolean; // single use\n\tm?: string[]; // mints\n\td?: string; // description\n\tt?: RawTransport[]; // transports\n\tnut10?: RawNUT10Option;\n\tnut26?: boolean; // P2BK\n};\n\nexport type PaymentRequestTransport = {\n\ttype: PaymentRequestTransportType;\n\ttarget: string;\n\ttags?: string[][];\n};\n\nexport enum PaymentRequestTransportType {\n\tPOST = 'post',\n\tNOSTR = 'nostr',\n}\n\nexport type PaymentRequestPayload = {\n\tid?: string;\n\tmemo?: string;\n\tunit: string;\n\tmint: string;\n\tproofs: Proof[];\n};\n\n/**\n * Used to express a spending condition that proofs should be encumbered with.\n */\nexport type NUT10Option = {\n\t/**\n\t * The kind of spending condition.\n\t */\n\tkind: string;\n\t/**\n\t * Expresses the spending condition relative to the kind.\n\t */\n\tdata: string;\n\t/**\n\t * Tags associated with the spending condition for additional data.\n\t */\n\ttags: string[][];\n};\n", "import type { AuthProvider } from './AuthProvider';\nimport request, { type RequestFn } from '../transport';\nimport { joinUrls, hasValidDleq, encodeJsonToBase64, Bytes } from '../utils';\nimport { MintInfo } from '../model/MintInfo';\nimport { OutputData } from '../model/OutputData';\nimport type { MintActiveKeys, MintAllKeysets, Proof } from '../model/types';\nimport { type GetInfoResponse, type BlindAuthMintResponse } from '../mint/types';\nimport { type Logger, NULL_LOGGER } from '../logger';\nimport { type OIDCAuth, type TokenResponse } from './OIDCAuth';\nimport { KeyChain, type Keyset } from '../wallet';\n\nexport type AuthManagerOptions = {\n\t/**\n\t * Hard limit to target when minting BATs in one request. If omitted, we'll read\n\t * `nuts['22'].bat_max_mint` from the mint \"/v1/info\" endpoint.\n\t */\n\tmaxPerMint?: number;\n\t/**\n\t * Desired BAT pool size. Well top-up to min(desiredPoolSize, bat_max_mint) on demand.\n\t */\n\tdesiredPoolSize?: number;\n\t/**\n\t * Custom request fn (e.g. for tests or host env).\n\t */\n\trequest?: RequestFn;\n\t/**\n\t * Logger.\n\t */\n\tlogger?: Logger;\n};\n\ntype StoredTokens = {\n\taccessToken?: string;\n\trefreshToken?: string;\n\t/**\n\t * Epoch timestamp (ms).\n\t */\n\texpiresAt?: number;\n};\n\n/**\n * AuthManager.\n *\n * - Owns CAT lifecycle (stores, optional refresh via attached OIDCAuth)\n * - Mints and serves BATs (NUT-22)\n * - Validates DLEQs for BATs per NUT-12.\n * - Supplies serialized BATs for 'Blind-auth' and CAT for 'Clear-auth'\n */\nexport class AuthManager implements AuthProvider {\n\tprivate readonly mintUrl: string;\n\tprivate readonly req: RequestFn;\n\tprivate readonly logger: Logger;\n\tprivate info?: MintInfo;\n\tprivate lockChain?: Promise<void>;\n\tprivate inflightRefresh?: Promise<void>;\n\tprivate static readonly MIN_VALID_SECS = 30;\n\n\t// Open ID Connect (OIDC)\n\tprivate oidc?: OIDCAuth;\n\tprivate tokens: StoredTokens = {};\n\n\t// Blind Auth Token (BAT) pool\n\tprivate pool: Proof[] = [];\n\tprivate desiredPoolSize = 10;\n\tprivate maxPerMint = 10;\n\n\t// Keychain for 'auth' unit\n\tprivate keychain?: KeyChain;\n\n\tconstructor(mintUrl: string, opts?: AuthManagerOptions) {\n\t\tthis.mintUrl = mintUrl;\n\t\tthis.req = opts?.request ?? request;\n\t\tthis.logger = opts?.logger ?? NULL_LOGGER;\n\t\tthis.desiredPoolSize = Math.max(1, opts?.desiredPoolSize ?? this.desiredPoolSize);\n\t\tthis.maxPerMint = Math.max(1, opts?.maxPerMint ?? this.maxPerMint);\n\t}\n\n\t// ------------------------------\n\t// Public API\n\t// ------------------------------\n\n\t/**\n\t * Attach an OIDCAuth instance so this manager can refresh CATs. Registers a listener to update\n\t * internal CAT/refresh state on new tokens.\n\t */\n\tattachOIDC(oidc: OIDCAuth): this {\n\t\tthis.oidc = oidc;\n\t\tthis.oidc.addTokenListener((t) => this.updateFromOIDC(t));\n\t\treturn this;\n\t}\n\n\tget poolSize(): number {\n\t\treturn this.pool.length;\n\t}\n\tget poolTarget(): number {\n\t\treturn this.desiredPoolSize;\n\t}\n\tget activeAuthKeysetId(): string | undefined {\n\t\ttry {\n\t\t\treturn this.keychain?.getCheapestKeyset().id;\n\t\t} catch {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\tget hasCAT(): boolean {\n\t\treturn !!this.tokens.accessToken;\n\t}\n\n\t// ------------------------------\n\t// AuthProvider (NUT-21, Clear-auth)\n\t// ------------------------------\n\n\tgetCAT(): string | undefined {\n\t\treturn this.tokens.accessToken;\n\t}\n\n\tsetCAT(cat: string | undefined): void {\n\t\tthis.tokens.accessToken = cat;\n\t\tif (!cat) {\n\t\t\tthis.tokens.refreshToken = undefined;\n\t\t\tthis.tokens.expiresAt = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Ensure a valid CAT is available (refresh if expiring soon). Returns a token safe to send right\n\t * now, or undefined if unobtainable.\n\t */\n\tasync ensureCAT(minValidSecs?: number): Promise<string | undefined> {\n\t\tif (this.validForAtLeast(minValidSecs)) {\n\t\t\treturn this.tokens.accessToken;\n\t\t}\n\n\t\tif (!this.oidc || !this.tokens.refreshToken) {\n\t\t\treturn this.tokens.accessToken; // nothing we can do\n\t\t}\n\n\t\t// One refresh at a time\n\t\tif (!this.inflightRefresh) {\n\t\t\tthis.inflightRefresh = (async () => {\n\t\t\t\ttry {\n\t\t\t\t\tconst tok = await this.oidc!.refresh(this.tokens.refreshToken!);\n\t\t\t\t\tthis.updateFromOIDC(tok);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tthis.logger.warn('AuthManager: CAT refresh failed', { err });\n\t\t\t\t} finally {\n\t\t\t\t\tthis.inflightRefresh = undefined;\n\t\t\t\t}\n\t\t\t})();\n\t\t}\n\t\tawait this.inflightRefresh;\n\t\treturn this.validForAtLeast(0) ? this.tokens.accessToken : undefined;\n\t}\n\n\t// Returns true if expiry date is >minValidSecs away\n\tprivate validForAtLeast(minValidSecs: number = AuthManager.MIN_VALID_SECS): boolean {\n\t\tconst { accessToken, expiresAt } = this.tokens;\n\t\tif (!accessToken) return false;\n\t\tif (!expiresAt) return true; // Unknown expiry, allow and rely on server to reject if invalid\n\t\treturn Date.now() + minValidSecs * 1000 < expiresAt;\n\t}\n\n\t// Updates access and refresh tokens in our store, using either the explicit expires_in key or falling back to the JWT expiry.\n\tprivate updateFromOIDC(t: TokenResponse): void {\n\t\tif (!t.access_token) return;\n\t\tconst nowMs = Date.now();\n\t\tthis.tokens.accessToken = t.access_token;\n\t\tif (t.refresh_token) this.tokens.refreshToken = t.refresh_token;\n\t\tif (typeof t.expires_in === 'number' && t.expires_in > 0) {\n\t\t\tthis.tokens.expiresAt = nowMs + t.expires_in * 1000; // Prefer expires_in\n\t\t} else {\n\t\t\t// Fall back to JWT exp, else undefined\n\t\t\tconst expSec = this.parseJwtExpSec(t.access_token);\n\t\t\tthis.tokens.expiresAt = expSec ? expSec * 1000 : undefined;\n\t\t}\n\t\tthis.logger.debug('AuthManager: OIDC tokens updated', { expiresAt: this.tokens.expiresAt });\n\t}\n\n\t// ------------------------------\n\t// AuthProvider (NUT-22, Blind-auth)\n\t// ------------------------------\n\n\t/**\n\t * Ensure there are enough BAT tokens (topping up if needed)\n\t *\n\t * @param minTokens Minimum tokens needed.\n\t */\n\tasync ensure(minTokens: number): Promise<void> {\n\t\tawait this.init();\n\t\tif (this.pool.length >= minTokens) return;\n\t\tconst toTarget = Math.max(this.desiredPoolSize, minTokens);\n\t\tconst batMax = this.getBatMaxMint();\n\t\tconst batch = Math.min(toTarget - this.pool.length, batMax);\n\t\tif (batch <= 0) return;\n\t\tawait this.topUp(batch);\n\t}\n\n\t/**\n\t * Gets a Blind Authentication Token (BAT)\n\t *\n\t * @param {method, path} to Call (not used in our implementation)\n\t * @returns The serialized BAT ready to insert into request header.\n\t */\n\tasync getBlindAuthToken({\n\t\tmethod,\n\t\tpath,\n\t}: {\n\t\tmethod: 'GET' | 'POST';\n\t\tpath: string;\n\t}): Promise<string> {\n\t\tif (this.info && !this.info.requiresBlindAuthToken(method, path)) {\n\t\t\tthis.logger.warn('Endpoint is not marked as protected by NUT-22; still issuing BAT', {\n\t\t\t\tmethod,\n\t\t\t\tpath,\n\t\t\t});\n\t\t}\n\n\t\treturn this.withLock(async () => {\n\t\t\tawait this.ensure(1);\n\t\t\tif (this.pool.length === 0) {\n\t\t\t\tthrow new Error('AuthManager: no BATs available and minting failed');\n\t\t\t}\n\t\t\t// Pop one BAT and serialize without DLEQ for the header. Per NUT-22, wallets\n\t\t\t// SHOULD delete BAT even on error, so no need to track it in-flight.\n\t\t\tconst proof = this.pool.pop()!;\n\t\t\tthis.logger.debug('AuthManager: BAT requested', {\n\t\t\t\tmethod,\n\t\t\t\tpath,\n\t\t\t\tremaining: this.pool.length,\n\t\t\t});\n\t\t\treturn serializeBAT(proof);\n\t\t});\n\t}\n\n\t/**\n\t * Replace or merge the current BAT pool with previously persisted BATs.\n\t */\n\timportPool(proofs: Proof[], mode: 'replace' | 'merge' = 'replace'): void {\n\t\tif (mode === 'replace') {\n\t\t\tthis.pool = [];\n\t\t}\n\t\tconst seen = new Map(this.pool.map((p) => [p.secret, p]));\n\t\tfor (const p of proofs) {\n\t\t\tif (!p || !p.secret || !p.C || !p.id) continue; // shape check\n\t\t\tif (!seen.has(p.secret)) {\n\t\t\t\tthis.pool.push(p);\n\t\t\t\tseen.set(p.secret, p);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Return a deep-copied snapshot of the current BAT pool (full Proofs, including dleq).\n\t */\n\texportPool(): Proof[] {\n\t\treturn this.pool.map((p) => ({ ...p, dleq: p.dleq ? { ...p.dleq } : undefined }));\n\t}\n\n\t// ------------------------------\n\t// Internals\n\t// ------------------------------\n\n\t/**\n\t * Extract exp, seconds since epoch, from a JWT access token.\n\t */\n\tprivate parseJwtExpSec(token?: string): number | undefined {\n\t\tif (!token) return;\n\t\tconst parts = token.split('.');\n\t\tif (parts.length !== 3) return;\n\t\ttry {\n\t\t\tconst jsonStr = Bytes.toString(Bytes.fromBase64(parts[1]));\n\t\t\tconst obj = JSON.parse(jsonStr) as { exp?: unknown };\n\t\t\tconst exp = typeof obj.exp === 'number' ? obj.exp : Number(obj.exp);\n\t\t\tif (Number.isFinite(exp) && exp > 0) return exp;\n\t\t} catch {\n\t\t\tthis.logger.warn('JWT access token was malformed.', {\n\t\t\t\ttoken,\n\t\t\t});\n\t\t}\n\t\treturn;\n\t}\n\n\t/**\n\t * Simple mutex lock - chains promises in order.\n\t */\n\tprivate async withLock<T>(fn: () => T | Promise<T>): Promise<T> {\n\t\tconst prev = this.lockChain ?? Promise.resolve();\n\t\tlet release!: () => void;\n\t\tconst lock = new Promise<void>((resolve) => {\n\t\t\trelease = resolve;\n\t\t});\n\t\tconst chain = prev.then(() => lock); // capture the exact Promise we assign\n\t\tthis.lockChain = chain;\n\t\ttry {\n\t\t\tawait prev;\n\t\t\treturn await fn();\n\t\t} finally {\n\t\t\trelease();\n\t\t\t// Only clear if no newer chain has been installed\n\t\t\tif (this.lockChain === chain) this.lockChain = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Initialise mint info and auth keysets/keys as needed.\n\t */\n\tprivate async init(): Promise<void> {\n\t\tif (!this.info) {\n\t\t\tconst info = await this.req<GetInfoResponse>({\n\t\t\t\tendpoint: joinUrls(this.mintUrl, '/v1/info'),\n\t\t\t\tmethod: 'GET',\n\t\t\t});\n\t\t\tthis.info = new MintInfo(info);\n\t\t}\n\t\tif (!this.keychain) {\n\t\t\t// fetch blind keysets and keys for unit 'auth'\n\t\t\tconst [allKeysets, allKeys] = await Promise.all([\n\t\t\t\tthis.req<MintAllKeysets>({\n\t\t\t\t\tendpoint: joinUrls(this.mintUrl, '/v1/auth/blind/keysets'),\n\t\t\t\t\tmethod: 'GET',\n\t\t\t\t}),\n\t\t\t\tthis.req<MintActiveKeys>({\n\t\t\t\t\tendpoint: joinUrls(this.mintUrl, '/v1/auth/blind/keys'),\n\t\t\t\t\tmethod: 'GET',\n\t\t\t\t}),\n\t\t\t]);\n\t\t\t// build a KeyChain preloaded with caches, unit 'auth'\n\t\t\t// Then smoke test to surface errors early - no need to init() with cached keys\n\t\t\tthis.keychain = new KeyChain(this.mintUrl, 'auth', allKeysets.keysets, allKeys.keysets);\n\t\t\tthis.keychain.getCheapestKeyset();\n\t\t}\n\t}\n\n\t/**\n\t * Gets the BAT minting limit: lower of manager limit and Mints NUT-22 limit.\n\t */\n\tprivate getBatMaxMint(): number {\n\t\tif (!this.info) throw new Error('AuthManager: mint info not loaded');\n\t\tconst n22 = this.info.nuts['22'];\n\t\tconst mintMax = n22?.bat_max_mint ?? this.maxPerMint;\n\t\treturn Math.max(1, Math.min(this.maxPerMint, mintMax));\n\t}\n\n\tprivate getActiveKeys(): Keyset {\n\t\tif (!this.keychain) throw new Error('AuthManager: keyset not loaded for active keyset');\n\t\treturn this.keychain.getCheapestKeyset();\n\t}\n\n\t/**\n\t * Mint a batch of BATs using the current CAT if the endpoint is protected by NUT-21.\n\t */\n\tprivate async topUp(n: number): Promise<void> {\n\t\tif (!this.info) throw new Error('AuthManager: mint info not loaded');\n\n\t\t// Check NUT-21 protection of the BAT mint endpoint\n\t\tconst needsCAT = this.info.requiresClearAuthToken('POST', '/v1/auth/blind/mint');\n\t\tlet cat: string | undefined;\n\t\tif (needsCAT) {\n\t\t\tcat = await this.ensureCAT();\n\t\t\tif (!cat) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'AuthManager: Clear-auth token required for /v1/auth/blind/mint but not available. Authenticate with the mint to obtain a CAT first.',\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\t// Create blinded messages for amount n in unit 'auth' (supports only 1s)\n\t\tconst keys = this.getActiveKeys();\n\t\tconst outputs = OutputData.createRandomData(n, keys);\n\t\tconst payload = { outputs: outputs.map((d) => d.blindedMessage) };\n\t\t// Set CAT header if needed\n\t\tconst headers: Record<string, string> = {};\n\t\tif (cat) headers['Clear-auth'] = cat;\n\t\t// Do the topup\n\t\tconst res = await this.req<BlindAuthMintResponse>({\n\t\t\tendpoint: joinUrls(this.mintUrl, '/v1/auth/blind/mint'),\n\t\t\tmethod: 'POST',\n\t\t\theaders,\n\t\t\trequestBody: payload as unknown as Record<string, unknown>,\n\t\t});\n\t\tif (!Array.isArray(res?.signatures) || res.signatures.length !== outputs.length) {\n\t\t\tthrow new Error('AuthManager: bad BAT mint response');\n\t\t}\n\t\t// Create BAT proofs and check DLEQ\n\t\tconst proofs = outputs.map((d, i) => d.toProof(res.signatures[i], keys));\n\t\tfor (const p of proofs) {\n\t\t\tif (!hasValidDleq(p, keys)) {\n\t\t\t\tthrow new Error('AuthManager: mint returned BAT with invalid DLEQ');\n\t\t\t}\n\t\t}\n\t\t// Add BAT proofs to pool\n\t\tthis.pool.push(...proofs);\n\t\tthis.logger.debug('AuthManager: performed topUp', {\n\t\t\tminted: proofs.length,\n\t\t\tpool: this.pool.length,\n\t\t});\n\t}\n}\n\n// ------------------------------\n// Helpers\n// ------------------------------\n\n/**\n * Serialize an Auth Proof as a BAT header value: \"authA\" + base64(JSON_without_dleq)\n */\nfunction serializeBAT(proof: Proof): string {\n\t// strip dleq per NUT-22\n\tconst token = { id: proof.id, secret: proof.secret, C: proof.C };\n\tconst base64Data = encodeJsonToBase64(token);\n\treturn `authA${base64Data}`;\n}\n", "import { type Logger } from '../logger';\nimport { Mint } from '../mint/Mint';\nimport { Wallet } from '../wallet/Wallet';\nimport { AuthManager } from './AuthManager';\nimport type { OIDCAuth, OIDCAuthOptions } from './OIDCAuth';\n\n/**\n * High-level helper to create a fully authenticated wallet session.\n *\n * @remarks\n * Like a dependency injector, it wires AuthManager->Mint->OIDCAuth->Wallet in the correct order.\n * Wallet is returned ready to use.\n * @param mintUrl URL of the mint to connect to.\n * @param options.authPool Optional. Desired BAT pool size (default 10)\n * @param options.oidc Optional. Options for OIDCAuth (scope, clientId, logger, etc.)\n * @returns {mint, auth, oidc, wallet}  hydrated, ready to use.\n * @throws If mint does not require authentication.\n */\nexport async function createAuthWallet(\n\tmintUrl: string,\n\toptions?: {\n\t\tauthPool?: number;\n\t\toidc?: OIDCAuthOptions;\n\t\tlogger?: Logger;\n\t},\n): Promise<{ mint: Mint; auth: AuthManager; oidc: OIDCAuth; wallet: Wallet }> {\n\t// 1. Create an AuthManager for both BAT and CAT handling\n\tconst auth = new AuthManager(mintUrl, {\n\t\tdesiredPoolSize: options?.authPool ?? 10,\n\t\tlogger: options?.logger,\n\t});\n\n\t// 2. Create a Mint instance using the AuthManager\n\tconst mint = new Mint(mintUrl, { authProvider: auth, logger: options?.logger });\n\n\t// 3. Discover and configure OIDCAuth from the mint\n\tconst oidc = await mint.oidcAuth({\n\t\t...options?.oidc,\n\t\tlogger: options?.logger,\n\t\tonTokens: (t) => auth.setCAT(t.access_token), // set CAT automatically\n\t});\n\n\t// 4. Attach OIDCAuth back into AuthManager for refresh, etc.\n\tauth.attachOIDC(oidc);\n\n\t// 5. Hydrate wallet using the same mint and auth provider\n\tconst wallet = new Wallet(mint, { authProvider: auth, logger: options?.logger });\n\tawait wallet.loadMint();\n\n\treturn { mint, auth, oidc, wallet };\n}\n"],
  "mappings": "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",
  "names": ["_", "hex", "isLE", "_32n", "le", "G", "num", "hex", "hex", "fn", "_0n", "_1n", "_0n", "_1n", "gcd", "tn", "Q", "num", "_0n", "_1n", "_1n", "isLE", "_0n", "_1n", "num", "isLE", "num", "_1n", "_0n", "_1n", "W", "Point", "wbits", "isLE", "_0n", "Fn", "num", "_2n", "_0n", "_1n", "hex", "rs", "ss", "_3n", "_4n", "Fn", "pointToBytes", "L", "Point", "X", "endo", "Q", "tv5", "c1", "c2", "randomBytes", "hmac", "r", "s", "is", "Fn", "Point", "L", "xn", "yn", "createHasher", "Point", "num", "N", "_0n", "_1n", "_2n", "_3n", "Fn", "createHasher", "K", "T", "_", "L", "isBytes", "abytes", "anumber", "fn", "padding", "num", "re", "alphabet", "abytes", "sha256", "isBytes", "hasHexBuiltin", "abytes", "num", "MeltQuoteState", "MintQuoteState", "HttpResponseError", "message", "status", "NetworkError", "MintOperationError", "code", "detail", "NULL_LOGGER", "fail", "logger", "context", "failIf", "condition", "failIfNullish", "value", "safeCallback", "cb", "payload", "maybePromise", "error", "LEVEL_ORDER", "ConsoleLogger", "minLevel", "level", "ctx", "out", "k", "v", "line", "fn", "msg", "measureTime", "start", "globalRequestOptions", "requestLogger", "setGlobalRequestOptions", "options", "setRequestLogger", "_request", "endpoint", "requestBody", "requestHeaders", "body", "headers", "response", "err", "errorData", "errorMessage", "request", "_WS", "injectWebSocketImpl", "ws", "getWebSocketImpl", "Bytes", "hex", "matches", "byte", "bytes", "str", "arrays", "totalLength", "sum", "arr", "result", "offset", "size", "buffer", "i", "chunk", "base64", "normalizedBase64", "c", "a", "b", "minLength", "encodeUint8toBase64Url", "encodeBase64toUint8", "base64String", "encodeJsonToBase64", "jsonObj", "jsonString", "base64urlFromBase64", "encodeBase64ToJson", "base64urlToBase64", "isBase64String", "base64url", "normalized", "padLength", "padded", "decoded", "reStandard", "reUrl", "originalNoPad", "isResultKeyType", "encodeCBOR", "encodeItem", "encodeNumber", "encodeString", "encodeArray", "encodeByteString", "encodeObject", "encodeUnsigned", "encodeSigned", "unsigned", "encodeFloat64", "ab", "dv", "length", "utf8", "item", "keys", "key", "decodeCBOR", "data", "view", "decodeItem", "initialByte", "majorType", "additionalInfo", "decodeUnsigned", "decodeSigned", "decodeByteString", "decodeString", "decodeArray", "decodeMap", "decodeSimpleAndFloat", "ensureAvailable", "needed", "decodeLength", "hi", "lo", "newOffset", "array", "currentOffset", "map", "keyResult", "valueResult", "decodeFloat16", "uint16", "exponent", "fraction", "sign", "P2BK_DST", "utf8ToBytes", "deriveP2BKBlindedPubkeys", "pubkeys", "keysetId", "eBytes", "secp256k1", "e", "E", "kid", "hexToBytes", "pubkey", "P", "pointFromHex", "r", "deriveP2BKBlindingTweakFromECDH", "P_", "bytesToHex", "deriveP2BKSecretKeys", "Ehex", "privateKey", "blindPubKey", "keysetIdHex", "privs", "pubs", "privHex", "p", "hexP_", "kHex", "deriveP2BKSecretKey", "privkey", "rBlind", "blindPubkey", "naturalPub", "n", "hexToNumber", "skStd", "skNeg", "numberToHexPadded64", "R", "xP", "xNaturalPub", "yP", "yNaturalPub", "point", "scalar", "slotIndex", "Zx", "iByte", "bytesToNumber", "sha256", "createP2PKsecret", "newSecret", "randomBytes", "parseP2PKSecret", "secret", "signP2PKSecret", "msghash", "sig", "schnorr", "signBlindedMessage", "B_", "msgHash", "verifyP2PKSecretSignature", "signature", "pubkeyX", "hasP2PKSignedProof", "proof", "getP2PKWitnessSignatures", "getP2PKExpectedKWitnessPubkeys", "secretStr", "now", "getP2PKLocktime", "getP2PKWitnessPubkeys", "getP2PKWitnessRefundkeys", "tags", "pubkeysTag", "tag", "refundTag", "locktimeTag", "getP2PKNSigs", "n_sigsTag", "n_sigs_refundTag", "getP2PKSigFlag", "sigFlagTag", "witness", "signP2PKProofs", "proofs", "index", "privateKeys", "maybeDeriveP2BKPrivateKeys", "signedProof", "priv", "signP2PKProof", "parsed", "witnesses", "w", "signatures", "verifyP2PKSig", "parsedSecret", "signatories", "requiredSigs", "verifyP2PKSigOutput", "output", "publicKey", "getSignedOutput", "getSignedOutputs", "outputs", "o", "DOMAIN_SEPARATOR", "hashToCurve", "msgToHash", "counter", "maxIterations", "counterBytes", "hash", "hash_e", "e_", "pointFromBytes", "getKeysetIdInt", "keysetIdInt", "createRandomSecretKey", "createBlindSignature", "amount", "id", "createRandomBlindedMessage", "blindMessage", "Y", "rG", "unblindSignature", "C_", "A", "constructProofFromPromise", "promise", "C", "serializeProof", "deserializeProof", "DERIVATION_PATH", "serializeMintKeys", "mintKeys", "serializedMintKeys", "deserializeMintKeys", "getPubKeyFromPrivKey", "privKey", "createNewMintKeys", "pow2height", "seed", "pubKeys", "privKeys", "masterKey", "HDKey", "deriveKeysetId", "verifyProof", "STANDARD_DERIVATION_PATH", "deriveSecret", "isValidHex", "derive_deprecated", "derive", "deriveBlindingFactor", "secretOrBlinding", "hmac", "hdkey", "derivationPath", "derived", "arraysEqual", "arr1", "arr2", "verifyDLEQProof", "dleq", "sG", "eA", "sB_", "eC_", "R_1", "R_2", "verifyDLEQProof_reblind", "bG", "createDLEQProof", "scalar_a", "scalar_e", "s_scalar", "numberToBytesBE", "constructMessage", "quote", "blindedMessages", "blindedMessage", "msgbytes", "signMintQuote", "privkeyBytes", "verifyMintQuoteSignature", "sigbytes", "pubkeyBytes", "PaymentRequest", "transport", "unit", "mints", "description", "singleUse", "nut10", "nut26", "rawRequest", "t", "type", "rawPaymentRequest", "transports", "encodedRequest", "encodedData", "splitAmount", "keyset", "split", "order", "totalSplitAmount", "sumArray", "positive", "amt", "totalPositive", "hasCorrespondingKey", "sortedKeyAmounts", "getKeysetAmounts", "requireCount", "getKeepAmounts", "proofsWeHave", "amountToKeep", "targetCount", "amountsWeWant", "amountsWeHave", "countWeHave", "countWeWant", "amountDiff", "number", "hasNonHexId", "bigIntStringify", "_key", "getEncodedTokenV3", "token", "removeDleq", "convertToShortKeysetId", "stripDleq", "v3TokenObj", "newP", "getEncodedToken", "opts", "getEncodedTokenV4", "tokenTemplate", "templateFromToken", "prefix", "version", "base64Data", "idMap", "mint", "tokenFromTemplate", "template", "decodedToken", "getDecodedToken", "tokenString", "keysets", "removePrefix", "tokenObj", "handleTokens", "mapShortKeysetIds", "getTokenMetadata", "sumProofs", "encodedToken", "parsedV3Token", "entry", "uInt8Token", "tokenData", "expiry", "versionByte", "isDeprecatedBase64", "pubkeysConcat", "pubKey", "prev", "curr", "mergeUInt8Arrays", "hashHex", "a1", "a2", "mergedArray", "sortProofsById", "isObj", "checkResponse", "joinUrls", "parts", "part", "sanitizeUrl", "url", "acc", "decodePaymentRequest", "paymentRequest", "MessageNode", "node", "MessageQueue", "messageNode", "newNode", "verifyKeysetId", "isBase64", "newProofs", "idBytes", "found", "hasValidDleq", "concatByteArrays", "byteArray", "pointer", "getEncodedTokenBinary", "utf8Encoder", "binaryTemplate", "getDecodedTokenBinary", "utfDecoder", "binaryToken", "deepEqual", "keysA", "keysB", "ConnectionManager", "newConn", "WSConnection", "resolve", "reject", "method", "params", "subId", "callback", "errorCallback", "notification", "handleMeltQuoteResponseDeprecated", "handleMintQuoteResponseDeprecated", "handleMintInfoContactFieldDeprecated", "contact", "MintInfo", "info", "pe22", "pe21", "num", "path", "idx", "cacheKey", "cached", "exactHit", "regexHit", "res", "mintMeltInfo", "maybe", "rec", "mm", "pp", "endpoints", "exact", "regex", "metachar", "met", "OIDCAuth", "discoveryUrl", "n21", "clientId", "scope", "text", "json", "cfg", "rnd", "verifier", "vBytes", "chBytes", "challenge", "input", "form", "tok", "ep", "device_code", "intervalSec", "delay", "interval", "aborted", "refresh_token", "username", "password", "listener", "enc", "formBody", "ms", "Mint", "mintUrl", "customRequest", "swapPayload", "errDetail", "mintQuotePayload", "mintPayload", "meltQuotePayload", "meltPayload", "checkPayload", "targetUrl", "restorePayload", "wsSegment", "bat", "init", "requestInstance", "cat", "Keyset", "active", "input_fee_ppk", "final_expiry", "KeyChain", "cachedKeysets", "cachedKeys", "arrayOfKeys", "forceRefresh", "allKeysetsResponse", "allKeysResponse", "allKeysets", "allKeys", "keysMap", "mk", "activeKeysets", "BlindedMessage", "RESERVED_P2PK_TAGS", "assertValidTagKey", "MAX_SECRET_LENGTH", "EPHEMERAL_E", "setEphemeralE", "target", "takeEphemeralE", "OutputData", "blindingFactor", "blindSignature", "serializedProof", "p2pk", "customSplit", "lockKeys", "refundKeys", "reqLock", "reqRefund", "refund", "ordered", "blinded", "_E", "ts", "vals", "charCount", "secretBytes", "od", "randomHex", "secretBytesAsHex", "utf8SecretBytes", "deterministicR", "normalisePubkey", "pk", "toUnixSeconds", "P2PKBuilder", "when", "values", "locks", "refunds", "total", "selectProofsRGLI", "amountToSend", "keyChain", "includeFees", "exactMatch", "_logger", "timer", "bestSubset", "bestDelta", "bestAmount", "bestFeePPK", "feeForProof", "sumExFees", "feePPK", "shuffleArray", "shuffled", "j", "binarySearchIndex", "lessOrEqual", "left", "right", "mid", "midValue", "insertSorted", "obj", "calculateDelta", "totalAmount", "totalFeePPK", "proofWithFees", "ppkfee", "exFee", "spendableProofs", "endIndex", "rightIndex", "biggerIndex", "nextBiggerExFee", "totalNetSum", "maxOverAmount", "trial", "S", "newAmount", "newFeePPK", "netSum", "SSet", "others", "indices", "_", "objP", "tempAmount", "tempFeePPK", "tempNetSum", "qIndex", "objQ", "delta", "tempS", "tempDelta", "bestSum", "bestProofs", "bestSubsetSet", "keep", "EphemeralCounterSource", "initial", "release", "chain", "cur", "minNext", "next", "WalletOps", "wallet", "SendBuilder", "ReceiveBuilder", "MintBuilder", "MeltBuilder", "denoms", "factory", "on", "requireDleq", "outputConfig", "bolt11", "bolt12", "safeStringify", "seen", "_k", "normalizeError", "makeAbortError", "cancelSafely", "WalletEvents", "signal", "cancel", "onAbort", "subscribeFn", "timeoutMsg", "cancelP", "to", "cleanup", "h", "ids", "uniq", "proofMap", "y", "ys", "handler", "unique", "cancels", "lastError", "fullyRegistered", "quoteId", "thisCanceller", "queue", "done", "notify", "max", "dropMode", "wake", "push", "dropped", "cancelled", "cancelAll", "WalletCounters", "src", "CheckStateEnum", "PENDING_KEYSET_ID", "Wallet", "promises", "totalOutputs", "ot", "outputTypes", "range", "cursor", "patched", "need", "used", "ks", "outputType", "customTotal", "denominations", "receiveFee", "receiveFeeAmounts", "splitSum", "outputData", "inputs", "keepOutputs", "sendOutputs", "mergedBlindingData", "keepVector", "sortedOutputData", "sortedKeepVector", "d", "config", "onCountersReserved", "tokenMintUrl", "netAmount", "receiveOT", "autoCounters", "swapTransaction", "proofsReceived", "orderedProofs", "s", "send", "sendPrepared", "wantsDeterministicByPolicy", "isPlainRandom", "reasons", "expectedFee", "sendOT", "sendAmount", "unselectedProofs", "selectedProofs", "selectedSum", "swapFee", "changeAmount", "keepOT", "keepAmount", "swapProofs", "reorderedProofs", "reorderedKeepVector", "keepProofs", "sendProofs", "sumPPK", "nInputs", "keepDleq", "p2pk_e", "rest", "gapLimit", "batchSize", "requiredEmptyBatches", "restoredProofs", "lastCounterWithSignature", "emptyBatchesFound", "restoreRes", "count", "zeros", "signatureMap", "matchingSig", "supported", "resPubkey", "mintInfo", "baseRes", "mintOT", "mintAmount", "mintQuoteSignature", "invoice", "meltQuote", "offer", "amountMsat", "millisatPartialAmount", "meltOptions", "proofsToSend", "onChangeOutputsCreated", "feeReserve", "meltOT", "blanks", "meltResponse", "preferAsync", "change", "Ys", "BATCH_SIZE", "states", "YsSlice", "batchStates", "stateMap", "state", "PaymentRequestTransportType", "_AuthManager", "oidc", "minValidSecs", "accessToken", "expiresAt", "nowMs", "expSec", "minTokens", "toTarget", "batMax", "batch", "serializeBAT", "mode", "jsonStr", "exp", "lock", "mintMax", "needsCAT", "AuthManager", "createAuthWallet", "auth"]
}
