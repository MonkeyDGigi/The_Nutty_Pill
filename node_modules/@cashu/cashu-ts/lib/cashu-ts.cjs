"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const m=require("@noble/curves/secp256k1"),D=require("@noble/hashes/sha2"),b=require("@noble/curves/utils"),M=require("@noble/hashes/utils"),ke=require("@scure/bip32"),wn=require("@noble/hashes/hmac"),st={UNPAID:"UNPAID",PENDING:"PENDING",PAID:"PAID"},pt={UNPAID:"UNPAID",PAID:"PAID",ISSUED:"ISSUED"};class rt extends Error{constructor(t,e){super(t),this.status=e,this.name="HttpResponseError",Object.setPrototypeOf(this,rt.prototype)}}class vt extends Error{constructor(t){super(t),this.name="NetworkError",Object.setPrototypeOf(this,vt.prototype)}}class At extends rt{constructor(t,e){super(e||"Unknown mint operation error",400),this.code=t,this.name="MintOperationError",Object.setPrototypeOf(this,At.prototype)}}const H={error(){},warn(){},info(){},debug(){},trace(){},log(){}};function St(s,t=H,e){throw t.error(s,e),new Error(s)}function Pe(s,t,e=H,n){s&&St(t,e,n)}function be(s,t,e=H,n){s==null&&St(t,e,n)}function lt(s,t,e=H,n){if(s)try{const r=s(t);r&&typeof r.then=="function"&&r.catch(i=>{try{e.warn("callback failed",{...n??{},error:i,cb:s.name??""})}catch{}})}catch(r){try{e.warn("callback failed",{...n??{},error:r,cb:s.name??""})}catch{}}}const le={error:0,warn:1,info:2,debug:3,trace:4};class kn{constructor(t="info"){this.minLevel=t}should(t){return le[t]<=le[this.minLevel]}method(t){switch(t){case"error":return console.error;case"warn":return console.warn;case"info":return console.info;case"debug":return console.debug;case"trace":return console.trace;default:return console.log}}header(t,e){return`[${t.toUpperCase()}] ${e}`}flattenContext(t){if(!t)return;const e={};for(const[n,r]of Object.entries(t))e[n]=r instanceof Error?{message:r.message,stack:r.stack}:r;return e}emit(t,e,n){if(!this.should(t))return;const r=this.header(t,e),i=this.flattenContext(n),o=this.method(t);i&&Object.keys(i).length?o(r,i):o(r)}error(t,e){this.emit("error",t,e)}warn(t,e){this.emit("warn",t,e)}info(t,e){this.emit("info",t,e)}debug(t,e){this.emit("debug",t,e)}trace(t,e){this.emit("trace",t,e)}log(t,e,n){this.emit(t,e,n)}}function Pn(){const s=Date.now();return{elapsed:()=>Date.now()-s}}let _e={},ve=H;function bn(s){_e=s}function _n(s){ve=s}async function vn({endpoint:s,requestBody:t,headers:e,...n}){const r=t?JSON.stringify(t):void 0,i={Accept:"application/json, text/plain, */*",...r?{"Content-Type":"application/json"}:void 0,...e};let o;try{o=await fetch(s,{body:r,headers:i,...n})}catch(a){throw new vt(a instanceof Error?a.message:"Network request failed")}if(!o.ok){let a;try{a=await o.json()}catch{a={error:"bad response"}}if(o.status===400&&"code"in a&&typeof a.code=="number"&&"detail"in a&&typeof a.detail=="string")throw new At(a.code,a.detail);let c="HTTP request failed";throw"error"in a&&typeof a.error=="string"?c=a.error:"detail"in a&&typeof a.detail=="string"&&(c=a.detail),new rt(c,o.status)}try{return await o.json()}catch(a){throw ve.error("Failed to parse HTTP response",{err:a}),new rt("bad response",o.status)}}async function Ae(s){return await vn({...s,..._e})}let mt;typeof WebSocket<"u"&&(mt=WebSocket);function An(s){mt=s}function Sn(){if(mt===void 0)throw new Error("WebSocket implementation not initialized");return mt}class _{static fromHex(t){if(t=t.trim(),t.length===0)return new Uint8Array(0);if(t.length<2||t.length&1)throw new Error("Invalid hex string: odd length.");if((t.startsWith("0x")||t.startsWith("0X"))&&(t=t.slice(2)),!t.match(/^[0-9a-fA-F]*$/))throw new Error("Invalid hex string: contains non-hex characters");const n=t.match(/.{1,2}/g);if(!n)throw new Error("Invalid hex string");return new Uint8Array(n.map(r=>parseInt(r,16)))}static toHex(t){return Array.from(t,e=>e.toString(16).padStart(2,"0")).join("")}static fromString(t){return t=t.trim(),new TextEncoder().encode(t)}static toString(t){return new TextDecoder("utf-8").decode(t)}static concat(...t){const e=t.reduce((i,o)=>i+o.length,0),n=new Uint8Array(e);let r=0;for(const i of t)n.set(i,r),r+=i.length;return n}static alloc(t){return new Uint8Array(t)}static writeBigUint64BE(t){const e=new ArrayBuffer(8);return new DataView(e).setBigUint64(0,t,!1),new Uint8Array(e)}static toBase64(t){if(typeof Buffer<"u")return Buffer.from(t).toString("base64");if(t.length>32768){let e="";for(let n=0;n<t.length;n+=32768){const r=t.slice(n,n+32768);e+=btoa(String.fromCharCode(...r))}return e}return btoa(String.fromCharCode(...t))}static fromBase64(t){t=t.trim();let e=t.replace(/-/g,"+").replace(/_/g,"/");for(;e.length%4;)e+="=";return typeof Buffer<"u"?new Uint8Array(Buffer.from(e,"base64")):new Uint8Array([...atob(e)].map(n=>n.charCodeAt(0)))}static equals(t,e){if(t.length!==e.length)return!1;let n=0;for(let r=0;r<t.length;r++)n|=t[r]^e[r];return n===0}static compare(t,e){const n=Math.min(t.length,e.length);for(let r=0;r<n;r++){if(t[r]<e[r])return-1;if(t[r]>e[r])return 1}return t.length-e.length}}function Nt(s){return _.toBase64(s).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}function jt(s){return _.fromBase64(s)}function Se(s){const t=JSON.stringify(s);return xn(_.toBase64(_.fromString(t)))}function Tn(s){const t=_.toString(_.fromBase64(En(s)));return JSON.parse(t)}function En(s){return s.replace(/-/g,"+").replace(/_/g,"/").split("=")[0]}function xn(s){return s.replace(/\+/g,"-").replace(/\//g,"_").split("=")[0]}function Qt(s){if(typeof s!="string"||s.length===0)return!1;const t=/^[A-Za-z0-9\-_]+={0,2}$/,e=/^[A-Za-z0-9+/]+={0,2}$/;if(!t.test(s)&&!e.test(s))return!1;const n=s.replace(/-/g,"+").replace(/_/g,"/"),r=(4-n.length%4)%4;if(r>2)return!1;const i=n+"=".repeat(r);try{const o=_.fromBase64(i),a=_.toBase64(o),c=a.replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,""),u=n.replace(/=+$/,"");return a.replace(/=+$/,"")===u||c===u}catch{return!1}}function Mn(s){return typeof s=="number"||typeof s=="string"}function zt(s){const t=[];return Vt(s,t),new Uint8Array(t)}function Vt(s,t){if(s===null)t.push(246);else if(s===void 0)t.push(247);else if(typeof s=="boolean")t.push(s?245:244);else if(typeof s=="number")Kn(s,t);else if(typeof s=="string")Te(s,t);else if(Array.isArray(s))Dn(s,t);else if(s instanceof Uint8Array)On(s,t);else if(typeof s=="object"&&s!==null&&!Array.isArray(s))qn(s,t);else throw new Error("Unsupported type")}function In(s,t){if(s<24)t.push(s);else if(s<256)t.push(24,s);else if(s<65536)t.push(25,s>>>8&255,s&255);else if(s<4294967296)t.push(26,s>>>24&255,s>>>16&255,s>>>8&255,s&255);else throw new Error("Unsupported integer size")}function Bn(s,t){const e=-1-s;if(e<24)t.push(32|e);else if(e<256)t.push(56,e&255);else if(e<65536)t.push(57,e>>>8&255,e&255);else if(e<4294967296)t.push(58,e>>>24&255,e>>>16&255,e>>>8&255,e&255);else throw new Error("Unsupported integer size")}function Cn(s,t){const e=new ArrayBuffer(8),n=new DataView(e);n.setFloat64(0,s,!1),t.push(251);for(let r=0;r<8;r++)t.push(n.getUint8(r))}function Kn(s,t){Number.isInteger(s)?s>=0?In(s,t):Bn(s,t):Cn(s,t)}function On(s,t){const e=s.length;if(e<24)t.push(64+e);else if(e<256)t.push(88,e);else if(e<65536)t.push(89,e>>8&255,e&255);else if(e<4294967296)t.push(90,e>>>24&255,e>>>16&255,e>>>8&255,e&255);else throw new Error("Byte string too long to encode");for(let n=0;n<s.length;n++)t.push(s[n])}function Te(s,t){const e=new TextEncoder().encode(s),n=e.length;if(n<24)t.push(96+n);else if(n<256)t.push(120,n);else if(n<65536)t.push(121,n>>>8&255,n&255);else if(n<4294967296)t.push(122,n>>>24&255,n>>>16&255,n>>>8&255,n&255);else throw new Error("String too long to encode");for(let r=0;r<e.length;r++)t.push(e[r])}function Dn(s,t){const e=s.length;if(e<24)t.push(128|e);else if(e<256)t.push(152,e);else if(e<65536)t.push(153,e>>>8&255,e&255);else throw new Error("Unsupported array length");for(const n of s)Vt(n,t)}function qn(s,t){const e=Object.keys(s),n=e.length;if(n>=4294967296)throw new Error("Object has too many keys to encode");n<24?t.push(160|n):n<256?t.push(184,n):n<65536?t.push(185,n>>8&255,n&255):t.push(186,n>>24&255,n>>16&255,n>>8&255,n&255);for(const r of e)Te(r,t),Vt(s[r],t)}function Gt(s){const t=new DataView(s.buffer,s.byteOffset,s.byteLength);return yt(t,0).value}function yt(s,t){if(t>=s.byteLength)throw new Error("Unexpected end of data");const e=s.getUint8(t++),n=e>>5,r=e&31;switch(n){case 0:return Un(s,t,r);case 1:return Rn(s,t,r);case 2:return Nn(s,t,r);case 3:return Fn(s,t,r);case 4:return Ln(s,t,r);case 5:return Hn(s,t,r);case 7:return Wn(s,t,r);default:throw new Error(`Unsupported major type: ${n}`)}}function V(s,t,e){if(t+e>s.byteLength)throw new Error("Unexpected end of data")}function ot(s,t,e){if(e<24)return{value:e,offset:t};if(e===24)return V(s,t,1),{value:s.getUint8(t++),offset:t};if(e===25){V(s,t,2);const n=s.getUint16(t,!1);return t+=2,{value:n,offset:t}}if(e===26){V(s,t,4);const n=s.getUint32(t,!1);return t+=4,{value:n,offset:t}}if(e===27){V(s,t,8);const n=s.getUint32(t,!1),r=s.getUint32(t+4,!1);return t+=8,{value:n*2**32+r,offset:t}}throw new Error(`Unsupported length: ${e}`)}function Un(s,t,e){const{value:n,offset:r}=ot(s,t,e);return{value:n,offset:r}}function Rn(s,t,e){const{value:n,offset:r}=ot(s,t,e);return{value:-1-n,offset:r}}function Nn(s,t,e){const{value:n,offset:r}=ot(s,t,e);if(r+n>s.byteLength)throw new Error("Byte string length exceeds data length");return{value:new Uint8Array(s.buffer,s.byteOffset+r,n),offset:r+n}}function Fn(s,t,e){const{value:n,offset:r}=ot(s,t,e);if(r+n>s.byteLength)throw new Error("String length exceeds data length");const i=new Uint8Array(s.buffer,s.byteOffset+r,n);return{value:new TextDecoder().decode(i),offset:r+n}}function Ln(s,t,e){const{value:n,offset:r}=ot(s,t,e),i=[];let o=r;for(let a=0;a<n;a++){const c=yt(s,o);i.push(c.value),o=c.offset}return{value:i,offset:o}}function Hn(s,t,e){const{value:n,offset:r}=ot(s,t,e),i={};let o=r;for(let a=0;a<n;a++){const c=yt(s,o);if(!Mn(c.value))throw new Error("Invalid key type");const u=yt(s,c.offset);i[c.value]=u.value,o=u.offset}return{value:i,offset:o}}function $n(s){const t=(s&31744)>>10,e=s&1023,n=s&32768?-1:1;return t===0?n*2**-14*(e/1024):t===31?e?NaN:n*(1/0):n*2**(t-15)*(1+e/1024)}function Wn(s,t,e){if(e<24)switch(e){case 20:return{value:!1,offset:t};case 21:return{value:!0,offset:t};case 22:return{value:null,offset:t};case 23:return{value:void 0,offset:t};default:throw new Error(`Unknown simple value: ${e}`)}if(e===24)return V(s,t,1),{value:s.getUint8(t++),offset:t};if(e===25){V(s,t,2);const n=$n(s.getUint16(t,!1));return t+=2,{value:n,offset:t}}if(e===26){V(s,t,4);const n=s.getFloat32(t,!1);return t+=4,{value:n,offset:t}}if(e===27){V(s,t,8);const n=s.getFloat64(t,!1);return t+=8,{value:n,offset:t}}throw new Error(`Unknown simple or float value: ${e}`)}const Ft=M.utf8ToBytes("Cashu_P2BK_v1");function Ee(s,t,e){if(!s.length)return{blinded:[],Ehex:""};e=e??m.secp256k1.utils.randomSecretKey();const n=m.secp256k1.Point.Fn.fromBytes(e),r=m.secp256k1.getPublicKey(e,!0),i=M.hexToBytes(t);return{blinded:s.map((a,c)=>{const u=G(a),l=Ie(u,n,i,c),h=u.add(m.secp256k1.Point.BASE.multiply(l));if(h.equals(m.secp256k1.Point.ZERO))throw new Error("Blinded key at infinity");return h.toHex(!0)}),Ehex:M.bytesToHex(r)}}function xe(s,t,e,n){const r=Array.isArray(t)?t:[t],i=Array.isArray(e)?e:[e],o=new Set,a=m.secp256k1.Point.fromHex(s),c=M.hexToBytes(n);for(const u of r){const l=m.secp256k1.Point.Fn.fromBytes(M.hexToBytes(u)),h=m.secp256k1.getPublicKey(M.hexToBytes(u),!0);i.forEach((d,p)=>{const y=Ie(a,l,c,p),v=M.hexToBytes(d),A=Me(u,y,v,h);A&&o.add(A)})}return Array.from(o)}function Me(s,t,e,n){const r=m.secp256k1.Point.CURVE().n,i=typeof s=="string"?it(s):s,o=typeof t=="string"?it(t):t;if(i<=0n||i>=r)throw new Error("Invalid private key");if(o<=0n||o>=r)throw new Error("Invalid scalar r");if(n=n??m.secp256k1.Point.BASE.multiply(i).toBytes(!0),n.length!==33)throw new Error("naturalPub must be 33 bytes");const a=(i+o)%r,c=(r-i+o)%r;if(!e){if(a===0n)throw new Error("Derived secret key is zero");return kt(a)}if(e.length!==33)throw new Error("blindPubkey must be 33 bytes");const u=m.secp256k1.Point.fromHex(e),l=m.secp256k1.Point.BASE.multiply(o),h=u.subtract(l);if(h.equals(m.secp256k1.Point.ZERO))return null;const d=h.toBytes(!0).slice(1),p=n.slice(1);if(!_.equals(d,p))return null;const y=h.toBytes(!0)[0]&1,v=n[0]&1,A=y===v?a:c;if(A===0n)throw new Error("Derived secret key is zero");return kt(A)}function Ie(s,t,e,n){const r=s.multiply(t).toBytes(!0).slice(1),i=new Uint8Array([n&255]);let o=L(D.sha256(_.concat(Ft,r,e,i)));if((o===0n||o>=m.secp256k1.Point.CURVE().n)&&(o=L(D.sha256(_.concat(Ft,r,e,i,new Uint8Array([255])))),o===0n||o>=m.secp256k1.Point.CURVE().n))throw new Error("P2BK: tweak derivation failed");return o}const jn=s=>{const t=["P2PK",{nonce:b.bytesToHex(b.randomBytes(32)),data:s}];return JSON.stringify(t)},W=s=>{try{return s instanceof Uint8Array&&(s=new TextDecoder().decode(s)),JSON.parse(s)}catch{throw new Error("can't parse secret")}},Be=(s,t)=>{const e=D.sha256(s),n=m.schnorr.sign(e,t);return b.bytesToHex(n)},Ce=(s,t)=>{const e=D.sha256(s),n=m.schnorr.sign(e,t);return b.bytesToHex(n)},Tt=(s,t,e)=>{try{const n=D.sha256(t),r=e.length===66?e.slice(2):e;if(m.schnorr.verify(s,n,b.hexToBytes(r)))return!0}catch(n){console.error("verifyP2PKsecret error:",n)}return!1},Qn=(s,t)=>t.witness?xt(t.witness).some(n=>{try{return Tt(n,t.secret,s)}catch{return!1}}):!1;function Et(s){try{const t=typeof s=="string"?W(s):s;if(t[0]!=="P2PK")throw new Error('Invalid P2PK secret: must start with "P2PK"');const e=Math.floor(Date.now()/1e3);return Yt(t)>e?Jt(t):Xt(t)}catch{}return[]}function Jt(s){const t=typeof s=="string"?W(s):s;if(t[0]!=="P2PK")throw new Error('Invalid P2PK secret: must start with "P2PK"');const{data:e,tags:n}=t[1],r=n&&n.find(o=>o[0]==="pubkeys"),i=r&&r.length>1?r.slice(1):[];return[e,...i].filter(Boolean)}function Xt(s){const t=typeof s=="string"?W(s):s;if(t[0]!=="P2PK")throw new Error('Invalid P2PK secret: must start with "P2PK"');const{tags:e}=t[1],n=e&&e.find(r=>r[0]==="refund");return n&&n.length>1?n.slice(1).filter(Boolean):[]}function Yt(s){const t=typeof s=="string"?W(s):s;if(t[0]!=="P2PK")throw new Error('Invalid P2PK secret: must start with "P2PK"');const{tags:e}=t[1],n=e&&e.find(r=>r[0]==="locktime");return n&&n.length>1?parseInt(n[1],10):1/0}function Ke(s){const t=typeof s=="string"?W(s):s;if(t[0]!=="P2PK")throw new Error('Invalid P2PK secret: must start with "P2PK"');if(!Et(t).length)return 0;const{tags:n}=t[1],r=Math.floor(Date.now()/1e3);if(Yt(t)>r){const a=n&&n.find(c=>c[0]==="n_sigs");return a&&a.length>1?parseInt(a[1],10):1}const o=n&&n.find(a=>a[0]==="n_sigs_refund");return o&&o.length>1?parseInt(o[1],10):1}function zn(s){const t=typeof s=="string"?W(s):s;if(t[0]!=="P2PK")throw new Error('Invalid P2PK secret: must start with "P2PK"');const{tags:e}=t[1],n=e&&e.find(r=>r[0]==="sigflag");return n&&n.length>1?n[1]:"SIG_INPUTS"}const xt=s=>{if(!s)return[];if(typeof s=="string")try{return JSON.parse(s).signatures||[]}catch(t){return console.error("Failed to parse witness string:",t),[]}return s.signatures||[]},Oe=(s,t,e=H)=>s.map((n,r)=>{try{const i=qe(t,n);let o=n;for(const a of i)try{o=De(o,a)}catch(c){const u=c instanceof Error?c.message:"Unknown error";e.warn(`Proof #${r+1}: ${u}`)}return o}catch(i){const o=i instanceof Error?i.message:"Unknown error";throw e.error(`Proof #${r+1}: ${o}`),new Error(`Failed signing proof #${r+1}: ${o}`)}}),De=(s,t)=>{const e=W(s.secret);if(e[0]!=="P2PK")throw new Error("not a P2PK secret");const n=b.bytesToHex(m.schnorr.getPublicKey(t)),r=Et(e);if(!r.length||!r.some(c=>c.includes(n)))throw new Error(`Signature not required from [02|03]${n}`);const i=xt(s.witness);if(i.some(c=>{try{return Tt(c,s.secret,n)}catch{return!1}}))throw new Error(`Proof already signed by [02|03]${n}`);const a=Be(s.secret,t);return{...s,witness:{signatures:[...i,a]}}},Vn=s=>{if(!s.witness)throw new Error("could not verify signature, no witness provided");const t=W(s.secret),e=Et(t);if(!e.length)throw new Error("no signatures required, proof is unlocked");let n=0;const r=Ke(t),i=xt(s.witness);for(const o of e)i.some(c=>{try{return Tt(c,s.secret,o)}catch{return!1}})&&n++;return n>=r},Gn=(s,t)=>{if(!s.witness?.signatures||s.witness.signatures.length===0)throw new Error("could not verify signature, no witness signatures provided");return m.schnorr.verify(s.witness.signatures[0],D.sha256(s.B_.toHex(!0)),t.slice(2))},Zt=(s,t)=>{const e=s.B_.toHex(!0),n=Ce(e,t);return s.witness={signatures:[n]},s},Jn=(s,t)=>s.map(e=>Zt(e,t));function qe(s,t){const e=Array.isArray(s)?s:[s],n=t?.p2pk_e;if(!n)return Array.from(new Set(e));const r=W(t.secret),i=[...Jt(r),...Xt(r)],o=t.id;return xe(n,e,i,o)}const Xn=b.hexToBytes("536563703235366b315f48617368546f43757276655f43617368755f");function at(s){const t=D.sha256(_.concat(Xn,s)),e=new Uint32Array(1),n=2**16;for(let r=0;r<n;r++){const i=new Uint8Array(e.buffer),o=D.sha256(_.concat(t,i));try{return G(b.bytesToHex(_.concat(new Uint8Array([2]),o)))}catch{e[0]++}}throw new Error("No valid point found")}function te(s){const e=s.map(n=>n.toHex(!1)).join("");return D.sha256(new TextEncoder().encode(e))}function Yn(s){return m.secp256k1.Point.fromHex(b.bytesToHex(s))}function G(s){return m.secp256k1.Point.fromHex(s)}const Ue=s=>{let t;return/^[a-fA-F0-9]+$/.test(s)?t=it(s)%BigInt(2**31-1):t=L(jt(s))%BigInt(2**31-1),t};function ee(){return m.secp256k1.utils.randomSecretKey()}function Zn(s,t,e,n){return{C_:s.multiply(L(t)),amount:e,id:n}}function ts(s){return ht(b.randomBytes(32),L(m.secp256k1.utils.randomSecretKey()),s)}function ht(s,t,e){const n=at(s);t||(t=L(m.secp256k1.utils.randomSecretKey()));const r=m.secp256k1.Point.BASE.multiply(t),i=n.add(r);return e!==void 0?Zt({B_:i,r:t,secret:s},e):{B_:i,r:t,secret:s}}function Re(s,t,e){return s.subtract(e.multiply(t))}function Ne(s,t,e,n){const r=n,i=Re(s.C_,t,r);return{id:s.id,amount:s.amount,secret:e,C:i}}const Fe=s=>({amount:s.amount,C:s.C.toHex(!0),id:s.id,secret:new TextDecoder().decode(s.secret),witness:JSON.stringify(s.witness)}),es=s=>({amount:s.amount,C:G(s.C),id:s.id,secret:new TextEncoder().encode(s.secret),witness:s.witness?JSON.parse(s.witness):void 0}),de="m/0'/0'/0'";function Le(s){const t={};return Object.keys(s).forEach(e=>{t[e]=b.bytesToHex(s[e])}),t}function ns(s){const t={};return Object.keys(s).forEach(e=>{t[e]=b.hexToBytes(s[e])}),t}function He(s){return m.secp256k1.getPublicKey(s,!0)}function ss(s,t){let e=0n;const n={},r={};let i;for(t&&(i=ke.HDKey.fromMasterSeed(t));e<s;){const a=(2n**e).toString();if(i){const c=i.derive(`${de}/${e}`).privateKey;if(c)r[a]=c;else throw new Error(`Could not derive Private key from: ${de}/${e}`)}else r[a]=ee();n[a]=He(r[a]),e++}const o=Bt(Le(n));return{pubKeys:n,privKeys:r,keysetId:o}}function rs(s,t){return at(s.secret).multiply(L(t)).equals(s.C)}const is="m/129372'/0'",$e=(s,t,e)=>{const n=/^[a-fA-F0-9]+$/.test(t);if(!n&&Qt(t)||n&&t.startsWith("00"))return wt(s,t,e,0);if(n&&t.startsWith("01"))return je(s,t,e,0);throw new Error(`Unrecognized keyset ID version ${t.slice(0,2)}`)},We=(s,t,e)=>{const n=/^[a-fA-F0-9]+$/.test(t);if(!n&&Qt(t)||n&&t.startsWith("00"))return wt(s,t,e,1);if(n&&t.startsWith("01"))return je(s,t,e,1);throw new Error(`Unrecognized keyset ID version ${t.slice(0,2)}`)},je=(s,t,e,n)=>{let r=_.concat(_.fromString("Cashu_KDF_HMAC_SHA256"),_.fromHex(t),_.writeBigUint64BE(BigInt(e)));switch(n){case 0:r=_.concat(r,_.fromHex("00"));break;case 1:r=_.concat(r,_.fromHex("01"))}return wn.hmac(D.sha256,s,r)},wt=(s,t,e,n)=>{const r=ke.HDKey.fromMasterSeed(s),i=Ue(t),o=`${is}/${i}'/${e}'/${n}`,a=r.derive(o);if(a.privateKey===null)throw new Error("Could not derive private key");return a.privateKey};function os(s,t){if(s.length!==t.length)return!1;for(let e=0;e<s.length;e++)if(s[e]!==t[e])return!1;return!0}const Qe=(s,t,e,n)=>{const r=m.secp256k1.Point.BASE.multiply(m.secp256k1.Point.Fn.fromBytes(s.s)),i=n.multiply(L(s.e)),o=t.multiply(L(s.s)),a=e.multiply(L(s.e)),c=r.subtract(i),u=o.subtract(a),l=te([c,u,n,e]);return os(l,s.e)},ze=(s,t,e,n)=>{if(t.r===void 0)throw new Error("verifyDLEQProof_reblind: Undefined blinding factor");const r=at(s),i=e.add(n.multiply(t.r)),o=m.secp256k1.Point.BASE.multiply(t.r),a=r.add(o);return Qe(t,a,i,n)},as=(s,t)=>{const e=m.secp256k1.Point.Fn.fromBytes(ee()),n=m.secp256k1.Point.BASE.multiply(e),r=s.multiply(e),i=m.secp256k1.Point.Fn.fromBytes(t),o=s.multiply(i),a=m.secp256k1.Point.BASE.multiply(i),c=te([n,r,a,o]),u=m.secp256k1.Point.Fn.fromBytes(c),l=m.secp256k1.Point.Fn.add(e,m.secp256k1.Point.Fn.mul(u,i));return{s:b.numberToBytesBE(l,32),e:c}};function Ve(s,t){let e=s;for(const r of t)e+=r.B_;const n=new TextEncoder().encode(e);return D.sha256(n)}function Ge(s,t,e){const n=Ve(t,e),r=M.hexToBytes(s),i=m.schnorr.sign(n,r);return M.bytesToHex(i)}function cs(s,t,e,n){const r=M.hexToBytes(n);let i=M.hexToBytes(s);if(i.length!==33)return!1;i=i.slice(1);const o=Ve(t,e);return m.schnorr.verify(r,o,i)}class Mt{constructor(t,e,n,r,i,o,a=!1,c,u=!1){this.transport=t,this.id=e,this.amount=n,this.unit=r,this.mints=i,this.description=o,this.singleUse=a,this.nut10=c,this.nut26=u}toRawRequest(){const t={};return this.transport&&(t.t=this.transport.map(e=>({t:e.type,a:e.target,g:e.tags}))),this.id&&(t.i=this.id),this.amount&&(t.a=this.amount),this.unit&&(t.u=this.unit),this.mints&&(t.m=this.mints),this.description&&(t.d=this.description),this.singleUse&&(t.s=this.singleUse),this.nut10&&(t.nut10={k:this.nut10.kind,d:this.nut10.data,t:this.nut10.tags}),this.nut26&&(t.nut26=this.nut26),t}toEncodedRequest(){const t=this.toRawRequest(),e=zt(t);return"creqA"+_.toBase64(e)}getTransport(t){return this.transport?.find(e=>e.type===t)}static fromRawRequest(t){const e=t.t?t.t.map(r=>({type:r.t,target:r.a,tags:r.g})):void 0,n=t.nut10?{kind:t.nut10.k,data:t.nut10.d,tags:t.nut10.t}:void 0;return new Mt(e,t.i,t.a,t.u,t.m,t.d,t.s,n,t.nut26)}static fromEncodedRequest(t){if(!t.startsWith("creq"))throw new Error("unsupported pr: invalid prefix");if(t[4]!=="A")throw new Error("unsupported pr version");const n=t.slice(5),r=jt(n),i=Gt(r);return this.fromRawRequest(i)}}function Q(s,t,e,n){if(e){const i=fe(e);if(s===0&&i===0)return e;const o=e.filter(c=>c>0),a=fe(o);if(a>s)throw new Error(`Split is greater than total amount: ${a} > ${s}`);if(o.some(c=>!se(c,t)))throw new Error("Provided amount preferences do not match the amounts of the mint keyset.");if(a===s)return o;e=o,s-=a}else e=[];const r=ne(t,"desc");if(!r||r.length===0)throw new Error("Cannot split amount, keyset is inactive or contains no keys");for(const i of r){if(i<=0)continue;const o=Math.floor(s/i);if(e.push(...Array(o).fill(i)),s-=i*o,s===0)break}if(s!==0)throw new Error(`Unable to split remaining amount: ${s}`);return n?e.sort((i,o)=>n==="desc"?o-i:i-o):e}function Je(s,t,e,n){const r=[],i=s.map(c=>c.amount);ne(e,"asc").forEach(c=>{const u=i.filter(h=>h===c).length,l=Math.max(n-u,0);for(let h=0;h<l&&!(r.reduce((d,p)=>d+p,0)+c>t);++h)r.push(c)});const a=t-r.reduce((c,u)=>c+u,0);return a&&Q(a,e).forEach(u=>{r.push(u)}),r.sort((c,u)=>c-u)}function ne(s,t="desc"){return t=="desc"?Object.keys(s).map(e=>parseInt(e)).sort((e,n)=>n-e):Object.keys(s).map(e=>parseInt(e)).sort((e,n)=>e-n)}function se(s,t){return s in t}function L(s){return it(b.bytesToHex(s))}function it(s){return BigInt(`0x${s}`)}function kt(s){return s.toString(16).padStart(64,"0")}function Pt(s){return/^[a-f0-9]*$/i.test(s)}function It(s){return Array.isArray(s)?s.some(t=>!Pt(t.id)):!Pt(s.id)}function us(s,t){return typeof t=="bigint"?t.toString():t}function Xe(s,t){It(s.proofs)||(s.proofs=Ye(s.proofs)),t&&(s.proofs=oe(s.proofs));const e={token:[{mint:s.mint,proofs:s.proofs}]};return s.unit&&(e.unit=s.unit),s.memo&&(e.memo=s.memo),"cashu"+"A"+Se(e)}function Ye(s){return s.map(t=>{const e={...t};return e.id=e.id.slice(0,16),e})}function hs(s,t){if(It(s.proofs)||t?.version===3){if(t?.version===4)throw new Error("can not encode to v4 token if proofs contain non-hex keyset id");return Xe(s,t?.removeDleq)}return Ze(s,t?.removeDleq)}function Ze(s,t){if(t&&(s.proofs=oe(s.proofs)),s.proofs.forEach(c=>{if(c.dleq&&c.dleq.r==null)throw new Error("Missing blinding factor in included DLEQ proof")}),It(s.proofs))throw new Error("can not encode to v4 token if proofs contain non-hex keyset id");s.proofs=Ye(s.proofs);const n=tn(s),r=zt(n),i="cashu",o="B",a=Nt(r);return i+o+a}function tn(s){const t={},e=s.mint;for(let r=0;r<s.proofs.length;r++){const i=s.proofs[r];t[i.id]?t[i.id].push(i):t[i.id]=[i]}const n={m:e,u:s.unit||"sat",t:Object.keys(t).map(r=>({i:b.hexToBytes(r),p:t[r].map(i=>({a:i.amount,s:i.secret,c:b.hexToBytes(i.C),...i.dleq&&{d:{e:b.hexToBytes(i.dleq.e),s:b.hexToBytes(i.dleq.s),r:b.hexToBytes(i.dleq.r??"00")}},...i.p2pk_e&&{pe:b.hexToBytes(i.p2pk_e)},...i.witness&&{w:JSON.stringify(i.witness)}}))}))};return s.memo&&(n.d=s.memo),n}function en(s){const t=[];s.t.forEach(n=>n.p.forEach(r=>{t.push({secret:r.s,C:b.bytesToHex(r.c),amount:r.a,id:b.bytesToHex(n.i),...r.d&&{dleq:{r:b.bytesToHex(r.d.r),s:b.bytesToHex(r.d.s),e:b.bytesToHex(r.d.e)}},...r.pe&&{p2pk_e:b.bytesToHex(r.pe)},...r.w&&{witness:r.w}})}));const e={mint:s.m,proofs:t,unit:s.u||"sat"};return s.d&&(e.memo=s.d),e}function nn(s,t){const e=on(s),n=re(e);return n.proofs=ms(n.proofs,t),n}function ls(s){s=on(s);const t=re(s);return{unit:t.unit||"sat",mint:t.mint,amount:J(t.proofs),...t.memo&&{memo:t.memo},incompleteProofs:t.proofs.map(e=>({secret:e.secret,C:e.C,amount:e.amount,...e.dleq&&{dleq:e.dleq},...e.witness&&{witness:e.witness}}))}}function re(s){const t=s.slice(0,1),e=s.slice(1);if(t==="A"){const n=Tn(e);if(n.token.length>1)throw new Error("Multi entry token are not supported");const r=n.token[0],i={mint:r.mint,proofs:r.proofs,unit:n.unit||"sat"};return n.memo&&(i.memo=n.memo),i}else if(t==="B"){const n=jt(e),r=Gt(n);return en(r)}throw new Error("Token version is not supported")}function Bt(s,t,e,n=0,r=!1){if(r){const c=Object.entries(s).sort((h,d)=>+h[0]-+d[0]).map(([,h])=>h).reduce((h,d)=>h+d,""),u=D.sha256(c);return _.toBase64(u).slice(0,12)}let i=Object.entries(s).sort((c,u)=>+c[0]-+u[0]).map(([,c])=>b.hexToBytes(c)).reduce((c,u)=>ft(c,u),new Uint8Array),o,a;switch(n){case 0:return o=D.sha256(i),a=_.toHex(o).slice(0,14),"00"+a;case 1:if(!t)throw new Error("Cannot compute keyset ID version 01: unit is required.");return i=ft(i,_.fromString("unit:"+t)),e&&(i=ft(i,_.fromString("final_expiry:"+e.toString()))),o=D.sha256(i),a=_.toHex(o),"01"+a;default:throw new Error(`Unrecognized keyset ID version: ${n}`)}}function ft(s,t){const e=new Uint8Array(s.length+t.length);return e.set(s),e.set(t,s.length),e}function ds(s){return s.sort((t,e)=>t.id.localeCompare(e.id))}function x(s){return typeof s=="object"}function fs(s){if(x(s)){if("error"in s&&s.error)throw new Error(s.error);if("detail"in s&&s.detail)throw new Error(s.detail)}}function $(...s){return s.map(t=>t.replace(/(^\/+|\/+$)/g,"")).join("/")}function ie(s){return s.replace(/\/$/,"")}function J(s){return s.reduce((t,e)=>t+e.amount,0)}function gs(s){return Mt.fromEncodedRequest(s)}class sn{get value(){return this._value}set value(t){this._value=t}get next(){return this._next}set next(t){this._next=t}constructor(t){this._value=t,this._next=null}}class rn{get first(){return this._first}set first(t){this._first=t}get last(){return this._last}set last(t){this._last=t}get size(){return this._size}set size(t){this._size=t}constructor(){this._first=null,this._last=null,this._size=0}enqueue(t){const e=new sn(t);return this._size===0||!this._last?(this._first=e,this._last=e):(this._last.next=e,this._last=e),this._size++,!0}dequeue(){if(this._size===0||!this._first)return null;const t=this._first;return this._first=t.next,t.next=null,this._size--,t.value}}function oe(s){return s.map(t=>{const e={...t};return delete e.dleq,e})}function ps(s){const t=Qt(s.id),e=/^[a-fA-F0-9]+$/.test(s.id),n=e?b.hexToBytes(s.id)[0]:0;return Bt(s.keys,s.unit,s.final_expiry,n,t&&!e)===s.id}function ms(s,t){const e=[];for(const n of s){let r;try{r=b.hexToBytes(n.id)}catch{e.push(n);continue}if(r[0]===0)e.push(n);else if(r[0]===1){if(!t)throw new Error("A short keyset ID v2 was encountered, but got no keysets to map it to.");let i=!1;for(const o of t)if(n.id===o.id.slice(0,n.id.length)){n.id=o.id,e.push(n),i=!0;break}if(!i)throw new Error(`Couldn't map short keyset ID ${n.id} to any known keysets of the current Mint`)}else throw new Error(`Unknown keyset ID version: ${r[0]}`)}return e}function ae(s,t){if(s.dleq==null)return!1;const e={e:b.hexToBytes(s.dleq.e),s:b.hexToBytes(s.dleq.s),r:it(s.dleq.r??"00")};if(!se(s.amount,t.keys))throw new Error(`undefined key for amount ${s.amount}`);const n=t.keys[s.amount];return ze(new TextEncoder().encode(s.secret),e,G(s.C),G(n))}function ys(...s){const t=s.reduce((r,i)=>r+i.length,0),e=new Uint8Array(t);let n=0;for(let r=0;r<s.length;r++)e.set(s[r],n),n=n+s[r].length;return e}function ws(s){const t=new TextEncoder,e=tn(s),n=zt(e),r=t.encode("craw"),i=t.encode("B");return ys(r,i,n)}function ks(s){const t=new TextDecoder,e=t.decode(s.slice(0,4)),n=t.decode(new Uint8Array([s[4]]));if(e!=="craw"||n!=="B")throw new Error("not a valid binary token");const r=s.slice(5),i=Gt(r);return en(i)}function fe(s){return s.reduce((t,e)=>t+e,0)}function Lt(s,t){if(s===t)return!0;if(s==null||t==null||typeof s!="object"||typeof t!="object")return!1;if(Array.isArray(s)&&Array.isArray(t))return s.length!==t.length?!1:s.every((r,i)=>Lt(r,t[i]));if(Array.isArray(s)||Array.isArray(t))return!1;const e=Object.keys(s),n=Object.keys(t);return e.length!==n.length?!1:e.every(r=>n.includes(r)&&Lt(s[r],t[r]))}function on(s){return["web+cashu://","cashu://","cashu:","cashu"].forEach(e=>{s.startsWith(e)&&(s=s.slice(e.length))}),s}class nt{constructor(){this.connectionMap=new Map}static getInstance(){return nt.instance||(nt.instance=new nt),nt.instance}getConnection(t,e){if(this.connectionMap.has(t))return this.connectionMap.get(t);const n=new an(t,e);return this.connectionMap.set(t,n),n}}class an{constructor(t,e){this.subListeners={},this.rpcListeners={},this.rpcId=0,this.onCloseCallbacks=[],this._WS=Sn(),this.url=new URL(t),this.messageQueue=new rn,this._logger=e??H}connect(){return this.connectionPromise||(this.connectionPromise=new Promise((t,e)=>{try{this.ws=new this._WS(this.url.toString()),this.onCloseCallbacks=[]}catch(n){e(n instanceof Error?n:new Error(String(n)));return}this.ws.onopen=()=>{t()},this.ws.onerror=()=>{e(new Error("Failed to open WebSocket"))},this.ws.onmessage=n=>{this.messageQueue.enqueue(n.data),this.handlingInterval||(this.handlingInterval=setInterval(this.handleNextMessage.bind(this),0))},this.ws.onclose=n=>{this.connectionPromise=void 0,this.onCloseCallbacks.forEach(r=>r(n))}})),this.connectionPromise}sendRequest(t,e){if(this.ws?.readyState!==1){if(t==="unsubscribe")return;throw this._logger.error("Attempted sendRequest, but socket was not open"),new Error("Socket not open")}const n=this.rpcId;this.rpcId++;const r=JSON.stringify({jsonrpc:"2.0",method:t,params:e,id:n});this.ws?.send(r)}closeSubscription(t){this.ws?.send(JSON.stringify(["CLOSE",t]))}addSubListener(t,e){(this.subListeners[t]=this.subListeners[t]||[]).push(e)}addRpcListener(t,e,n){this.rpcListeners[n]={callback:t,errorCallback:e}}removeRpcListener(t){delete this.rpcListeners[t]}removeListener(t,e){if(this.subListeners[t]){if(this.subListeners[t].length===1){delete this.subListeners[t];return}this.subListeners[t]=this.subListeners[t].filter(n=>n!==e)}}async ensureConnection(){this.ws?.readyState!==1&&await this.connect()}handleNextMessage(){if(this.messageQueue.size===0){clearInterval(this.handlingInterval),this.handlingInterval=void 0;return}const t=this.messageQueue.dequeue();let e;try{if(e=JSON.parse(t),"result"in e&&e.id!=null)this.rpcListeners[e.id]&&(this.rpcListeners[e.id].callback(),this.removeRpcListener(e.id));else if("error"in e&&e.id!=null)this.rpcListeners[e.id]&&(this.rpcListeners[e.id].errorCallback(new Error(e.error.message)),this.removeRpcListener(e.id));else if("method"in e&&!("id"in e)){const n=e.params?.subId;if(!n)return;if(this.subListeners[n]?.length>0){const r=e;this.subListeners[n].forEach(i=>i(r.params?.payload))}}}catch(n){this._logger.error("Error doing handleNextMessage",{e:n});return}}createSubscription(t,e,n){if(this.ws?.readyState!==1)throw this._logger.error("Attempted createSubscription, but socket was not open"),new Error("Socket is not open");const r=(Math.random()+1).toString(36).substring(7);return this.addRpcListener(()=>{this.addSubListener(r,e)},n,this.rpcId),this.sendRequest("subscribe",{...t,subId:r}),this.rpcId++,r}cancelSubscription(t,e,n){this.removeListener(t,e),this.addRpcListener(()=>{this._logger.info("Unsubscribed {subId}",{subId:t})},n||(r=>this._logger.error("Unsubscribe failed",{e:r})),this.rpcId),this.sendRequest("unsubscribe",{subId:t})}get activeSubscriptions(){return Object.keys(this.subListeners)}close(){this.ws&&this.ws?.close()}onClose(t){this.onCloseCallbacks.push(t)}}function qt(s,t){return s.state||(t.warn("Field 'state' not found in MeltQuoteResponse. Update NUT-05 of mint: https://github.com/cashubtc/nuts/pull/136)"),typeof s.paid=="boolean"&&(s.state=s.paid?st.PAID:st.UNPAID)),s}function ge(s,t){return s.state||(t.warn("Field 'state' not found in MintQuoteResponse. Update NUT-04 of mint: https://github.com/cashubtc/nuts/pull/141)"),typeof s.paid=="boolean"&&(s.state=s.paid?pt.PAID:pt.UNPAID)),s}function Ps(s,t){return Array.isArray(s?.contact)&&s?.contact.length>0&&(s.contact=s.contact.map(e=>Array.isArray(e)&&e.length===2&&typeof e[0]=="string"&&typeof e[1]=="string"?(t.warn("Mint returned deprecated 'contact' field: Update NUT-06: https://github.com/cashubtc/nuts/pull/117"),{method:e[0],info:e[1]}):e)),s}class dt{constructor(t){this.REGEX_METACHAR=/[\\^$.*+?()[\]{}|]/,this._mintInfo=t;const e=this.toEndpoints(t?.nuts?.[22]?.protected_endpoints);this._protected22=this.buildIndex(e);const n=this.toEndpoints(t?.nuts?.[21]?.protected_endpoints);this._protected21=this.buildIndex(n)}isSupported(t){switch(t){case 4:case 5:return this.checkMintMelt(t);case 7:case 8:case 9:case 10:case 11:case 12:case 14:case 20:return this.checkGenericNut(t);case 17:return this.checkNut17();case 15:return this.checkNut15();default:throw new Error("nut is not supported by cashu-ts")}}requiresBlindAuthToken(t,e){return this.matchesProtected(this._protected22,t,e)}requiresClearAuthToken(t,e){return this.matchesProtected(this._protected21,t,e)}matchesProtected(t,e,n){if(!t)return!1;const r=`${e} ${n}`,i=t.cache[r];if(typeof i=="boolean")return i;const o=t.exact.some(u=>u.method===e&&u.path===n),a=o?!1:t.regex.some(u=>u.method===e&&u.regex.test(n)),c=o||a;return t.cache[r]=c,c}checkGenericNut(t){return this._mintInfo.nuts[t]?.supported?{supported:!0}:{supported:!1}}checkMintMelt(t){const e=this._mintInfo.nuts[t];return e&&e.methods.length>0&&!e.disabled?{disabled:!1,params:e.methods}:{disabled:!0,params:e?.methods??[]}}checkNut17(){return this._mintInfo.nuts[17]&&this._mintInfo.nuts[17].supported.length>0?{supported:!0,params:this._mintInfo.nuts[17].supported}:{supported:!1}}checkNut15(){return this._mintInfo.nuts[15]&&this._mintInfo.nuts[15].methods.length>0?{supported:!0,params:this._mintInfo.nuts[15].methods}:{supported:!1}}toEndpoints(t){if(!Array.isArray(t))return[];const e=[];for(const n of t)if(n&&typeof n=="object"){const r=n,i=r.method,o=r.path;if(typeof i=="string"&&typeof o=="string"){const a=i.toUpperCase();(a==="GET"||a==="POST")&&e.push({method:a,path:o})}}return e}buildIndex(t){if(!t||t.length===0)return;const e=[],n=[],r=this.REGEX_METACHAR;for(const o of t){if(o.path.startsWith("^")||o.path.endsWith("$")||r.test(o.path))try{n.push({method:o.method,regex:new RegExp(o.path)});continue}catch{}e.push({method:o.method,path:o.path})}return{cache:{},exact:e,regex:n}}get contact(){return this._mintInfo.contact}get description(){return this._mintInfo.description}get description_long(){return this._mintInfo.description_long}get name(){return this._mintInfo.name}get pubkey(){return this._mintInfo.pubkey}get nuts(){return this._mintInfo.nuts}get version(){return this._mintInfo.version}get motd(){return this._mintInfo.motd}get supportsBolt12Description(){return this.supportsNut04Description("bolt12")}supportsNut04Description(t,e){return this._mintInfo.nuts[4]?.methods.some(n=>n.method===t&&(e?n.unit===e:!0)&&(n.options?.description===!0||n.description===!0))}}class Ct{constructor(t,e){this.tokenListeners=[],this.discoveryUrl=t,this.logger=e?.logger??H,this.clientId=e?.clientId??"cashu-client",this.scope=e?.scope??"openid",this.onTokens=e?.onTokens}static fromMintInfo(t,e){const n=t?.nuts?.["21"];if(!n?.openid_discovery)throw new Error("OIDCAuth: mint does not advertise NUT-21 openid_discovery");const r=e?.clientId??n.client_id??"cashu-client";return new Ct(n.openid_discovery,{...e,clientId:r})}setClient(t){this.clientId=t}setScope(t){this.scope=t??"openid"}addTokenListener(t){this.tokenListeners.push(t)}async loadConfig(){if(this.config)return this.config;const t=await fetch(this.discoveryUrl,{method:"GET",headers:{Accept:"application/json"}}),e=await t.text();let n;try{n=e?JSON.parse(e):void 0}catch(i){this.logger.warn("OIDCAuth: bad discovery JSON",{err:i})}if(!t.ok||!n)throw new Error("OIDCAuth: invalid discovery document");const r=n;if(typeof r.token_endpoint!="string"||r.token_endpoint.length===0)throw new Error("OIDCAuth: invalid discovery document, missing token_endpoint");return this.config=r,r}generatePKCE(){const t=b.randomBytes(48),e=Nt(t),n=_.fromString(e),r=D.sha256(n),i=Nt(r);return{verifier:e,challenge:i}}async buildAuthCodeUrl(t){const e=await this.loadConfig(),n=t.scope??this.scope,r=new URLSearchParams({response_type:"code",client_id:this.clientId,redirect_uri:t.redirectUri,scope:n,code_challenge_method:t.codeChallengeMethod??"S256",code_challenge:t.codeChallenge});if(t.state&&r.set("state",t.state),!e.authorization_endpoint)throw new Error("OIDCAuth: discovery lacks authorization_endpoint");return`${e.authorization_endpoint}?${r.toString()}`}async exchangeAuthCode(t){const e=await this.loadConfig(),n=this.toForm({grant_type:"authorization_code",code:t.code,redirect_uri:t.redirectUri,client_id:this.clientId,code_verifier:t.codeVerifier}),r=await this.postFormStrict(e.token_endpoint,n);return this.handleTokens(r),r}async deviceStart(){const e=(await this.loadConfig()).device_authorization_endpoint;if(!e)throw new Error("OIDCAuth: provider lacks device_authorization_endpoint");const n=this.toForm({client_id:this.clientId,scope:this.scope});return this.postFormStrict(e,n)}async devicePoll(t,e=5){const n=await this.loadConfig();let r=Math.max(1,e);for(;;){await this.sleep(r*1e3);const i=this.toForm({grant_type:"urn:ietf:params:oauth:grant-type:device_code",device_code:t,client_id:this.clientId}),o=await this.postFormLoose(n.token_endpoint,i);if(o.access_token)return this.handleTokens(o),o;const a=(o.error??"").toString();if(a==="authorization_pending")continue;if(a==="slow_down"){r=Math.max(r+5,r*2);continue}const c=o.error_description||a||"device authorization failed";throw new Error(`OIDCAuth: ${c}`)}}async startDeviceAuth(t=5){const e=await this.deviceStart(),n=Math.max(e.interval??1,t);let r=!1;return{...e,poll:async()=>{const a=await this.loadConfig();let c=Math.max(1,n);for(;;){if(r)throw new Error("OIDCAuth: device polling cancelled");await this.sleep(c*1e3);const u=this.toForm({grant_type:"urn:ietf:params:oauth:grant-type:device_code",device_code:e.device_code,client_id:this.clientId}),l=await this.postFormLoose(a.token_endpoint,u);if(l.access_token)return this.handleTokens(l),l;const h=(l.error??"").toString();if(h==="authorization_pending")continue;if(h==="slow_down"){c=Math.max(c+5,c*2);continue}const d=l.error_description||h||"device authorization failed";throw new Error(`OIDCAuth: ${d}`)}},cancel:()=>{r=!0}}}async refresh(t){const e=await this.loadConfig(),n=this.toForm({grant_type:"refresh_token",refresh_token:t,client_id:this.clientId}),r=await this.postFormStrict(e.token_endpoint,n);return this.handleTokens(r),r}async passwordGrant(t,e){const n=await this.loadConfig(),r=this.toForm({grant_type:"password",client_id:this.clientId,username:t,password:e,scope:this.scope}),i=await this.postFormStrict(n.token_endpoint,r);return this.handleTokens(i),i}handleTokens(t){if(!t.access_token){const e=t.error_description||t.error||"token response missing access_token";throw new Error(`OIDCAuth: ${e}`)}queueMicrotask(()=>lt(this.onTokens,t,this.logger,{where:"OIDCAuth.handleTokens"}));for(const e of this.tokenListeners)queueMicrotask(()=>lt(e,t,this.logger,{where:"OIDCAuth.handleTokens.listener"}))}toForm(t){const e=n=>encodeURIComponent(n).replace(/%20/g,"+");return Object.entries(t).map(([n,r])=>`${e(n)}=${e(r)}`).join("&")}async postFormStrict(t,e){try{this.logger.debug("OIDCAuth Request",{formBody:e});const n=await fetch(t,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded",Accept:"application/json"},body:e}),r=await n.text();let i;try{i=r?JSON.parse(r):void 0}catch(o){this.logger.warn("OIDCAuth: bad JSON (strict)",{err:o})}if(!n.ok){const o=i??{},a=o.error_description||o.error||`HTTP ${n.status}`;throw new Error(`OIDCAuth: ${a}`)}return this.logger.debug("OIDCAuth Response",{json:i}),i??{}}catch(n){throw this.logger.error("OIDCAuth: postFormStrict failed",{err:n}),n}}async postFormLoose(t,e){try{this.logger.debug("OIDCAuth Request",{formBody:e});const r=await(await fetch(t,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded",Accept:"application/json"},body:e})).text();let i;try{i=r?JSON.parse(r):void 0}catch(o){this.logger.warn("OIDCAuth: bad JSON (loose)",{err:o})}return this.logger.debug("OIDCAuth Response",{json:i}),i??{}}catch(n){return this.logger.error("OIDCAuth: postFormLoose network error",{err:n}),{error:"network_error",error_description:String(n)}}}sleep(t){return new Promise(e=>setTimeout(e,t))}}class Kt{constructor(t,e){this._mintUrl=ie(t),this._request=e?.customRequest??Ae,this._authProvider=e?.authProvider,this._logger=e?.logger??H,_n(this._logger)}get mintUrl(){return this._mintUrl}async oidcAuth(t){const e=(await this.getLazyMintInfo()).nuts[21];if(!e?.openid_discovery)throw new Error("Mint: no NUT-21 openid_discovery");return new Ct(e.openid_discovery,{...t,clientId:t?.clientId??e.client_id??"cashu-client"})}async getInfo(t){const n=await(t??this._request)({endpoint:$(this._mintUrl,"/v1/info")});return Ps(n,this._logger)}async getLazyMintInfo(){if(this._mintInfo)return this._mintInfo;const t=await this.getInfo();return this._mintInfo=new dt(t),this._mintInfo}async swap(t,e){const n=await this.requestWithAuth("POST","/v1/swap",{requestBody:t},e);if(!x(n)||!Array.isArray(n?.signatures)){const r=x(n)&&"detail"in n?n.detail:void 0;throw new Error(r??"bad response")}return n}async createMintQuoteBolt11(t,e){const n=await this.requestWithAuth("POST","/v1/mint/quote/bolt11",{requestBody:t},e);return ge(n,this._logger)}async createMintQuoteBolt12(t,e){return await this.requestWithAuth("POST","/v1/mint/quote/bolt12",{requestBody:t},e)}async checkMintQuoteBolt11(t,e){const n=await this.requestWithAuth("GET",`/v1/mint/quote/bolt11/${t}`,{},e);return ge(n,this._logger)}async checkMintQuoteBolt12(t,e){return await this.requestWithAuth("GET",`/v1/mint/quote/bolt12/${t}`,{},e)}async mintBolt11(t,e){const n=await this.requestWithAuth("POST","/v1/mint/bolt11",{requestBody:t},e);if(!x(n)||!Array.isArray(n?.signatures)){const r=x(n)&&"detail"in n?n.detail:void 0;throw new Error(r??"bad response")}return n}async mintBolt12(t,e){const n=await this.requestWithAuth("POST","/v1/mint/bolt12",{requestBody:t},e);if(!x(n)||!Array.isArray(n?.signatures)){const r=x(n)&&"detail"in n?n.detail:void 0;throw new Error(r??"bad response")}return n}async createMeltQuoteBolt11(t,e){const n=await this.requestWithAuth("POST","/v1/melt/quote/bolt11",{requestBody:t},e),r=qt(n,this._logger);if(!x(r)||typeof r?.amount!="number"||typeof r?.fee_reserve!="number"||typeof r?.quote!="string"){const i=x(r)&&"detail"in r?r.detail:void 0;throw new Error(i??"bad response")}return r}async createMeltQuoteBolt12(t,e){return await this.requestWithAuth("POST","/v1/melt/quote/bolt12",{requestBody:t},e)}async checkMeltQuoteBolt11(t,e){const n=await this.requestWithAuth("GET",`/v1/melt/quote/bolt11/${t}`,{},e),r=qt(n,this._logger);if(!x(r)||typeof r?.amount!="number"||typeof r?.fee_reserve!="number"||typeof r?.quote!="string"||typeof r?.state!="string"||!Object.values(st).includes(r.state)){const i=x(r)&&"detail"in r?r.detail:void 0;throw new Error(i??"bad response")}return r}async checkMeltQuoteBolt12(t,e){return await this.requestWithAuth("GET",`/v1/melt/quote/bolt12/${t}`,{},e)}async meltBolt11(t,e){const n={...e?.preferAsync?{Prefer:"respond-async"}:{}},r=await this.requestWithAuth("POST","/v1/melt/bolt11",{requestBody:t,headers:n},e?.customRequest),i=qt(r,this._logger);if(!x(i)||typeof i?.state!="string"||!Object.values(st).includes(i.state)){const o=x(i)&&"detail"in i?i.detail:void 0;throw new Error(o??"bad response")}return i}async meltBolt12(t,e){const n={...e?.preferAsync?{Prefer:"respond-async"}:{}};return await this.requestWithAuth("POST","/v1/melt/bolt12",{requestBody:t,headers:n},e?.customRequest)}async check(t,e){const n=await this.requestWithAuth("POST","/v1/checkstate",{requestBody:t},e);if(!x(n)||!Array.isArray(n?.states)){const r=x(n)&&"detail"in n?n.detail:void 0;throw new Error(r??"bad response")}return n}async getKeys(t,e,n){const r=e||this._mintUrl;t&&(t=t.replace(/\//g,"_").replace(/\+/g,"-"));const o=await(n??this._request)({endpoint:t?$(r,"/v1/keys",t):$(r,"/v1/keys")});if(!x(o)||!Array.isArray(o.keysets)){const a=x(o)&&"detail"in o?o.detail:void 0;throw new Error(a??"bad response")}return o}async getKeySets(t){return(t??this._request)({endpoint:$(this._mintUrl,"/v1/keysets")})}async restore(t,e){const r=await(e??this._request)({endpoint:$(this._mintUrl,"/v1/restore"),method:"POST",requestBody:t});if(!x(r)||!Array.isArray(r?.outputs)||!Array.isArray(r?.signatures)){const i=x(r)&&"detail"in r?r.detail:void 0;throw new Error(i??"bad response")}return r}async connectWebSocket(){if(this.ws)await this.ws.ensureConnection();else{const t=new URL(this._mintUrl),e="v1/ws";t.pathname&&(t.pathname.endsWith("/")?t.pathname+=e:t.pathname+="/"+e),this.ws=nt.getInstance().getConnection(`${t.protocol==="https:"?"wss":"ws"}://${t.host}${t.pathname}`);try{await this.ws.connect()}catch(n){throw this._logger.error("Failed to connect to WebSocket...",{e:n}),new Error("Failed to connect to WebSocket...")}}}disconnectWebSocket(){this.ws&&this.ws.close()}get webSocketConnection(){return this.ws}async handleClearAuth(t,e){if(!(!this._authProvider||!(await this.getLazyMintInfo()).requiresClearAuthToken(t,e)))return this._logger.error("Clear Authentication Token...",{cat:this._authProvider.getCAT()}),this._authProvider.getCAT()}async handleBlindAuth(t,e){if(!this._authProvider||!(await this.getLazyMintInfo()).requiresBlindAuthToken(t,e))return;const r=await this._authProvider.getBlindAuthToken({method:t,path:e});return this._logger.error("Blind Authentication Token...",{bat:r}),r}async requestWithAuth(t,e,n={},r){const i=r??this._request,o=await this.handleBlindAuth(t,e),a=await this.handleClearAuth(t,e),c={...n.headers??{},...o?{"Blind-auth":o}:{},...a?{"Clear-auth":a}:{}};return i({...n,endpoint:$(this._mintUrl,e),method:t,headers:c})}}class cn{constructor(t,e,n,r,i){this._keys={},this._id=t,this._unit=e,this._active=n,this._input_fee_ppk=r,this._final_expiry=i}get id(){return this._id}get unit(){return this._unit}get isActive(){return this._active}get fee(){return this._input_fee_ppk??0}get expiry(){return this._final_expiry}get hasKeys(){return Object.keys(this._keys).length>0}get hasHexId(){return Pt(this._id)}get keys(){return this._keys}set keys(t){this._keys=t}get active(){return this._active}get input_fee_ppk(){return this._input_fee_ppk??0}get final_expiry(){return this._final_expiry}toMintKeyset(){return{id:this._id,unit:this._unit,active:this._active,input_fee_ppk:this._input_fee_ppk,final_expiry:this._final_expiry}}toMintKeys(){return this.hasKeys?{id:this._id,unit:this._unit,keys:this._keys}:null}verify(){if(!this.hasKeys)return!1;const t=b.hexToBytes(this._id)[0];return Bt(this._keys,this._unit,this._final_expiry,t)===this._id}}class ce{constructor(t,e,n,r){if(this.keysets={},this.mint=typeof t=="string"?new Kt(t):t,this.unit=e,n&&r){const i=Array.isArray(r)?r:[r];this.buildKeychain(n,i)}}async init(t){if(Object.keys(this.keysets).length>0&&!t)return;const[e,n]=await Promise.all([this.mint.getKeySets(),this.mint.getKeys()]);this.buildKeychain(e.keysets,n.keysets),this.getCheapestKeyset()}buildKeychain(t,e){this.keysets={},t.filter(i=>i.unit===this.unit).forEach(i=>{this.keysets[i.id]=new cn(i.id,i.unit,i.active,i.input_fee_ppk,i.final_expiry)});const r=new Map(e.filter(i=>i.unit===this.unit).map(i=>[i.id,i]));Object.values(this.keysets).forEach(i=>{if(!i.hasHexId||!i.isActive)return;const o=r.get(i.id);if(o&&(i.keys=o.keys,!i.verify()))throw new Error(`Keyset verification failed for ID ${i.id}`)})}getKeyset(t){const e=t?this.keysets[t]:this.getCheapestKeyset();if(!e)throw new Error(`Keyset '${t}' not found`);return e}getCheapestKeyset(){if(Object.keys(this.keysets).length===0)throw new Error("KeyChain not initialized");const t=Object.values(this.keysets).filter(e=>e.isActive&&e.hasHexId&&e.hasKeys);if(t.length===0)throw new Error("No active keyset found");return t.sort((e,n)=>e.fee-n.fee)[0]}getKeysets(){if(Object.keys(this.keysets).length===0)throw new Error("KeyChain not initialized");return Object.values(this.keysets)}getCache(){const t=this.getKeysets(),e=t.filter(n=>n.hasKeys).map(n=>n.toMintKeys()).filter(n=>n!==null);return{keysets:t.map(n=>n.toMintKeyset()),keys:e,unit:this.unit,mintUrl:this.mint.mintUrl}}}class Ut{constructor(t,e,n){this.amount=t,this.B_=e,this.id=n}getSerializedBlindedMessage(){return{amount:this.amount,B_:this.B_.toHex(!0),id:this.id}}}const bs=new Set(["locktime","pubkeys","n_sigs","refund","n_sigs_refund"]);function un(s){if(!s||typeof s!="string")throw new Error("tag key must be a non empty string");if(bs.has(s))throw new Error(`additionalTags must not use reserved key "${s}"`)}const pe=1024,Ht=new WeakMap;function _s(s,t){t&&Ht.set(s,t)}function vs(s){const t=Ht.get(s);if(t)return Ht.delete(s),t}class U{constructor(t,e,n){this.secret=n,this.blindingFactor=e,this.blindedMessage=t}toProof(t,e){let n;t.dleq&&(n={s:M.hexToBytes(t.dleq.s),e:M.hexToBytes(t.dleq.e),r:this.blindingFactor});const r={id:t.id,amount:t.amount,C_:G(t.C_)},i=G(e.keys[t.amount]),o=Ne(r,this.blindingFactor,this.secret,i),a={...Fe(o),...n&&{dleq:{s:M.bytesToHex(n.s),e:M.bytesToHex(n.e),r:kt(n.r??BigInt(0))}}},c=vs(this);return c&&(a.p2pk_e=c),a}static createP2PKData(t,e,n,r){return Q(e,n.keys,r).map(o=>this.createSingleP2PKData(t,o,n.id))}static createSingleP2PKData(t,e,n){const r=Array.isArray(t.pubkey)?t.pubkey:[t.pubkey],i=t.refundKeys??[],o=Math.max(1,Math.min(t.requiredSignatures??1,r.length)),a=Math.max(1,Math.min(t.requiredRefundSignatures??1,i.length||1));let c=r[0],u=r.slice(1),l=i,h;if(t.blindKeys){const K=[c,...u,...i],{blinded:E,Ehex:O}=Ee(K,n);c=E[0],u=E.slice(1,r.length),l=E.slice(r.length),h=O}const d=[],p=t.locktime??NaN;if(Number.isSafeInteger(p)&&p>=0&&d.push(["locktime",String(p)]),u.length>0&&(d.push(["pubkeys",...u]),o>1&&d.push(["n_sigs",String(o)])),l.length>0&&(d.push(["refund",...l]),a>1&&d.push(["n_sigs_refund",String(a)])),t.additionalTags?.length){const K=t.additionalTags.map(([E,...O])=>(un(E),[E,...O.map(String)]));d.push(...K)}const y=["P2PK",{nonce:M.bytesToHex(M.randomBytes(32)),data:c,tags:d}],v=JSON.stringify(y),A=[...v].length;if(A>pe)throw new Error(`Secret too long (${A} characters), maximum is ${pe}`);const k=new TextEncoder().encode(v),{r:S,B_:I}=ht(k),R=new U(new Ut(e,I,n).getSerializedBlindedMessage(),S,k);return t.blindKeys&&h&&_s(R,h),R}static createRandomData(t,e,n){return Q(t,e.keys,n).map(i=>this.createSingleRandomData(i,e.id))}static createSingleRandomData(t,e){const n=M.bytesToHex(M.randomBytes(32)),r=new TextEncoder().encode(n),{r:i,B_:o}=ht(r);return new U(new Ut(t,o,e).getSerializedBlindedMessage(),i,r)}static createDeterministicData(t,e,n,r,i){return Q(t,r.keys,i).map((a,c)=>this.createSingleDeterministicData(a,e,n+c,r.id))}static createSingleDeterministicData(t,e,n,r){const i=$e(e,r,n),o=M.bytesToHex(i),a=new TextEncoder().encode(o),c=L(We(e,r,n)),{r:u,B_:l}=ht(a,c);return new U(new Ut(t,l,r).getSerializedBlindedMessage(),u,a)}static sumOutputAmounts(t){return t.reduce((e,n)=>e+n.blindedMessage.amount,0)}}function me(s){const t=s.toLowerCase();if(t.length===66&&(t.startsWith("02")||t.startsWith("03")))return t;if(t.length===64)return`02${t}`;throw new Error(`Invalid pubkey, expected 33 byte compressed or 32 byte x only, got length ${t.length}`)}function As(s){return s instanceof Date?Math.floor(s.getTime()/1e3):s<1e12?Math.floor(s):Math.floor(s/1e3)}class ue{constructor(){this.lockSet=new Set,this.refundSet=new Set,this.extraTags=[]}addLockPubkey(t){const e=Array.isArray(t)?t:[t];for(const n of e)this.lockSet.add(me(n));return this}addRefundPubkey(t){const e=Array.isArray(t)?t:[t];for(const n of e)this.refundSet.add(me(n));return this}lockUntil(t){return this.locktime=As(t),this}requireLockSignatures(t){return this.nSigs=Math.max(1,Math.trunc(t)),this}requireRefundSignatures(t){return this.nSigsRefund=Math.max(1,Math.trunc(t)),this}addTag(t,e){un(t);const n=e===void 0?[]:Array.isArray(e)?e:[e];return this.extraTags.push([t,...n.map(String)]),this}addTags(t){for(const[e,...n]of t)this.addTag(e,n);return this}blindKeys(){return this._blindKeys=!0,this}toOptions(){const t=Array.from(this.lockSet),e=Array.from(this.refundSet);if(t.length===0)throw new Error("At least one lock pubkey is required");if(e.length>0&&this.locktime===void 0)throw new Error("Refund pubkeys require a locktime, add lockUntil(...) or remove refund keys");const n=t.length+e.length;if(n>10)throw new Error(`Too many pubkeys, ${n} provided, maximum allowed is 10 in total`);const r=this.nSigs?Math.min(Math.max(1,this.nSigs),t.length):void 0,i=this.nSigsRefund?Math.min(Math.max(1,this.nSigsRefund),Math.max(1,e.length)):void 0,a={pubkey:t.length===1?t[0]:t,...this.locktime!==void 0?{locktime:this.locktime}:{},...e.length?{refundKeys:e}:{},...r&&r>1?{requiredSignatures:r}:{},...i&&i>1?{requiredRefundSignatures:i}:{},...this.extraTags.length?{additionalTags:this.extraTags.slice()}:{},...this._blindKeys?{blindKeys:!0}:{}};return U.createSingleP2PKData(a,1,"deedbeef"),a}static fromOptions(t){const e=new ue,n=Array.isArray(t.pubkey)?t.pubkey:[t.pubkey];return e.addLockPubkey(n),t.locktime!==void 0&&e.lockUntil(t.locktime),t.refundKeys?.length&&e.addRefundPubkey(t.refundKeys),t.requiredSignatures!==void 0&&e.requireLockSignatures(t.requiredSignatures),t.requiredRefundSignatures!==void 0&&e.requireRefundSignatures(t.requiredRefundSignatures),t.additionalTags?.length&&e.addTags(t.additionalTags),t.blindKeys&&e.blindKeys(),e}}const hn=(s,t,e,n=!1,r=!1,i=H)=>{const h=Pn();let d=null,p=1/0,y=0,v=0;const A=f=>{try{return e.getKeyset(f.id).fee}catch(g){St(`Could not get fee. No keyset found for keyset id: ${f.id}`,i,{error:g,keychain:e.getKeysets()})}},k=(f,g)=>f-(n?Math.ceil(g/1e3):0),S=f=>{const g=[...f];for(let P=g.length-1;P>0;P--){const w=Math.floor(Math.random()*(P+1));[g[P],g[w]]=[g[w],g[P]]}return g},I=(f,g,P)=>{let w=0,F=f.length-1,T=null;for(;w<=F;){const z=Math.floor((w+F)/2),Z=f[z].exFee;(P?Z<=g:Z>=g)?(T=z,P?w=z+1:F=z-1):P?F=z-1:w=z+1}return P?T:w<f.length?w:null},R=(f,g)=>{const P=g.exFee;let w=0,F=f.length;for(;w<F;){const T=Math.floor((w+F)/2);f[T].exFee<P?w=T+1:F=T}f.splice(w,0,g)},K=(f,g)=>k(f,g)<t?1/0:f+g/1e3-t;let E=0,O=0;const ct=s.map(f=>{const g=A(f),P=n?f.amount-g/1e3:f.amount,w={proof:f,exFee:P,ppkfee:g};return(!n||P>0)&&(E+=f.amount,O+=g),w});let B=n?ct.filter(f=>f.exFee>0):ct;if(B.sort((f,g)=>f.exFee-g.exFee),B.length>0){let f;if(r){const g=I(B,t,!0);f=g!==null?g+1:0}else{const g=I(B,t,!1);if(g!==null){const P=B[g].exFee,w=I(B,P,!0);be(w,"Unexpected null rightIndex in binary search",i),f=w+1}else f=B.length}for(let g=f;g<B.length;g++)E-=B[g].proof.amount,O-=B[g].ppkfee;B=B.slice(0,f)}const X=k(E,O);if(t<=0||t>X)return{keep:s,send:[]};const Y=Math.min(Math.ceil(t*(1+0/100)),t+0,X);for(let f=0;f<60;f++){const g=[];let P=0,w=0;for(const C of S(B)){const N=P+C.proof.amount,q=w+C.ppkfee,j=k(N,q);if(r&&j>t||(g.push(C),P=N,w=q,j>=t))break}const F=new Set(g),T=B.filter(C=>!F.has(C)),z=S(Array.from({length:g.length},(C,N)=>N)).slice(0,5e3);for(const C of z){const N=k(P,w);if(N===t||!r&&N>=t&&N<=Y)break;const q=g[C],j=P-q.proof.amount,tt=w-q.ppkfee,yn=k(j,tt),he=t-yn,Dt=I(T,he,r);if(Dt!==null){const ut=T[Dt];(!r||ut.exFee>q.exFee)&&(he>=0||ut.exFee<=q.exFee)&&(g[C]=ut,P=j+ut.proof.amount,w=tt+ut.ppkfee,T.splice(Dt,1),R(T,q))}}const Z=K(P,w);if(Z<p){i.debug(`selectProofsToSend: best solution found in trial #${f} - amount: ${P}, delta: ${Z}`),d=[...g].sort((N,q)=>q.exFee-N.exFee),p=Z,y=P,v=w;const C=[...d];for(;C.length>1&&p>0;){const N=C.pop(),q=P-N.proof.amount,j=w-N.ppkfee,tt=K(q,j);if(tt==1/0)break;tt<p&&(d=[...C],p=tt,y=q,v=j,P=q,w=j)}}if(d&&p<1/0){const C=k(y,v);if(C===t||!r&&C>=t&&C<=Y)break}if(h.elapsed()>1e3){Pe(r,"Proof selection took too long. Try again with a smaller proof set.",i),i.warn("Proof selection took too long. Returning best selection so far.");break}}if(d&&p<1/0){const f=d.map(w=>w.proof),g=new Set(f),P=s.filter(w=>!g.has(w));return i.info(`Proof selection took ${h.elapsed()}ms`),{keep:P,send:f}}return{keep:s,send:[]}};class Ss{constructor(t){if(this.next=new Map,this.locks=new Map,t)for(const[e,n]of Object.entries(t))this.next.set(e,n)}async withLock(t,e){const n=this.locks.get(t)??Promise.resolve();let r;const i=new Promise(a=>r=a),o=n.then(()=>i);this.locks.set(t,o);try{return await n,await e()}finally{r(),this.locks.get(t)===o&&this.locks.delete(t)}}async reserve(t,e){if(e<0)throw new Error("reserve called with negative count");return this.withLock(t,()=>{const n=this.next.get(t)??0;return e===0?{start:n,count:0}:(this.next.set(t,n+e),{start:n,count:e})})}async advanceToAtLeast(t,e){await this.withLock(t,()=>{const n=this.next.get(t)??0;e>n&&this.next.set(t,e)})}async setNext(t,e){await this.withLock(t,()=>{if(e<0)throw new Error("setNext: negative next not allowed");this.next.set(t,e)})}snapshot(){return Promise.resolve(Object.fromEntries(this.next.entries()))}}class ln{constructor(t){this.wallet=t}send(t,e){return new dn(this.wallet,t,e)}receive(t){return new fn(this.wallet,t)}mintBolt11(t,e){return new $t(this.wallet,"bolt11",t,e)}mintBolt12(t,e){return new $t(this.wallet,"bolt12",t,e)}meltBolt11(t,e){return new Wt(this.wallet,"bolt11",t,e)}meltBolt12(t,e){return new Wt(this.wallet,"bolt12",t,e)}}class dn{constructor(t,e,n){this.wallet=t,this.amount=e,this.proofs=n,this.config={}}asRandom(t){return this.sendOT={type:"random",denominations:t},this}asDeterministic(t=0,e){return this.sendOT={type:"deterministic",counter:t,denominations:e},this}asP2PK(t,e){return this.sendOT={type:"p2pk",options:t,denominations:e},this}asFactory(t,e){return this.sendOT={type:"factory",factory:t,denominations:e},this}asCustom(t){return this.sendOT={type:"custom",data:t},this}keepAsRandom(t){return this.keepOT={type:"random",denominations:t},this}keepAsDeterministic(t=0,e){return this.keepOT={type:"deterministic",counter:t,denominations:e},this}keepAsP2PK(t,e){return this.keepOT={type:"p2pk",options:t,denominations:e},this}keepAsFactory(t,e){return this.keepOT={type:"factory",factory:t,denominations:e},this}keepAsCustom(t){return this.keepOT={type:"custom",data:t},this}includeFees(t=!0){return this.config.includeFees=t,this}keyset(t){return this.config.keysetId=t,this}proofsWeHave(t){return this.config.proofsWeHave=t,this}onCountersReserved(t){return this.config.onCountersReserved=t,this}offlineExactOnly(t=!1){return this.offlineExact={requireDleq:t},this}offlineCloseMatch(t=!1){return this.offlineClose={requireDleq:t},this}async run(){if((this.offlineExact||this.offlineClose)&&(this.sendOT||this.keepOT))throw new Error("Offline selection cannot be combined with custom output types. Remove send/keep output configuration, or use an online swap.");if(this.offlineExact)return this.wallet.sendOffline(this.amount,this.proofs,{includeFees:this.config.includeFees,exactMatch:!0,requireDleq:this.offlineExact.requireDleq});if(this.offlineClose)return this.wallet.sendOffline(this.amount,this.proofs,{includeFees:this.config.includeFees,exactMatch:!1,requireDleq:this.offlineClose.requireDleq});const t={send:this.sendOT??this.wallet.defaultOutputType(),...this.keepOT?{keep:this.keepOT}:{}};return this.wallet.send(this.amount,this.proofs,this.config,t)}}class fn{constructor(t,e){this.wallet=t,this.token=e,this.config={}}asRandom(t){return this.outputType={type:"random",denominations:t},this}asDeterministic(t=0,e){return this.outputType={type:"deterministic",counter:t,denominations:e},this}asP2PK(t,e){return this.outputType={type:"p2pk",options:t,denominations:e},this}asFactory(t,e){return this.outputType={type:"factory",factory:t,denominations:e},this}asCustom(t){return this.outputType={type:"custom",data:t},this}keyset(t){return this.config.keysetId=t,this}requireDleq(t=!0){return this.config.requireDleq=t,this}privkey(t){return this.config.privkey=t,this}proofsWeHave(t){return this.config.proofsWeHave=t,this}onCountersReserved(t){return this.config.onCountersReserved=t,this}async run(){return this.wallet.receive(this.token,this.config,this.outputType)}}class $t{constructor(t,e,n,r){this.wallet=t,this.method=e,this.amount=n,this.quote=r,this.config={},this._hasPrivkey}asRandom(t){return this.outputType={type:"random",denominations:t},this}asDeterministic(t=0,e){return this.outputType={type:"deterministic",counter:t,denominations:e},this}asP2PK(t,e){return this.outputType={type:"p2pk",options:t,denominations:e},this}asFactory(t,e){return this.outputType={type:"factory",factory:t,denominations:e},this}asCustom(t){return this.outputType={type:"custom",data:t},this}keyset(t){return this.config.keysetId=t,this}privkey(t){return this.config.privkey=t,this}proofsWeHave(t){return this.config.proofsWeHave=t,this}onCountersReserved(t){return this.config.onCountersReserved=t,this}async run(){if(this.method==="bolt11"){const e=this.quote;if(e.pubkey&&!this.config.privkey)throw new Error("privkey is required for locked BOLT11 mint quotes");return this.wallet.mintProofsBolt11(this.amount,e,this.config,this.outputType)}const t=this.quote;if(!this.config.privkey)throw new Error("privkey is required for BOLT12 mint quotes");return this.wallet.mintProofsBolt12(this.amount,t,this.config.privkey,this.config,this.outputType)}}class Wt{constructor(t,e,n,r){this.wallet=t,this.method=e,this.quote=n,this.proofs=r,this.config={}}asRandom(t){return this.outputType={type:"random",denominations:t},this}asDeterministic(t=0,e){return this.outputType={type:"deterministic",counter:t,denominations:e},this}asP2PK(t,e){return this.outputType={type:"p2pk",options:t,denominations:e},this}asFactory(t,e){return this.outputType={type:"factory",factory:t,denominations:e},this}asCustom(t){return this.outputType={type:"custom",data:t},this}keyset(t){return this.config.keysetId=t,this}onCountersReserved(t){return this.config.onCountersReserved=t,this}onChangeOutputsCreated(t){return this.config.onChangeOutputsCreated=t,this}async run(){return this.method==="bolt11"?this.wallet.meltProofsBolt11(this.quote,this.proofs,this.config,this.outputType):this.wallet.meltProofsBolt12(this.quote,this.proofs,this.config,this.outputType)}}function Ts(s){const t=new WeakSet;try{return JSON.stringify(s,(e,n)=>{if(typeof n=="object"&&n!==null){if(t.has(n))return"[Circular]";t.add(n)}return n})}catch{return Object.prototype.toString.call(s)}}function ye(s){if(s instanceof Error)return s;const t=typeof s=="string"?s:Ts(s),e=new Error(t);return e.cause=s,e}function we(){const s=new Error("Aborted");return Object.defineProperty(s,"name",{value:"AbortError"}),s}function et(s){s&&Promise.resolve(s).then(t=>{try{t()}catch{}}).catch(()=>{})}class gn{constructor(t){this.wallet=t,this.countersReservedHandlers=new Set,this.meltBlanksHandlers=new Set}withAbort(t,e){if(!t)return e;if(t.aborted)return e(),()=>{};const n=()=>e();return t.addEventListener("abort",n,{once:!0}),()=>{t.removeEventListener("abort",n),e()}}waitUntilPaid(t,e,n,r="Timeout waiting for paid"){return new Promise((i,o)=>{let a=null,c=null;const u=h=>{et(a),c&&(clearTimeout(c),c=null),n?.signal&&n.signal.removeEventListener("abort",l),h&&o(ye(h))},l=()=>u(we());if(n?.signal){if(n.signal.aborted)return l();n.signal.addEventListener("abort",l,{once:!0})}n?.timeoutMs&&n.timeoutMs>0&&(c=setTimeout(()=>u(new Error(r)),n.timeoutMs)),a=t(e,h=>{u(),i(h)},h=>u(h),{signal:n?.signal})})}countersReserved(t,e){this.countersReservedHandlers.add(t);const n=()=>this.countersReservedHandlers.delete(t);return this.withAbort(e?.signal,n)}_emitCountersReserved(t){for(const e of this.countersReservedHandlers)lt(e,t,this.wallet.logger,{event:"countersReserved"})}meltBlanksCreated(t,e){this.meltBlanksHandlers.add(t);const n=()=>this.meltBlanksHandlers.delete(t);return this.withAbort(e?.signal,n)}_emitMeltBlanksCreated(t){for(const e of this.meltBlanksHandlers)lt(e,t,this.wallet.logger,{event:"meltBlanksCreated"})}async mintQuoteUpdates(t,e,n,r){await this.wallet.mint.connectWebSocket();const i=this.wallet.mint.webSocketConnection;if(!i)throw new Error("Failed to establish WebSocket connection.");const o=Array.from(new Set(t)),a=i.createSubscription({kind:"bolt11_mint_quote",filters:o},e,n),c=()=>i.cancelSubscription(a,e);return this.withAbort(r?.signal,c)}async mintQuotePaid(t,e,n,r){return this.mintQuoteUpdates([t],i=>{i.state===pt.PAID&&e(i)},n,r)}async meltQuoteUpdates(t,e,n,r){await this.wallet.mint.connectWebSocket();const i=this.wallet.mint.webSocketConnection;if(!i)throw new Error("Failed to establish WebSocket connection.");const o=Array.from(new Set(t)),a=i.createSubscription({kind:"bolt11_melt_quote",filters:o},e,n),c=()=>i.cancelSubscription(a,e);return this.withAbort(r?.signal,c)}async meltQuotePaid(t,e,n,r){return this.meltQuoteUpdates([t],i=>{i.state===st.PAID&&e(i)},n,r)}async proofStateUpdates(t,e,n,r){await this.wallet.mint.connectWebSocket();const i=this.wallet.mint.webSocketConnection;if(!i)throw new Error("Failed to establish WebSocket connection.");const o=new TextEncoder,a={};for(const d of t){const p=at(o.encode(d.secret)).toHex(!0);a[p]=d}const c=Object.keys(a),u=d=>{e({...d,proof:a[d.Y]})},l=i.createSubscription({kind:"proof_state",filters:c},u,n),h=()=>i.cancelSubscription(l,u);return this.withAbort(r?.signal,h)}onceMintPaid(t,e){return this.waitUntilPaid(this.mintQuotePaid.bind(this),t,e,"Timeout waiting for mint paid")}onceAnyMintPaid(t,e){return new Promise((n,r)=>{const i=Array.from(new Set(t)),o=new Map;let a=null,c=null,u=!1;const l=d=>{for(const p of o.values())et(p);o.clear(),a&&(clearTimeout(a),a=null),e?.signal&&e.signal.removeEventListener("abort",h),d&&r(ye(d))},h=()=>l(we());if(e?.signal){if(e.signal.aborted)return h();e.signal.addEventListener("abort",h,{once:!0})}if(e?.timeoutMs&&e.timeoutMs>0&&(a=setTimeout(()=>l(new Error("Timeout waiting for any mint paid")),e.timeoutMs)),i.length===0)return l(new Error("No quote ids provided"));for(const d of i){const p=this.mintQuotePaid(d,y=>{l(),n({id:d,quote:y})},y=>{if(e?.failOnError){l(y);return}c=y;const v=o.get(d);v&&(et(v),o.delete(d)),u&&o.size===0&&l(c??new Error("No subscriptions remaining"))});o.set(d,p)}u=!0})}onceMeltPaid(t,e){return this.waitUntilPaid(this.meltQuotePaid.bind(this),t,e,"Timeout waiting for melt paid")}proofStatesStream(t,e){return async function*(){const n=[];let r=!1,i=null;const o=e?.maxBuffer&&e.maxBuffer>0?e.maxBuffer:1/0,a=e?.drop??"oldest",c=()=>{const d=i;i=null,d&&d()},u=d=>{if(n.length>=o)if(a==="oldest"){const p=n.shift();if(p!==void 0)try{e?.onDrop?.(p)}catch{}n.push(d)}else{try{e?.onDrop?.(d)}catch{}return}else n.push(d);c()},l=this.proofStateUpdates(t,d=>{u(d)},()=>{r=!0,c()},{signal:e?.signal}),h=()=>{r=!0,c()};try{for(e?.signal&&(e.signal.aborted?h():e.signal.addEventListener("abort",h,{once:!0}));!r||n.length;){for(;n.length;)yield n.shift();if(r)break;await new Promise(d=>i=d)}}finally{et(l),e?.signal&&e.signal.removeEventListener("abort",h)}}.call(this)}group(){const t=[];let e=!1;const n=(()=>{if(!e)for(e=!0;t.length;)et(t.pop())});return n.add=r=>e?(et(r),r):(t.push(r),r),Object.defineProperty(n,"cancelled",{get:()=>e,enumerable:!0}),n}}class pn{constructor(t){this.src=t}async peekNext(t){return(await this.src.reserve(t,0)).start}async advanceToAtLeast(t,e){await this.src.advanceToAtLeast(t,e)}async setNext(t,e){if(typeof this.src.setNext=="function"){await this.src.setNext(t,e);return}throw new Error("CounterSource does not support setNext()")}async snapshot(){if(typeof this.src.snapshot=="function")return await this.src.snapshot();throw new Error("CounterSource does not support snapshot()")}}const gt={UNSPENT:"UNSPENT",PENDING:"PENDING",SPENT:"SPENT"},Rt="__PENDING__";class Ot{constructor(t,e){this._seed=void 0,this._unit="sat",this._mintInfo=void 0,this._denominationTarget=3,this._secretsPolicy="auto",this._boundKeysetId=Rt,this.swap=this.send.bind(this),this.ops=new ln(this),this.on=new gn(this),this._logger=e?.logger??H,this._selectProofs=e?.selectProofs??hn,this.mint=typeof t=="string"?new Kt(t,{authProvider:e?.authProvider,logger:this._logger}):t,this._unit=e?.unit??this._unit,this._boundKeysetId=e?.keysetId??this._boundKeysetId,e?.bip39seed&&(this.failIf(!(e.bip39seed instanceof Uint8Array),"bip39seed must be a valid Uint8Array",{bip39seed:e.bip39seed}),this._seed=e.bip39seed),this._secretsPolicy=e?.secretsPolicy??this._secretsPolicy,e?.counterSource?this._counterSource=e.counterSource:this._counterSource=new Ss(e?.counterInit),this.counters=new pn(this._counterSource),this.keyChain=new ce(this.mint,this._unit,e?.keysets,e?.keys),this._mintInfo=e?.mintInfo?new dt(e.mintInfo):this._mintInfo,this._denominationTarget=e?.denominationTarget??this._denominationTarget}fail(t,e){return St(t,this._logger,e)}failIf(t,e,n){return Pe(t,e,this._logger,n)}failIfNullish(t,e,n){return be(t,e,this._logger,n)}safeCallback(t,e,n){lt(t,e,this._logger,n)}async loadMint(t){const e=[];if((!this._mintInfo||t)&&e.push(this.mint.getInfo().then(n=>(this._mintInfo=new dt(n),null))),e.push(this.keyChain.init(t).then(()=>null)),await Promise.all(e),this._logger.debug("KeyChain",{keychain:this.keyChain.getCache()}),this._boundKeysetId===Rt)this._boundKeysetId=this.keyChain.getCheapestKeyset().id;else{const n=this.keyChain.getKeyset(this._boundKeysetId);this.failIf(!n.hasKeys,"Wallet keyset has no keys after refresh",{keyset:n.id})}}get unit(){return this._unit}getMintInfo(){return this.failIfNullish(this._mintInfo,"Mint info not initialized; call loadMint first"),this._mintInfo}get keysetId(){return this.failIf(this._boundKeysetId===Rt,"Wallet not initialised, call loadMint"),this._boundKeysetId}getKeyset(t){const e=this.keyChain.getKeyset(t??this.keysetId);return this.failIf(e.unit!==this._unit,"Keyset unit does not match wallet unit",{keyset:e.id,unit:e.unit,walletUnit:this._unit}),this.failIf(!e.hasKeys,"Keyset has no keys loaded",{keyset:e.id}),e}get logger(){return this._logger}async reserveFor(t,e){return e<=0?{start:0,count:0}:this._counterSource.reserve(t,e)}countersNeeded(t){return t.type!=="deterministic"||t.counter!==0?0:(t.denominations??[]).length}async addCountersToOutputTypes(t,...e){const n=e.reduce((c,u)=>c+this.countersNeeded(u),0);if(n===0)return{outputTypes:e};const r=await this.reserveFor(t,n);let i=r.start;const o=e.map(c=>{if(c.type==="deterministic"&&c.counter===0){const u=(c.denominations??[]).length;if(u>0){const l={...c,counter:i};return i+=u,l}}return c}),a={keysetId:t,start:r.start,count:r.count,next:r.start+r.count};return this.on._emitCountersReserved(a),{outputTypes:o,used:a}}bindKeyset(t){const e=this.keyChain.getKeyset(t);this.failIf(e.unit!==this._unit,"Keyset unit does not match wallet unit",{keyset:e.id,unit:e.unit,walletUnit:this._unit}),this.failIf(!e.hasKeys,"Keyset has no keys loaded",{keyset:e.id}),this._boundKeysetId=e.id,this._logger.debug("Wallet bound to keyset",{keysetId:e.id,unit:e.unit,feePPK:e.fee})}withKeyset(t,e){return new Ot(this.mint,{keysetId:t,bip39seed:this._seed,secretsPolicy:this._secretsPolicy,logger:this._logger,counterSource:e?.counterSource??this._counterSource,...this.keyChain.getCache()})}defaultOutputType(){return this._secretsPolicy==="random"?{type:"random"}:this._secretsPolicy==="deterministic"?(this.failIfNullish(this._seed,"Deterministic policy requires a seed"),{type:"deterministic",counter:0}):this._seed?{type:"deterministic",counter:0}:{type:"random"}}configureOutputs(t,e,n,r=!1,i=[]){let o=t;if(n.type==="custom"){this.failIf(r,"The custom OutputType does not support automatic fee inclusion");const c=U.sumOutputAmounts(n.data);return this.failIf(c!==t,`Custom output data total (${c}) does not match amount (${t})`),n}let a=n.denominations??[];if(a.length===0&&i.length>0&&(a=Je(i,o,e.keys,this._denominationTarget)),a=Q(o,e.keys,a),r){let c=this.getFeesForKeyset(a.length,e.id),u=Q(c,e.keys);for(;this.getFeesForKeyset(a.length+u.length,e.id)>c;)c++,u=Q(c,e.keys);o+=c,a=[...a,...u]}return{...n,denominations:a}}preparedTotal(t){return t.type==="custom"?U.sumOutputAmounts(t.data):(t.denominations??[]).reduce((n,r)=>n+r,0)}createOutputData(t,e,n){if(this.failIf(t<0,"Amount was negative",{amount:t}),n.type!="custom"&&n.denominations&&n.denominations.length>0){const i=n.denominations.reduce((o,a)=>o+a,0);this.failIf(i!==t,"Denominations do not sum to the expected amount",{splitSum:i,expected:t})}let r;switch(n.type){case"random":r=U.createRandomData(t,e,n.denominations);break;case"deterministic":this.failIfNullish(this._seed,"Deterministic outputs require a seed configured in the wallet"),r=U.createDeterministicData(t,this._seed,n.counter,e,n.denominations);break;case"p2pk":r=U.createP2PKData(n.options,t,e,n.denominations);break;case"factory":{r=Q(t,e.keys,n.denominations).map(o=>n.factory(o,e));break}case"custom":{r=n.data;const i=U.sumOutputAmounts(r);this.failIf(i!==t,`Custom output data total (${i}) does not match amount (${t})`);break}default:this.fail("Invalid OutputType")}return r}createSwapTransaction(t,e,n=[]){t=this._prepareInputsForMint(t);const r=[...e,...n],i=r.map((h,d)=>d).sort((h,d)=>r[h].blindedMessage.amount-r[d].blindedMessage.amount),o=[...Array.from({length:e.length},()=>!0),...Array.from({length:n.length},()=>!1)],a=i.map(h=>r[h]),c=i.map(h=>o[h]),u=a.map(h=>h.blindedMessage);return this._logger.debug("createSwapTransaction:",{indices:i,sortedKeepVector:c}),{payload:{inputs:t,outputs:u},outputData:a,keepVector:c,sortedIndices:i}}async receive(t,e,n){const{keysetId:r,privkey:i,requireDleq:o,proofsWeHave:a,onCountersReserved:c}=e||{};n=n??this.defaultOutputType();const u=typeof t=="string"?this.decodeToken(t):t,l=ie(u.mint);this.failIf(l!==this.mint.mintUrl,"Token belongs to a different mint",{token:l,wallet:this.mint.mintUrl}),this.failIf(u.unit!==this._unit,"Token is not in wallet unit",{token:u.unit,wallet:this._unit});let h=[];({proofs:h}=u);const d=J(h);if(d===0)return[];i&&(h=this.signP2PKProofs(h,i));const p=this.getKeyset(r);if(o)for(const E of h){const O=this.keyChain.getKeyset(E.id);ae(E,O)||this.fail("Token contains proofs with invalid or missing DLEQ")}const y=d-this.getFeesForProofs(h);let v=this.configureOutputs(y,p,n,!1,a);const A=await this.addCountersToOutputTypes(p.id,v);[v]=A.outputTypes,A.used&&this.safeCallback(c,A.used,{op:"receive"}),this._logger.debug("receive counter",{counter:A.used,receiveOT:v});const k=this.createOutputData(this.preparedTotal(v),p,v),S=this.createSwapTransaction(h,k,[]),{signatures:I}=await this.mint.swap(S.payload),R=S.outputData.map((E,O)=>E.toProof(I[O],p)),K=[];return S.sortedIndices.forEach((E,O)=>{K[E]=R[O]}),this._logger.debug("RECEIVE COMPLETED",{amounts:K.map(E=>E.amount)}),K}sendOffline(t,e,n){const{requireDleq:r=!1,includeFees:i=!1,exactMatch:o=!0}=n||{};r&&(e=e.filter(l=>l.dleq!=null)),this.failIf(J(e)<t,"Not enough funds available to send");const{keep:a,send:c}=this.selectProofsToSend(e,t,i,o),u=this._prepareInputsForMint(c,r);return{keep:a,send:u}}async send(t,e,n,r){const{keysetId:i,includeFees:o=!1,onCountersReserved:a}=n||{};r=r??{send:this.defaultOutputType(),keep:this.defaultOutputType()};try{const f=this.defaultOutputType().type==="deterministic",g=T=>!T||T.type==="random"&&(!T.denominations||T.denominations.length===0);if(i||f||!g(r.send)||r.keep&&!g(r.keep)){const T=[];throw i&&T.push("keysetId override"),f&&T.push("wallet default is deterministic"),g(r.send)||T.push("non-default send output type"),r.keep&&!g(r.keep)&&T.push("non-default keep output type"),new Error(`Options require a swap: ${T.join(", ")}`)}const{keep:P,send:w}=this.sendOffline(t,e,{includeFees:o,exactMatch:!0,requireDleq:!1}),F=o?this.getFeesForProofs(w):0;if(J(w)===t+F)return this._logger.info("Successful exactMatch offline selection!"),{keep:P,send:w}}catch(f){const g=f instanceof Error?f.message:"Unknown error";this._logger.debug("ExactMatch offline selection failed.",{e:g})}const c=this.getKeyset(i);let u=this.configureOutputs(t,c,r.send??this.defaultOutputType(),o);const l=this.preparedTotal(u),{keep:h,send:d}=this.selectProofsToSend(e,l,!0);if(d.length===0)throw new Error("Not enough funds available to send");const p=J(d),y=this.getFeesForProofs(d),v=p-y-l;this.failIf(v<0,"Not enough funds available for swap",{selectedSum:p,swapFee:y,sendAmount:l,changeAmount:v});let A=this.configureOutputs(v,c,r.keep??this.defaultOutputType(),!1,n?.proofsWeHave);const k=this.preparedTotal(A),S=await this.addCountersToOutputTypes(c.id,u,A);[u,A]=S.outputTypes,S.used&&this.safeCallback(a,S.used,{op:"send"}),this._logger.debug("send counters",{counter:S.used,sendOT:u,keepOT:A});const I=this.createOutputData(l,c,u),R=this.createOutputData(k,c,A),K=this.createSwapTransaction(d,R,I),{signatures:E}=await this.mint.swap(K.payload),O=K.outputData.map((f,g)=>f.toProof(E[g],c)),ct=Array(O.length),B=Array(K.keepVector.length);K.sortedIndices.forEach((f,g)=>{B[f]=K.keepVector[g],ct[f]=O[g]});const X=[],Y=[];return ct.forEach((f,g)=>{B[g]?X.push(f):Y.push(f)}),this._logger.debug("SEND COMPLETED",{unselectedProofs:h.map(f=>f.amount),keepProofs:X.map(f=>f.amount),sendProofs:Y.map(f=>f.amount)}),{keep:[...X,...h],send:Y}}selectProofsToSend(t,e,n=!1,r=!1){const{keep:i,send:o}=this._selectProofs(t,e,this.keyChain,n,r);return{keep:i,send:o}}signP2PKProofs(t,e){return Oe(t,e)}getFeesForProofs(t){const e=t.reduce((n,r)=>n+this.getProofFeePPK(r),0);return Math.ceil(e/1e3)}getProofFeePPK(t){try{return this.keyChain.getKeyset(t.id).fee}catch(e){this.fail(`Could not get fee. No keyset found for keyset id: ${t.id}`,{e,keychain:this.keyChain.getKeysets()})}}getFeesForKeyset(t,e){try{const n=this.keyChain.getKeyset(e).fee;return Math.floor(Math.max((t*n+999)/1e3,0))}catch(n){this.fail(`No keyset found with ID ${e}`,{e:n})}}_prepareInputsForMint(t,e=!1){return t.map(n=>{const r=n.witness&&typeof n.witness!="string"?JSON.stringify(n.witness):n.witness,{dleq:i,p2pk_e:o,...a}=n;return e&&i?{...a,dleq:i,witness:r}:{...a,witness:r}})}decodeToken(t){const e=this.keyChain.getKeysets();return nn(t,e)}async batchRestore(t=300,e=100,n=0,r){const i=Math.ceil(t/e),o=[];let a,c=0;for(;c<i;){const u=await this.restore(n,e,{keysetId:r});u.proofs.length>0?(c=0,o.push(...u.proofs),a=u.lastCounterWithSignature):c++,n+=e}return{proofs:o,lastCounterWithSignature:a}}async restore(t,e,n){const{keysetId:r}=n||{},i=this.getKeyset(r);this.failIfNullish(this._seed,"Cashu Wallet must be initialized with a seed to use restore");const o=Array(e).fill(0),a=U.createDeterministicData(0,this._seed,t,i,o),{outputs:c,signatures:u}=await this.mint.restore({outputs:a.map(p=>p.blindedMessage)}),l={};c.forEach((p,y)=>l[p.B_]=u[y]);const h=[];let d;for(let p=0;p<a.length;p++){const y=l[a[p].blindedMessage.B_];y&&(d=t+p,a[p].blindedMessage.amount=y.amount,h.push(a[p].toProof(y,i)))}return{proofs:h,lastCounterWithSignature:d}}async createMintQuote(t,e){return this.createMintQuoteBolt11(t,e)}async createMintQuoteBolt11(t,e){e&&(this.getMintInfo().supportsNut04Description("bolt11",this._unit)||this.fail("Mint does not support description for bolt11"));const n={unit:this._unit,amount:t,description:e},r=await this.mint.createMintQuoteBolt11(n);return{...r,amount:r.amount||t,unit:r.unit||this._unit}}async createLockedMintQuote(t,e,n){const{supported:r}=this.getMintInfo().isSupported(20);this.failIf(!r,"Mint does not support NUT-20");const i={unit:this._unit,amount:t,description:n,pubkey:e},o=await this.mint.createMintQuoteBolt11(i);this.failIf(typeof o.pubkey!="string","Mint returned unlocked mint quote");const a=o.pubkey;return{...o,pubkey:a,amount:o.amount||t,unit:o.unit||this._unit}}async createMintQuoteBolt12(t,e){const n=this.getMintInfo();e?.description&&!n.supportsNut04Description("bolt12",this._unit)&&this.fail("Mint does not support description for bolt12");const r={pubkey:t,unit:this._unit,amount:e?.amount,description:e?.description};return this.mint.createMintQuoteBolt12(r)}async checkMintQuote(t){return this.checkMintQuoteBolt11(t)}async checkMintQuoteBolt11(t){const e=typeof t=="string"?t:t.quote,n=await this.mint.checkMintQuoteBolt11(e);return typeof t=="string"?n:{...n,amount:n.amount||t.amount,unit:n.unit||t.unit}}async checkMintQuoteBolt12(t){return this.mint.checkMintQuoteBolt12(t)}async mintProofs(t,e,n,r){return this._mintProofs("bolt11",t,e,n,r)}async mintProofsBolt11(t,e,n,r){return this._mintProofs("bolt11",t,e,n,r)}async mintProofsBolt12(t,e,n,r,i){return this._mintProofs("bolt12",t,e,{...r,privkey:n},i)}async _mintProofs(t,e,n,r,i){i=i??this.defaultOutputType();const{privkey:o,keysetId:a,proofsWeHave:c,onCountersReserved:u}=r??{};this.failIf(e<=0,"Invalid mint amount: must be positive",{amount:e});const l=this.getKeyset(a);let h=this.configureOutputs(e,l,i,!1,c);const d=this.preparedTotal(h),p=await this.addCountersToOutputTypes(l.id,h);[h]=p.outputTypes,p.used&&this.safeCallback(u,p.used,{op:"mintProofs"}),this._logger.debug("mint counter",{counter:p.used,mintOT:h});const y=this.createOutputData(d,l,h),v=y.map(S=>S.blindedMessage),A={outputs:v,quote:typeof n=="string"?n:n.quote};if(typeof n!="string"&&n.pubkey){this.failIf(!o,"Can not sign locked quote without private key");const S=Ge(o,n.quote,v);A.signature=S}let k;return t==="bolt12"?{signatures:k}=await this.mint.mintBolt12(A):{signatures:k}=await this.mint.mintBolt11(A),this.failIf(k.length!==y.length,`Mint returned ${k.length} signatures, expected ${y.length}`),this._logger.debug("MINT COMPLETED",{amounts:y.map(S=>S.blindedMessage.amount)}),y.map((S,I)=>S.toProof(k[I],l))}async createMeltQuote(t){return this.createMeltQuoteBolt11(t)}async createMeltQuoteBolt11(t){const e={unit:this._unit,request:t},n=await this.mint.createMeltQuoteBolt11(e);return{...n,unit:n.unit||this._unit,request:n.request||t}}async createMeltQuoteBolt12(t,e){return this.mint.createMeltQuoteBolt12({unit:this._unit,request:t,options:e?{amountless:{amount_msat:e}}:void 0})}async createMultiPathMeltQuote(t,e){const{supported:n,params:r}=this.getMintInfo().isSupported(15);this.failIf(!n,"Mint does not support NUT-15"),this.failIf(!r?.some(u=>u.method==="bolt11"&&u.unit===this._unit),`Mint does not support MPP for bolt11 and ${this._unit}`);const o={mpp:{amount:e}},a={unit:this._unit,request:t,options:o};return{...await this.mint.createMeltQuoteBolt11(a),request:t,unit:this._unit}}async checkMeltQuote(t){return this.checkMeltQuoteBolt11(t)}async checkMeltQuoteBolt11(t){const e=typeof t=="string"?t:t.quote,n=await this.mint.checkMeltQuoteBolt11(e);return typeof t=="string"?n:{...n,request:t.request,unit:t.unit}}async checkMeltQuoteBolt12(t){return this.mint.checkMeltQuoteBolt12(t)}async meltProofs(t,e,n,r){return this._meltProofs("bolt11",t,e,n,r)}async meltProofsBolt11(t,e,n,r){return this._meltProofs("bolt11",t,e,n,r)}async meltProofsBolt12(t,e,n,r){return this._meltProofs("bolt12",t,e,n,r)}async _meltProofs(t,e,n,r,i){i=i??this.defaultOutputType();const{keysetId:o,onChangeOutputsCreated:a,onCountersReserved:c}=r||{},u=this.getKeyset(o),l=J(n),h=l-e.amount;let d=[];if(this.failIf(h<0,"Not enough proofs to cover amount + fee reserve",{sendAmount:l,quoteAmount:e.amount}),h>0){let k=Math.ceil(Math.log2(h))||1;k<0&&(k=0);const S=k?new Array(k).fill(0):[];this._logger.debug("Creating NUT-08 blanks for fee reserve",{feeReserve:h,denominations:S}),i.type==="custom"&&this.fail("Custom OutputType not supported for melt change (must be 0-sat blanks)");let I={...i,denominations:S};const R=await this.addCountersToOutputTypes(u.id,I);[I]=R.outputTypes,R.used&&this.safeCallback(c,R.used,{op:"meltProofs"}),this._logger.debug("melt counter",{counter:R.used,meltOT:I}),d=this.createOutputData(0,u,I)}n=this._prepareInputsForMint(n);const p={quote:e.quote,inputs:n,outputs:d.map(k=>k.blindedMessage)};if(d.length>0){const k={method:t,payload:p,outputData:d,keyset:u,quote:e};this.safeCallback(a,k,{op:"meltProofs"}),this.on._emitMeltBlanksCreated(k)}let y;const v=typeof a=="function";t==="bolt12"?y=await this.mint.meltBolt12(p,{preferAsync:v}):y=await this.mint.meltBolt11(p,{preferAsync:v}),this.failIf((y.change?.length??0)>d.length,`Mint returned ${y.change?.length??0} signatures, but only ${d.length} blanks were provided`);const A=y.change?.map((k,S)=>d[S].toProof(k,u))??[];return this._logger.debug("MELT COMPLETED",{changeAmounts:A.map(k=>k.amount)}),{quote:{...y,unit:e.unit,request:e.request},change:A}}async completeMelt(t){const e=t.method==="bolt12"?await this.mint.meltBolt12(t.payload):await this.mint.meltBolt11(t.payload);this.failIf((e.change?.length??0)>t.outputData.length,`Mint returned ${e.change?.length??0} signatures, but only ${t.outputData.length} blanks were provided`);const n=e.change?.map((r,i)=>t.outputData[i].toProof(r,t.keyset))??[];return this._logger.debug("COMPLETE MELT",{changeAmounts:n.map(r=>r.amount)}),{quote:{...e,unit:t.quote.unit,request:t.quote.request},change:n}}async checkProofsStates(t){const e=new TextEncoder,n=t.map(o=>at(e.encode(o.secret)).toHex(!0)),r=100,i=[];for(let o=0;o<n.length;o+=r){const a=n.slice(o,o+r),{states:c}=await this.mint.check({Ys:a}),u={};c.forEach(l=>{u[l.Y]=l});for(let l=0;l<a.length;l++){const h=u[a[l]];this.failIfNullish(h,"Could not find state for proof with Y: "+a[l]),i.push(h)}}return i}async groupProofsByState(t){const e=await this.checkProofsStates(t),n={unspent:[],pending:[],spent:[]};for(let r=0;r<e.length;r++){const i=t[r];switch(e[r].state){case gt.UNSPENT:n.unspent.push(i);break;case gt.PENDING:n.pending.push(i);break;case gt.SPENT:n.spent.push(i);break}}return n}}var mn=(s=>(s.POST="post",s.NOSTR="nostr",s))(mn||{});const _t=class _t{constructor(t,e){this.tokens={},this.pool=[],this.desiredPoolSize=10,this.maxPerMint=10,this.mintUrl=t,this.req=e?.request??Ae,this.logger=e?.logger??H,this.desiredPoolSize=Math.max(1,e?.desiredPoolSize??this.desiredPoolSize),this.maxPerMint=Math.max(1,e?.maxPerMint??this.maxPerMint)}attachOIDC(t){return this.oidc=t,this.oidc.addTokenListener(e=>this.updateFromOIDC(e)),this}get poolSize(){return this.pool.length}get poolTarget(){return this.desiredPoolSize}get activeAuthKeysetId(){try{return this.keychain?.getCheapestKeyset().id}catch{return}}get hasCAT(){return!!this.tokens.accessToken}getCAT(){return this.tokens.accessToken}setCAT(t){this.tokens.accessToken=t,t||(this.tokens.refreshToken=void 0,this.tokens.expiresAt=void 0)}async ensureCAT(t){return this.validForAtLeast(t)?this.tokens.accessToken:!this.oidc||!this.tokens.refreshToken?this.tokens.accessToken:(this.inflightRefresh||(this.inflightRefresh=(async()=>{try{const e=await this.oidc.refresh(this.tokens.refreshToken);this.updateFromOIDC(e)}catch(e){this.logger.warn("AuthManager: CAT refresh failed",{err:e})}finally{this.inflightRefresh=void 0}})()),await this.inflightRefresh,this.validForAtLeast(0)?this.tokens.accessToken:void 0)}validForAtLeast(t=_t.MIN_VALID_SECS){const{accessToken:e,expiresAt:n}=this.tokens;return e?n?Date.now()+t*1e3<n:!0:!1}updateFromOIDC(t){if(!t.access_token)return;const e=Date.now();if(this.tokens.accessToken=t.access_token,t.refresh_token&&(this.tokens.refreshToken=t.refresh_token),typeof t.expires_in=="number"&&t.expires_in>0)this.tokens.expiresAt=e+t.expires_in*1e3;else{const n=this.parseJwtExpSec(t.access_token);this.tokens.expiresAt=n?n*1e3:void 0}this.logger.debug("AuthManager: OIDC tokens updated",{expiresAt:this.tokens.expiresAt})}async ensure(t){if(await this.init(),this.pool.length>=t)return;const e=Math.max(this.desiredPoolSize,t),n=this.getBatMaxMint(),r=Math.min(e-this.pool.length,n);r<=0||await this.topUp(r)}async getBlindAuthToken({method:t,path:e}){return this.info&&!this.info.requiresBlindAuthToken(t,e)&&this.logger.warn("Endpoint is not marked as protected by NUT-22; still issuing BAT",{method:t,path:e}),this.withLock(async()=>{if(await this.ensure(1),this.pool.length===0)throw new Error("AuthManager: no BATs available and minting failed");const n=this.pool.pop();return this.logger.debug("AuthManager: BAT requested",{method:t,path:e,remaining:this.pool.length}),Es(n)})}importPool(t,e="replace"){e==="replace"&&(this.pool=[]);const n=new Map(this.pool.map(r=>[r.secret,r]));for(const r of t)!r||!r.secret||!r.C||!r.id||n.has(r.secret)||(this.pool.push(r),n.set(r.secret,r))}exportPool(){return this.pool.map(t=>({...t,dleq:t.dleq?{...t.dleq}:void 0}))}parseJwtExpSec(t){if(!t)return;const e=t.split(".");if(e.length===3)try{const n=_.toString(_.fromBase64(e[1])),r=JSON.parse(n),i=typeof r.exp=="number"?r.exp:Number(r.exp);if(Number.isFinite(i)&&i>0)return i}catch{this.logger.warn("JWT access token was malformed.",{token:t})}}async withLock(t){const e=this.lockChain??Promise.resolve();let n;const r=new Promise(o=>{n=o}),i=e.then(()=>r);this.lockChain=i;try{return await e,await t()}finally{n(),this.lockChain===i&&(this.lockChain=void 0)}}async init(){if(!this.info){const t=await this.req({endpoint:$(this.mintUrl,"/v1/info"),method:"GET"});this.info=new dt(t)}if(!this.keychain){const[t,e]=await Promise.all([this.req({endpoint:$(this.mintUrl,"/v1/auth/blind/keysets"),method:"GET"}),this.req({endpoint:$(this.mintUrl,"/v1/auth/blind/keys"),method:"GET"})]);this.keychain=new ce(this.mintUrl,"auth",t.keysets,e.keysets),this.keychain.getCheapestKeyset()}}getBatMaxMint(){if(!this.info)throw new Error("AuthManager: mint info not loaded");const e=this.info.nuts[22]?.bat_max_mint??this.maxPerMint;return Math.max(1,Math.min(this.maxPerMint,e))}getActiveKeys(){if(!this.keychain)throw new Error("AuthManager: keyset not loaded for active keyset");return this.keychain.getCheapestKeyset()}async topUp(t){if(!this.info)throw new Error("AuthManager: mint info not loaded");const e=this.info.requiresClearAuthToken("POST","/v1/auth/blind/mint");let n;if(e&&(n=await this.ensureCAT(),!n))throw new Error("AuthManager: Clear-auth token required for /v1/auth/blind/mint but not available. Authenticate with the mint to obtain a CAT first.");const r=this.getActiveKeys(),i=U.createRandomData(t,r),o={outputs:i.map(l=>l.blindedMessage)},a={};n&&(a["Clear-auth"]=n);const c=await this.req({endpoint:$(this.mintUrl,"/v1/auth/blind/mint"),method:"POST",headers:a,requestBody:o});if(!Array.isArray(c?.signatures)||c.signatures.length!==i.length)throw new Error("AuthManager: bad BAT mint response");const u=i.map((l,h)=>l.toProof(c.signatures[h],r));for(const l of u)if(!ae(l,r))throw new Error("AuthManager: mint returned BAT with invalid DLEQ");this.pool.push(...u),this.logger.debug("AuthManager: performed topUp",{minted:u.length,pool:this.pool.length})}};_t.MIN_VALID_SECS=30;let bt=_t;function Es(s){const t={id:s.id,secret:s.secret,C:s.C};return`authA${Se(t)}`}async function xs(s,t){const e=new bt(s,{desiredPoolSize:t?.authPool??10,logger:t?.logger}),n=new Kt(s,{authProvider:e,logger:t?.logger}),r=await n.oidcAuth({...t?.oidc,logger:t?.logger,onTokens:o=>e.setCAT(o.access_token)});e.attachOIDC(r);const i=new Ot(n,{authProvider:e,logger:t?.logger});return await i.loadMint(),{mint:n,auth:e,oidc:r,wallet:i}}exports.AuthManager=bt;exports.CheckStateEnum=gt;exports.ConsoleLogger=kn;exports.HttpResponseError=rt;exports.KeyChain=ce;exports.Keyset=cn;exports.MeltBuilder=Wt;exports.MeltQuoteState=st;exports.MessageNode=sn;exports.MessageQueue=rn;exports.Mint=Kt;exports.MintBuilder=$t;exports.MintInfo=dt;exports.MintOperationError=At;exports.MintQuoteState=pt;exports.NetworkError=vt;exports.OIDCAuth=Ct;exports.OutputData=U;exports.P2BK_DST=Ft;exports.P2PKBuilder=ue;exports.PaymentRequest=Mt;exports.PaymentRequestTransportType=mn;exports.ReceiveBuilder=fn;exports.SendBuilder=dn;exports.WSConnection=an;exports.Wallet=Ot;exports.WalletCounters=pn;exports.WalletEvents=gn;exports.WalletOps=ln;exports.bigIntStringify=us;exports.blindMessage=ht;exports.bytesToNumber=L;exports.checkResponse=fs;exports.constructProofFromPromise=Ne;exports.createAuthWallet=xs;exports.createBlindSignature=Zn;exports.createDLEQProof=as;exports.createNewMintKeys=ss;exports.createP2PKsecret=jn;exports.createRandomBlindedMessage=ts;exports.createRandomSecretKey=ee;exports.decodePaymentRequest=gs;exports.deepEqual=Lt;exports.deriveBlindingFactor=We;exports.deriveKeysetId=Bt;exports.deriveP2BKBlindedPubkeys=Ee;exports.deriveP2BKSecretKey=Me;exports.deriveP2BKSecretKeys=xe;exports.deriveSecret=$e;exports.deserializeMintKeys=ns;exports.deserializeProof=es;exports.getDecodedToken=nn;exports.getDecodedTokenBinary=ks;exports.getEncodedToken=hs;exports.getEncodedTokenBinary=ws;exports.getEncodedTokenV3=Xe;exports.getEncodedTokenV4=Ze;exports.getKeepAmounts=Je;exports.getKeysetAmounts=ne;exports.getKeysetIdInt=Ue;exports.getP2PKExpectedKWitnessPubkeys=Et;exports.getP2PKLocktime=Yt;exports.getP2PKNSigs=Ke;exports.getP2PKSigFlag=zn;exports.getP2PKWitnessPubkeys=Jt;exports.getP2PKWitnessRefundkeys=Xt;exports.getP2PKWitnessSignatures=xt;exports.getPubKeyFromPrivKey=He;exports.getSignedOutput=Zt;exports.getSignedOutputs=Jn;exports.getTokenMetadata=ls;exports.handleTokens=re;exports.hasCorrespondingKey=se;exports.hasNonHexId=It;exports.hasP2PKSignedProof=Qn;exports.hasValidDleq=ae;exports.hashToCurve=at;exports.hash_e=te;exports.hexToNumber=it;exports.injectWebSocketImpl=An;exports.isObj=x;exports.isValidHex=Pt;exports.joinUrls=$;exports.maybeDeriveP2BKPrivateKeys=qe;exports.mergeUInt8Arrays=ft;exports.numberToHexPadded64=kt;exports.parseP2PKSecret=W;exports.pointFromBytes=Yn;exports.pointFromHex=G;exports.sanitizeUrl=ie;exports.selectProofsRGLI=hn;exports.serializeMintKeys=Le;exports.serializeProof=Fe;exports.setGlobalRequestOptions=bn;exports.signBlindedMessage=Ce;exports.signMintQuote=Ge;exports.signP2PKProof=De;exports.signP2PKProofs=Oe;exports.signP2PKSecret=Be;exports.sortProofsById=ds;exports.splitAmount=Q;exports.stripDleq=oe;exports.sumProofs=J;exports.unblindSignature=Re;exports.verifyDLEQProof=Qe;exports.verifyDLEQProof_reblind=ze;exports.verifyKeysetId=ps;exports.verifyMintQuoteSignature=cs;exports.verifyP2PKSecretSignature=Tt;exports.verifyP2PKSig=Vn;exports.verifyP2PKSigOutput=Gn;exports.verifyProof=rs;
//# sourceMappingURL=cashu-ts.cjs.map
