{"version":3,"file":"cashu-ts.cjs","sources":["../src/mint/types/responses.ts","../src/model/Errors.ts","../src/logger/NullLogger.ts","../src/logger/helpers.ts","../src/logger/ConsoleLogger.ts","../src/transport/request.ts","../src/transport/ws.ts","../src/utils/Bytes.ts","../src/utils/base64.ts","../src/utils/cbor.ts","../src/crypto/NUT26.ts","../src/crypto/NUT11.ts","../src/crypto/core.ts","../src/crypto/NUT01.ts","../src/crypto/NUT13.ts","../src/crypto/NUT12.ts","../src/crypto/NUT20.ts","../src/model/PaymentRequest.ts","../src/utils/core.ts","../src/transport/WSConnection.ts","../src/legacy/nut-05.ts","../src/legacy/nut-04.ts","../src/legacy/nut-06.ts","../src/model/MintInfo.ts","../src/auth/OIDCAuth.ts","../src/mint/Mint.ts","../src/wallet/Keyset.ts","../src/wallet/KeyChain.ts","../src/model/BlindedMessage.ts","../src/model/OutputData.ts","../src/wallet/P2PKBuilder.ts","../src/wallet/SelectProofs.ts","../src/wallet/CounterSource.ts","../src/wallet/WalletOps.ts","../src/wallet/WalletEvents.ts","../src/wallet/WalletCounters.ts","../src/model/types/proof-state.ts","../src/wallet/Wallet.ts","../src/wallet/types/payment-requests.ts","../src/auth/AuthManager.ts","../src/auth/createAuthWallet.ts"],"sourcesContent":["import type {\n\tSerializedBlindedMessage,\n\tSerializedBlindedSignature,\n} from '../../model/types/blinded';\nimport type { ProofState } from '../../model/types/proof-state';\n\n/**\n * Cashu api error.\n */\nexport type ApiError = {\n\t/**\n\t * Error message.\n\t */\n\terror?: string;\n\t/**\n\t * HTTP error code.\n\t */\n\tcode?: number;\n\t/**\n\t * Detailed error message.\n\t */\n\tdetail?: string;\n};\n\n/**\n * Response when checking proofs if they are spendable. Should not rely on this for receiving, since\n * it can be easily cheated.\n */\nexport type CheckStateResponse = {\n\tstates: ProofState[];\n} & ApiError;\n\n/**\n * Response from mint at /info endpoint.\n */\nexport type GetInfoResponse = {\n\tname: string;\n\tpubkey: string;\n\tversion: string;\n\tdescription?: string;\n\tdescription_long?: string;\n\ticon_url?: string;\n\tcontact: MintContactInfo[];\n\tnuts: {\n\t\t'4': {\n\t\t\t// Minting\n\t\t\tmethods: SwapMethod[];\n\t\t\tdisabled: boolean;\n\t\t};\n\t\t'5': {\n\t\t\t// Melting\n\t\t\tmethods: SwapMethod[];\n\t\t\tdisabled: boolean;\n\t\t};\n\t\t'7'?: {\n\t\t\t// Token state check\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'8'?: {\n\t\t\t// Overpaid melt fees\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'9'?: {\n\t\t\t// Restore\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'10'?: {\n\t\t\t// Spending conditions\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'11'?: {\n\t\t\t// P2PK\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'12'?: {\n\t\t\t// DLEQ\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'14'?: {\n\t\t\t// HTLCs\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'15'?: {\n\t\t\t// MPP\n\t\t\tmethods: MPPMethod[];\n\t\t};\n\t\t'17'?: {\n\t\t\t// WebSockets\n\t\t\tsupported: WebSocketSupport[];\n\t\t};\n\t\t'20'?: {\n\t\t\t// Locked Mint Quote\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'21'?: {\n\t\t\t// Clear Authentication\n\t\t\topenid_discovery: string;\n\t\t\tclient_id: string;\n\t\t\tprotected_endpoints?: Array<{ method: 'GET' | 'POST'; path: string }>;\n\t\t};\n\t\t'22'?: {\n\t\t\t// Blind Authentication\n\t\t\tbat_max_mint: number;\n\t\t\tprotected_endpoints: Array<{ method: 'GET' | 'POST'; path: string }>;\n\t\t};\n\t};\n\tmotd?: string;\n};\n\n/**\n * Response from the mint after requesting a melt quote.\n */\nexport type PartialMeltQuoteResponse = {\n\t/**\n\t * Quote ID.\n\t */\n\tquote: string;\n\t/**\n\t * Amount to be melted.\n\t */\n\tamount: number;\n\t/**\n\t * Fee reserve to be added to the amount.\n\t */\n\tfee_reserve: number;\n\t/**\n\t * State of the melt quote.\n\t */\n\tstate: MeltQuoteState;\n\t/**\n\t * Timestamp of when the quote expires.\n\t */\n\texpiry: number;\n\t/**\n\t * Preimage of the paid invoice. is null if it the invoice has not been paid yet. can be null,\n\t * depending on which LN-backend the mint uses.\n\t */\n\tpayment_preimage: string | null;\n\t/**\n\t * Return/Change from overpaid fees. This happens due to Lighting fee estimation being inaccurate.\n\t */\n\tchange?: SerializedBlindedSignature[];\n\t/**\n\t * Payment request for the melt quote.\n\t */\n\trequest?: string;\n\t/**\n\t * Unit of the melt quote.\n\t */\n\tunit?: string;\n} & ApiError;\n\nexport type MeltQuoteResponse = PartialMeltQuoteResponse & { request: string; unit: string };\n\n/**\n * Response from the mint after requesting a BOLT12 melt quote. Contains payment details and state\n * for paying Lightning Network offers.\n */\nexport type Bolt12MeltQuoteResponse = MeltQuoteResponse;\n\nexport const MeltQuoteState = {\n\tUNPAID: 'UNPAID',\n\tPENDING: 'PENDING',\n\tPAID: 'PAID',\n} as const;\nexport type MeltQuoteState = (typeof MeltQuoteState)[keyof typeof MeltQuoteState];\n\nexport type MintContactInfo = {\n\tmethod: string;\n\tinfo: string;\n};\n\nexport const MintQuoteState = {\n\tUNPAID: 'UNPAID',\n\tPAID: 'PAID',\n\tISSUED: 'ISSUED',\n} as const;\nexport type MintQuoteState = (typeof MintQuoteState)[keyof typeof MintQuoteState];\n\n/**\n * Response from the mint after requesting a mint.\n */\nexport type PartialMintQuoteResponse = {\n\t/**\n\t * Payment request.\n\t */\n\trequest: string;\n\t/**\n\t * Quote ID.\n\t */\n\tquote: string;\n\t/**\n\t * State of the mint quote.\n\t */\n\tstate: MintQuoteState;\n\t/**\n\t * Timestamp of when the quote expires.\n\t */\n\texpiry: number;\n\t/**\n\t * Public key the quote is locked to.\n\t */\n\tpubkey?: string;\n\t/**\n\t * Unit of the quote.\n\t */\n\tunit?: string;\n\t/**\n\t * Amount requested for mint quote.\n\t */\n\tamount?: number;\n} & ApiError;\n\nexport type MintQuoteResponse = PartialMintQuoteResponse & { amount: number; unit: string };\n\nexport type LockedMintQuoteResponse = MintQuoteResponse & { pubkey: string };\n\n/**\n * Response from the mint after requesting a BOLT12 mint quote. Contains a Lightning Network offer\n * and tracks payment/issuance amounts.\n */\nexport type Bolt12MintQuoteResponse = {\n\t/**\n\t * Quote identifier.\n\t */\n\tquote: string;\n\t/**\n\t * BOLT12 offer that can be paid to mint tokens.\n\t */\n\trequest: string;\n\t/**\n\t * Requested amount. This is null for amount-less offers.\n\t */\n\tamount: number | null;\n\t/**\n\t * Unit of the amount.\n\t */\n\tunit: string;\n\t/**\n\t * Unix timestamp when quote expires.\n\t */\n\texpiry: number | null;\n\t/**\n\t * Public key that locked this quote.\n\t */\n\tpubkey: string;\n\t/**\n\t * The amount that has been paid to the mint via the bolt12 offer. The difference between this and\n\t * `amount_issued` can be minted.\n\t */\n\tamount_paid: number;\n\t/**\n\t * The amount of ecash that has been issued for the given mint quote.\n\t */\n\tamount_issued: number;\n};\n\n/**\n * Response from the mint after requesting a mint.\n */\nexport type MintResponse = {\n\tsignatures: SerializedBlindedSignature[];\n} & ApiError;\n\n/**\n * Response from mint at /v1/restore endpoint.\n */\nexport type PostRestoreResponse = {\n\toutputs: SerializedBlindedMessage[];\n\tsignatures: SerializedBlindedSignature[];\n};\n\n/**\n * Ecash to other MoE swap method, displayed in @type {GetInfoResponse}\n */\nexport type SwapMethod = {\n\tmethod: string;\n\tunit: string;\n\tmin_amount: number;\n\tmax_amount: number;\n\tdescription?: boolean; //added this for Nutshell =>0.16.4 compatibility, see https://github.com/cashubtc/nutshell/pull/783\n\toptions?: {\n\t\tdescription?: boolean;\n\t};\n};\n\n/**\n * Response from the mint after performing a split action.\n */\nexport type SwapResponse = {\n\t/**\n\t * Represents the outputs after the split.\n\t */\n\tsignatures: SerializedBlindedSignature[];\n} & ApiError;\n\n/**\n * MPP supported methods.\n */\nexport type MPPMethod = {\n\tmethod: string;\n\tunit: string;\n};\n\n/**\n * WebSocket supported methods.\n */\nexport type WebSocketSupport = {\n\tmethod: string;\n\tunit: string;\n\tcommands: string[];\n};\n\n/**\n * Response from the mint after blind auth minting.\n */\nexport type BlindAuthMintResponse = {\n\tsignatures: SerializedBlindedSignature[];\n} & ApiError;\n","/**\n * This error is thrown when a HTTP response is not 2XX nor a protocol error.\n */\nexport class HttpResponseError extends Error {\n\tstatus: number;\n\tconstructor(message: string, status: number) {\n\t\tsuper(message);\n\t\tthis.status = status;\n\t\tthis.name = 'HttpResponseError';\n\t\tObject.setPrototypeOf(this, HttpResponseError.prototype);\n\t}\n}\n\n/**\n * This error is thrown when a network request fails.\n */\nexport class NetworkError extends Error {\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = 'NetworkError';\n\t\tObject.setPrototypeOf(this, NetworkError.prototype);\n\t}\n}\n\n/**\n * This error is thrown when a [protocol\n * error](https://github.com/cashubtc/nuts/blob/main/00.md#errors) occurs. See error codes\n * [here](https://github.com/cashubtc/nuts/blob/main/error_codes.md).\n */\nexport class MintOperationError extends HttpResponseError {\n\tcode: number;\n\tconstructor(code: number, detail: string) {\n\t\tsuper(detail || 'Unknown mint operation error', 400);\n\t\tthis.code = code;\n\t\tthis.name = 'MintOperationError';\n\t\tObject.setPrototypeOf(this, MintOperationError.prototype);\n\t}\n}\n","import type { Logger } from './Logger';\n\n// The default logger implementation - does nothing\n/* eslint-disable @typescript-eslint/no-empty-function */\nexport const NULL_LOGGER: Logger = {\n\terror() {},\n\twarn() {},\n\tinfo() {},\n\tdebug() {},\n\ttrace() {},\n\tlog() {},\n};\n/* eslint-enable @typescript-eslint/no-empty-function */\n","import { type Logger } from './Logger';\nimport { NULL_LOGGER } from './NullLogger';\n\n/**\n * Log at ERROR and throw. Always throws.\n *\n * @param message - Error message to log and throw.\n * @param logger - Logger to use, defaults to NULL_LOGGER.\n * @param context - Optional structured context for the log.\n * @throws {Error} Always throws with the given message.\n */\nexport function fail(\n\tmessage: string,\n\tlogger: Logger = NULL_LOGGER,\n\tcontext?: Record<string, unknown>,\n): never {\n\tlogger.error(message, context);\n\tthrow new Error(message);\n}\n\n/**\n * Throw if a Boolean condition is true. On return, the compiler knows the condition is false.\n *\n * @param condition - Condition that must be false to continue.\n * @param message - Error message if condition is true.\n * @param logger - Logger to use, defaults to NULL_LOGGER.\n * @param context - Optional structured context for the log.\n * @throws {Error} If condition is true, throws with the given message.\n */\nexport function failIf(\n\tcondition: boolean,\n\tmessage: string,\n\tlogger: Logger = NULL_LOGGER,\n\tcontext?: Record<string, unknown>,\n): asserts condition is false {\n\tif (condition) fail(message, logger, context);\n}\n\n/**\n * Throw if a value is null or undefined. Value is narrowed thereafter.\n *\n * @typeParam T - The value type to check.\n * @param value - The value to validate.\n * @param message - Error message if value is nullish.\n * @param logger - Logger to use, defaults to NULL_LOGGER.\n * @param context - Optional structured context for the log.\n * @throws {Error} If value is null or undefined.\n */\nexport function failIfNullish<T>(\n\tvalue: T,\n\tmessage: string,\n\tlogger: Logger = NULL_LOGGER,\n\tcontext?: Record<string, unknown>,\n): asserts value is Exclude<T, null | undefined> {\n\tif (value == null) fail(message, logger, context);\n}\n\n/**\n * Invoke a user-supplied callback safely in a fire-and-forget manner.\n *\n * Used for per-operation hooks (e.g. `onCountersReserved`, `onChangeOutputsCreated`) where user\n * code must never break the wallet’s control flow. The callback is invoked synchronously,\n * exceptions are caught and logged (as a warning), and then swallowed.\n *\n * The wallet never `await`s the callback.\n *\n * @example\n *\n * ```ts\n * if (autoCounters.used) {\n * \tsafeCallback(onCountersReserved, autoCounters.used, _logger, { keysetId });\n * }\n * ```\n *\n * @typeParam T Type of the payload passed to the callback.\n * @param cb The callback to invoke, or `undefined`.\n * @param payload The payload to pass to the callback.\n * @param logger Logger to use (defaults to NULL_LOGGER).\n * @param context Optional structured context for the log.\n */\nexport function safeCallback<T>(\n\tcb: ((p: T) => void | Promise<void>) | undefined,\n\tpayload: T,\n\tlogger: Logger = NULL_LOGGER,\n\tcontext?: Record<string, unknown>,\n): void {\n\tif (!cb) return;\n\n\ttry {\n\t\tconst maybePromise = cb(payload);\n\t\tif (maybePromise && typeof maybePromise.then === 'function') {\n\t\t\tmaybePromise.catch((error) => {\n\t\t\t\ttry {\n\t\t\t\t\tlogger.warn('callback failed', {\n\t\t\t\t\t\t...(context ?? {}),\n\t\t\t\t\t\terror,\n\t\t\t\t\t\tcb: cb.name ?? '',\n\t\t\t\t\t});\n\t\t\t\t} catch {\n\t\t\t\t\t/* ignore logger errors */\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t} catch (error) {\n\t\ttry {\n\t\t\tlogger.warn('callback failed', {\n\t\t\t\t...(context ?? {}),\n\t\t\t\terror,\n\t\t\t\tcb: cb.name ?? '',\n\t\t\t});\n\t\t} catch {\n\t\t\t/* ignore logger errors */\n\t\t}\n\t}\n}\n","import { type Logger, type LogLevel } from './Logger';\n\nconst LEVEL_ORDER: Record<LogLevel, number> = {\n\terror: 0,\n\twarn: 1,\n\tinfo: 2,\n\tdebug: 3,\n\ttrace: 4,\n};\n\n/**\n * Outputs messages to the console based on the specified log level.\n *\n * Supports placeholder substitution in messages (e.g., `{key}`) using values from the optional\n * `context` object. Context keys not used in substitution are appended to the output as additional\n * data. Each log message is prefixed with the log level in square brackets (e.g., `[INFO]`).\n *\n * @example Const logger = new ConsoleLogger(LogLevel.DEBUG); logger.info('User {username} logged\n * in', { username: 'alice', ip: '127.0.0.1' }); // Output: [INFO] User alice logged in { ip:\n * \"127.0.0.1\" }\n */\nexport class ConsoleLogger implements Logger {\n\tprivate minLevel: LogLevel;\n\n\tconstructor(minLevel: LogLevel = 'info') {\n\t\tthis.minLevel = minLevel;\n\t}\n\n\tprivate should(level: LogLevel): boolean {\n\t\treturn LEVEL_ORDER[level] <= LEVEL_ORDER[this.minLevel];\n\t}\n\tprivate method(level: LogLevel): (msg: string, ...rest: unknown[]) => void {\n\t\tswitch (level) {\n\t\t\tcase 'error':\n\t\t\t\treturn console.error;\n\t\t\tcase 'warn':\n\t\t\t\treturn console.warn;\n\t\t\tcase 'info':\n\t\t\t\treturn console.info;\n\t\t\tcase 'debug':\n\t\t\t\treturn console.debug;\n\t\t\tcase 'trace':\n\t\t\t\treturn console.trace;\n\t\t\tdefault:\n\t\t\t\treturn console.log;\n\t\t}\n\t}\n\tprivate header(level: LogLevel, message: string): string {\n\t\treturn `[${level.toUpperCase()}] ${message}`;\n\t}\n\tprivate flattenContext(ctx?: Record<string, unknown>): Record<string, unknown> | undefined {\n\t\tif (!ctx) return undefined;\n\t\tconst out: Record<string, unknown> = {};\n\t\tfor (const [k, v] of Object.entries(ctx)) {\n\t\t\tout[k] = v instanceof Error ? { message: v.message, stack: v.stack } : v;\n\t\t}\n\t\treturn out;\n\t}\n\tprivate emit(level: LogLevel, message: string, context?: Record<string, unknown>) {\n\t\tif (!this.should(level)) return;\n\t\tconst line = this.header(level, message);\n\t\tconst ctx = this.flattenContext(context);\n\t\tconst fn = this.method(level);\n\t\tif (ctx && Object.keys(ctx).length) fn(line, ctx);\n\t\telse fn(line);\n\t}\n\n\terror(msg: string, ctx?: Record<string, unknown>) {\n\t\tthis.emit('error', msg, ctx);\n\t}\n\twarn(msg: string, ctx?: Record<string, unknown>) {\n\t\tthis.emit('warn', msg, ctx);\n\t}\n\tinfo(msg: string, ctx?: Record<string, unknown>) {\n\t\tthis.emit('info', msg, ctx);\n\t}\n\tdebug(msg: string, ctx?: Record<string, unknown>) {\n\t\tthis.emit('debug', msg, ctx);\n\t}\n\ttrace(msg: string, ctx?: Record<string, unknown>) {\n\t\tthis.emit('trace', msg, ctx);\n\t}\n\n\tlog(level: LogLevel, message: string, context?: Record<string, unknown>) {\n\t\tthis.emit(level, message, context);\n\t}\n}\n\n/**\n * Creates a timer to measure elapsed time in milliseconds.\n *\n * @example Const timer = measureTime(); // ... some code ... const duration = timer.elapsed();\n *\n * @returns An object with an `elapsed` method to retrieve the duration since the timer started.\n */\nexport function measureTime() {\n\tconst start = Date.now();\n\treturn {\n\t\telapsed: () => {\n\t\t\treturn Date.now() - start;\n\t\t},\n\t};\n}\n","import { HttpResponseError, NetworkError, MintOperationError } from '../model/Errors';\nimport { type Logger, NULL_LOGGER } from '../logger';\nimport { type ApiError } from '../mint/types/responses';\n\n// Generic request function type so callers can do requestInstance<T>(...)\nexport type RequestFn = <T = unknown>(args: RequestOptions) => Promise<T>;\n\nexport type RequestArgs = {\n\tendpoint: string;\n\trequestBody?: Record<string, unknown>;\n\theaders?: Record<string, string>;\n\tlogger?: Logger;\n};\n\nexport type RequestOptions = RequestArgs & Omit<RequestInit, 'body' | 'headers'>;\n\nlet globalRequestOptions: Partial<RequestOptions> = {};\nlet requestLogger = NULL_LOGGER;\n\n/**\n * An object containing any custom settings that you want to apply to the global fetch method.\n *\n * @param options See possible options here:\n *   https://developer.mozilla.org/en-US/docs/Web/API/fetch#options.\n */\nexport function setGlobalRequestOptions(options: Partial<RequestOptions>): void {\n\tglobalRequestOptions = options;\n}\n\n/**\n * Allows a logger to be set.\n *\n * @param {Logger} logger The logger instance to use.\n */\nexport function setRequestLogger(logger: Logger): void {\n\trequestLogger = logger;\n}\n\nasync function _request({\n\tendpoint,\n\trequestBody,\n\theaders: requestHeaders,\n\t...options\n}: RequestOptions): Promise<unknown> {\n\tconst body = requestBody ? JSON.stringify(requestBody) : undefined;\n\tconst headers = {\n\t\t...{ Accept: 'application/json, text/plain, */*' },\n\t\t...(body ? { 'Content-Type': 'application/json' } : undefined),\n\t\t...requestHeaders,\n\t};\n\n\tlet response: Response;\n\ttry {\n\t\tresponse = await fetch(endpoint, { body, headers, ...options });\n\t} catch (err) {\n\t\t// A fetch() promise only rejects when the request fails,\n\t\t// for example, because of a badly-formed request URL or a network error.\n\t\tthrow new NetworkError(err instanceof Error ? err.message : 'Network request failed');\n\t}\n\n\tif (!response.ok) {\n\t\tlet errorData: ApiError;\n\t\ttry {\n\t\t\terrorData = (await response.json()) as ApiError;\n\t\t} catch {\n\t\t\terrorData = { error: 'bad response' };\n\t\t}\n\n\t\tif (\n\t\t\tresponse.status === 400 &&\n\t\t\t'code' in errorData &&\n\t\t\ttypeof errorData.code === 'number' &&\n\t\t\t'detail' in errorData &&\n\t\t\ttypeof errorData.detail === 'string'\n\t\t) {\n\t\t\tthrow new MintOperationError(errorData.code, errorData.detail);\n\t\t}\n\n\t\tlet errorMessage = 'HTTP request failed';\n\t\tif ('error' in errorData && typeof errorData.error === 'string') {\n\t\t\terrorMessage = errorData.error;\n\t\t} else if ('detail' in errorData && typeof errorData.detail === 'string') {\n\t\t\terrorMessage = errorData.detail;\n\t\t}\n\n\t\tthrow new HttpResponseError(errorMessage, response.status);\n\t}\n\n\ttry {\n\t\treturn await response.json();\n\t} catch (err) {\n\t\trequestLogger.error('Failed to parse HTTP response', { err });\n\t\tthrow new HttpResponseError('bad response', response.status);\n\t}\n}\n\nexport default async function request<T>(options: RequestOptions): Promise<T> {\n\tconst data = await _request({ ...options, ...globalRequestOptions });\n\treturn data as T;\n}\n","let _WS: typeof WebSocket | undefined;\n\nif (typeof WebSocket !== 'undefined') {\n\t_WS = WebSocket;\n}\n\nexport function injectWebSocketImpl(ws: typeof WebSocket) {\n\t_WS = ws;\n}\n\nexport function getWebSocketImpl() {\n\tif (_WS === undefined) {\n\t\tthrow new Error('WebSocket implementation not initialized');\n\t}\n\treturn _WS;\n}\n","export class Bytes {\n\tstatic fromHex(hex: string): Uint8Array {\n\t\thex = hex.trim();\n\t\tif (hex.length === 0) {\n\t\t\treturn new Uint8Array(0);\n\t\t}\n\t\tif (hex.length < 2 || hex.length & 1) {\n\t\t\tthrow new Error('Invalid hex string: odd length.');\n\t\t}\n\t\tif (hex.startsWith('0x') || hex.startsWith('0X')) {\n\t\t\thex = hex.slice(2);\n\t\t}\n\t\tconst match = hex.match(/^[0-9a-fA-F]*$/);\n\t\tif (!match) {\n\t\t\tthrow new Error('Invalid hex string: contains non-hex characters');\n\t\t}\n\t\tconst matches = hex.match(/.{1,2}/g);\n\t\tif (!matches) {\n\t\t\tthrow new Error('Invalid hex string');\n\t\t}\n\t\treturn new Uint8Array(matches.map((byte) => parseInt(byte, 16)));\n\t}\n\n\tstatic toHex(bytes: Uint8Array): string {\n\t\treturn Array.from(bytes, (byte) => byte.toString(16).padStart(2, '0')).join('');\n\t}\n\n\tstatic fromString(str: string): Uint8Array {\n\t\tstr = str.trim();\n\t\treturn new TextEncoder().encode(str);\n\t}\n\n\tstatic toString(bytes: Uint8Array): string {\n\t\treturn new TextDecoder('utf-8').decode(bytes);\n\t}\n\n\tstatic concat(...arrays: Uint8Array[]): Uint8Array {\n\t\tconst totalLength = arrays.reduce((sum, arr) => sum + arr.length, 0);\n\t\tconst result = new Uint8Array(totalLength);\n\t\tlet offset = 0;\n\t\tfor (const arr of arrays) {\n\t\t\tresult.set(arr, offset);\n\t\t\toffset += arr.length;\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic alloc(size: number): Uint8Array {\n\t\treturn new Uint8Array(size);\n\t}\n\n\tstatic writeBigUint64BE(value: bigint): Uint8Array {\n\t\tconst buffer = new ArrayBuffer(8);\n\t\tnew DataView(buffer).setBigUint64(0, value, false);\n\t\treturn new Uint8Array(buffer);\n\t}\n\n\tstatic toBase64(bytes: Uint8Array): string {\n\t\tif (typeof Buffer !== 'undefined') {\n\t\t\treturn Buffer.from(bytes).toString('base64');\n\t\t}\n\t\t// preventing stack overflow by chunking\n\t\tif (bytes.length > 32768) {\n\t\t\tlet result = '';\n\t\t\tfor (let i = 0; i < bytes.length; i += 32768) {\n\t\t\t\tconst chunk = bytes.slice(i, i + 32768);\n\t\t\t\tresult += btoa(String.fromCharCode(...chunk));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\treturn btoa(String.fromCharCode(...bytes));\n\t}\n\n\tstatic fromBase64(base64: string): Uint8Array {\n\t\tbase64 = base64.trim();\n\t\t// normalise base64url to base64 and pad\n\t\tlet normalizedBase64 = base64.replace(/-/g, '+').replace(/_/g, '/');\n\t\twhile (normalizedBase64.length % 4) {\n\t\t\tnormalizedBase64 += '=';\n\t\t}\n\t\tif (typeof Buffer !== 'undefined') {\n\t\t\treturn new Uint8Array(Buffer.from(normalizedBase64, 'base64'));\n\t\t}\n\t\treturn new Uint8Array([...atob(normalizedBase64)].map((c) => c.charCodeAt(0)));\n\t}\n\t// NOTE: MUST remain a constant-time implementation (full byte check)\n\t// because callers rely on it (e.g. deriveP2BKSecretKey).\n\tstatic equals(a: Uint8Array, b: Uint8Array): boolean {\n\t\tif (a.length !== b.length) return false;\n\t\tlet result = 0;\n\t\tfor (let i = 0; i < a.length; i++) {\n\t\t\tresult |= a[i] ^ b[i];\n\t\t}\n\t\treturn result === 0;\n\t}\n\n\tstatic compare(a: Uint8Array, b: Uint8Array): number {\n\t\tconst minLength = Math.min(a.length, b.length);\n\t\tfor (let i = 0; i < minLength; i++) {\n\t\t\tif (a[i] < b[i]) return -1;\n\t\t\tif (a[i] > b[i]) return 1;\n\t\t}\n\t\treturn a.length - b.length;\n\t}\n}\n","import { Bytes } from './Bytes';\n\nfunction encodeUint8toBase64(uint8array: Uint8Array): string {\n\treturn Bytes.toBase64(uint8array);\n}\n\nfunction encodeUint8toBase64Url(bytes: Uint8Array): string {\n\treturn Bytes.toBase64(bytes)\n\t\t.replace(/\\+/g, '-') // Replace + with -\n\t\t.replace(/\\//g, '_') // Replace / with _\n\t\t.replace(/=+$/, ''); // Remove padding characters\n}\n\nfunction encodeBase64toUint8(base64String: string): Uint8Array {\n\treturn Bytes.fromBase64(base64String);\n}\n\nfunction encodeJsonToBase64(jsonObj: unknown): string {\n\tconst jsonString = JSON.stringify(jsonObj);\n\treturn base64urlFromBase64(Bytes.toBase64(Bytes.fromString(jsonString)));\n}\n\nfunction encodeBase64ToJson<T extends object>(base64String: string): T {\n\tconst jsonString = Bytes.toString(Bytes.fromBase64(base64urlToBase64(base64String)));\n\tconst jsonObj = JSON.parse(jsonString) as T;\n\treturn jsonObj;\n}\n\nfunction base64urlToBase64(str: string) {\n\treturn str.replace(/-/g, '+').replace(/_/g, '/').split('=')[0];\n\t// .replace(/./g, '=');\n}\n\nfunction base64urlFromBase64(str: string) {\n\treturn str.replace(/\\+/g, '-').replace(/\\//g, '_').split('=')[0];\n\t// .replace(/=/g, '.');\n}\n\nfunction isBase64String(s: string): boolean {\n\tif (typeof s !== 'string' || s.length === 0) return false;\n\n\t// Accept both base64 and base64url char sets\n\tconst base64url = /^[A-Za-z0-9\\-_]+={0,2}$/;\n\tconst base64 = /^[A-Za-z0-9+/]+={0,2}$/;\n\n\t// Quick character-set check\n\tif (!base64url.test(s) && !base64.test(s)) return false;\n\n\t// Normalize base64url to standard base64 for decoding\n\tconst normalized = s.replace(/-/g, '+').replace(/_/g, '/');\n\n\t// Padding: length must be multiple of 4. Add '=' padding if needed (but no more than 2)\n\tconst padLength = (4 - (normalized.length % 4)) % 4;\n\tif (padLength > 2) return false; // should never happen but keep safe\n\tconst padded = normalized + '='.repeat(padLength);\n\n\ttry {\n\t\tconst decoded = Bytes.fromBase64(padded);\n\n\t\t// Re-encode and compare to the original (allowing either standard or url-safe representation)\n\t\tconst reStandard = Bytes.toBase64(decoded);\n\t\tconst reUrl = reStandard.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n\n\t\t// Also compare against original normalized-without-padding variant\n\t\tconst originalNoPad = normalized.replace(/=+$/, '');\n\n\t\tif (reStandard.replace(/=+$/, '') === originalNoPad) return true;\n\t\tif (reUrl === originalNoPad) return true;\n\n\t\treturn false;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\nexport {\n\tencodeUint8toBase64,\n\tencodeUint8toBase64Url,\n\tencodeBase64toUint8,\n\tencodeJsonToBase64,\n\tencodeBase64ToJson,\n\tisBase64String,\n};\n","/*\n * Lightweight CBOR encoder/decoder (purpose and limitations)\n *\n * Supported\n * - Major types: 0 (unsigned), 1 (negative), 2 (byte string), 3 (text string),\n *   4 (array), 5 (map), 7 (simple values & floats).\n * - Additional-info lengths: short (0..23), 1-, 2- and 4-byte length forms are\n *   encoded by the encoder. The decoder understands 8-byte length fields\n *   (additional-info 27) and will decode them into a JavaScript Number\n *   (hi * 2**32 + lo) but the encoder intentionally does not emit 8-byte\n *   integer forms (see 'Not implemented' below).\n * - Floating point: decoder supports float16/float32/float64. Encoder emits\n *   float64 for non-integers.\n * - Guardrails: explicit throws for unsupported types and sizes (e.g. huge\n *   strings/byte arrays/arrays/maps > 2**32-1, integers larger than 32-bit for\n *   encoding). DataView out-of-bounds reads are normalized to\n *   \"Unexpected end of data\" for clearer errors.\n *\n * Not implemented / intentionally out of scope\n * - Indefinite-length (streaming) containers (indefinite-length arrays,\n *   maps, byte/text strings) are not supported. Test vectors with streaming\n *   markers are skipped in the test harness.\n * - Semantic tags (major type 6) are not interpreted; tagged values are\n *   skipped in encode-roundtrip tests. Implementing tags should return a\n *   wrapper object or otherwise surface the tag + value.\n * - Big integers / bignum handling: this implementation does not return\n *   BigInt for values outside Number.isSafeInteger nor emit CBOR bignum tags\n *   (tag 2/3). Decode may parse 8-byte unsigned/negative integers into a\n *   Number which can overflow JS precision; callers who need accurate bignum\n *   support should add BigInt decoding and encoder support.\n * - Encoder does not emit float16/float32 or 8-byte integer (additional-info\n *   27) forms. It intentionally limits integer encoding to <= 32-bit and\n *   uses float64 for non-integers to keep the implementation small.\n *\n * Guidance for contributors\n * - To add streaming support, implement indefinite-length decoders that\n *   concatenate chunks until the break byte (0xff) and update decodeItem\n *   accordingly.\n * - To add BigInt/bignum support, change decode paths to return BigInt when\n *   required, add fixture representation for BigInt in tests, and emit proper\n *   tag-2/3 bignum encodings or 8-byte integer forms in the encoder.\n */\n\n/* Reference: CBOR specification (RFC 8949) https://www.rfc-editor.org/rfc/rfc8949.html */\n\ntype SimpleValue = boolean | null | undefined;\n\nexport type ResultObject = { [key: string]: ResultValue };\nexport type ResultValue = SimpleValue | number | string | Uint8Array | ResultValue[] | ResultObject;\n\ntype ResultKeyType = Extract<ResultValue, number | string>;\nexport type ValidDecodedType = Extract<ResultValue, ResultObject>;\n\nfunction isResultKeyType(value: ResultValue): value is ResultKeyType {\n\treturn typeof value === 'number' || typeof value === 'string';\n}\n\ntype DecodeResult<T extends ResultValue> = {\n\tvalue: T;\n\toffset: number;\n};\n\nexport function encodeCBOR(value: unknown): Uint8Array {\n\tconst buffer: number[] = [];\n\tencodeItem(value, buffer);\n\treturn new Uint8Array(buffer);\n}\n\nfunction encodeItem(value: unknown, buffer: number[]) {\n\tif (value === null) {\n\t\tbuffer.push(0xf6);\n\t} else if (value === undefined) {\n\t\tbuffer.push(0xf7);\n\t} else if (typeof value === 'boolean') {\n\t\tbuffer.push(value ? 0xf5 : 0xf4);\n\t} else if (typeof value === 'number') {\n\t\tencodeNumber(value, buffer);\n\t} else if (typeof value === 'string') {\n\t\tencodeString(value, buffer);\n\t} else if (Array.isArray(value)) {\n\t\tencodeArray(value, buffer);\n\t} else if (value instanceof Uint8Array) {\n\t\tencodeByteString(value, buffer);\n\t} else if (\n\t\t// Defensive: POJO only (null/array handled above)\n\t\ttypeof value === 'object' &&\n\t\tvalue !== null &&\n\t\t!Array.isArray(value)\n\t) {\n\t\tencodeObject(value as Record<string, unknown>, buffer);\n\t} else {\n\t\tthrow new Error('Unsupported type');\n\t}\n}\n\nfunction encodeUnsigned(value: number, buffer: number[]) {\n\tif (value < 24) {\n\t\tbuffer.push(value);\n\t} else if (value < 256) {\n\t\tbuffer.push(0x18, value);\n\t} else if (value < 65536) {\n\t\tbuffer.push(0x19, (value >>> 8) & 0xff, value & 0xff);\n\t} else if (value < 4294967296) {\n\t\tbuffer.push(\n\t\t\t0x1a,\n\t\t\t(value >>> 24) & 0xff,\n\t\t\t(value >>> 16) & 0xff,\n\t\t\t(value >>> 8) & 0xff,\n\t\t\tvalue & 0xff,\n\t\t);\n\t} else {\n\t\tthrow new Error('Unsupported integer size');\n\t}\n}\n\nfunction encodeSigned(value: number, buffer: number[]) {\n\t// CBOR negative integer encoding: store -1 - value as unsigned under major type 1\n\tconst unsigned = -1 - value;\n\tif (unsigned < 24) {\n\t\tbuffer.push(0x20 | unsigned);\n\t} else if (unsigned < 256) {\n\t\tbuffer.push(0x38, unsigned & 0xff);\n\t} else if (unsigned < 65536) {\n\t\tbuffer.push(0x39, (unsigned >>> 8) & 0xff, unsigned & 0xff);\n\t} else if (unsigned < 4294967296) {\n\t\tbuffer.push(\n\t\t\t0x3a,\n\t\t\t(unsigned >>> 24) & 0xff,\n\t\t\t(unsigned >>> 16) & 0xff,\n\t\t\t(unsigned >>> 8) & 0xff,\n\t\t\tunsigned & 0xff,\n\t\t);\n\t} else {\n\t\tthrow new Error('Unsupported integer size');\n\t}\n}\n\nfunction encodeFloat64(value: number, buffer: number[]) {\n\t// major type 7, additional info 27 (0xfb) followed by 8 bytes IEEE 754 big-endian\n\tconst ab = new ArrayBuffer(8);\n\tconst dv = new DataView(ab);\n\tdv.setFloat64(0, value, false);\n\tbuffer.push(0xfb);\n\tfor (let i = 0; i < 8; i++) buffer.push(dv.getUint8(i));\n}\n\nfunction encodeNumber(value: number, buffer: number[]) {\n\tif (Number.isInteger(value)) {\n\t\tif (value >= 0) {\n\t\t\t// unsigned\n\t\t\tencodeUnsigned(value, buffer);\n\t\t} else {\n\t\t\t// negative integer\n\t\t\tencodeSigned(value, buffer);\n\t\t}\n\t} else {\n\t\t// encode non-integer numbers as float64 for simplicity\n\t\tencodeFloat64(value, buffer);\n\t}\n}\n\nfunction encodeByteString(value: Uint8Array, buffer: number[]) {\n\tconst length = value.length;\n\n\tif (length < 24) {\n\t\tbuffer.push(0x40 + length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0x58, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0x59, (length >> 8) & 0xff, length & 0xff);\n\t} else if (length < 4294967296) {\n\t\tbuffer.push(\n\t\t\t0x5a,\n\t\t\t(length >>> 24) & 0xff,\n\t\t\t(length >>> 16) & 0xff,\n\t\t\t(length >>> 8) & 0xff,\n\t\t\tlength & 0xff,\n\t\t);\n\t} else {\n\t\tthrow new Error('Byte string too long to encode');\n\t}\n\n\tfor (let i = 0; i < value.length; i++) {\n\t\tbuffer.push(value[i]);\n\t}\n}\n\nfunction encodeString(value: string, buffer: number[]) {\n\tconst utf8 = new TextEncoder().encode(value);\n\tconst length = utf8.length;\n\n\tif (length < 24) {\n\t\tbuffer.push(0x60 + length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0x78, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0x79, (length >>> 8) & 0xff, length & 0xff);\n\t} else if (length < 4294967296) {\n\t\tbuffer.push(\n\t\t\t0x7a,\n\t\t\t(length >>> 24) & 0xff,\n\t\t\t(length >>> 16) & 0xff,\n\t\t\t(length >>> 8) & 0xff,\n\t\t\tlength & 0xff,\n\t\t);\n\t} else {\n\t\tthrow new Error('String too long to encode');\n\t}\n\n\tfor (let i = 0; i < utf8.length; i++) {\n\t\tbuffer.push(utf8[i]);\n\t}\n}\n\nfunction encodeArray(value: unknown[], buffer: number[]) {\n\tconst length = value.length;\n\tif (length < 24) {\n\t\tbuffer.push(0x80 | length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0x98, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0x99, (length >>> 8) & 0xff, length & 0xff);\n\t} else {\n\t\tthrow new Error('Unsupported array length');\n\t}\n\n\tfor (const item of value) {\n\t\tencodeItem(item, buffer);\n\t}\n}\n\nfunction encodeObject(value: Record<string, unknown>, buffer: number[]) {\n\tconst keys = Object.keys(value);\n\tconst length = keys.length;\n\n\t// Guardrail: we only support map lengths up to 2^32-1 (same as encodeUnsigned max)\n\tif (length >= 4294967296) {\n\t\tthrow new Error('Object has too many keys to encode');\n\t}\n\n\t// Write initial byte for major type 5 (map) and additional info based on length\n\tif (length < 24) {\n\t\tbuffer.push(0xa0 | length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0xb8, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0xb9, (length >> 8) & 0xff, length & 0xff);\n\t} else {\n\t\tbuffer.push(\n\t\t\t0xba,\n\t\t\t(length >> 24) & 0xff,\n\t\t\t(length >> 16) & 0xff,\n\t\t\t(length >> 8) & 0xff,\n\t\t\tlength & 0xff,\n\t\t);\n\t}\n\tfor (const key of keys) {\n\t\tencodeString(key, buffer);\n\t\tencodeItem(value[key], buffer);\n\t}\n}\n\nexport function decodeCBOR(data: Uint8Array): ResultValue {\n\tconst view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n\tconst result = decodeItem(view, 0);\n\treturn result.value;\n}\n\nfunction decodeItem(view: DataView, offset: number): DecodeResult<ResultValue> {\n\tif (offset >= view.byteLength) {\n\t\tthrow new Error('Unexpected end of data');\n\t}\n\tconst initialByte = view.getUint8(offset++);\n\tconst majorType = initialByte >> 5;\n\tconst additionalInfo = initialByte & 0x1f;\n\n\tswitch (majorType) {\n\t\tcase 0:\n\t\t\treturn decodeUnsigned(view, offset, additionalInfo);\n\t\tcase 1:\n\t\t\treturn decodeSigned(view, offset, additionalInfo);\n\t\tcase 2:\n\t\t\treturn decodeByteString(view, offset, additionalInfo);\n\t\tcase 3:\n\t\t\treturn decodeString(view, offset, additionalInfo);\n\t\tcase 4:\n\t\t\treturn decodeArray(view, offset, additionalInfo);\n\t\tcase 5:\n\t\t\treturn decodeMap(view, offset, additionalInfo);\n\t\tcase 7:\n\t\t\treturn decodeSimpleAndFloat(view, offset, additionalInfo);\n\t\tdefault:\n\t\t\tthrow new Error(`Unsupported major type: ${majorType}`);\n\t}\n}\n\nfunction ensureAvailable(view: DataView, offset: number, needed: number) {\n\tif (offset + needed > view.byteLength) {\n\t\tthrow new Error('Unexpected end of data');\n\t}\n}\n\nfunction decodeLength(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<number> {\n\tif (additionalInfo < 24) return { value: additionalInfo, offset };\n\tif (additionalInfo === 24) {\n\t\tensureAvailable(view, offset, 1);\n\t\treturn { value: view.getUint8(offset++), offset };\n\t}\n\tif (additionalInfo === 25) {\n\t\tensureAvailable(view, offset, 2);\n\t\tconst value = view.getUint16(offset, false);\n\t\toffset += 2;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 26) {\n\t\tensureAvailable(view, offset, 4);\n\t\tconst value = view.getUint32(offset, false);\n\t\toffset += 4;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 27) {\n\t\tensureAvailable(view, offset, 8);\n\t\tconst hi = view.getUint32(offset, false);\n\t\tconst lo = view.getUint32(offset + 4, false);\n\t\toffset += 8;\n\t\treturn { value: hi * 2 ** 32 + lo, offset };\n\t}\n\tthrow new Error(`Unsupported length: ${additionalInfo}`);\n}\n\nfunction decodeUnsigned(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<number> {\n\tconst { value, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\treturn { value, offset: newOffset };\n}\n\nfunction decodeSigned(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<number> {\n\tconst { value, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\treturn { value: -1 - value, offset: newOffset };\n}\n\nfunction decodeByteString(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<Uint8Array> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tif (newOffset + length > view.byteLength) {\n\t\tthrow new Error('Byte string length exceeds data length');\n\t}\n\tconst value = new Uint8Array(view.buffer, view.byteOffset + newOffset, length);\n\treturn { value, offset: newOffset + length };\n}\n\nfunction decodeString(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<string> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tif (newOffset + length > view.byteLength) {\n\t\tthrow new Error('String length exceeds data length');\n\t}\n\tconst bytes = new Uint8Array(view.buffer, view.byteOffset + newOffset, length);\n\tconst value = new TextDecoder().decode(bytes);\n\treturn { value, offset: newOffset + length };\n}\n\nfunction decodeArray(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<ResultValue[]> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tconst array = [];\n\tlet currentOffset = newOffset;\n\tfor (let i = 0; i < length; i++) {\n\t\tconst result = decodeItem(view, currentOffset);\n\t\tarray.push(result.value);\n\t\tcurrentOffset = result.offset;\n\t}\n\treturn { value: array, offset: currentOffset };\n}\n\nfunction decodeMap(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<Record<string, ResultValue>> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tconst map: { [key: string]: ResultValue } = {};\n\tlet currentOffset = newOffset;\n\tfor (let i = 0; i < length; i++) {\n\t\tconst keyResult = decodeItem(view, currentOffset);\n\t\tif (!isResultKeyType(keyResult.value)) {\n\t\t\tthrow new Error('Invalid key type');\n\t\t}\n\t\tconst valueResult = decodeItem(view, keyResult.offset);\n\t\tmap[keyResult.value] = valueResult.value;\n\t\tcurrentOffset = valueResult.offset;\n\t}\n\treturn { value: map, offset: currentOffset };\n}\n\nfunction decodeFloat16(uint16: number): number {\n\tconst exponent = (uint16 & 0x7c00) >> 10;\n\tconst fraction = uint16 & 0x03ff;\n\tconst sign = uint16 & 0x8000 ? -1 : 1;\n\n\tif (exponent === 0) {\n\t\treturn sign * 2 ** -14 * (fraction / 1024);\n\t} else if (exponent === 0x1f) {\n\t\treturn fraction ? NaN : sign * Infinity;\n\t}\n\treturn sign * 2 ** (exponent - 15) * (1 + fraction / 1024);\n}\n\nfunction decodeSimpleAndFloat(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<SimpleValue | number> {\n\tif (additionalInfo < 24) {\n\t\tswitch (additionalInfo) {\n\t\t\tcase 20:\n\t\t\t\treturn { value: false, offset };\n\t\t\tcase 21:\n\t\t\t\treturn { value: true, offset };\n\t\t\tcase 22:\n\t\t\t\treturn { value: null, offset };\n\t\t\tcase 23:\n\t\t\t\treturn { value: undefined, offset };\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown simple value: ${additionalInfo}`);\n\t\t}\n\t}\n\tif (additionalInfo === 24) {\n\t\tensureAvailable(view, offset, 1);\n\t\treturn { value: view.getUint8(offset++), offset };\n\t}\n\tif (additionalInfo === 25) {\n\t\tensureAvailable(view, offset, 2);\n\t\tconst value = decodeFloat16(view.getUint16(offset, false));\n\t\toffset += 2;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 26) {\n\t\tensureAvailable(view, offset, 4);\n\t\tconst value = view.getFloat32(offset, false);\n\t\toffset += 4;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 27) {\n\t\tensureAvailable(view, offset, 8);\n\t\tconst value = view.getFloat64(offset, false);\n\t\toffset += 8;\n\t\treturn { value, offset };\n\t}\n\tthrow new Error(`Unknown simple or float value: ${additionalInfo}`);\n}\n","import { secp256k1 } from '@noble/curves/secp256k1';\nimport { Bytes, bytesToNumber, hexToNumber, numberToHexPadded64 } from '../utils';\nimport { pointFromHex } from './core';\nimport { bytesToHex, hexToBytes, utf8ToBytes } from '@noble/hashes/utils';\nimport { sha256 } from '@noble/hashes/sha2';\nimport { type WeierstrassPoint } from '@noble/curves/abstract/weierstrass';\n\n/**\n * BIP340-style domain separation tag (DST) for P2BK.\n *\n * @alpha\n */\nexport const P2BK_DST = utf8ToBytes('Cashu_P2BK_v1');\n\n/**\n * Blind a sequence of public keys using ECDH derived tweaks, one tweak per slot.\n *\n * @remarks\n * Security note: \"Ehex\" must never be reused. Doing so would create linkability and leak privacy.\n * The only exception is for SIG_ALL proofs, as all secret tags must match.\n *\n * This is the Sender side API.\n * @param pubkeys Ordered SEC1 compressed pubkeys, [data, ...pubkeys, ...refund]\n * @param keysetId Hex keyset identifier, bound into the tweak.\n * @param eBytes Optional. Fixed ephemeral secret key to use (eg for SIG_ALL / testing)\n * @returns Blinded pubkeys in the same order, and Ehex as SEC1 compressed hex, 33 bytes.\n * @throws If a blinded key is at infinity.\n * @alpha\n */\nexport function deriveP2BKBlindedPubkeys(\n\tpubkeys: string[],\n\tkeysetId: string,\n\teBytes?: Uint8Array,\n): { blinded: string[]; Ehex: string } {\n\tif (!pubkeys.length) return { blinded: [], Ehex: '' };\n\t// Create fresh ephemeral secret (e) if not supplied, and calculate pubkey (E)\n\teBytes = eBytes ?? secp256k1.utils.randomSecretKey(); // 32 bytes\n\tconst e = secp256k1.Point.Fn.fromBytes(eBytes); // bigint in [1..n-1]\n\tconst E = secp256k1.getPublicKey(eBytes, true); // SEC1 compressed (bytes)\n\tconst kid = hexToBytes(keysetId);\n\t// Blind each pubkey in turn\n\tconst blinded = pubkeys.map((pubkey, i) => {\n\t\tconst P = pointFromHex(pubkey);\n\t\tconst r = deriveP2BKBlindingTweakFromECDH(P, e, kid, i);\n\t\tconst P_ = P.add(secp256k1.Point.BASE.multiply(r));\n\t\tif (P_.equals(secp256k1.Point.ZERO)) throw new Error('Blinded key at infinity');\n\t\treturn P_.toHex(true);\n\t});\n\treturn { blinded, Ehex: bytesToHex(E) };\n}\n\n/**\n * Derive blinded secret keys that correspond to given P2BK blinded pubkeys.\n *\n * Pubkeys are processed in order, for a proof that is [data, ...pubkeys, ...refund]. Private key\n * order does not matter.\n *\n * @remarks\n * Security note, this operates on long lived secrets. JavaScript BigInt arithmetic in a JIT is not\n * guaranteed constant time. Do not expose this function on a server that holds private keys.\n *\n * This is the Receiver side API.\n * @param Ehex Ephemeral public key (E) as SEC1 hex.\n * @param privateKey Secret key or array of secret keys, hex.\n * @param blindPubKey Blinded public key or array of blinded public keys, hex.\n * @param keysetIdHex Keyset identifier as hex.\n * @returns Array of derived secret keys as 64 char hex.\n * @alpha\n */\nexport function deriveP2BKSecretKeys(\n\tEhex: string,\n\tprivateKey: string | string[],\n\tblindPubKey: string | string[],\n\tkeysetIdHex: string,\n): string[] {\n\tconst privs = Array.isArray(privateKey) ? privateKey : [privateKey];\n\tconst pubs = Array.isArray(blindPubKey) ? blindPubKey : [blindPubKey];\n\tconst out = new Set<string>();\n\tconst E = secp256k1.Point.fromHex(Ehex);\n\tconst kid = hexToBytes(keysetIdHex);\n\tfor (const privHex of privs) {\n\t\tconst p = secp256k1.Point.Fn.fromBytes(hexToBytes(privHex));\n\t\tconst P = secp256k1.getPublicKey(hexToBytes(privHex), true); // 33 bytes, validates on curve\n\t\tpubs.forEach((hexP_, i) => {\n\t\t\tconst r = deriveP2BKBlindingTweakFromECDH(E, p, kid, i);\n\t\t\tconst P_ = hexToBytes(hexP_);\n\t\t\tconst kHex = deriveP2BKSecretKey(privHex, r, P_, P);\n\t\t\tif (kHex) out.add(kHex); // add only when this priv matches this P′\n\t\t});\n\t}\n\treturn Array.from(out);\n}\n\n/**\n * Derive a blinded secret key per NUT-26.\n *\n * Unblinds the pubkey (P = P_ - r·G), verifies x-coord against the naturalPub x(P) == x(p·G), then\n * choose skStd = (p + rᵢ) mod n if parity(P) == parity(p·G), otherwise skNeg = (-p + rᵢ) mod n.\n * Returns skStd if no blindPubkey is provided.\n *\n * @remarks\n * Security note, this operates on long lived secrets. JavaScript BigInt arithmetic in a JIT is not\n * guaranteed constant time. Do not expose this function on a server that holds private keys.\n * @param privkey Unblinded private key (p), hex or bigint.\n * @param rBlind Blinding scalar (r), hex or bigint.\n * @param blindPubkey Optional. Blinded pubkey (P_) to match, 33 byte hex.\n * @param naturalPub Optional. Pubkey calculated from private key (P = p·G), 33 byte hex.\n * @returns Derived blinded secret key as 64 char hex.\n * @throws If inputs are out of range, or the derived key would be zero.\n * @alpha\n */\nexport function deriveP2BKSecretKey(\n\tprivkey: string | bigint,\n\trBlind: string | bigint,\n\tblindPubkey?: Uint8Array,\n\tnaturalPub?: Uint8Array,\n): string | null {\n\t// Implementation note: must keep algorithmic constant time!\n\tconst n = secp256k1.Point.CURVE().n;\n\tconst p = typeof privkey === 'string' ? hexToNumber(privkey) : privkey;\n\tconst r = typeof rBlind === 'string' ? hexToNumber(rBlind) : rBlind;\n\tif (p <= 0n || p >= n) throw new Error('Invalid private key');\n\tif (r <= 0n || r >= n) throw new Error('Invalid scalar r');\n\t// If caller didn't provide P = p·G, compute it in compressed form (33 bytes)\n\tnaturalPub = naturalPub ?? secp256k1.Point.BASE.multiply(p).toBytes(true);\n\tif (naturalPub.length !== 33) throw new Error('naturalPub must be 33 bytes');\n\t// Calculate both sk candidates for constant time (add/subtract is cheap)\n\tconst skStd: bigint = (p + r) % n;\n\tconst skNeg: bigint = (n - p + r) % n;\n\t// Return skStd if no blinded pubkey was provided to verify against\n\tif (!blindPubkey) {\n\t\tif (skStd === 0n) throw new Error('Derived secret key is zero');\n\t\treturn numberToHexPadded64(skStd);\n\t}\n\tif (blindPubkey.length !== 33) throw new Error('blindPubkey must be 33 bytes');\n\t// Decode P′, compute R and unblind\n\tconst P_ = secp256k1.Point.fromHex(blindPubkey); // valid point\n\tconst R = secp256k1.Point.BASE.multiply(r); // R = r·G\n\tconst P = P_.subtract(R); // P = P_ - R\n\tif (P.equals(secp256k1.Point.ZERO)) return null;\n\t// Check x only equality, using constant time compare\n\tconst xP = P.toBytes(true).slice(1);\n\tconst xNaturalPub = naturalPub.slice(1);\n\tif (!Bytes.equals(xP, xNaturalPub)) {\n\t\treturn null; // this P' is not for this privkey\n\t}\n\t// Select by parity, comparing the low bit only\n\tconst yP = P.toBytes(true)[0] & 1;\n\tconst yNaturalPub = naturalPub[0] & 1;\n\tconst out = yP === yNaturalPub ? skStd : skNeg;\n\tif (out === 0n) throw new Error('Derived secret key is zero');\n\treturn numberToHexPadded64(out);\n}\n\n/**\n * Internal helper, derive P2BK blinding tweak using ECDH.\n *\n * @remarks\n * Computes the shared point Z = scalar·point, takes its 32 byte x coordinate Zx, then derives:\n *\n *     rᵢ = SHA - 256(P2BK_DST || Zx || keysetId || i); // all inputs as raw bytes\n *\n * If the result reduces to zero, or is >= curve order (n), retries once with an extra 0xff byte\n * appended to the message. Throws if the retry also reduces to zero.\n *\n * This function is symmetric. It can be called with either.\n *\n * - The receiver's private key (p) and the sender's ephemeral public key (E)\n * - The sender's ephemeral secret (e) and the receiver's public key (P)\n *\n * Both yield the same Z and therefore the same r thanks to the magic of ECDH!\n * @param point Ephemeral public key (E) or recipient public key (P)\n * @param scalar Private scalar (p) or ephemeral scalar (e) in [1, n − 1]\n * @param keysetId Keyset identifier as raw bytes.\n * @param slotIndex Zero based slot index, only lowest 8 bits (0–255) are used.\n * @returns Tweak (r) in [1, n − 1]\n * @throws If r reduces to zero after the retry.\n * @alpha\n */\nfunction deriveP2BKBlindingTweakFromECDH(\n\tpoint: WeierstrassPoint<bigint>, // E or P\n\tscalar: bigint, // p or e\n\tkeysetId: Uint8Array, // kid\n\tslotIndex: number, // i\n): bigint {\n\t// Calculate x-only ECDH shared point (Zx)\n\tconst Zx = point.multiply(scalar).toBytes(true).slice(1);\n\tconst iByte = new Uint8Array([slotIndex & 0xff]);\n\t// Derive deterministic blinding factor (r):\n\tlet r = bytesToNumber(sha256(Bytes.concat(P2BK_DST, Zx, keysetId, iByte)));\n\tif (r === 0n || r >= secp256k1.Point.CURVE().n) {\n\t\t// Very unlikely to get here!\n\t\tr = bytesToNumber(sha256(Bytes.concat(P2BK_DST, Zx, keysetId, iByte, new Uint8Array([0xff]))));\n\t\tif (r === 0n || r >= secp256k1.Point.CURVE().n) {\n\t\t\tthrow new Error('P2BK: tweak derivation failed');\n\t\t}\n\t}\n\treturn r;\n}\n","import { type PrivKey, bytesToHex, hexToBytes, randomBytes } from '@noble/curves/utils';\nimport { sha256 } from '@noble/hashes/sha2';\nimport { schnorr } from '@noble/curves/secp256k1';\nimport { type P2PKWitness, type Proof } from '../model/types';\nimport { type BlindedMessage } from './core';\nimport { deriveP2BKSecretKeys } from './NUT26';\nimport { type Logger, NULL_LOGGER } from '../logger';\n\nexport type SigFlag = 'SIG_INPUTS' | 'SIG_ALL';\n\nexport type Secret = [WellKnownSecret, SecretData];\n\nexport type WellKnownSecret = 'P2PK';\n\nexport type SecretData = {\n\tnonce: string;\n\tdata: string;\n\ttags?: string[][];\n};\n\nexport const createP2PKsecret = (pubkey: string): string => {\n\tconst newSecret: Secret = [\n\t\t'P2PK',\n\t\t{\n\t\t\tnonce: bytesToHex(randomBytes(32)),\n\t\t\tdata: pubkey,\n\t\t},\n\t];\n\treturn JSON.stringify(newSecret);\n};\n\nexport const parseP2PKSecret = (secret: string | Uint8Array): Secret => {\n\ttry {\n\t\tif (secret instanceof Uint8Array) {\n\t\t\tsecret = new TextDecoder().decode(secret);\n\t\t}\n\t\treturn JSON.parse(secret) as Secret;\n\t} catch {\n\t\tthrow new Error(\"can't parse secret\");\n\t}\n};\n\n/**\n * Signs a P2PK secret using Schnorr.\n *\n * @remarks\n * Signatures are non-deterministic because schnorr.sign() generates a new random auxiliary value\n * (auxRand) each time it is called.\n */\nexport const signP2PKSecret = (secret: string, privateKey: PrivKey): string => {\n\tconst msghash = sha256(secret);\n\tconst sig = schnorr.sign(msghash, privateKey); // auxRand is random by default\n\treturn bytesToHex(sig);\n};\n\nexport const signBlindedMessage = (B_: string, privateKey: PrivKey): string => {\n\tconst msgHash = sha256(B_);\n\tconst sig = schnorr.sign(msgHash, privateKey);\n\treturn bytesToHex(sig);\n};\n\n/**\n * Verifies a Schnorr signature on a P2PK secret.\n *\n * @param signature - The Schnorr signature (hex-encoded).\n * @param secret - The Secret to verify.\n * @param pubkey - The Cashu P2PK public key (hex-encoded, X-only or with 02/03 prefix).\n * @returns {boolean} True if the signature is valid, false otherwise.\n */\nexport const verifyP2PKSecretSignature = (\n\tsignature: string,\n\tsecret: string,\n\tpubkey: string,\n): boolean => {\n\ttry {\n\t\tconst msghash = sha256(secret);\n\t\t// Use X-only pubkey: strip 02/03 prefix if pubkey is 66 hex chars (33 bytes)\n\t\tconst pubkeyX = pubkey.length === 66 ? pubkey.slice(2) : pubkey;\n\t\tif (schnorr.verify(signature, msghash, hexToBytes(pubkeyX))) {\n\t\t\treturn true;\n\t\t}\n\t} catch (e) {\n\t\tconsole.error('verifyP2PKsecret error:', e);\n\t}\n\treturn false; // no bueno\n};\n\n/**\n * Verifies a pubkey has signed a P2PK Proof.\n *\n * @param pubkey - The Cashu P2PK public key (hex-encoded, X-only or with 02/03 prefix).\n * @param proof - A Cashu proof.\n * @returns {boolean} True if one of the signatures is theirs, false otherwise.\n */\nexport const hasP2PKSignedProof = (pubkey: string, proof: Proof): boolean => {\n\tif (!proof.witness) {\n\t\treturn false;\n\t}\n\tconst signatures = getP2PKWitnessSignatures(proof.witness);\n\t// See if any of the signatures belong to this pubkey. We need to do this\n\t// as Schnorr signatures are non-deterministic (see: signP2PKSecret)\n\treturn signatures.some((sig) => {\n\t\ttry {\n\t\t\treturn verifyP2PKSecretSignature(sig, proof.secret, pubkey);\n\t\t} catch {\n\t\t\treturn false; // Invalid signature, treat as not signed\n\t\t}\n\t});\n};\n\n/**\n * Returns the expected witness public keys from a NUT-11 P2PK secret.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {array} With the public keys or empty array.\n */\nexport function getP2PKExpectedKWitnessPubkeys(secretStr: string | Secret): string[] {\n\ttry {\n\t\t// Validate secret\n\t\tconst secret: Secret = typeof secretStr === 'string' ? parseP2PKSecret(secretStr) : secretStr;\n\t\tif (secret[0] !== 'P2PK') {\n\t\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t\t}\n\t\tconst now = Math.floor(Date.now() / 1000);\n\t\tconst locktime = getP2PKLocktime(secret);\n\t\tif (locktime > now) {\n\t\t\t// Am interpretting NUT-11 as intending pubkeys to be usable for a\n\t\t\t// 1-of-m multisig if provided, even if n_sigs is not set\n\t\t\treturn getP2PKWitnessPubkeys(secret);\n\t\t}\n\t\treturn getP2PKWitnessRefundkeys(secret);\n\t} catch {\n\t\t// do nothing\n\t}\n\treturn []; // Unlocked, malformed or expired with no refund keys\n}\n\n/**\n * Returns ALL locktime witnesses from a NUT-11 P2PK secret NB: Does not specify if they are\n * expected to sign - see: getP2PKExpectedKWitnessPubkeys()\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {array} With the public key(s or empty array.\n */\nexport function getP2PKWitnessPubkeys(secretStr: string | Secret): string[] {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseP2PKSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\tconst { data, tags } = secret[1];\n\tconst pubkeysTag = tags && tags.find((tag) => tag[0] === 'pubkeys');\n\tconst pubkeys = pubkeysTag && pubkeysTag.length > 1 ? pubkeysTag.slice(1) : [];\n\treturn [data, ...pubkeys].filter(Boolean);\n}\n\n/**\n * Returns ALL refund witnesses from a NUT-11 P2PK secret NB: Does not specify if they are expected\n * to sign - see: getP2PKExpectedKWitnessPubkeys()\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {array} With the public keys or empty array.\n */\nexport function getP2PKWitnessRefundkeys(secretStr: string | Secret): string[] {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseP2PKSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\tconst { tags } = secret[1];\n\tconst refundTag = tags && tags.find((tag) => tag[0] === 'refund');\n\treturn refundTag && refundTag.length > 1 ? refundTag.slice(1).filter(Boolean) : [];\n}\n\n/**\n * Returns the locktime from a NUT-11 P2PK secret or Infinity if no locktime.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {number} The locktime unix timestamp or Infinity (permanent lock)\n */\nexport function getP2PKLocktime(secretStr: string | Secret): number {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseP2PKSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\tconst { tags } = secret[1];\n\tconst locktimeTag = tags && tags.find((tag) => tag[0] === 'locktime');\n\treturn locktimeTag && locktimeTag.length > 1 ? parseInt(locktimeTag[1], 10) : Infinity; // Permanent lock if not set\n}\n\n/**\n * Returns the number of signatures required from a NUT-11 P2PK secret.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {number} The number of signatories (n_sigs / n_sigs_refund) or 0 if secret is unlocked.\n */\nexport function getP2PKNSigs(secretStr: string | Secret): number {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseP2PKSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\t// Check for witnesses\n\tconst witness = getP2PKExpectedKWitnessPubkeys(secret);\n\tif (!witness.length) {\n\t\treturn 0; // unlocked if no witnesses needed\n\t}\n\t// Check for Lock multisig\n\tconst { tags } = secret[1];\n\tconst now = Math.floor(Date.now() / 1000);\n\tconst locktime = getP2PKLocktime(secret);\n\tif (locktime > now) {\n\t\tconst n_sigsTag = tags && tags.find((tag) => tag[0] === 'n_sigs');\n\t\treturn n_sigsTag && n_sigsTag.length > 1 ? parseInt(n_sigsTag[1], 10) : 1; // Default: 1\n\t}\n\t// Refund multisig\n\tconst n_sigs_refundTag = tags && tags.find((tag) => tag[0] === 'n_sigs_refund');\n\treturn n_sigs_refundTag && n_sigs_refundTag.length > 1 ? parseInt(n_sigs_refundTag[1], 10) : 1; // Default: 1\n}\n\n/**\n * Returns the sigflag from a NUT-11 P2PK secret.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {string} The sigflag or 'SIG_INPUTS' (default)\n */\nexport function getP2PKSigFlag(secretStr: string | Secret): string {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseP2PKSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\tconst { tags } = secret[1];\n\tconst sigFlagTag = tags && tags.find((tag) => tag[0] === 'sigflag');\n\treturn sigFlagTag && sigFlagTag.length > 1 ? (sigFlagTag[1] as SigFlag) : 'SIG_INPUTS';\n}\n\n/**\n * Gets witness signatures as an array.\n *\n * @param witness From Proof.\n * @returns Array of witness signatures.\n */\nexport const getP2PKWitnessSignatures = (witness: string | P2PKWitness | undefined): string[] => {\n\tif (!witness) return [];\n\tif (typeof witness === 'string') {\n\t\ttry {\n\t\t\tconst parsed = JSON.parse(witness) as P2PKWitness;\n\t\t\treturn parsed.signatures || [];\n\t\t} catch (e) {\n\t\t\tconsole.error('Failed to parse witness string:', e);\n\t\t\treturn [];\n\t\t}\n\t}\n\treturn witness.signatures || [];\n};\n\n/**\n * Signs proofs with provided private key(s) if required NB: Will only sign if the proof requires a\n * signature from the key.\n *\n * @param proofs - An array of proofs to sign.\n * @param privateKey - A single private key or array of private keys.\n * @param logger - Optional logger (default: NULL_LOGGER)\n */\nexport const signP2PKProofs = (\n\tproofs: Proof[],\n\tprivateKey: string | string[],\n\tlogger: Logger = NULL_LOGGER,\n): Proof[] => {\n\treturn proofs.map((proof, index) => {\n\t\ttry {\n\t\t\tconst privateKeys: string[] = maybeDeriveP2BKPrivateKeys(privateKey, proof);\n\t\t\tlet signedProof = proof;\n\t\t\tfor (const priv of privateKeys) {\n\t\t\t\ttry {\n\t\t\t\t\tsignedProof = signP2PKProof(signedProof, priv);\n\t\t\t\t} catch (error: unknown) {\n\t\t\t\t\t// Log signature failures only - these are not fatal, just informational\n\t\t\t\t\t// as not all keys will be needed for some proofs (eg P2BK, NIP60 etc)\n\t\t\t\t\tconst message = error instanceof Error ? error.message : 'Unknown error';\n\t\t\t\t\tlogger.warn(`Proof #${index + 1}: ${message}`);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn signedProof;\n\t\t} catch (error: unknown) {\n\t\t\t// General errors (eg from deriveP2BKSecretKey)\n\t\t\tconst message = error instanceof Error ? error.message : 'Unknown error';\n\t\t\tlogger.error(`Proof #${index + 1}: ${message}`);\n\t\t\tthrow new Error(`Failed signing proof #${index + 1}: ${message}`);\n\t\t}\n\t});\n};\n\n/**\n * Signs a single proof with the provided private key if required NB: Will only sign if the proof\n * requires a signature from the key.\n *\n * @param proof - A proof to sign.\n * @param privateKey - A single private key.\n * @throws Error if signature is not required or proof is already signed.\n */\nexport const signP2PKProof = (proof: Proof, privateKey: string): Proof => {\n\t// Check secret is P2PK\n\tconst parsed: Secret = parseP2PKSecret(proof.secret);\n\tif (parsed[0] !== 'P2PK') {\n\t\tthrow new Error('not a P2PK secret');\n\t}\n\t// Check if the private key is required to sign by checking its\n\t// X-only pubkey (no 02/03 prefix) against the expected witness pubkeys\n\t// NB: Nostr pubkeys prepend 02 by convention, ignoring actual Y-parity\n\tconst pubkey = bytesToHex(schnorr.getPublicKey(privateKey)); // x-only\n\tconst witnesses = getP2PKExpectedKWitnessPubkeys(parsed);\n\tif (!witnesses.length || !witnesses.some((w) => w.includes(pubkey))) {\n\t\tthrow new Error(`Signature not required from [02|03]${pubkey}`);\n\t}\n\t// Check if the public key has already signed\n\tconst signatures = getP2PKWitnessSignatures(proof.witness);\n\tconst alreadySigned = signatures.some((sig) => {\n\t\ttry {\n\t\t\treturn verifyP2PKSecretSignature(sig, proof.secret, pubkey);\n\t\t} catch {\n\t\t\treturn false; // Invalid signature, treat as not signed\n\t\t}\n\t});\n\tif (alreadySigned) {\n\t\tthrow new Error(`Proof already signed by [02|03]${pubkey}`);\n\t}\n\t// Add new signature\n\tconst signature = signP2PKSecret(proof.secret, privateKey);\n\treturn { ...proof, witness: { signatures: [...signatures, signature] } };\n};\n\nexport const verifyP2PKSig = (proof: Proof): boolean => {\n\tif (!proof.witness) {\n\t\tthrow new Error('could not verify signature, no witness provided');\n\t}\n\n\tconst parsedSecret: Secret = parseP2PKSecret(proof.secret);\n\tconst witnesses = getP2PKExpectedKWitnessPubkeys(parsedSecret);\n\tif (!witnesses.length) {\n\t\tthrow new Error('no signatures required, proof is unlocked');\n\t}\n\tlet signatories = 0;\n\tconst requiredSigs = getP2PKNSigs(parsedSecret);\n\tconst signatures = getP2PKWitnessSignatures(proof.witness);\n\t// Loop through witnesses to see if any of the signatures belong to them.\n\t// We need to do this as Schnorr signatures are non-deterministic\n\t// (see: signP2PKSecret), so we count the number of valid witnesses,\n\t// not the number of valid signatures\n\tfor (const pubkey of witnesses) {\n\t\tconst hasSigned = signatures.some((sig) => {\n\t\t\ttry {\n\t\t\t\treturn verifyP2PKSecretSignature(sig, proof.secret, pubkey);\n\t\t\t} catch {\n\t\t\t\treturn false; // Invalid signature, treat as not signed\n\t\t\t}\n\t\t});\n\t\tif (hasSigned) {\n\t\t\tsignatories++;\n\t\t}\n\t}\n\treturn signatories >= requiredSigs;\n};\n\nexport const verifyP2PKSigOutput = (output: BlindedMessage, publicKey: string): boolean => {\n\tif (!output.witness?.signatures || output.witness.signatures.length === 0) {\n\t\tthrow new Error('could not verify signature, no witness signatures provided');\n\t}\n\treturn schnorr.verify(\n\t\toutput.witness.signatures[0],\n\t\tsha256(output.B_.toHex(true)),\n\t\tpublicKey.slice(2),\n\t);\n};\n\nexport const getSignedOutput = (output: BlindedMessage, privateKey: PrivKey): BlindedMessage => {\n\tconst B_ = output.B_.toHex(true);\n\tconst signature = signBlindedMessage(B_, privateKey);\n\toutput.witness = { signatures: [signature] };\n\treturn output;\n};\n\nexport const getSignedOutputs = (\n\toutputs: BlindedMessage[],\n\tprivateKey: string,\n): BlindedMessage[] => {\n\treturn outputs.map((o) => getSignedOutput(o, privateKey));\n};\n\n/**\n * Derives blinded secret keys for a P2BK proof.\n *\n * @remarks\n * Calculates the deterministic blinding factor for each P2PK pubkey (data, pubkeys, refund) and\n * calling our parity-aware derivation.\n * @param privateKey Secret key (or array of secret keys)\n * @param proof The proof.\n * @returns Deduplicated list of derived secret keys (hex, 64 chars)\n * @alpha\n */\nexport function maybeDeriveP2BKPrivateKeys(privateKey: string | string[], proof: Proof): string[] {\n\tconst privs = Array.isArray(privateKey) ? privateKey : [privateKey];\n\tconst Ehex: string | undefined = proof?.p2pk_e;\n\tif (!Ehex) {\n\t\treturn Array.from(new Set(privs));\n\t}\n\t// Extract pubkeys and keyset ID from proof\n\tconst secret = parseP2PKSecret(proof.secret);\n\tconst pubs = [...getP2PKWitnessPubkeys(secret), ...getP2PKWitnessRefundkeys(secret)];\n\tconst kid = proof.id; // keyset id is hex\n\treturn deriveP2BKSecretKeys(Ehex, privs, pubs, kid);\n}\n","import { type WeierstrassPoint } from '@noble/curves/abstract/weierstrass';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { sha256 } from '@noble/hashes/sha2';\nimport { type PrivKey, randomBytes, bytesToHex, hexToBytes } from '@noble/curves/utils';\nimport { Bytes, bytesToNumber, hexToNumber, encodeBase64toUint8 } from '../utils';\nimport { type P2PKWitness } from '../model/types';\nimport { getSignedOutput } from './NUT11';\n\nexport type BlindSignature = {\n\tC_: WeierstrassPoint<bigint>;\n\tamount: number;\n\tid: string;\n};\n\nexport type BlindedMessage = {\n\tB_: WeierstrassPoint<bigint>;\n\tr: bigint;\n\tsecret: Uint8Array;\n\twitness?: P2PKWitness;\n};\n\nexport type DLEQ = {\n\ts: Uint8Array; // signature\n\te: Uint8Array; // challenge\n\tr?: bigint; // optional: blinding factor\n};\n\nexport type RawProof = {\n\tC: WeierstrassPoint<bigint>;\n\tsecret: Uint8Array;\n\tamount: number;\n\tid: string;\n\twitness?: P2PKWitness;\n};\n\nexport type SerializedProof = {\n\tC: string;\n\tsecret: string;\n\tamount: number;\n\tid: string;\n\twitness?: string;\n};\n\nconst DOMAIN_SEPARATOR = hexToBytes('536563703235366b315f48617368546f43757276655f43617368755f');\n\nexport function hashToCurve(secret: Uint8Array): WeierstrassPoint<bigint> {\n\tconst msgToHash = sha256(Bytes.concat(DOMAIN_SEPARATOR, secret));\n\tconst counter = new Uint32Array(1);\n\tconst maxIterations = 2 ** 16;\n\tfor (let i = 0; i < maxIterations; i++) {\n\t\tconst counterBytes = new Uint8Array(counter.buffer);\n\t\tconst hash = sha256(Bytes.concat(msgToHash, counterBytes));\n\t\ttry {\n\t\t\treturn pointFromHex(bytesToHex(Bytes.concat(new Uint8Array([0x02]), hash)));\n\t\t} catch {\n\t\t\tcounter[0]++;\n\t\t}\n\t}\n\tthrow new Error('No valid point found');\n}\n\nexport function hash_e(pubkeys: Array<WeierstrassPoint<bigint>>): Uint8Array {\n\tconst hexStrings = pubkeys.map((p) => p.toHex(false));\n\tconst e_ = hexStrings.join('');\n\treturn sha256(new TextEncoder().encode(e_));\n}\n\nexport function pointFromBytes(bytes: Uint8Array) {\n\treturn secp256k1.Point.fromHex(bytesToHex(bytes));\n}\n\nexport function pointFromHex(hex: string) {\n\treturn secp256k1.Point.fromHex(hex);\n}\n\nexport const getKeysetIdInt = (keysetId: string): bigint => {\n\tlet keysetIdInt: bigint;\n\tif (/^[a-fA-F0-9]+$/.test(keysetId)) {\n\t\tkeysetIdInt = hexToNumber(keysetId) % BigInt(2 ** 31 - 1);\n\t} else {\n\t\t//legacy keyset compatibility\n\t\tkeysetIdInt = bytesToNumber(encodeBase64toUint8(keysetId)) % BigInt(2 ** 31 - 1);\n\t}\n\treturn keysetIdInt;\n};\n\nexport function createRandomSecretKey() {\n\treturn secp256k1.utils.randomSecretKey();\n}\n\nexport function createBlindSignature(\n\tB_: WeierstrassPoint<bigint>,\n\tprivateKey: Uint8Array,\n\tamount: number,\n\tid: string,\n): BlindSignature {\n\tconst C_: WeierstrassPoint<bigint> = B_.multiply(bytesToNumber(privateKey));\n\treturn { C_, amount, id };\n}\n\nexport function createRandomBlindedMessage(privateKey?: PrivKey): BlindedMessage {\n\treturn blindMessage(\n\t\trandomBytes(32),\n\t\tbytesToNumber(secp256k1.utils.randomSecretKey()),\n\t\tprivateKey,\n\t);\n}\n\nexport function blindMessage(secret: Uint8Array, r?: bigint, privateKey?: PrivKey): BlindedMessage {\n\tconst Y = hashToCurve(secret);\n\tif (!r) {\n\t\tr = bytesToNumber(secp256k1.utils.randomSecretKey());\n\t}\n\tconst rG = secp256k1.Point.BASE.multiply(r);\n\tconst B_ = Y.add(rG);\n\tif (privateKey !== undefined) {\n\t\treturn getSignedOutput({ B_, r, secret }, privateKey);\n\t}\n\treturn { B_, r, secret };\n}\n\nexport function unblindSignature(\n\tC_: WeierstrassPoint<bigint>,\n\tr: bigint,\n\tA: WeierstrassPoint<bigint>,\n): WeierstrassPoint<bigint> {\n\tconst C = C_.subtract(A.multiply(r));\n\treturn C;\n}\n\nexport function constructProofFromPromise(\n\tpromise: BlindSignature,\n\tr: bigint,\n\tsecret: Uint8Array,\n\tkey: WeierstrassPoint<bigint>,\n): RawProof {\n\tconst A = key;\n\tconst C = unblindSignature(promise.C_, r, A);\n\tconst proof = {\n\t\tid: promise.id,\n\t\tamount: promise.amount,\n\t\tsecret,\n\t\tC,\n\t};\n\treturn proof;\n}\n\nexport const serializeProof = (proof: RawProof): SerializedProof => {\n\treturn {\n\t\tamount: proof.amount,\n\t\tC: proof.C.toHex(true),\n\t\tid: proof.id,\n\t\tsecret: new TextDecoder().decode(proof.secret),\n\t\twitness: JSON.stringify(proof.witness),\n\t};\n};\n\nexport const deserializeProof = (proof: SerializedProof): RawProof => {\n\treturn {\n\t\tamount: proof.amount,\n\t\tC: pointFromHex(proof.C),\n\t\tid: proof.id,\n\t\tsecret: new TextEncoder().encode(proof.secret),\n\t\twitness: proof.witness ? (JSON.parse(proof.witness) as P2PKWitness) : undefined,\n\t};\n};\n","import { type WeierstrassPoint } from '@noble/curves/abstract/weierstrass';\nimport { bytesToHex, hexToBytes } from '@noble/curves/utils';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { type RawProof, createRandomSecretKey, hashToCurve } from './core';\nimport { HDKey } from '@scure/bip32';\nimport { deriveKeysetId, bytesToNumber } from '../utils';\n\nconst DERIVATION_PATH = \"m/0'/0'/0'\";\n\nexport type RawMintKeys = { [k: string]: Uint8Array };\n\nexport type SerializedMintKeys = {\n\t[k: string]: string;\n};\n\nexport type Enumerate<N extends number, Acc extends number[] = []> = Acc['length'] extends N\n\t? Acc[number]\n\t: Enumerate<N, [...Acc, Acc['length']]>;\n\nexport type IntRange<F extends number, T extends number> = Exclude<Enumerate<T>, Enumerate<F>>;\n\nexport type KeysetPair = {\n\tkeysetId: string;\n\tpubKeys: RawMintKeys;\n\tprivKeys: RawMintKeys;\n};\n\nexport function serializeMintKeys(mintKeys: RawMintKeys): SerializedMintKeys {\n\tconst serializedMintKeys: SerializedMintKeys = {};\n\tObject.keys(mintKeys).forEach((p) => {\n\t\tserializedMintKeys[p] = bytesToHex(mintKeys[p]);\n\t});\n\treturn serializedMintKeys;\n}\n\nexport function deserializeMintKeys(serializedMintKeys: SerializedMintKeys): RawMintKeys {\n\tconst mintKeys: RawMintKeys = {};\n\tObject.keys(serializedMintKeys).forEach((p) => {\n\t\tmintKeys[p] = hexToBytes(serializedMintKeys[p]);\n\t});\n\treturn mintKeys;\n}\n\nexport function getPubKeyFromPrivKey(privKey: Uint8Array) {\n\treturn secp256k1.getPublicKey(privKey, true);\n}\n\nexport function createNewMintKeys(pow2height: IntRange<0, 65>, seed?: Uint8Array): KeysetPair {\n\tlet counter = 0n;\n\tconst pubKeys: RawMintKeys = {};\n\tconst privKeys: RawMintKeys = {};\n\tlet masterKey;\n\tif (seed) {\n\t\tmasterKey = HDKey.fromMasterSeed(seed);\n\t}\n\twhile (counter < pow2height) {\n\t\tconst index: string = (2n ** counter).toString();\n\t\tif (masterKey) {\n\t\t\tconst k = masterKey.derive(`${DERIVATION_PATH}/${counter}`).privateKey;\n\t\t\tif (k) {\n\t\t\t\tprivKeys[index] = k;\n\t\t\t} else {\n\t\t\t\tthrow new Error(`Could not derive Private key from: ${DERIVATION_PATH}/${counter}`);\n\t\t\t}\n\t\t} else {\n\t\t\tprivKeys[index] = createRandomSecretKey();\n\t\t}\n\n\t\tpubKeys[index] = getPubKeyFromPrivKey(privKeys[index]);\n\t\tcounter++;\n\t}\n\tconst keysetId = deriveKeysetId(serializeMintKeys(pubKeys));\n\treturn { pubKeys, privKeys, keysetId };\n}\n\nexport function verifyProof(proof: RawProof, privKey: Uint8Array): boolean {\n\tconst Y: WeierstrassPoint<bigint> = hashToCurve(proof.secret);\n\tconst aY: WeierstrassPoint<bigint> = Y.multiply(bytesToNumber(privKey));\n\treturn aY.equals(proof.C);\n}\n","import { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha2';\nimport { getKeysetIdInt } from './core';\nimport { HDKey } from '@scure/bip32';\nimport { Bytes, isBase64String } from '../utils';\n\nconst STANDARD_DERIVATION_PATH = `m/129372'/0'`;\n\nenum DerivationType {\n\tSECRET = 0,\n\tBLINDING_FACTOR = 1,\n}\n\nexport const deriveSecret = (seed: Uint8Array, keysetId: string, counter: number): Uint8Array => {\n\tconst isValidHex = /^[a-fA-F0-9]+$/.test(keysetId);\n\tif (!isValidHex && isBase64String(keysetId)) {\n\t\treturn derive_deprecated(seed, keysetId, counter, DerivationType.SECRET);\n\t}\n\n\tif (isValidHex && keysetId.startsWith('00')) {\n\t\treturn derive_deprecated(seed, keysetId, counter, DerivationType.SECRET);\n\t} else if (isValidHex && keysetId.startsWith('01')) {\n\t\treturn derive(seed, keysetId, counter, DerivationType.SECRET);\n\t}\n\tthrow new Error(`Unrecognized keyset ID version ${keysetId.slice(0, 2)}`);\n};\n\nexport const deriveBlindingFactor = (\n\tseed: Uint8Array,\n\tkeysetId: string,\n\tcounter: number,\n): Uint8Array => {\n\tconst isValidHex = /^[a-fA-F0-9]+$/.test(keysetId);\n\tif (!isValidHex && isBase64String(keysetId)) {\n\t\treturn derive_deprecated(seed, keysetId, counter, DerivationType.BLINDING_FACTOR);\n\t}\n\n\tif (isValidHex && keysetId.startsWith('00')) {\n\t\treturn derive_deprecated(seed, keysetId, counter, DerivationType.BLINDING_FACTOR);\n\t} else if (isValidHex && keysetId.startsWith('01')) {\n\t\treturn derive(seed, keysetId, counter, DerivationType.BLINDING_FACTOR);\n\t}\n\tthrow new Error(`Unrecognized keyset ID version ${keysetId.slice(0, 2)}`);\n};\n\nconst derive = (\n\tseed: Uint8Array,\n\tkeysetId: string,\n\tcounter: number,\n\tsecretOrBlinding: DerivationType,\n): Uint8Array => {\n\tlet message = Bytes.concat(\n\t\tBytes.fromString('Cashu_KDF_HMAC_SHA256'),\n\t\tBytes.fromHex(keysetId),\n\t\tBytes.writeBigUint64BE(BigInt(counter)),\n\t);\n\n\tswitch (secretOrBlinding) {\n\t\tcase DerivationType.SECRET:\n\t\t\tmessage = Bytes.concat(message, Bytes.fromHex('00'));\n\t\t\tbreak;\n\t\tcase DerivationType.BLINDING_FACTOR:\n\t\t\tmessage = Bytes.concat(message, Bytes.fromHex('01'));\n\t}\n\n\t// Step 2: Compute HMAC-SHA256\n\treturn hmac(sha256, seed, message);\n};\n\nconst derive_deprecated = (\n\tseed: Uint8Array,\n\tkeysetId: string,\n\tcounter: number,\n\tsecretOrBlinding: DerivationType,\n): Uint8Array => {\n\tconst hdkey = HDKey.fromMasterSeed(seed);\n\tconst keysetIdInt = getKeysetIdInt(keysetId);\n\tconst derivationPath = `${STANDARD_DERIVATION_PATH}/${keysetIdInt}'/${counter}'/${secretOrBlinding}`;\n\tconst derived = hdkey.derive(derivationPath);\n\tif (derived.privateKey === null) {\n\t\tthrow new Error('Could not derive private key');\n\t}\n\treturn derived.privateKey;\n};\n","import { type DLEQ, hash_e, hashToCurve, createRandomSecretKey } from './core';\nimport { bytesToNumber } from '../utils';\nimport { type WeierstrassPoint } from '@noble/curves/abstract/weierstrass';\nimport { numberToBytesBE } from '@noble/curves/utils';\nimport { secp256k1 } from '@noble/curves/secp256k1';\n\nfunction arraysEqual(arr1: Uint8Array, arr2: Uint8Array) {\n\tif (arr1.length !== arr2.length) return false;\n\tfor (let i = 0; i < arr1.length; i++) {\n\t\tif (arr1[i] !== arr2[i]) return false;\n\t}\n\treturn true;\n}\n\nexport const verifyDLEQProof = (\n\tdleq: DLEQ,\n\tB_: WeierstrassPoint<bigint>,\n\tC_: WeierstrassPoint<bigint>,\n\tA: WeierstrassPoint<bigint>,\n) => {\n\tconst sG = secp256k1.Point.BASE.multiply(secp256k1.Point.Fn.fromBytes(dleq.s));\n\tconst eA = A.multiply(bytesToNumber(dleq.e));\n\tconst sB_ = B_.multiply(bytesToNumber(dleq.s));\n\tconst eC_ = C_.multiply(bytesToNumber(dleq.e));\n\tconst R_1 = sG.subtract(eA); // R1 = sG - eA\n\tconst R_2 = sB_.subtract(eC_); // R2 = sB' - eC'\n\tconst hash = hash_e([R_1, R_2, A, C_]); // e == hash(R1, R2, A, C')\n\treturn arraysEqual(hash, dleq.e);\n};\n\nexport const verifyDLEQProof_reblind = (\n\tsecret: Uint8Array, // secret\n\tdleq: DLEQ,\n\tC: WeierstrassPoint<bigint>, // unblinded e-cash signature point\n\tA: WeierstrassPoint<bigint>, // mint public key point\n) => {\n\tif (dleq.r === undefined) throw new Error('verifyDLEQProof_reblind: Undefined blinding factor');\n\tconst Y = hashToCurve(secret);\n\tconst C_ = C.add(A.multiply(dleq.r)); // Re-blind the e-cash signature\n\tconst bG = secp256k1.Point.BASE.multiply(dleq.r);\n\tconst B_ = Y.add(bG); // Re-blind the message\n\treturn verifyDLEQProof(dleq, B_, C_, A);\n};\n\n/**\n * !!! WARNING !!! Not recommended for production use, due to non-constant time operations See:\n * https://github.com/cashubtc/cashu-crypto-ts/pull/2 for more details See:\n * https://en.wikipedia.org/wiki/Timing_attack for information about timing attacks.\n */\nexport const createDLEQProof = (B_: WeierstrassPoint<bigint>, a: Uint8Array): DLEQ => {\n\tconst r = secp256k1.Point.Fn.fromBytes(createRandomSecretKey()); // r <- random (Uint8Array)\n\tconst R_1 = secp256k1.Point.BASE.multiply(r); // R1 = rG\n\tconst R_2 = B_.multiply(r); // R2 = rB_\n\tconst scalar_a = secp256k1.Point.Fn.fromBytes(a);\n\tconst C_ = B_.multiply(scalar_a); // C_ = aB_\n\tconst A = secp256k1.Point.BASE.multiply(scalar_a); // A = aG\n\tconst e = hash_e([R_1, R_2, A, C_]); // e = hash(R1, R2, A, C_)\n\tconst scalar_e = secp256k1.Point.Fn.fromBytes(e);\n\t// Use field operations for constant-time addition and multiplication\n\tconst s_scalar = secp256k1.Point.Fn.add(r, secp256k1.Point.Fn.mul(scalar_e, scalar_a));\n\tconst s = numberToBytesBE(s_scalar, 32); // s = (r + e * a) mod n\n\treturn { s, e };\n};\n","import { schnorr } from '@noble/curves/secp256k1';\nimport { type SerializedBlindedMessage } from '../model/types';\nimport { bytesToHex, hexToBytes } from '@noble/hashes/utils';\nimport { sha256 } from '@noble/hashes/sha2';\n\nfunction constructMessage(quote: string, blindedMessages: SerializedBlindedMessage[]): Uint8Array {\n\tlet message = quote;\n\tfor (const blindedMessage of blindedMessages) {\n\t\tmessage += blindedMessage.B_;\n\t}\n\tconst msgbytes = new TextEncoder().encode(message);\n\treturn sha256(msgbytes);\n}\n\nexport function signMintQuote(\n\tprivkey: string,\n\tquote: string,\n\tblindedMessages: SerializedBlindedMessage[],\n): string {\n\tconst message = constructMessage(quote, blindedMessages);\n\tconst privkeyBytes = hexToBytes(privkey);\n\tconst signature = schnorr.sign(message, privkeyBytes);\n\treturn bytesToHex(signature);\n}\n\nexport function verifyMintQuoteSignature(\n\tpubkey: string,\n\tquote: string,\n\tblindedMessages: SerializedBlindedMessage[],\n\tsignature: string,\n): boolean {\n\tconst sigbytes = hexToBytes(signature);\n\tlet pubkeyBytes = hexToBytes(pubkey);\n\tif (pubkeyBytes.length !== 33) return false;\n\tpubkeyBytes = pubkeyBytes.slice(1);\n\tconst message = constructMessage(quote, blindedMessages);\n\treturn schnorr.verify(sigbytes, message, pubkeyBytes);\n}\n","import { encodeBase64toUint8, decodeCBOR, encodeCBOR, Bytes } from '../utils';\nimport type {\n\tRawPaymentRequest,\n\tRawTransport,\n\tNUT10Option,\n\tPaymentRequestTransport,\n\tPaymentRequestTransportType,\n} from '../wallet/types';\n\nexport class PaymentRequest {\n\tconstructor(\n\t\tpublic transport?: PaymentRequestTransport[],\n\t\tpublic id?: string,\n\t\tpublic amount?: number,\n\t\tpublic unit?: string,\n\t\tpublic mints?: string[],\n\t\tpublic description?: string,\n\t\tpublic singleUse: boolean = false,\n\t\tpublic nut10?: NUT10Option,\n\t\tpublic nut26: boolean = false,\n\t) {}\n\n\ttoRawRequest() {\n\t\tconst rawRequest: RawPaymentRequest = {};\n\t\tif (this.transport) {\n\t\t\trawRequest.t = this.transport.map((t: PaymentRequestTransport) => ({\n\t\t\t\tt: t.type,\n\t\t\t\ta: t.target,\n\t\t\t\tg: t.tags,\n\t\t\t}));\n\t\t}\n\t\tif (this.id) {\n\t\t\trawRequest.i = this.id;\n\t\t}\n\t\tif (this.amount) {\n\t\t\trawRequest.a = this.amount;\n\t\t}\n\t\tif (this.unit) {\n\t\t\trawRequest.u = this.unit;\n\t\t}\n\t\tif (this.mints) {\n\t\t\trawRequest.m = this.mints;\n\t\t}\n\t\tif (this.description) {\n\t\t\trawRequest.d = this.description;\n\t\t}\n\t\tif (this.singleUse) {\n\t\t\trawRequest.s = this.singleUse;\n\t\t}\n\t\tif (this.nut10) {\n\t\t\trawRequest.nut10 = {\n\t\t\t\tk: this.nut10.kind,\n\t\t\t\td: this.nut10.data,\n\t\t\t\tt: this.nut10.tags,\n\t\t\t};\n\t\t}\n\t\tif (this.nut26) {\n\t\t\trawRequest.nut26 = this.nut26;\n\t\t}\n\t\treturn rawRequest;\n\t}\n\n\ttoEncodedRequest() {\n\t\tconst rawRequest: RawPaymentRequest = this.toRawRequest();\n\t\tconst data = encodeCBOR(rawRequest);\n\t\tconst encodedData = Bytes.toBase64(data);\n\t\treturn 'creq' + 'A' + encodedData;\n\t}\n\n\tgetTransport(type: PaymentRequestTransportType) {\n\t\treturn this.transport?.find((t: PaymentRequestTransport) => t.type === type);\n\t}\n\n\tstatic fromRawRequest(rawPaymentRequest: RawPaymentRequest): PaymentRequest {\n\t\tconst transports = rawPaymentRequest.t\n\t\t\t? rawPaymentRequest.t.map((t: RawTransport) => ({\n\t\t\t\t\ttype: t.t,\n\t\t\t\t\ttarget: t.a,\n\t\t\t\t\ttags: t.g,\n\t\t\t\t}))\n\t\t\t: undefined;\n\t\tconst nut10 = rawPaymentRequest.nut10\n\t\t\t? {\n\t\t\t\t\tkind: rawPaymentRequest.nut10.k,\n\t\t\t\t\tdata: rawPaymentRequest.nut10.d,\n\t\t\t\t\ttags: rawPaymentRequest.nut10.t,\n\t\t\t\t}\n\t\t\t: undefined;\n\t\treturn new PaymentRequest(\n\t\t\ttransports,\n\t\t\trawPaymentRequest.i,\n\t\t\trawPaymentRequest.a,\n\t\t\trawPaymentRequest.u,\n\t\t\trawPaymentRequest.m,\n\t\t\trawPaymentRequest.d,\n\t\t\trawPaymentRequest.s,\n\t\t\tnut10,\n\t\t\trawPaymentRequest.nut26,\n\t\t);\n\t}\n\n\tstatic fromEncodedRequest(encodedRequest: string): PaymentRequest {\n\t\tif (!encodedRequest.startsWith('creq')) {\n\t\t\tthrow new Error('unsupported pr: invalid prefix');\n\t\t}\n\t\tconst version = encodedRequest[4];\n\t\tif (version !== 'A') {\n\t\t\tthrow new Error('unsupported pr version');\n\t\t}\n\t\tconst encodedData = encodedRequest.slice(5);\n\t\tconst data = encodeBase64toUint8(encodedData);\n\t\tconst decoded = decodeCBOR(data) as RawPaymentRequest;\n\t\treturn this.fromRawRequest(decoded);\n\t}\n}\n","import { type DLEQ, pointFromHex, verifyDLEQProof_reblind } from '../crypto';\nimport { bytesToHex, hexToBytes } from '@noble/curves/utils';\nimport { sha256 } from '@noble/hashes/sha2';\nimport {\n\tencodeBase64ToJson,\n\tencodeBase64toUint8,\n\tencodeJsonToBase64,\n\tencodeUint8toBase64Url,\n\tisBase64String,\n} from './base64';\nimport { decodeCBOR, encodeCBOR } from './cbor';\nimport { PaymentRequest } from '../model/PaymentRequest';\nimport type {\n\tTokenMetadata,\n\tDeprecatedToken,\n\tKeys,\n\tMintKeys,\n\tMintKeyset,\n\tProof,\n\tSerializedDLEQ,\n\tToken,\n\tTokenV4Template,\n\tV4DLEQTemplate,\n\tV4InnerToken,\n\tV4ProofTemplate,\n} from '../model/types';\nimport { Bytes } from './Bytes';\nimport { type Keyset } from '../wallet';\n\n/**\n * Splits the amount into denominations of the provided keyset.\n *\n * @remarks\n * Partial splits will be filled up to value using minimum splits required. Sorting is only applied\n * if a fill was made - exact custom splits are always returned in the same order.\n * @param value Amount to split.\n * @param keyset Keys to look up split amounts.\n * @param split? Optional custom split amounts.\n * @param order? Optional order for split amounts (if fill was required)\n * @returns Array of split amounts.\n * @throws Error if split sum is greater than value or mint does not have keys for requested split.\n */\nexport function splitAmount(\n\tvalue: number,\n\tkeyset: Keys,\n\tsplit?: number[],\n\torder?: 'desc' | 'asc',\n): number[] {\n\tif (split) {\n\t\tconst totalSplitAmount = sumArray(split);\n\n\t\t// Special case: explicit \"zero-total\" outputs (restore or NUT-08 blanks)\n\t\tif (value === 0 && totalSplitAmount === 0) {\n\t\t\treturn split;\n\t\t}\n\n\t\t// Normal positive-value paths: ignore zeros for validation and totals\n\t\tconst positive = split.filter((amt) => amt > 0);\n\t\tconst totalPositive = sumArray(positive);\n\t\tif (totalPositive > value) {\n\t\t\tthrow new Error(`Split is greater than total amount: ${totalPositive} > ${value}`);\n\t\t}\n\t\tif (positive.some((amt) => !hasCorrespondingKey(amt, keyset))) {\n\t\t\tthrow new Error('Provided amount preferences do not match the amounts of the mint keyset.');\n\t\t}\n\n\t\t// if caller supplied an exact custom split, preserve their order\n\t\tif (totalPositive === value) {\n\t\t\treturn positive;\n\t\t}\n\n\t\t// Work only with validated positive amounts from here on\n\t\tsplit = positive;\n\t\tvalue -= totalPositive;\n\t} else {\n\t\tsplit = [];\n\t}\n\n\t// Denomination fill for the remaining value\n\tconst sortedKeyAmounts = getKeysetAmounts(keyset, 'desc');\n\tif (!sortedKeyAmounts || sortedKeyAmounts.length === 0) {\n\t\tthrow new Error('Cannot split amount, keyset is inactive or contains no keys');\n\t}\n\tfor (const amt of sortedKeyAmounts) {\n\t\tif (amt <= 0) continue;\n\t\t// Calculate how many of amt fit into remaining value\n\t\tconst requireCount = Math.floor(value / amt);\n\t\t// Add them to the split and reduce the target value by added amounts\n\t\tsplit.push(...Array<number>(requireCount).fill(amt));\n\t\tvalue -= amt * requireCount;\n\t\t// Break early once target is satisfied\n\t\tif (value === 0) break;\n\t}\n\tif (value !== 0) {\n\t\tthrow new Error(`Unable to split remaining amount: ${value}`);\n\t}\n\n\t// Only sort when we performed a fill and it was requested\n\t// Exact custom splits were returned unsorted earlier\n\tif (order) {\n\t\treturn split.sort((a, b) => (order === 'desc' ? b - a : a - b));\n\t}\n\treturn split;\n}\n\n/**\n * Creates a list of amounts to keep based on the proofs we have and the proofs we want to reach.\n *\n * @param proofsWeHave Complete set of proofs stored (from current mint)\n * @param amountToKeep Amount to keep.\n * @param keys Keys of current keyset.\n * @param targetCount The target number of proofs to reach.\n * @returns An array of amounts to keep.\n */\nexport function getKeepAmounts(\n\tproofsWeHave: Proof[],\n\tamountToKeep: number,\n\tkeys: Keys,\n\ttargetCount: number,\n): number[] {\n\t// determines amounts we need to reach the targetCount for each amount based on the amounts of the proofs we have\n\t// it tries to select amounts so that the proofs we have and the proofs we want reach the targetCount\n\tconst amountsWeWant: number[] = [];\n\tconst amountsWeHave = proofsWeHave.map((p: Proof) => p.amount);\n\tconst sortedKeyAmounts = getKeysetAmounts(keys, 'asc');\n\tsortedKeyAmounts.forEach((amt) => {\n\t\tconst countWeHave = amountsWeHave.filter((a) => a === amt).length;\n\t\tconst countWeWant = Math.max(targetCount - countWeHave, 0);\n\t\tfor (let i = 0; i < countWeWant; ++i) {\n\t\t\tif (amountsWeWant.reduce((a, b) => a + b, 0) + amt > amountToKeep) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tamountsWeWant.push(amt);\n\t\t}\n\t});\n\t// use splitAmount to fill the rest between the sum of amountsWeHave and amountToKeep\n\tconst amountDiff = amountToKeep - amountsWeWant.reduce((a, b) => a + b, 0);\n\tif (amountDiff) {\n\t\tconst remainingAmounts = splitAmount(amountDiff, keys);\n\t\tremainingAmounts.forEach((amt: number) => {\n\t\t\tamountsWeWant.push(amt);\n\t\t});\n\t}\n\treturn amountsWeWant.sort((a, b) => a - b);\n}\n/**\n * Returns the amounts in the keyset sorted by the order specified.\n *\n * @param keyset To search in.\n * @param order Order to sort the amounts in.\n * @returns The amounts in the keyset sorted by the order specified.\n */\nexport function getKeysetAmounts(keyset: Keys, order: 'asc' | 'desc' = 'desc'): number[] {\n\tif (order == 'desc') {\n\t\treturn Object.keys(keyset)\n\t\t\t.map((k: string) => parseInt(k))\n\t\t\t.sort((a: number, b: number) => b - a);\n\t}\n\treturn Object.keys(keyset)\n\t\t.map((k: string) => parseInt(k))\n\t\t.sort((a: number, b: number) => a - b);\n}\n\n/**\n * Checks if the provided amount is in the keyset.\n *\n * @param amount Amount to check.\n * @param keyset To search in.\n * @returns True if the amount is in the keyset, false otherwise.\n */\nexport function hasCorrespondingKey(amount: number, keyset: Keys): boolean {\n\treturn amount in keyset;\n}\n\n/**\n * Converts a bytes array to a number.\n *\n * @param bytes To convert to number.\n * @returns Number.\n */\nexport function bytesToNumber(bytes: Uint8Array): bigint {\n\treturn hexToNumber(bytesToHex(bytes));\n}\n\n/**\n * Converts a hex string to a number.\n *\n * @param hex To convert to number.\n * @returns Number.\n */\nexport function hexToNumber(hex: string): bigint {\n\treturn BigInt(`0x${hex}`);\n}\n\n/**\n * Converts a number to a hex string of 64 characters.\n *\n * @param number (bigint) to conver to hex.\n * @returns Hex string start-padded to 64 characters.\n */\nexport function numberToHexPadded64(number: bigint): string {\n\treturn number.toString(16).padStart(64, '0');\n}\n\nexport function isValidHex(str: string) {\n\treturn /^[a-f0-9]*$/i.test(str);\n}\n\n/**\n * Checks wether a proof or a list of proofs contains a non-hex id.\n *\n * @param p Proof or list of proofs.\n * @returns Boolean.\n */\nexport function hasNonHexId(p: Proof | Proof[]) {\n\tif (Array.isArray(p)) {\n\t\treturn p.some((proof) => !isValidHex(proof.id));\n\t}\n\treturn !isValidHex(p.id);\n}\n\n//used for json serialization\nexport function bigIntStringify<T>(_key: unknown, value: T) {\n\treturn typeof value === 'bigint' ? value.toString() : value;\n}\n\n/**\n * Helper function to encode a v3 cashu token.\n *\n * @param token To encode.\n * @returns Encoded token.\n */\nexport function getEncodedTokenV3(token: Token, removeDleq?: boolean): string {\n\tif (!hasNonHexId(token.proofs)) {\n\t\ttoken.proofs = convertToShortKeysetId(token.proofs);\n\t}\n\tif (removeDleq) {\n\t\ttoken.proofs = stripDleq(token.proofs);\n\t}\n\tconst v3TokenObj: DeprecatedToken = { token: [{ mint: token.mint, proofs: token.proofs }] };\n\tif (token.unit) {\n\t\tv3TokenObj.unit = token.unit;\n\t}\n\tif (token.memo) {\n\t\tv3TokenObj.memo = token.memo;\n\t}\n\tconst prefix = 'cashu';\n\tconst version = 'A';\n\treturn prefix + version + encodeJsonToBase64(v3TokenObj);\n}\n\n/*\n * Convert a keyset ID into short form\n */\nfunction convertToShortKeysetId(proofs: Proof[]) {\n\treturn proofs.map((p) => {\n\t\tconst newP = { ...p };\n\t\tnewP.id = newP.id.slice(0, 16);\n\t\treturn newP;\n\t});\n}\n\n/**\n * Helper function to encode a cashu token (defaults to v4 if keyset id allows it)\n *\n * @param token\n * @param [opts]\n */\nexport function getEncodedToken(\n\ttoken: Token,\n\topts?: { version?: 3 | 4; removeDleq?: boolean },\n): string {\n\t// Find out if it's a base64 keyset\n\tconst nonHex = hasNonHexId(token.proofs);\n\tif (nonHex || opts?.version === 3) {\n\t\tif (opts?.version === 4) {\n\t\t\tthrow new Error('can not encode to v4 token if proofs contain non-hex keyset id');\n\t\t}\n\t\treturn getEncodedTokenV3(token, opts?.removeDleq);\n\t}\n\treturn getEncodedTokenV4(token, opts?.removeDleq);\n}\n\nexport function getEncodedTokenV4(token: Token, removeDleq?: boolean): string {\n\tif (removeDleq) {\n\t\ttoken.proofs = stripDleq(token.proofs);\n\t}\n\t// Make sure each DLEQ has its blinding factor\n\ttoken.proofs.forEach((p) => {\n\t\tif (p.dleq && p.dleq.r == undefined) {\n\t\t\tthrow new Error('Missing blinding factor in included DLEQ proof');\n\t\t}\n\t});\n\tconst nonHex = hasNonHexId(token.proofs);\n\tif (nonHex) {\n\t\tthrow new Error('can not encode to v4 token if proofs contain non-hex keyset id');\n\t}\n\t// Map keyset IDs to short IDs\n\ttoken.proofs = convertToShortKeysetId(token.proofs);\n\n\tconst tokenTemplate = templateFromToken(token);\n\n\tconst encodedData = encodeCBOR(tokenTemplate);\n\tconst prefix = 'cashu';\n\tconst version = 'B';\n\tconst base64Data = encodeUint8toBase64Url(encodedData);\n\treturn prefix + version + base64Data;\n}\n\nfunction templateFromToken(token: Token): TokenV4Template {\n\tconst idMap: { [id: string]: Proof[] } = {};\n\tconst mint = token.mint;\n\tfor (let i = 0; i < token.proofs.length; i++) {\n\t\tconst proof = token.proofs[i];\n\t\tif (idMap[proof.id]) {\n\t\t\tidMap[proof.id].push(proof);\n\t\t} else {\n\t\t\tidMap[proof.id] = [proof];\n\t\t}\n\t}\n\tconst tokenTemplate: TokenV4Template = {\n\t\tm: mint,\n\t\tu: token.unit || 'sat',\n\t\tt: Object.keys(idMap).map(\n\t\t\t(id: string): V4InnerToken => ({\n\t\t\t\ti: hexToBytes(id),\n\t\t\t\tp: idMap[id].map(\n\t\t\t\t\t(p: Proof): V4ProofTemplate => ({\n\t\t\t\t\t\ta: p.amount,\n\t\t\t\t\t\ts: p.secret,\n\t\t\t\t\t\tc: hexToBytes(p.C),\n\t\t\t\t\t\t...(p.dleq && {\n\t\t\t\t\t\t\td: {\n\t\t\t\t\t\t\t\te: hexToBytes(p.dleq.e),\n\t\t\t\t\t\t\t\ts: hexToBytes(p.dleq.s),\n\t\t\t\t\t\t\t\tr: hexToBytes(p.dleq.r ?? '00'),\n\t\t\t\t\t\t\t} as V4DLEQTemplate,\n\t\t\t\t\t\t}),\n\t\t\t\t\t\t...(p.p2pk_e && {\n\t\t\t\t\t\t\tpe: hexToBytes(p.p2pk_e),\n\t\t\t\t\t\t}),\n\t\t\t\t\t\t...(p.witness && {\n\t\t\t\t\t\t\tw: JSON.stringify(p.witness),\n\t\t\t\t\t\t}),\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t}),\n\t\t),\n\t} as TokenV4Template;\n\tif (token.memo) {\n\t\ttokenTemplate.d = token.memo;\n\t}\n\treturn tokenTemplate;\n}\n\nfunction tokenFromTemplate(template: TokenV4Template): Token {\n\tconst proofs: Proof[] = [];\n\ttemplate.t.forEach((t) =>\n\t\tt.p.forEach((p) => {\n\t\t\tproofs.push({\n\t\t\t\tsecret: p.s,\n\t\t\t\tC: bytesToHex(p.c),\n\t\t\t\tamount: p.a,\n\t\t\t\tid: bytesToHex(t.i),\n\t\t\t\t...(p.d && {\n\t\t\t\t\tdleq: {\n\t\t\t\t\t\tr: bytesToHex(p.d.r),\n\t\t\t\t\t\ts: bytesToHex(p.d.s),\n\t\t\t\t\t\te: bytesToHex(p.d.e),\n\t\t\t\t\t} as SerializedDLEQ,\n\t\t\t\t}),\n\t\t\t\t...(p.pe && {\n\t\t\t\t\tp2pk_e: bytesToHex(p.pe),\n\t\t\t\t}),\n\t\t\t\t...(p.w && {\n\t\t\t\t\twitness: p.w,\n\t\t\t\t}),\n\t\t\t});\n\t\t}),\n\t);\n\tconst decodedToken: Token = { mint: template.m, proofs, unit: template.u || 'sat' };\n\tif (template.d) {\n\t\tdecodedToken.memo = template.d;\n\t}\n\treturn decodedToken;\n}\n\n/**\n * Helper function to decode cashu tokens into object.\n *\n * @param token An encoded cashu token (cashuAey...)\n * @returns Cashu token object.\n */\nexport function getDecodedToken(tokenString: string, keysets?: MintKeyset[] | Keyset[]) {\n\t// remove prefixes\n\tconst token = removePrefix(tokenString);\n\tconst tokenObj = handleTokens(token);\n\ttokenObj.proofs = mapShortKeysetIds(tokenObj.proofs, keysets);\n\treturn tokenObj;\n}\n\n/**\n * Returns the metadata of a cashu token.\n *\n * @param token An encoded cashu token (cashuAey...)\n * @returns Token metadata.\n */\nexport function getTokenMetadata(token: string): TokenMetadata {\n\ttoken = removePrefix(token);\n\tconst tokenObj = handleTokens(token);\n\treturn {\n\t\tunit: tokenObj.unit || 'sat',\n\t\tmint: tokenObj.mint,\n\t\tamount: sumProofs(tokenObj.proofs),\n\t\t...(tokenObj.memo && { memo: tokenObj.memo }),\n\t\tincompleteProofs: tokenObj.proofs.map((p) => ({\n\t\t\tsecret: p.secret,\n\t\t\tC: p.C,\n\t\t\tamount: p.amount,\n\t\t\t...(p.dleq && {\n\t\t\t\tdleq: p.dleq,\n\t\t\t}),\n\t\t\t...(p.witness && {\n\t\t\t\twitness: p.witness,\n\t\t\t}),\n\t\t})),\n\t};\n}\n\n/**\n * Helper function to decode different versions of cashu tokens into an object.\n *\n * @param token An encoded cashu token (cashuAey...)\n * @returns Cashu Token object.\n */\nexport function handleTokens(token: string): Token {\n\tconst version = token.slice(0, 1);\n\tconst encodedToken = token.slice(1);\n\tif (version === 'A') {\n\t\tconst parsedV3Token = encodeBase64ToJson<DeprecatedToken>(encodedToken);\n\t\tif (parsedV3Token.token.length > 1) {\n\t\t\tthrow new Error('Multi entry token are not supported');\n\t\t}\n\t\tconst entry = parsedV3Token.token[0];\n\t\tconst tokenObj: Token = {\n\t\t\tmint: entry.mint,\n\t\t\tproofs: entry.proofs,\n\t\t\tunit: parsedV3Token.unit || 'sat',\n\t\t};\n\t\tif (parsedV3Token.memo) {\n\t\t\ttokenObj.memo = parsedV3Token.memo;\n\t\t}\n\t\treturn tokenObj;\n\t} else if (version === 'B') {\n\t\tconst uInt8Token = encodeBase64toUint8(encodedToken);\n\t\tconst tokenData = decodeCBOR(uInt8Token) as TokenV4Template;\n\t\treturn tokenFromTemplate(tokenData);\n\t}\n\tthrow new Error('Token version is not supported');\n}\n\n/**\n * Returns the keyset id of a set of keys.\n *\n * @param keys Keys object to derive keyset id from.\n * @param unit (optional) the unit of the keyset.\n * @param expiry (optional) expiry of the keyset.\n * @param versionByte (optional) version of the keyset ID. Default is 0.\n * @param isDeprecatedBase64 (optional) true if the keyset ID should be derived as a deprecated v0\n *   base64 keyset ID.\n * @returns Keyset id of the keys.\n * @throws If keyset versionByte is not valid.\n */\nexport function deriveKeysetId(\n\tkeys: Keys,\n\tunit?: string,\n\texpiry?: number,\n\tversionByte: number = 0,\n\tisDeprecatedBase64: boolean = false,\n) {\n\tif (isDeprecatedBase64) {\n\t\tconst pubkeysConcat = Object.entries(keys)\n\t\t\t.sort((a: [string, string], b: [string, string]) => +a[0] - +b[0])\n\t\t\t.map(([, pubKey]: [unknown, string]) => pubKey)\n\t\t\t.reduce((prev: string, curr: string) => prev + curr, '');\n\t\tconst hash = sha256(pubkeysConcat);\n\t\tconst b64 = Bytes.toBase64(hash);\n\t\treturn b64.slice(0, 12);\n\t}\n\n\tlet pubkeysConcat = Object.entries(keys)\n\t\t.sort((a: [string, string], b: [string, string]) => +a[0] - +b[0])\n\t\t.map(([, pubKey]: [unknown, string]) => hexToBytes(pubKey))\n\t\t.reduce((prev: Uint8Array, curr: Uint8Array) => mergeUInt8Arrays(prev, curr), new Uint8Array());\n\n\tlet hash;\n\tlet hashHex;\n\tswitch (versionByte) {\n\t\tcase 0:\n\t\t\thash = sha256(pubkeysConcat);\n\t\t\thashHex = Bytes.toHex(hash).slice(0, 14);\n\t\t\treturn '00' + hashHex;\n\t\tcase 1:\n\t\t\tif (!unit) {\n\t\t\t\tthrow new Error('Cannot compute keyset ID version 01: unit is required.');\n\t\t\t}\n\t\t\tpubkeysConcat = mergeUInt8Arrays(pubkeysConcat, Bytes.fromString('unit:' + unit));\n\t\t\tif (expiry) {\n\t\t\t\tpubkeysConcat = mergeUInt8Arrays(\n\t\t\t\t\tpubkeysConcat,\n\t\t\t\t\tBytes.fromString('final_expiry:' + expiry.toString()),\n\t\t\t\t);\n\t\t\t}\n\t\t\thash = sha256(pubkeysConcat);\n\t\t\thashHex = Bytes.toHex(hash);\n\t\t\treturn '01' + hashHex;\n\t\tdefault:\n\t\t\tthrow new Error(`Unrecognized keyset ID version: ${versionByte}`);\n\t}\n}\n\nexport function mergeUInt8Arrays(a1: Uint8Array, a2: Uint8Array): Uint8Array {\n\t// sum of individual array lengths\n\tconst mergedArray = new Uint8Array(a1.length + a2.length);\n\tmergedArray.set(a1);\n\tmergedArray.set(a2, a1.length);\n\treturn mergedArray;\n}\n\nexport function sortProofsById(proofs: Proof[]) {\n\treturn proofs.sort((a: Proof, b: Proof) => a.id.localeCompare(b.id));\n}\n\nexport function isObj(v: unknown): v is object {\n\treturn typeof v === 'object';\n}\n\nexport function checkResponse(data: { error?: string; detail?: string }) {\n\tif (!isObj(data)) return;\n\tif ('error' in data && data.error) {\n\t\tthrow new Error(data.error);\n\t}\n\tif ('detail' in data && data.detail) {\n\t\tthrow new Error(data.detail);\n\t}\n}\n\nexport function joinUrls(...parts: string[]): string {\n\treturn parts.map((part: string) => part.replace(/(^\\/+|\\/+$)/g, '')).join('/');\n}\n\nexport function sanitizeUrl(url: string): string {\n\treturn url.replace(/\\/$/, '');\n}\n\nexport function sumProofs(proofs: Proof[]) {\n\treturn proofs.reduce((acc: number, proof: Proof) => acc + proof.amount, 0);\n}\n\nexport function decodePaymentRequest(paymentRequest: string) {\n\treturn PaymentRequest.fromEncodedRequest(paymentRequest);\n}\n\nexport class MessageNode {\n\tprivate _value: string;\n\tprivate _next: MessageNode | null;\n\n\tpublic get value(): string {\n\t\treturn this._value;\n\t}\n\tpublic set value(message: string) {\n\t\tthis._value = message;\n\t}\n\tpublic get next(): MessageNode | null {\n\t\treturn this._next;\n\t}\n\tpublic set next(node: MessageNode | null) {\n\t\tthis._next = node;\n\t}\n\n\tconstructor(message: string) {\n\t\tthis._value = message;\n\t\tthis._next = null;\n\t}\n}\n\nexport class MessageQueue {\n\tprivate _first: MessageNode | null;\n\tprivate _last: MessageNode | null;\n\n\tpublic get first(): MessageNode | null {\n\t\treturn this._first;\n\t}\n\tpublic set first(messageNode: MessageNode | null) {\n\t\tthis._first = messageNode;\n\t}\n\tpublic get last(): MessageNode | null {\n\t\treturn this._last;\n\t}\n\tpublic set last(messageNode: MessageNode | null) {\n\t\tthis._last = messageNode;\n\t}\n\tprivate _size: number;\n\tpublic get size(): number {\n\t\treturn this._size;\n\t}\n\tpublic set size(v: number) {\n\t\tthis._size = v;\n\t}\n\n\tconstructor() {\n\t\tthis._first = null;\n\t\tthis._last = null;\n\t\tthis._size = 0;\n\t}\n\tenqueue(message: string): boolean {\n\t\tconst newNode = new MessageNode(message);\n\t\tif (this._size === 0 || !this._last) {\n\t\t\tthis._first = newNode;\n\t\t\tthis._last = newNode;\n\t\t} else {\n\t\t\tthis._last.next = newNode;\n\t\t\tthis._last = newNode;\n\t\t}\n\t\tthis._size++;\n\t\treturn true;\n\t}\n\tdequeue(): string | null {\n\t\tif (this._size === 0 || !this._first) return null;\n\n\t\tconst prev = this._first;\n\t\tthis._first = prev.next;\n\t\tprev.next = null;\n\n\t\tthis._size--;\n\t\treturn prev.value;\n\t}\n}\n/**\n * Removes all traces of DLEQs from a list of proofs.\n *\n * @param proofs The list of proofs that dleq should be stripped from.\n */\nexport function stripDleq(proofs: Proof[]): Array<Omit<Proof, 'dleq'>> {\n\treturn proofs.map((p) => {\n\t\tconst newP = { ...p };\n\t\tdelete newP['dleq'];\n\t\treturn newP;\n\t});\n}\n\n/**\n * Check that the keyset hashes to the specified ID.\n *\n * @deprecated Now part of Keyset class.\n * @param keys The keyset to be verified.\n * @returns True if the verification was successful, false otherwise.\n * @throws Error if the keyset ID version is unrecognized.\n */\nexport function verifyKeysetId(keys: MintKeys): boolean {\n\tconst isBase64 = isBase64String(keys.id);\n\tconst isValidHex = /^[a-fA-F0-9]+$/.test(keys.id);\n\tconst versionByte = isValidHex ? hexToBytes(keys.id)[0] : 0;\n\treturn (\n\t\tderiveKeysetId(\n\t\t\tkeys.keys,\n\t\t\tkeys.unit,\n\t\t\tkeys.final_expiry,\n\t\t\tversionByte,\n\t\t\tisBase64 && !isValidHex,\n\t\t) === keys.id\n\t);\n}\n\n/**\n * Maps the short keyset IDs stored in the token to actual keyset IDs that were fetched from the\n * Mint.\n */\nfunction mapShortKeysetIds(proofs: Proof[], keysets?: MintKeyset[] | Keyset[]): Proof[] {\n\tconst newProofs = [];\n\tfor (const proof of proofs) {\n\t\tlet idBytes;\n\t\ttry {\n\t\t\tidBytes = hexToBytes(proof.id);\n\t\t} catch {\n\t\t\t// Base64 keysets don't need conversion\n\t\t\tnewProofs.push(proof);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (idBytes[0] === 0x00) {\n\t\t\tnewProofs.push(proof);\n\t\t} else if (idBytes[0] === 0x01) {\n\t\t\tif (!keysets) {\n\t\t\t\tthrow new Error('A short keyset ID v2 was encountered, but got no keysets to map it to.');\n\t\t\t}\n\t\t\t// Look for a match: prefix(keyset ID) == short ID\n\t\t\tlet found = false;\n\t\t\tfor (const keyset of keysets) {\n\t\t\t\tif (proof.id === keyset.id.slice(0, proof.id.length)) {\n\t\t\t\t\tproof.id = keyset.id;\n\t\t\t\t\tnewProofs.push(proof);\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Couldn't map short keyset ID ${proof.id} to any known keysets of the current Mint`,\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(`Unknown keyset ID version: ${idBytes[0]}`);\n\t\t}\n\t}\n\n\treturn newProofs;\n}\n\n/**\n * Checks that the proof has a valid DLEQ proof according to keyset `keys`\n *\n * @param proof The proof subject to verification.\n * @param keyset The Mint's keyset to be used for verification.\n * @returns True if verification succeeded, false otherwise.\n * @throws Error if @param proof does not match any key in @param keyset.\n */\nexport function hasValidDleq(proof: Proof, keyset: MintKeys | Keyset): boolean {\n\tif (proof.dleq == undefined) {\n\t\treturn false;\n\t}\n\tconst dleq = {\n\t\te: hexToBytes(proof.dleq.e),\n\t\ts: hexToBytes(proof.dleq.s),\n\t\tr: hexToNumber(proof.dleq.r ?? '00'),\n\t} as DLEQ;\n\tif (!hasCorrespondingKey(proof.amount, keyset.keys)) {\n\t\tthrow new Error(`undefined key for amount ${proof.amount}`);\n\t}\n\tconst key = keyset.keys[proof.amount];\n\treturn verifyDLEQProof_reblind(\n\t\tnew TextEncoder().encode(proof.secret),\n\t\tdleq,\n\t\tpointFromHex(proof.C),\n\t\tpointFromHex(key),\n\t);\n}\n\nfunction concatByteArrays(...arrays: Uint8Array[]): Uint8Array {\n\tconst totalLength = arrays.reduce((a, c) => a + c.length, 0);\n\tconst byteArray = new Uint8Array(totalLength);\n\tlet pointer = 0;\n\tfor (let i = 0; i < arrays.length; i++) {\n\t\tbyteArray.set(arrays[i], pointer);\n\t\tpointer = pointer + arrays[i].length;\n\t}\n\treturn byteArray;\n}\n\nexport function getEncodedTokenBinary(token: Token): Uint8Array {\n\tconst utf8Encoder = new TextEncoder();\n\tconst template = templateFromToken(token);\n\tconst binaryTemplate = encodeCBOR(template);\n\tconst prefix = utf8Encoder.encode('craw');\n\tconst version = utf8Encoder.encode('B');\n\treturn concatByteArrays(prefix, version, binaryTemplate);\n}\n\nexport function getDecodedTokenBinary(bytes: Uint8Array): Token {\n\tconst utfDecoder = new TextDecoder();\n\tconst prefix = utfDecoder.decode(bytes.slice(0, 4));\n\tconst version = utfDecoder.decode(new Uint8Array([bytes[4]]));\n\tif (prefix !== 'craw' || version !== 'B') {\n\t\tthrow new Error('not a valid binary token');\n\t}\n\tconst binaryToken = bytes.slice(5);\n\tconst decoded = decodeCBOR(binaryToken) as TokenV4Template;\n\treturn tokenFromTemplate(decoded);\n}\n\nfunction sumArray(arr: number[]) {\n\treturn arr.reduce((a, c) => a + c, 0);\n}\n\n/**\n * Utility function for deep equality comparison of objects.\n */\nexport function deepEqual<T>(a: T, b: T): boolean {\n\tif (a === b) return true;\n\tif (a == null || b == null) return false;\n\tif (typeof a !== 'object' || typeof b !== 'object') return false;\n\n\tif (Array.isArray(a) && Array.isArray(b)) {\n\t\tif (a.length !== b.length) return false;\n\t\treturn a.every((item, index) => deepEqual(item, b[index]));\n\t}\n\n\tif (Array.isArray(a) || Array.isArray(b)) return false;\n\n\tconst keysA = Object.keys(a) as Array<keyof T>;\n\tconst keysB = Object.keys(b) as Array<keyof T>;\n\tif (keysA.length !== keysB.length) return false;\n\n\treturn keysA.every((key) => keysB.includes(key) && deepEqual(a[key], b[key]));\n}\n\nfunction removePrefix(token: string): string {\n\tconst uriPrefixes = ['web+cashu://', 'cashu://', 'cashu:', 'cashu'];\n\turiPrefixes.forEach((prefix: string) => {\n\t\tif (!token.startsWith(prefix)) {\n\t\t\treturn;\n\t\t}\n\t\ttoken = token.slice(prefix.length);\n\t});\n\treturn token;\n}\n","import { MessageQueue } from '../utils';\nimport { type JsonRpcMessage, type JsonRpcReqParams, type RpcSubId } from '../model/types';\nimport { type OnOpenError, type OnOpenSuccess } from '../wallet/types/websocket';\nimport { getWebSocketImpl } from './ws';\nimport { type Logger, NULL_LOGGER } from '../logger';\n\n// Internal interface for RPC listeners\ninterface RpcListener {\n\tcallback: () => void;\n\terrorCallback: (e: Error) => void;\n}\n\nexport class ConnectionManager {\n\tprivate static instance: ConnectionManager;\n\tprivate connectionMap: Map<string, WSConnection> = new Map();\n\n\tstatic getInstance() {\n\t\tif (!ConnectionManager.instance) {\n\t\t\tConnectionManager.instance = new ConnectionManager();\n\t\t}\n\t\treturn ConnectionManager.instance;\n\t}\n\n\tgetConnection(url: string, logger?: Logger): WSConnection {\n\t\tif (this.connectionMap.has(url)) {\n\t\t\treturn this.connectionMap.get(url) as WSConnection;\n\t\t}\n\t\tconst newConn = new WSConnection(url, logger);\n\t\tthis.connectionMap.set(url, newConn);\n\t\treturn newConn;\n\t}\n}\n\nexport class WSConnection {\n\tpublic readonly url: URL;\n\tprivate readonly _WS: typeof WebSocket;\n\tprivate ws: WebSocket | undefined;\n\tprivate connectionPromise: Promise<void> | undefined;\n\tprivate subListeners: { [subId: string]: Array<(payload: unknown) => void> } = {};\n\tprivate rpcListeners: { [rpcSubId: string]: RpcListener } = {};\n\tprivate messageQueue: MessageQueue;\n\tprivate handlingInterval?: number;\n\tprivate rpcId = 0;\n\tprivate _logger: Logger;\n\tprivate onCloseCallbacks: Array<(e: CloseEvent) => void> = [];\n\n\tconstructor(url: string, logger?: Logger) {\n\t\tthis._WS = getWebSocketImpl();\n\t\tthis.url = new URL(url);\n\t\tthis.messageQueue = new MessageQueue();\n\t\tthis._logger = logger ?? NULL_LOGGER;\n\t}\n\n\tconnect() {\n\t\tif (!this.connectionPromise) {\n\t\t\tthis.connectionPromise = new Promise((resolve: OnOpenSuccess, reject: OnOpenError) => {\n\t\t\t\ttry {\n\t\t\t\t\tthis.ws = new this._WS(this.url.toString());\n\t\t\t\t\tthis.onCloseCallbacks = [];\n\t\t\t\t} catch (err: unknown) {\n\t\t\t\t\treject(err instanceof Error ? err : new Error(String(err)));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.ws.onopen = () => {\n\t\t\t\t\tresolve();\n\t\t\t\t};\n\t\t\t\tthis.ws.onerror = () => {\n\t\t\t\t\treject(new Error('Failed to open WebSocket'));\n\t\t\t\t};\n\t\t\t\tthis.ws.onmessage = (e: MessageEvent) => {\n\t\t\t\t\tthis.messageQueue.enqueue(e.data as string);\n\t\t\t\t\tif (!this.handlingInterval) {\n\t\t\t\t\t\tthis.handlingInterval = setInterval(\n\t\t\t\t\t\t\tthis.handleNextMessage.bind(this),\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t) as unknown as number;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tthis.ws.onclose = (e: CloseEvent) => {\n\t\t\t\t\tthis.connectionPromise = undefined;\n\t\t\t\t\tthis.onCloseCallbacks.forEach((cb) => cb(e));\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\t\treturn this.connectionPromise;\n\t}\n\n\tsendRequest(method: 'subscribe', params: JsonRpcReqParams): void;\n\tsendRequest(method: 'unsubscribe', params: { subId: string }): void;\n\tsendRequest(method: 'subscribe' | 'unsubscribe', params: Partial<JsonRpcReqParams>) {\n\t\tif (this.ws?.readyState !== 1) {\n\t\t\tif (method === 'unsubscribe') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._logger.error('Attempted sendRequest, but socket was not open');\n\t\t\tthrow new Error('Socket not open');\n\t\t}\n\t\tconst id = this.rpcId;\n\t\tthis.rpcId++;\n\t\tconst message = JSON.stringify({ jsonrpc: '2.0', method, params, id });\n\t\tthis.ws?.send(message);\n\t}\n\n\t/**\n\t * @deprecated Use cancelSubscription for JSONRPC compliance.\n\t */\n\tcloseSubscription(subId: string) {\n\t\tthis.ws?.send(JSON.stringify(['CLOSE', subId]));\n\t}\n\n\taddSubListener<TPayload = unknown>(subId: string, callback: (payload: TPayload) => void) {\n\t\t(this.subListeners[subId] = this.subListeners[subId] || []).push(\n\t\t\tcallback as (payload: unknown) => void,\n\t\t);\n\t}\n\n\tprivate addRpcListener(\n\t\tcallback: () => void,\n\t\terrorCallback: (e: Error) => void,\n\t\tid: Exclude<RpcSubId, null>,\n\t) {\n\t\tthis.rpcListeners[id] = { callback, errorCallback };\n\t}\n\n\tprivate removeRpcListener(id: Exclude<RpcSubId, null>) {\n\t\tdelete this.rpcListeners[id];\n\t}\n\n\tprivate removeListener<TPayload = unknown>(subId: string, callback: (payload: TPayload) => void) {\n\t\tif (!this.subListeners[subId]) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.subListeners[subId].length === 1) {\n\t\t\tdelete this.subListeners[subId];\n\t\t\treturn;\n\t\t}\n\t\tthis.subListeners[subId] = this.subListeners[subId].filter(\n\t\t\t(fn) => fn !== (callback as (payload: unknown) => void),\n\t\t);\n\t}\n\n\tasync ensureConnection() {\n\t\tif (this.ws?.readyState !== 1) {\n\t\t\tawait this.connect();\n\t\t}\n\t}\n\n\tprivate handleNextMessage() {\n\t\tif (this.messageQueue.size === 0) {\n\t\t\tclearInterval(this.handlingInterval);\n\t\t\tthis.handlingInterval = undefined;\n\t\t\treturn;\n\t\t}\n\t\tconst message = this.messageQueue.dequeue() as string;\n\t\tlet parsed;\n\t\ttry {\n\t\t\tparsed = JSON.parse(message) as JsonRpcMessage;\n\t\t\tif ('result' in parsed && parsed.id != undefined) {\n\t\t\t\tif (this.rpcListeners[parsed.id]) {\n\t\t\t\t\tthis.rpcListeners[parsed.id].callback();\n\t\t\t\t\tthis.removeRpcListener(parsed.id);\n\t\t\t\t}\n\t\t\t} else if ('error' in parsed && parsed.id != undefined) {\n\t\t\t\tif (this.rpcListeners[parsed.id]) {\n\t\t\t\t\tthis.rpcListeners[parsed.id].errorCallback(new Error(parsed.error.message));\n\t\t\t\t\tthis.removeRpcListener(parsed.id);\n\t\t\t\t}\n\t\t\t} else if ('method' in parsed) {\n\t\t\t\tif ('id' in parsed) {\n\t\t\t\t\t// Do nothing as mints should not send requests\n\t\t\t\t} else {\n\t\t\t\t\tconst subId = parsed.params?.subId;\n\t\t\t\t\tif (!subId) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (this.subListeners[subId]?.length > 0) {\n\t\t\t\t\t\tconst notification = parsed;\n\t\t\t\t\t\tthis.subListeners[subId].forEach((cb) => cb(notification.params?.payload));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tthis._logger.error('Error doing handleNextMessage', { e });\n\t\t\treturn;\n\t\t}\n\t}\n\n\tcreateSubscription<TPayload = unknown>(\n\t\tparams: Omit<JsonRpcReqParams, 'subId'>,\n\t\tcallback: (payload: TPayload) => void,\n\t\terrorCallback: (e: Error) => void,\n\t): string {\n\t\tif (this.ws?.readyState !== 1) {\n\t\t\tthis._logger.error('Attempted createSubscription, but socket was not open');\n\t\t\tthrow new Error('Socket is not open');\n\t\t}\n\t\tconst subId = (Math.random() + 1).toString(36).substring(7);\n\t\tthis.addRpcListener(\n\t\t\t() => {\n\t\t\t\tthis.addSubListener(subId, callback);\n\t\t\t},\n\t\t\terrorCallback,\n\t\t\tthis.rpcId,\n\t\t);\n\t\tthis.sendRequest('subscribe', { ...params, subId });\n\t\tthis.rpcId++;\n\t\treturn subId;\n\t}\n\n\t/**\n\t * Cancels a subscription, sending an unsubscribe request and handling responses.\n\t *\n\t * @param subId The subscription ID to cancel.\n\t * @param callback The original payload callback to remove.\n\t * @param errorCallback Optional callback for unsubscribe errors (defaults to logging).\n\t */\n\tcancelSubscription<TPayload = unknown>(\n\t\tsubId: string,\n\t\tcallback: (payload: TPayload) => void,\n\t\terrorCallback?: (e: Error) => void,\n\t) {\n\t\tthis.removeListener(subId, callback);\n\t\tthis.addRpcListener(\n\t\t\t() => {\n\t\t\t\tthis._logger.info('Unsubscribed {subId}', { subId });\n\t\t\t},\n\t\t\terrorCallback || ((e: Error) => this._logger.error('Unsubscribe failed', { e })),\n\t\t\tthis.rpcId,\n\t\t);\n\t\tthis.sendRequest('unsubscribe', { subId });\n\t}\n\n\tget activeSubscriptions() {\n\t\treturn Object.keys(this.subListeners);\n\t}\n\n\tclose() {\n\t\tif (this.ws) {\n\t\t\tthis.ws?.close();\n\t\t}\n\t}\n\n\tonClose(callback: (e: CloseEvent) => void) {\n\t\tthis.onCloseCallbacks.push(callback);\n\t}\n}\n","import type { PartialMeltQuoteResponse } from '../mint/types';\nimport { MeltQuoteState } from '../mint/types';\nimport type { Logger } from '../logger';\n\nexport type MeltQuoteResponsePaidDeprecated = {\n\tpaid?: boolean;\n};\n\nexport function handleMeltQuoteResponseDeprecated(\n\tresponse: PartialMeltQuoteResponse & MeltQuoteResponsePaidDeprecated,\n\tlogger: Logger,\n): PartialMeltQuoteResponse {\n\t// if the response MeltQuoteResponse has a \"paid\" flag, we monkey patch it to the state enum\n\tif (!response.state) {\n\t\tlogger.warn(\n\t\t\t\"Field 'state' not found in MeltQuoteResponse. Update NUT-05 of mint: https://github.com/cashubtc/nuts/pull/136)\",\n\t\t);\n\t\tif (typeof response.paid === 'boolean') {\n\t\t\tresponse.state = response.paid ? MeltQuoteState.PAID : MeltQuoteState.UNPAID;\n\t\t}\n\t}\n\treturn response;\n}\n","import type { PartialMintQuoteResponse } from '../mint/types';\nimport { MintQuoteState } from '../mint/types';\nimport type { Logger } from '../logger';\n\nexport type MintQuoteResponsePaidDeprecated = {\n\tpaid?: boolean;\n};\n\nexport function handleMintQuoteResponseDeprecated(\n\tresponse: PartialMintQuoteResponse & MintQuoteResponsePaidDeprecated,\n\tlogger: Logger,\n): PartialMintQuoteResponse {\n\t// if the response MeltQuoteResponse has a \"paid\" flag, we monkey patch it to the state enum\n\tif (!response.state) {\n\t\tlogger.warn(\n\t\t\t\"Field 'state' not found in MintQuoteResponse. Update NUT-04 of mint: https://github.com/cashubtc/nuts/pull/141)\",\n\t\t);\n\t\tif (typeof response.paid === 'boolean') {\n\t\t\tresponse.state = response.paid ? MintQuoteState.PAID : MintQuoteState.UNPAID;\n\t\t}\n\t}\n\treturn response;\n}\n","import type { MintContactInfo, GetInfoResponse } from '../mint/types';\nimport type { Logger } from '../logger';\n\nexport function handleMintInfoContactFieldDeprecated(data: GetInfoResponse, logger: Logger) {\n\t// Monkey patch old contact field [\"email\", \"me@mail.com\"] Array<[string, string]>; to new contact field [{method: \"email\", info: \"me@mail.com\"}] Array<MintContactInfo>\n\t// This is to maintain backwards compatibility with older versions of the mint\n\tif (Array.isArray(data?.contact) && data?.contact.length > 0) {\n\t\tdata.contact = data.contact.map((contact: MintContactInfo) => {\n\t\t\tif (\n\t\t\t\tArray.isArray(contact) &&\n\t\t\t\tcontact.length === 2 &&\n\t\t\t\ttypeof contact[0] === 'string' &&\n\t\t\t\ttypeof contact[1] === 'string'\n\t\t\t) {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t`Mint returned deprecated 'contact' field: Update NUT-06: https://github.com/cashubtc/nuts/pull/117`,\n\t\t\t\t);\n\t\t\t\treturn { method: contact[0], info: contact[1] } as MintContactInfo;\n\t\t\t}\n\t\t\treturn contact;\n\t\t});\n\t}\n\treturn data;\n}\n","import {\n\ttype GetInfoResponse,\n\ttype MPPMethod,\n\ttype SwapMethod,\n\ttype WebSocketSupport,\n} from '../mint/types';\n\ntype Method = 'GET' | 'POST';\ntype Endpoint = { method: Method; path: string };\n\ntype ProtectedIndex = {\n\tcache: Record<string, boolean>; // \"METHOD /v1/foo\"\n\texact: Array<{ method: Method; path: string }>;\n\tregex: Array<{ method: Method; regex: RegExp }>;\n};\n\nexport class MintInfo {\n\t// Full mint info response\n\tprivate readonly _mintInfo: GetInfoResponse;\n\t// NUT-22, Blind-auth protected endpoints\n\tprivate readonly _protected22?: ProtectedIndex;\n\t// NUT-21, Clear-auth protected endpoints\n\tprivate readonly _protected21?: ProtectedIndex;\n\t// detects regex intent\n\tprivate readonly REGEX_METACHAR = /[\\\\^$.*+?()[\\]{}|]/;\n\n\tconstructor(info: GetInfoResponse) {\n\t\tthis._mintInfo = info;\n\n\t\tconst pe22 = this.toEndpoints(info?.nuts?.[22]?.protected_endpoints);\n\t\tthis._protected22 = this.buildIndex(pe22);\n\n\t\tconst pe21 = this.toEndpoints(info?.nuts?.[21]?.protected_endpoints);\n\t\tthis._protected21 = this.buildIndex(pe21);\n\t}\n\n\tisSupported(num: 4 | 5): { disabled: boolean; params: SwapMethod[] };\n\tisSupported(num: 7 | 8 | 9 | 10 | 11 | 12 | 14 | 20): { supported: boolean };\n\tisSupported(num: 17): { supported: boolean; params?: WebSocketSupport[] };\n\tisSupported(num: 15): { supported: boolean; params?: MPPMethod[] };\n\tisSupported(num: number) {\n\t\tswitch (num) {\n\t\t\tcase 4:\n\t\t\tcase 5: {\n\t\t\t\treturn this.checkMintMelt(num);\n\t\t\t}\n\t\t\tcase 7:\n\t\t\tcase 8:\n\t\t\tcase 9:\n\t\t\tcase 10:\n\t\t\tcase 11:\n\t\t\tcase 12:\n\t\t\tcase 14:\n\t\t\tcase 20: {\n\t\t\t\treturn this.checkGenericNut(num);\n\t\t\t}\n\t\t\tcase 17: {\n\t\t\t\treturn this.checkNut17();\n\t\t\t}\n\t\t\tcase 15: {\n\t\t\t\treturn this.checkNut15();\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error('nut is not supported by cashu-ts');\n\t\t\t}\n\t\t}\n\t}\n\n\trequiresBlindAuthToken(method: 'GET' | 'POST', path: string): boolean {\n\t\treturn this.matchesProtected(this._protected22, method, path);\n\t}\n\n\trequiresClearAuthToken(method: 'GET' | 'POST', path: string): boolean {\n\t\treturn this.matchesProtected(this._protected21, method, path);\n\t}\n\n\tprivate matchesProtected(idx: ProtectedIndex | undefined, method: Method, path: string): boolean {\n\t\tif (!idx) return false;\n\n\t\tconst cacheKey = `${method} ${path}`;\n\t\tconst cached = idx.cache[cacheKey];\n\t\tif (typeof cached === 'boolean') return cached;\n\n\t\tconst exactHit = idx.exact.some((e) => e.method === method && e.path === path);\n\t\tconst regexHit = exactHit\n\t\t\t? false\n\t\t\t: idx.regex.some((e) => e.method === method && e.regex.test(path));\n\n\t\tconst res = exactHit || regexHit;\n\t\tidx.cache[cacheKey] = res;\n\t\treturn res;\n\t}\n\n\tprivate checkGenericNut(num: 7 | 8 | 9 | 10 | 11 | 12 | 14 | 20) {\n\t\treturn this._mintInfo.nuts[num]?.supported ? { supported: true } : { supported: false };\n\t}\n\n\tprivate checkMintMelt(num: 4 | 5) {\n\t\tconst mintMeltInfo = this._mintInfo.nuts[num];\n\t\tif (mintMeltInfo && mintMeltInfo.methods.length > 0 && !mintMeltInfo.disabled) {\n\t\t\treturn { disabled: false, params: mintMeltInfo.methods };\n\t\t}\n\t\treturn { disabled: true, params: mintMeltInfo?.methods ?? [] };\n\t}\n\n\tprivate checkNut17() {\n\t\tif (this._mintInfo.nuts[17] && this._mintInfo.nuts[17].supported.length > 0) {\n\t\t\treturn { supported: true, params: this._mintInfo.nuts[17].supported };\n\t\t}\n\t\treturn { supported: false };\n\t}\n\n\tprivate checkNut15() {\n\t\tif (this._mintInfo.nuts[15] && this._mintInfo.nuts[15].methods.length > 0) {\n\t\t\treturn { supported: true, params: this._mintInfo.nuts[15].methods };\n\t\t}\n\t\treturn { supported: false };\n\t}\n\n\t// ---------- private helpers ----------\n\n\tprivate toEndpoints(maybe: unknown): Endpoint[] {\n\t\tif (!Array.isArray(maybe)) return [];\n\t\tconst out: Endpoint[] = [];\n\t\tfor (const e of maybe) {\n\t\t\tif (e && typeof e === 'object') {\n\t\t\t\tconst rec = e as Record<string, unknown>;\n\t\t\t\tconst mm = rec.method;\n\t\t\t\tconst pp = rec.path;\n\t\t\t\tif (typeof mm === 'string' && typeof pp === 'string') {\n\t\t\t\t\tconst method = mm.toUpperCase();\n\t\t\t\t\tif (method === 'GET' || method === 'POST') {\n\t\t\t\t\t\tout.push({ method, path: pp });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn out;\n\t}\n\n\tprivate buildIndex(endpoints?: Endpoint[]): ProtectedIndex | undefined {\n\t\tif (!endpoints || endpoints.length === 0) return undefined;\n\n\t\tconst exact: ProtectedIndex['exact'] = [];\n\t\tconst regex: ProtectedIndex['regex'] = [];\n\t\tconst metachar = this.REGEX_METACHAR;\n\n\t\tfor (const e of endpoints) {\n\t\t\tconst looksRegex = e.path.startsWith('^') || e.path.endsWith('$') || metachar.test(e.path);\n\t\t\tif (looksRegex) {\n\t\t\t\ttry {\n\t\t\t\t\tregex.push({ method: e.method, regex: new RegExp(e.path) });\n\t\t\t\t\tcontinue;\n\t\t\t\t} catch {\n\t\t\t\t\t// fall back to exact on malformed patterns\n\t\t\t\t}\n\t\t\t}\n\t\t\texact.push({ method: e.method, path: e.path });\n\t\t}\n\n\t\t// plain object avoids the unsafe any from Object.create(null)\n\t\tconst cache: Record<string, boolean> = {};\n\t\treturn { cache, exact, regex };\n\t}\n\n\t// ---------- getters ----------\n\n\tget contact() {\n\t\treturn this._mintInfo.contact;\n\t}\n\tget description() {\n\t\treturn this._mintInfo.description;\n\t}\n\tget description_long() {\n\t\treturn this._mintInfo.description_long;\n\t}\n\tget name() {\n\t\treturn this._mintInfo.name;\n\t}\n\tget pubkey() {\n\t\treturn this._mintInfo.pubkey;\n\t}\n\tget nuts() {\n\t\treturn this._mintInfo.nuts;\n\t}\n\tget version() {\n\t\treturn this._mintInfo.version;\n\t}\n\tget motd() {\n\t\treturn this._mintInfo.motd;\n\t}\n\n\t/**\n\t * @deprecated Use supportsNut04Description(method, unit)\n\t */\n\tget supportsBolt12Description(): boolean {\n\t\treturn this.supportsNut04Description('bolt12');\n\t}\n\n\t/**\n\t * Checks if the mint supports creating invoices/offers with a description for the specified\n\t * payment method.\n\t *\n\t * @param method - The payment method to check ('bolt11' or 'bolt12')\n\t * @returns True if the mint supports description for the method, false otherwise.\n\t */\n\tsupportsNut04Description(method: 'bolt11' | 'bolt12', unit?: string): boolean {\n\t\treturn this._mintInfo.nuts[4]?.methods.some(\n\t\t\t(met) =>\n\t\t\t\tmet.method === method &&\n\t\t\t\t(unit ? met.unit === unit : true) &&\n\t\t\t\t(met.options?.description === true || met.description === true),\n\t\t);\n\t}\n}\n","import { randomBytes } from '@noble/curves/utils';\nimport { type Logger, NULL_LOGGER, safeCallback } from '../logger';\nimport type { GetInfoResponse } from '../mint/types';\nimport { Bytes, encodeUint8toBase64Url } from '../utils';\nimport { sha256 } from '@noble/hashes/sha2';\n\nexport type OIDCConfig = {\n\tissuer: string;\n\tauthorization_endpoint?: string;\n\ttoken_endpoint: string;\n\tdevice_authorization_endpoint?: string;\n};\n\nexport type TokenResponse = {\n\taccess_token?: string;\n\ttoken_type?: string;\n\texpires_in?: number;\n\trefresh_token?: string;\n\tid_token?: string;\n\tscope?: string;\n\terror?: string;\n\terror_description?: string;\n};\n\nexport type DeviceStartResponse = {\n\tdevice_code: string;\n\tuser_code: string;\n\tverification_uri: string;\n\tverification_uri_complete?: string;\n\tinterval?: number;\n\texpires_in?: number;\n};\n\nexport type OIDCAuthOptions = {\n\tclientId?: string;\n\tscope?: string;\n\tlogger?: Logger;\n\tonTokens?: (t: TokenResponse) => void | Promise<void>;\n};\n\nexport class OIDCAuth {\n\tprivate readonly discoveryUrl: string;\n\tprivate readonly logger: Logger;\n\n\tprivate clientId: string;\n\tprivate scope: string;\n\tprivate config?: OIDCConfig;\n\tprivate onTokens?: (t: TokenResponse) => void | Promise<void>;\n\n\t// External listeners, notified after onTokens fires\n\tprivate tokenListeners: Array<(t: TokenResponse) => void | Promise<void>> = [];\n\n\tstatic fromMintInfo(info: { nuts: GetInfoResponse['nuts'] }, opts?: OIDCAuthOptions): OIDCAuth {\n\t\tconst n21 = info?.nuts?.['21'];\n\t\tif (!n21?.openid_discovery) {\n\t\t\tthrow new Error('OIDCAuth: mint does not advertise NUT-21 openid_discovery');\n\t\t}\n\t\tconst clientId = opts?.clientId ?? n21.client_id ?? 'cashu-client';\n\t\treturn new OIDCAuth(n21.openid_discovery, { ...opts, clientId });\n\t}\n\n\tconstructor(discoveryUrl: string, opts?: OIDCAuthOptions) {\n\t\tthis.discoveryUrl = discoveryUrl;\n\t\tthis.logger = opts?.logger ?? NULL_LOGGER;\n\t\tthis.clientId = opts?.clientId ?? 'cashu-client';\n\t\tthis.scope = opts?.scope ?? 'openid';\n\t\tthis.onTokens = opts?.onTokens;\n\t}\n\n\tsetClient(id: string): void {\n\t\tthis.clientId = id;\n\t}\n\n\tsetScope(scope?: string): void {\n\t\tthis.scope = scope ?? 'openid';\n\t}\n\n\t/**\n\t * Subscribe to token updates. Listeners are called after the primary onTokens callback.\n\t */\n\taddTokenListener(fn: (t: TokenResponse) => void | Promise<void>): void {\n\t\tthis.tokenListeners.push(fn);\n\t}\n\n\t// ---- Discovery ----\n\n\tasync loadConfig(): Promise<OIDCConfig> {\n\t\tif (this.config) return this.config;\n\t\tconst res = await fetch(this.discoveryUrl, {\n\t\t\tmethod: 'GET',\n\t\t\theaders: { Accept: 'application/json' },\n\t\t});\n\t\tconst text = await res.text();\n\t\tlet json: unknown;\n\t\ttry {\n\t\t\tjson = text ? JSON.parse(text) : undefined;\n\t\t} catch (err) {\n\t\t\tthis.logger.warn('OIDCAuth: bad discovery JSON', { err });\n\t\t}\n\t\tif (!res.ok || !json) {\n\t\t\tthrow new Error('OIDCAuth: invalid discovery document');\n\t\t}\n\t\tconst cfg = json as OIDCConfig;\n\t\tif (typeof cfg.token_endpoint !== 'string' || cfg.token_endpoint.length === 0) {\n\t\t\tthrow new Error('OIDCAuth: invalid discovery document, missing token_endpoint');\n\t\t}\n\t\tthis.config = cfg;\n\t\treturn cfg;\n\t}\n\n\t// --- Authorization Code with PKCE ---\n\n\t/**\n\t * Generate a PKCE verifier and S256 challenge.\n\t *\n\t * - Verifier: base64url of random bytes, length >= 43, RFC 7636 compliant.\n\t * - Challenge: base64url(sha256(verifier))\n\t */\n\tgeneratePKCE(): { verifier: string; challenge: string } {\n\t\t// 48 bytes->base64url is typically 64 chars without padding, comfortably >= 43\n\t\tconst rnd = randomBytes(48);\n\t\tconst verifier = encodeUint8toBase64Url(rnd);\n\n\t\t// RFC 7636, challenge = BASE64URL-ENCODE( SHA256( ASCII(verifier) ) )\n\t\tconst vBytes = Bytes.fromString(verifier);\n\t\tconst chBytes = sha256(vBytes);\n\t\tconst challenge = encodeUint8toBase64Url(chBytes);\n\n\t\treturn { verifier, challenge };\n\t}\n\n\t/**\n\t * Build an Authorization Code + PKCE URL.\n\t */\n\tasync buildAuthCodeUrl(input: {\n\t\tredirectUri: string;\n\t\tcodeChallenge: string;\n\t\tcodeChallengeMethod?: 'S256' | 'plain'; // default S256\n\t\tstate?: string; // optional state to pass back to redirectUrl\n\t\tscope?: string; // default this.scope\n\t}): Promise<string> {\n\t\tconst cfg = await this.loadConfig();\n\t\tconst scope = input.scope ?? this.scope;\n\t\tconst params = new URLSearchParams({\n\t\t\tresponse_type: 'code',\n\t\t\tclient_id: this.clientId,\n\t\t\tredirect_uri: input.redirectUri,\n\t\t\tscope,\n\t\t\tcode_challenge_method: input.codeChallengeMethod ?? 'S256',\n\t\t\tcode_challenge: input.codeChallenge,\n\t\t});\n\t\tif (input.state) params.set('state', input.state);\n\n\t\tif (!cfg.authorization_endpoint) {\n\t\t\tthrow new Error('OIDCAuth: discovery lacks authorization_endpoint');\n\t\t}\n\t\treturn `${cfg.authorization_endpoint}?${params.toString()}`;\n\t}\n\n\t/**\n\t * Exchange an auth code for tokens, using the PKCE verifier.\n\t */\n\tasync exchangeAuthCode(input: { code: string; redirectUri: string; codeVerifier: string }) {\n\t\tconst cfg = await this.loadConfig();\n\t\tconst form = this.toForm({\n\t\t\tgrant_type: 'authorization_code',\n\t\t\tcode: input.code,\n\t\t\tredirect_uri: input.redirectUri,\n\t\t\tclient_id: this.clientId,\n\t\t\tcode_verifier: input.codeVerifier,\n\t\t});\n\t\tconst tok = await this.postFormStrict<TokenResponse>(cfg.token_endpoint, form);\n\t\tthis.handleTokens(tok);\n\t\treturn tok;\n\t}\n\n\t// ---- Device Code (recommended for CLIs) ----\n\n\tasync deviceStart(): Promise<DeviceStartResponse> {\n\t\tconst cfg = await this.loadConfig();\n\t\tconst ep = cfg.device_authorization_endpoint;\n\t\tif (!ep) throw new Error('OIDCAuth: provider lacks device_authorization_endpoint');\n\n\t\tconst form = this.toForm({ client_id: this.clientId, scope: this.scope });\n\t\treturn this.postFormStrict<DeviceStartResponse>(ep, form);\n\t}\n\n\tasync devicePoll(device_code: string, intervalSec = 5): Promise<TokenResponse> {\n\t\tconst cfg = await this.loadConfig();\n\t\t// Clamp to a sensible minimum to avoid hot loops\n\t\tlet delay = Math.max(1, intervalSec);\n\t\twhile (true) {\n\t\t\tawait this.sleep(delay * 1000);\n\t\t\tconst form = this.toForm({\n\t\t\t\tgrant_type: 'urn:ietf:params:oauth:grant-type:device_code',\n\t\t\t\tdevice_code,\n\t\t\t\tclient_id: this.clientId,\n\t\t\t});\n\t\t\tconst res = await this.postFormLoose<TokenResponse>(cfg.token_endpoint, form);\n\t\t\tif (res.access_token) {\n\t\t\t\tthis.handleTokens(res);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\tconst err = (res.error ?? '').toString();\n\t\t\tif (err === 'authorization_pending') continue;\n\t\t\tif (err === 'slow_down') {\n\t\t\t\tdelay = Math.max(delay + 5, delay * 2);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst msg = res.error_description || err || 'device authorization failed';\n\t\t\tthrow new Error(`OIDCAuth: ${msg}`);\n\t\t}\n\t}\n\n\t/**\n\t * One call convenience for Device Code flow.\n\t *\n\t * @remarks\n\t * Polling interval will be the MAX of intervalSec and Mint interval.\n\t * @param intervalSec Desired polling interval in seconds.\n\t * @returns The start fields and helpers to poll or cancel.\n\t */\n\tasync startDeviceAuth(intervalSec: number = 5): Promise<\n\t\tDeviceStartResponse & {\n\t\t\tpoll: () => Promise<TokenResponse>;\n\t\t\tcancel: () => void;\n\t\t}\n\t> {\n\t\tconst start = await this.deviceStart();\n\t\tconst interval = Math.max(start.interval ?? 1, intervalSec);\n\t\tlet aborted = false;\n\n\t\tconst poll = async (): Promise<TokenResponse> => {\n\t\t\tconst cfg = await this.loadConfig();\n\t\t\tlet delay = Math.max(1, interval);\n\t\t\twhile (true) {\n\t\t\t\tif (aborted) throw new Error('OIDCAuth: device polling cancelled');\n\t\t\t\tawait this.sleep(delay * 1000);\n\t\t\t\tconst form = this.toForm({\n\t\t\t\t\tgrant_type: 'urn:ietf:params:oauth:grant-type:device_code',\n\t\t\t\t\tdevice_code: start.device_code,\n\t\t\t\t\tclient_id: this.clientId,\n\t\t\t\t});\n\t\t\t\tconst res = await this.postFormLoose<TokenResponse>(cfg.token_endpoint, form);\n\t\t\t\tif (res.access_token) {\n\t\t\t\t\tthis.handleTokens(res);\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tconst err = (res.error ?? '').toString();\n\t\t\t\tif (err === 'authorization_pending') continue;\n\t\t\t\tif (err === 'slow_down') {\n\t\t\t\t\tdelay = Math.max(delay + 5, delay * 2);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst msg = res.error_description || err || 'device authorization failed';\n\t\t\t\tthrow new Error(`OIDCAuth: ${msg}`);\n\t\t\t}\n\t\t};\n\n\t\tconst cancel = (): void => {\n\t\t\taborted = true;\n\t\t};\n\n\t\treturn { ...start, poll, cancel };\n\t}\n\n\t// ---- Refresh ----\n\n\tasync refresh(refresh_token: string): Promise<TokenResponse> {\n\t\tconst cfg = await this.loadConfig();\n\t\tconst form = this.toForm({\n\t\t\tgrant_type: 'refresh_token',\n\t\t\trefresh_token,\n\t\t\tclient_id: this.clientId,\n\t\t});\n\t\tconst tok = await this.postFormStrict<TokenResponse>(cfg.token_endpoint, form);\n\t\tthis.handleTokens(tok);\n\t\treturn tok;\n\t}\n\n\t// ---- ROPC (discouraged, but some mints allow it) ----\n\n\tasync passwordGrant(username: string, password: string): Promise<TokenResponse> {\n\t\tconst cfg = await this.loadConfig();\n\t\tconst form = this.toForm({\n\t\t\tgrant_type: 'password',\n\t\t\tclient_id: this.clientId,\n\t\t\tusername,\n\t\t\tpassword,\n\t\t\tscope: this.scope,\n\t\t});\n\t\tconst tok = await this.postFormStrict<TokenResponse>(cfg.token_endpoint, form);\n\t\tthis.handleTokens(tok);\n\t\treturn tok;\n\t}\n\n\t// ---- internals ----\n\n\t/**\n\t * Fire and forget token fan out. Any listener errors are logged inside safeCallback. Nothing\n\t * thrown here will come from listeners.\n\t */\n\tprivate handleTokens(t: TokenResponse): void {\n\t\tif (!t.access_token) {\n\t\t\tconst msg = t.error_description || t.error || 'token response missing access_token';\n\t\t\tthrow new Error(`OIDCAuth: ${msg}`);\n\t\t}\n\t\t// Schedule on microtask queue so we never block the caller and we avoid sync throws leaking.\n\t\tqueueMicrotask(() =>\n\t\t\tsafeCallback(this.onTokens, t, this.logger, { where: 'OIDCAuth.handleTokens' }),\n\t\t);\n\n\t\tfor (const listener of this.tokenListeners) {\n\t\t\tqueueMicrotask(() =>\n\t\t\t\tsafeCallback(listener, t, this.logger, {\n\t\t\t\t\twhere: 'OIDCAuth.handleTokens.listener',\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate toForm(params: Record<string, string>): string {\n\t\tconst enc = (v: string) => encodeURIComponent(v).replace(/%20/g, '+');\n\t\treturn Object.entries(params)\n\t\t\t.map(([k, v]) => `${enc(k)}=${enc(v)}`)\n\t\t\t.join('&');\n\t}\n\n\t// Strict, throws on non 2xx\n\tprivate async postFormStrict<TSuccess extends object>(\n\t\tendpoint: string,\n\t\tformBody: string,\n\t): Promise<TSuccess> {\n\t\ttry {\n\t\t\tthis.logger.debug('OIDCAuth Request', { formBody });\n\t\t\tconst res = await fetch(endpoint, {\n\t\t\t\tmethod: 'POST',\n\t\t\t\theaders: {\n\t\t\t\t\t'Content-Type': 'application/x-www-form-urlencoded',\n\t\t\t\t\tAccept: 'application/json',\n\t\t\t\t},\n\t\t\t\tbody: formBody,\n\t\t\t});\n\t\t\tconst text = await res.text();\n\t\t\tlet json: unknown;\n\t\t\ttry {\n\t\t\t\tjson = text ? JSON.parse(text) : undefined;\n\t\t\t} catch (err) {\n\t\t\t\tthis.logger.warn('OIDCAuth: bad JSON (strict)', { err });\n\t\t\t}\n\t\t\tif (!res.ok) {\n\t\t\t\tconst err = (json ?? {}) as TokenResponse;\n\t\t\t\tconst msg = err.error_description || err.error || `HTTP ${res.status}`;\n\t\t\t\tthrow new Error(`OIDCAuth: ${msg}`);\n\t\t\t}\n\t\t\tthis.logger.debug('OIDCAuth Response', { json });\n\t\t\treturn (json ?? {}) as TSuccess;\n\t\t} catch (err) {\n\t\t\tthis.logger.error('OIDCAuth: postFormStrict failed', { err });\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\t// Loose, returns JSON payload even on non 2xx\n\tprivate async postFormLoose<T extends object>(\n\t\tendpoint: string,\n\t\tformBody: string,\n\t): Promise<T | TokenResponse> {\n\t\ttry {\n\t\t\tthis.logger.debug('OIDCAuth Request', { formBody });\n\t\t\tconst res = await fetch(endpoint, {\n\t\t\t\tmethod: 'POST',\n\t\t\t\theaders: {\n\t\t\t\t\t'Content-Type': 'application/x-www-form-urlencoded',\n\t\t\t\t\tAccept: 'application/json',\n\t\t\t\t},\n\t\t\t\tbody: formBody,\n\t\t\t});\n\t\t\tconst text = await res.text();\n\t\t\tlet json: unknown;\n\t\t\ttry {\n\t\t\t\tjson = text ? JSON.parse(text) : undefined;\n\t\t\t} catch (err) {\n\t\t\t\tthis.logger.warn('OIDCAuth: bad JSON (loose)', { err });\n\t\t\t}\n\t\t\tthis.logger.debug('OIDCAuth Response', { json });\n\t\t\treturn (json ?? {}) as T | TokenResponse;\n\t\t} catch (err) {\n\t\t\tthis.logger.error('OIDCAuth: postFormLoose network error', { err });\n\t\t\treturn { error: 'network_error', error_description: String(err) };\n\t\t}\n\t}\n\n\tprivate sleep(ms: number): Promise<void> {\n\t\treturn new Promise<void>((resolve) => setTimeout(resolve, ms));\n\t}\n}\n","/**\n * Cashu Mint Class.\n *\n * @remarks\n * You should ordinarily not need to instantiate a Mint, as it will be auto-instantiated by the\n * Wallet class when you pass in the mint url.\n */\nimport type {\n\tGetInfoResponse,\n\tPartialMintQuoteResponse,\n\tMeltQuoteResponse,\n\tPartialMeltQuoteResponse,\n\tBolt12MintQuoteResponse,\n\tBolt12MeltQuoteResponse,\n\tCheckStateResponse,\n\tPostRestoreResponse,\n\tSwapResponse,\n\tCheckStatePayload,\n\tPostRestorePayload,\n\tMintResponse,\n\tApiError,\n} from './types';\nimport type { MintActiveKeys, MintAllKeysets } from '../model/types/keyset';\nimport type {\n\tMintQuotePayload,\n\tMintPayload,\n\tMeltQuotePayload,\n\tMeltPayload,\n\tSwapPayload,\n\tBolt12MintQuotePayload,\n} from '../wallet/types';\nimport { MeltQuoteState } from './types';\nimport request, {\n\tConnectionManager,\n\ttype WSConnection,\n\tsetRequestLogger,\n\ttype RequestFn,\n\ttype RequestOptions,\n} from '../transport';\nimport { isObj, joinUrls, sanitizeUrl } from '../utils';\nimport {\n\ttype MeltQuoteResponsePaidDeprecated,\n\thandleMeltQuoteResponseDeprecated,\n} from '../legacy/nut-05';\nimport {\n\ttype MintQuoteResponsePaidDeprecated,\n\thandleMintQuoteResponseDeprecated,\n} from '../legacy/nut-04';\nimport { handleMintInfoContactFieldDeprecated } from '../legacy/nut-06';\nimport { MintInfo } from '../model/MintInfo';\nimport { type Logger, NULL_LOGGER } from '../logger';\nimport type { AuthProvider } from '../auth/AuthProvider';\nimport { OIDCAuth, type OIDCAuthOptions } from '../auth/OIDCAuth';\n\n/**\n * Class represents Cashu Mint API.\n *\n * @remarks\n * This class contains lower-level functions that are implemented by Wallet.\n */\nclass Mint {\n\tprivate ws?: WSConnection;\n\tprivate _mintUrl: string;\n\tprivate _request: RequestFn;\n\tprivate _logger: Logger;\n\tprivate _mintInfo?: MintInfo;\n\tprivate _authProvider?: AuthProvider;\n\n\t/**\n\t * @param mintUrl Requires mint URL to create this object.\n\t * @param customRequest Optional, for custom network communication with the mint.\n\t * @param authTokenGetter Optional. Function to obtain a NUT-22 BlindedAuthToken (e.g. from a\n\t *   database or localstorage)\n\t */\n\tconstructor(\n\t\tmintUrl: string,\n\t\toptions?: {\n\t\t\tcustomRequest?: RequestFn;\n\t\t\tauthProvider?: AuthProvider;\n\t\t\tlogger?: Logger;\n\t\t},\n\t) {\n\t\tthis._mintUrl = sanitizeUrl(mintUrl);\n\t\tthis._request = options?.customRequest ?? request;\n\t\tthis._authProvider = options?.authProvider;\n\t\tthis._logger = options?.logger ?? NULL_LOGGER;\n\t\tsetRequestLogger(this._logger);\n\t}\n\n\tget mintUrl() {\n\t\treturn this._mintUrl;\n\t}\n\n\t/**\n\t * Create an OIDC client using this mint’s NUT-21 metadata.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const oidc = await mint.oidcAuth({ onTokens: (t) => authMgr.setCAT(t.access_token!) });\n\t * const start = await oidc.deviceStart();\n\t * // show start.user_code / start.verification_uri to the user\n\t * const token = await oidc.devicePoll(start.device_code, start.interval ?? 5);\n\t * // token.access_token is your CAT\n\t * ```\n\t */\n\tasync oidcAuth(opts?: OIDCAuthOptions): Promise<OIDCAuth> {\n\t\tconst n21 = (await this.getLazyMintInfo()).nuts['21'];\n\t\tif (!n21?.openid_discovery) {\n\t\t\tthrow new Error('Mint: no NUT-21 openid_discovery');\n\t\t}\n\t\treturn new OIDCAuth(n21.openid_discovery, {\n\t\t\t...opts,\n\t\t\tclientId: opts?.clientId ?? n21.client_id ?? 'cashu-client',\n\t\t});\n\t}\n\n\t/**\n\t * Fetches mint's info at the /info endpoint.\n\t *\n\t * @param customRequest Optional override for the request function.\n\t * @returns The mint's information response.\n\t */\n\tasync getInfo(customRequest?: RequestFn): Promise<GetInfoResponse> {\n\t\tconst requestInstance = customRequest ?? this._request;\n\t\tconst response = await requestInstance<GetInfoResponse>({\n\t\t\tendpoint: joinUrls(this._mintUrl, '/v1/info'),\n\t\t});\n\t\tconst data = handleMintInfoContactFieldDeprecated(response, this._logger);\n\t\treturn data;\n\t}\n\n\t/**\n\t * Lazily fetches and caches the mint's info if not already loaded.\n\t *\n\t * @returns The parsed MintInfo object.\n\t */\n\tasync getLazyMintInfo(): Promise<MintInfo> {\n\t\tif (this._mintInfo) {\n\t\t\treturn this._mintInfo;\n\t\t}\n\t\tconst data = await this.getInfo();\n\t\tthis._mintInfo = new MintInfo(data);\n\t\treturn this._mintInfo;\n\t}\n\n\t/**\n\t * Performs a swap operation with ecash inputs and outputs.\n\t *\n\t * @param swapPayload Payload containing inputs and outputs.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Signed outputs.\n\t */\n\tasync swap(swapPayload: SwapPayload, customRequest?: RequestFn): Promise<SwapResponse> {\n\t\tconst data = await this.requestWithAuth<SwapResponse>(\n\t\t\t'POST',\n\t\t\t'/v1/swap',\n\t\t\t{ requestBody: swapPayload },\n\t\t\tcustomRequest,\n\t\t);\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tconst errDetail = isObj(data) && 'detail' in data ? (data as ApiError).detail : undefined;\n\t\t\tthrow new Error(errDetail ?? 'bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Requests a new mint quote from the mint.\n\t *\n\t * @param mintQuotePayload Payload for creating a new mint quote.\n\t * @param customRequest Optional override for the request function.\n\t * @returns A new mint quote containing a payment request for the specified amount and unit.\n\t */\n\tasync createMintQuoteBolt11(\n\t\tmintQuotePayload: MintQuotePayload,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<PartialMintQuoteResponse> {\n\t\tconst response = await this.requestWithAuth<\n\t\t\tPartialMintQuoteResponse & MintQuoteResponsePaidDeprecated\n\t\t>('POST', '/v1/mint/quote/bolt11', { requestBody: mintQuotePayload }, customRequest);\n\t\tconst data = handleMintQuoteResponseDeprecated(response, this._logger);\n\t\treturn data;\n\t}\n\n\t/**\n\t * Requests a new BOLT12 mint quote from the mint using Lightning Network offers.\n\t *\n\t * @param mintQuotePayload Payload containing amount, unit, optional description, and required\n\t *   pubkey.\n\t * @param customRequest Optional override for the request function.\n\t * @returns A mint quote containing a BOLT12 offer.\n\t */\n\tasync createMintQuoteBolt12(\n\t\tmintQuotePayload: Bolt12MintQuotePayload,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<Bolt12MintQuoteResponse> {\n\t\tconst response = await this.requestWithAuth<Bolt12MintQuoteResponse>(\n\t\t\t'POST',\n\t\t\t'/v1/mint/quote/bolt12',\n\t\t\t{ requestBody: mintQuotePayload },\n\t\t\tcustomRequest,\n\t\t);\n\t\treturn response;\n\t}\n\n\t/**\n\t * Gets an existing mint quote from the mint.\n\t *\n\t * @param quote Quote ID.\n\t * @param customRequest Optional override for the request function.\n\t * @returns The status of the mint quote, including payment details and state.\n\t */\n\tasync checkMintQuoteBolt11(\n\t\tquote: string,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<PartialMintQuoteResponse> {\n\t\tconst response = await this.requestWithAuth<\n\t\t\tPartialMintQuoteResponse & MintQuoteResponsePaidDeprecated\n\t\t>('GET', `/v1/mint/quote/bolt11/${quote}`, {}, customRequest);\n\n\t\tconst data = handleMintQuoteResponseDeprecated(response, this._logger);\n\t\treturn data;\n\t}\n\n\t/**\n\t * Gets an existing BOLT12 mint quote from the mint.\n\t *\n\t * @param quote Quote ID to check.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Updated quote with current payment and issuance amounts.\n\t */\n\tasync checkMintQuoteBolt12(\n\t\tquote: string,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<Bolt12MintQuoteResponse> {\n\t\tconst response = await this.requestWithAuth<Bolt12MintQuoteResponse>(\n\t\t\t'GET',\n\t\t\t`/v1/mint/quote/bolt12/${quote}`,\n\t\t\t{},\n\t\t\tcustomRequest,\n\t\t);\n\t\treturn response;\n\t}\n\n\t/**\n\t * Mints new tokens by requesting blind signatures on the provided outputs.\n\t *\n\t * @param mintPayload Payload containing the outputs to get blind signatures on.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Serialized blinded signatures.\n\t */\n\tasync mintBolt11(mintPayload: MintPayload, customRequest?: RequestFn): Promise<MintResponse> {\n\t\tconst data = await this.requestWithAuth<MintResponse>(\n\t\t\t'POST',\n\t\t\t'/v1/mint/bolt11',\n\t\t\t{ requestBody: mintPayload },\n\t\t\tcustomRequest,\n\t\t);\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tconst errDetail = isObj(data) && 'detail' in data ? (data as ApiError).detail : undefined;\n\t\t\tthrow new Error(errDetail ?? 'bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Mints new tokens using a BOLT12 quote by requesting blind signatures on the provided outputs.\n\t *\n\t * @param mintPayload Payload containing the quote ID and outputs to get blind signatures on.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Serialized blinded signatures for the requested outputs.\n\t */\n\tasync mintBolt12(mintPayload: MintPayload, customRequest?: RequestFn): Promise<MintResponse> {\n\t\tconst data = await this.requestWithAuth<MintResponse>(\n\t\t\t'POST',\n\t\t\t'/v1/mint/bolt12',\n\t\t\t{ requestBody: mintPayload },\n\t\t\tcustomRequest,\n\t\t);\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tconst errDetail = isObj(data) && 'detail' in data ? (data as ApiError).detail : undefined;\n\t\t\tthrow new Error(errDetail ?? 'bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Requests a new melt quote from the mint.\n\t *\n\t * @param meltQuotePayload Payload for creating a new melt quote.\n\t * @param customRequest Optional override for the request function.\n\t * @returns The melt quote response.\n\t */\n\tasync createMeltQuoteBolt11(\n\t\tmeltQuotePayload: MeltQuotePayload,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<PartialMeltQuoteResponse> {\n\t\tconst response = await this.requestWithAuth<\n\t\t\tPartialMeltQuoteResponse & MeltQuoteResponsePaidDeprecated\n\t\t>('POST', '/v1/melt/quote/bolt11', { requestBody: meltQuotePayload }, customRequest);\n\n\t\tconst data = handleMeltQuoteResponseDeprecated(response, this._logger);\n\n\t\tif (\n\t\t\t!isObj(data) ||\n\t\t\ttypeof data?.amount !== 'number' ||\n\t\t\ttypeof data?.fee_reserve !== 'number' ||\n\t\t\ttypeof data?.quote !== 'string'\n\t\t) {\n\t\t\tconst errDetail = isObj(data) && 'detail' in data ? (data as ApiError).detail : undefined;\n\t\t\tthrow new Error(errDetail ?? 'bad response');\n\t\t}\n\t\treturn data;\n\t}\n\n\t/**\n\t * Requests a new BOLT12 melt quote from the mint for paying a Lightning Network offer. For\n\t * amount-less offers, specify the amount in options.amountless.amount_msat.\n\t *\n\t * @param meltQuotePayload Payload containing the BOLT12 offer to pay and unit.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Melt quote with amount, fee reserve, and payment state.\n\t */\n\tasync createMeltQuoteBolt12(\n\t\tmeltQuotePayload: MeltQuotePayload,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<Bolt12MeltQuoteResponse> {\n\t\tconst response = await this.requestWithAuth<Bolt12MeltQuoteResponse>(\n\t\t\t'POST',\n\t\t\t'/v1/melt/quote/bolt12',\n\t\t\t{ requestBody: meltQuotePayload },\n\t\t\tcustomRequest,\n\t\t);\n\t\treturn response;\n\t}\n\n\t/**\n\t * Gets an existing melt quote.\n\t *\n\t * @param quote Quote ID.\n\t * @param customRequest Optional override for the request function.\n\t * @returns The melt quote response.\n\t */\n\tasync checkMeltQuoteBolt11(\n\t\tquote: string,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<PartialMeltQuoteResponse> {\n\t\tconst response = await this.requestWithAuth<\n\t\t\tMeltQuoteResponse & MeltQuoteResponsePaidDeprecated\n\t\t>('GET', `/v1/melt/quote/bolt11/${quote}`, {}, customRequest);\n\n\t\tconst data = handleMeltQuoteResponseDeprecated(response, this._logger);\n\n\t\tif (\n\t\t\t!isObj(data) ||\n\t\t\ttypeof data?.amount !== 'number' ||\n\t\t\ttypeof data?.fee_reserve !== 'number' ||\n\t\t\ttypeof data?.quote !== 'string' ||\n\t\t\ttypeof data?.state !== 'string' ||\n\t\t\t!Object.values(MeltQuoteState).includes(data.state)\n\t\t) {\n\t\t\tconst errDetail = isObj(data) && 'detail' in data ? (data as ApiError).detail : undefined;\n\t\t\tthrow new Error(errDetail ?? 'bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Gets an existing BOLT12 melt quote from the mint. Returns current payment state (UNPAID,\n\t * PENDING, or PAID) and payment preimage if paid.\n\t *\n\t * @param quote Quote ID to check.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Updated quote with current payment state and preimage if available.\n\t */\n\tasync checkMeltQuoteBolt12(\n\t\tquote: string,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<Bolt12MeltQuoteResponse> {\n\t\tconst response = await this.requestWithAuth<Bolt12MeltQuoteResponse>(\n\t\t\t'GET',\n\t\t\t`/v1/melt/quote/bolt12/${quote}`,\n\t\t\t{},\n\t\t\tcustomRequest,\n\t\t);\n\t\treturn response;\n\t}\n\n\t/**\n\t * Requests the mint to pay for a Bolt11 payment request by providing ecash as inputs to be spent.\n\t * The inputs contain the amount and the fee_reserves for a Lightning payment. The payload can\n\t * also contain blank outputs in order to receive back overpaid Lightning fees.\n\t *\n\t * @param meltPayload The melt payload containing inputs and optional outputs.\n\t * @param options.customRequest Optional override for the request function.\n\t * @param options.preferAsync Optional override to set 'respond-async' header.\n\t * @returns The melt response.\n\t */\n\tasync meltBolt11(\n\t\tmeltPayload: MeltPayload,\n\t\toptions?: {\n\t\t\tcustomRequest?: RequestFn;\n\t\t\tpreferAsync?: boolean;\n\t\t},\n\t): Promise<PartialMeltQuoteResponse> {\n\t\tconst headers: Record<string, string> = {\n\t\t\t...(options?.preferAsync ? { Prefer: 'respond-async' } : {}),\n\t\t};\n\t\tconst response = await this.requestWithAuth<\n\t\t\tMeltQuoteResponse & MeltQuoteResponsePaidDeprecated\n\t\t>(\n\t\t\t'POST',\n\t\t\t'/v1/melt/bolt11',\n\t\t\t{\n\t\t\t\trequestBody: meltPayload,\n\t\t\t\theaders,\n\t\t\t},\n\t\t\toptions?.customRequest,\n\t\t);\n\n\t\tconst data = handleMeltQuoteResponseDeprecated(response, this._logger);\n\n\t\tif (\n\t\t\t!isObj(data) ||\n\t\t\ttypeof data?.state !== 'string' ||\n\t\t\t!Object.values(MeltQuoteState).includes(data.state)\n\t\t) {\n\t\t\tconst errDetail = isObj(data) && 'detail' in data ? (data as ApiError).detail : undefined;\n\t\t\tthrow new Error(errDetail ?? 'bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Requests the mint to pay a BOLT12 offer by providing ecash inputs to be spent. The inputs must\n\t * cover the amount plus fee reserves. Optional outputs can be included to receive change for\n\t * overpaid Lightning fees.\n\t *\n\t * @param meltPayload Payload containing quote ID, inputs, and optional outputs for change.\n\t * @param options.customRequest Optional override for the request function.\n\t * @param options.preferAsync Optional override to set 'respond-async' header.\n\t * @returns Payment result with state and optional change signatures.\n\t */\n\tasync meltBolt12(\n\t\tmeltPayload: MeltPayload,\n\t\toptions?: {\n\t\t\tcustomRequest?: RequestFn;\n\t\t\tpreferAsync?: boolean;\n\t\t},\n\t): Promise<Bolt12MeltQuoteResponse> {\n\t\tconst headers: Record<string, string> = {\n\t\t\t...(options?.preferAsync ? { Prefer: 'respond-async' } : {}),\n\t\t};\n\t\tconst data = await this.requestWithAuth<Bolt12MeltQuoteResponse>(\n\t\t\t'POST',\n\t\t\t'/v1/melt/bolt12',\n\t\t\t{\n\t\t\t\trequestBody: meltPayload,\n\t\t\t\theaders,\n\t\t\t},\n\t\t\toptions?.customRequest,\n\t\t);\n\t\treturn data;\n\t}\n\n\t/**\n\t * Checks if specific proofs have already been redeemed.\n\t *\n\t * @param checkPayload The payload containing proofs to check.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Redeemed and unredeemed ordered list of booleans.\n\t */\n\tasync check(\n\t\tcheckPayload: CheckStatePayload,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<CheckStateResponse> {\n\t\tconst data = await this.requestWithAuth<CheckStateResponse>(\n\t\t\t'POST',\n\t\t\t'/v1/checkstate',\n\t\t\t{ requestBody: checkPayload },\n\t\t\tcustomRequest,\n\t\t);\n\n\t\tif (!isObj(data) || !Array.isArray(data?.states)) {\n\t\t\tconst errDetail = isObj(data) && 'detail' in data ? (data as ApiError).detail : undefined;\n\t\t\tthrow new Error(errDetail ?? 'bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Get the mint's public keys.\n\t *\n\t * @param keysetId Optional param to get the keys for a specific keyset. If not specified, the\n\t *   keys from all active keysets are fetched.\n\t * @param mintUrl Optional alternative mint URL to use for this request.\n\t * @param customRequest Optional override for the request function.\n\t * @returns The mint's public keys.\n\t */\n\tasync getKeys(\n\t\tkeysetId?: string,\n\t\tmintUrl?: string,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<MintActiveKeys> {\n\t\tconst targetUrl = mintUrl || this._mintUrl;\n\t\t// backwards compatibility for base64 encoded keyset ids\n\t\tif (keysetId) {\n\t\t\t// make the keysetId url safe\n\t\t\tkeysetId = keysetId.replace(/\\//g, '_').replace(/\\+/g, '-');\n\t\t}\n\t\tconst requestInstance = customRequest ?? this._request;\n\t\tconst data = await requestInstance<MintActiveKeys>({\n\t\t\tendpoint: keysetId\n\t\t\t\t? joinUrls(targetUrl, '/v1/keys', keysetId)\n\t\t\t\t: joinUrls(targetUrl, '/v1/keys'),\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data.keysets)) {\n\t\t\tconst errDetail = isObj(data) && 'detail' in data ? (data as ApiError).detail : undefined;\n\t\t\tthrow new Error(errDetail ?? 'bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Get the mint's keysets in no specific order.\n\t *\n\t * @param customRequest Optional override for the request function.\n\t * @returns All the mint's past and current keysets.\n\t */\n\tasync getKeySets(customRequest?: RequestFn): Promise<MintAllKeysets> {\n\t\tconst requestInstance = customRequest ?? this._request;\n\t\treturn requestInstance<MintAllKeysets>({ endpoint: joinUrls(this._mintUrl, '/v1/keysets') });\n\t}\n\n\t/**\n\t * Restores proofs from the provided blinded messages.\n\t *\n\t * @param restorePayload The payload containing outputs to restore.\n\t * @param customRequest Optional override for the request function.\n\t * @returns The restore response with outputs and signatures.\n\t */\n\tasync restore(\n\t\trestorePayload: PostRestorePayload,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<PostRestoreResponse> {\n\t\tconst requestInstance = customRequest ?? this._request;\n\t\tconst data = await requestInstance<PostRestoreResponse>({\n\t\t\tendpoint: joinUrls(this._mintUrl, '/v1/restore'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: restorePayload,\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.outputs) || !Array.isArray(data?.signatures)) {\n\t\t\tconst errDetail = isObj(data) && 'detail' in data ? (data as ApiError).detail : undefined;\n\t\t\tthrow new Error(errDetail ?? 'bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Tries to establish a websocket connection with the websocket mint url according to NUT-17.\n\t */\n\tasync connectWebSocket() {\n\t\tif (this.ws) {\n\t\t\tawait this.ws.ensureConnection();\n\t\t} else {\n\t\t\tconst mintUrl = new URL(this._mintUrl);\n\t\t\tconst wsSegment = 'v1/ws';\n\t\t\tif (mintUrl.pathname) {\n\t\t\t\tif (mintUrl.pathname.endsWith('/')) {\n\t\t\t\t\tmintUrl.pathname += wsSegment;\n\t\t\t\t} else {\n\t\t\t\t\tmintUrl.pathname += '/' + wsSegment;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.ws = ConnectionManager.getInstance().getConnection(\n\t\t\t\t`${mintUrl.protocol === 'https:' ? 'wss' : 'ws'}://${mintUrl.host}${mintUrl.pathname}`,\n\t\t\t);\n\t\t\ttry {\n\t\t\t\tawait this.ws.connect();\n\t\t\t} catch (e) {\n\t\t\t\tthis._logger.error('Failed to connect to WebSocket...', { e });\n\t\t\t\tthrow new Error('Failed to connect to WebSocket...');\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Closes a websocket connection.\n\t */\n\tdisconnectWebSocket() {\n\t\tif (this.ws) {\n\t\t\tthis.ws.close();\n\t\t}\n\t}\n\n\tget webSocketConnection() {\n\t\treturn this.ws;\n\t}\n\n\t/**\n\t * Returns the Clear Authentication Token (CAT) to use in the 'Clear-auth' header, or undefined if\n\t * not required for the given path and method.\n\t *\n\t * @param method The method to call on the path.\n\t * @param path The API path to check for blind auth requirement.\n\t * @returns The blind auth token if required, otherwise undefined.\n\t */\n\tprivate async handleClearAuth(method: 'GET' | 'POST', path: string): Promise<string | undefined> {\n\t\tif (!this._authProvider) return undefined;\n\t\tconst info = await this.getLazyMintInfo();\n\t\tif (!info.requiresClearAuthToken(method, path)) return undefined;\n\t\tthis._logger.error('Clear Authentication Token...', { cat: this._authProvider.getCAT() });\n\t\treturn this._authProvider.getCAT();\n\t}\n\n\t/**\n\t * Returns a serialized Blind Authentication Token (BAT) to use in the 'Blind-auth' header, or\n\t * undefined if not required for the given path and method.\n\t *\n\t * @param method The method to call on the path.\n\t * @param path The API path to check for blind auth requirement.\n\t * @returns The blind auth token if required, otherwise undefined.\n\t */\n\tprivate async handleBlindAuth(method: 'GET' | 'POST', path: string): Promise<string | undefined> {\n\t\tif (!this._authProvider) return undefined;\n\t\tconst info = await this.getLazyMintInfo();\n\t\tif (!info.requiresBlindAuthToken(method, path)) return undefined;\n\t\tconst bat = await this._authProvider.getBlindAuthToken({ method, path });\n\t\tthis._logger.error('Blind Authentication Token...', { bat });\n\t\treturn bat;\n\t}\n\n\tprivate async requestWithAuth<T>(\n\t\tmethod: 'GET' | 'POST',\n\t\tpath: string,\n\t\tinit: Omit<RequestOptions, 'endpoint' | 'method' | 'headers' | 'requestBody'> & {\n\t\t\trequestBody?: Record<string, unknown>;\n\t\t\theaders?: Record<string, string>;\n\t\t} = {},\n\t\tcustomRequest?: RequestFn,\n\t): Promise<T> {\n\t\tconst requestInstance = customRequest ?? this._request;\n\t\t// Get BAT/CAT token if this endpoint is protected\n\t\tconst bat = await this.handleBlindAuth(method, path);\n\t\tconst cat = await this.handleClearAuth(method, path);\n\t\tconst headers: Record<string, string> = {\n\t\t\t...(init.headers ?? {}),\n\t\t\t...(bat ? { 'Blind-auth': bat } : {}),\n\t\t\t...(cat ? { 'Clear-auth': cat } : {}),\n\t\t};\n\t\treturn requestInstance<T>({\n\t\t\t...init,\n\t\t\tendpoint: joinUrls(this._mintUrl, path),\n\t\t\tmethod,\n\t\t\theaders,\n\t\t});\n\t}\n}\n\nexport { Mint };\n","import { isValidHex, deriveKeysetId } from '../utils';\nimport { type MintKeyset, type MintKeys } from '../model/types';\nimport { hexToBytes } from '@noble/curves/utils';\n\nexport class Keyset {\n\tprivate _id: string;\n\tprivate _unit: string;\n\tprivate _active: boolean;\n\tprivate _keys: Record<number, string> = {};\n\tprivate _input_fee_ppk?: number;\n\tprivate _final_expiry?: number;\n\n\tconstructor(\n\t\tid: string,\n\t\tunit: string,\n\t\tactive: boolean,\n\t\tinput_fee_ppk?: number,\n\t\tfinal_expiry?: number,\n\t) {\n\t\tthis._id = id;\n\t\tthis._unit = unit;\n\t\tthis._active = active;\n\t\tthis._input_fee_ppk = input_fee_ppk;\n\t\tthis._final_expiry = final_expiry;\n\t}\n\n\tget id(): string {\n\t\treturn this._id;\n\t}\n\n\tget unit(): string {\n\t\treturn this._unit;\n\t}\n\n\tget isActive(): boolean {\n\t\treturn this._active;\n\t}\n\n\tget fee(): number {\n\t\treturn this._input_fee_ppk ?? 0;\n\t}\n\n\tget expiry(): number | undefined {\n\t\treturn this._final_expiry;\n\t}\n\n\tget hasKeys(): boolean {\n\t\treturn Object.keys(this._keys).length > 0;\n\t}\n\n\tget hasHexId(): boolean {\n\t\treturn isValidHex(this._id);\n\t}\n\n\tget keys(): Record<number, string> {\n\t\treturn this._keys;\n\t}\n\n\tset keys(keys: Record<number, string>) {\n\t\tthis._keys = keys;\n\t}\n\n\t/**\n\t * For compat with v2 MintKeyset type.\n\t */\n\tget active(): boolean {\n\t\treturn this._active;\n\t}\n\n\t/**\n\t * For compat with v2 MintKeyset type.\n\t */\n\tget input_fee_ppk(): number {\n\t\treturn this._input_fee_ppk ?? 0;\n\t}\n\n\t/**\n\t * For compat with v2 MintKeyset type.\n\t */\n\tget final_expiry(): number | undefined {\n\t\treturn this._final_expiry;\n\t}\n\n\t/**\n\t * To Mint API MintKeyset format.\n\t *\n\t * @returns MintKeyset object.\n\t */\n\ttoMintKeyset(): MintKeyset {\n\t\treturn {\n\t\t\tid: this._id,\n\t\t\tunit: this._unit,\n\t\t\tactive: this._active,\n\t\t\tinput_fee_ppk: this._input_fee_ppk,\n\t\t\tfinal_expiry: this._final_expiry,\n\t\t};\n\t}\n\n\t/**\n\t * To Mint API MintKeys format.\n\t *\n\t * @returns MintKeys object.\n\t */\n\ttoMintKeys(): MintKeys | null {\n\t\tif (!this.hasKeys) {\n\t\t\treturn null;\n\t\t}\n\t\treturn {\n\t\t\tid: this._id,\n\t\t\tunit: this._unit,\n\t\t\tkeys: this._keys,\n\t\t};\n\t}\n\n\t/**\n\t * Verifies that the keyset's ID matches the derived ID from its keys, unit, and expiry.\n\t *\n\t * @returns True if verification succeeds, false otherwise (e.g., no keys or mismatch).\n\t */\n\tverify(): boolean {\n\t\tif (!this.hasKeys) {\n\t\t\treturn false;\n\t\t}\n\t\tconst versionByte = hexToBytes(this._id)[0];\n\t\tconst derivedId = deriveKeysetId(this._keys, this._unit, this._final_expiry, versionByte);\n\t\treturn derivedId === this._id;\n\t}\n}\n","import { Keyset } from './Keyset';\nimport { Mint } from '../mint';\nimport type { MintKeyset, MintKeys, MintAllKeysets, MintActiveKeys } from '../model/types/keyset';\n\n/**\n * Manages the unit-specific keysets for a Mint.\n *\n * @remarks\n * Will ONLY load keysets in the Keychain unit.\n */\nexport class KeyChain {\n\tprivate mint: Mint;\n\tprivate unit: string;\n\tprivate keysets: { [id: string]: Keyset } = {};\n\n\tconstructor(\n\t\tmint: string | Mint,\n\t\tunit: string,\n\t\tcachedKeysets?: MintKeyset[],\n\t\tcachedKeys?: MintKeys[] | MintKeys,\n\t) {\n\t\tthis.mint = typeof mint === 'string' ? new Mint(mint) : mint;\n\t\tthis.unit = unit;\n\t\tif (cachedKeysets && cachedKeys) {\n\t\t\t// Normalize and preload if both are provided\n\t\t\tconst arrayOfKeys = Array.isArray(cachedKeys) ? cachedKeys : [cachedKeys];\n\t\t\tthis.buildKeychain(cachedKeysets, arrayOfKeys);\n\t\t}\n\t}\n\n\t/**\n\t * Single entry point to load or refresh keysets and keys for the unit.\n\t *\n\t * @remarks\n\t * Fetches in parallel, filters by unit, assigns keys.\n\t * @param forceRefresh If true, refetch even if loaded.\n\t */\n\tasync init(forceRefresh?: boolean): Promise<void> {\n\t\t// Skip if already loaded, unless force\n\t\tif (Object.keys(this.keysets).length > 0 && !forceRefresh) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fetch keys and keysets in parallel\n\t\tconst [allKeysetsResponse, allKeysResponse]: [MintAllKeysets, MintActiveKeys] =\n\t\t\tawait Promise.all([this.mint.getKeySets(), this.mint.getKeys()]);\n\n\t\tthis.buildKeychain(allKeysetsResponse.keysets, allKeysResponse.keysets);\n\n\t\t// Smoke test (will throw if init was unsuccessful)\n\t\tthis.getCheapestKeyset();\n\t}\n\n\t/**\n\t * Builds keychain from Mint Keyset and Keys data.\n\t *\n\t * @param allKeysets Keyset data from mint.getKeySets() API.\n\t * @param allKeys Keys data from mint.getKeys() API.\n\t */\n\tprivate buildKeychain(allKeysets: MintKeyset[], allKeys: MintKeys[]): void {\n\t\t// Clear existing keysets to avoid stale data\n\t\tthis.keysets = {};\n\n\t\t// Filter and create Keysets for unit\n\t\tconst unitKeysets = allKeysets.filter((k: MintKeyset) => k.unit === this.unit);\n\t\tunitKeysets.forEach((k: MintKeyset) => {\n\t\t\tthis.keysets[k.id] = new Keyset(k.id, k.unit, k.active, k.input_fee_ppk, k.final_expiry);\n\t\t});\n\n\t\t// Create map of keys filtered by unit for fast lookup\n\t\tconst keysMap = new Map<string, MintKeys>(\n\t\t\tallKeys.filter((k) => k.unit === this.unit).map((k) => [k.id, k]),\n\t\t);\n\n\t\t// Assign keys and validate active hex keysets\n\t\t// Note: Non-hex and inactive keysets should not have keys\n\t\tObject.values(this.keysets).forEach((keyset) => {\n\t\t\tif (!keyset.hasHexId || !keyset.isActive) return;\n\t\t\tconst mk = keysMap.get(keyset.id);\n\t\t\tif (mk) {\n\t\t\t\tkeyset.keys = mk.keys;\n\t\t\t\tif (!keyset.verify()) {\n\t\t\t\t\tthrow new Error(`Keyset verification failed for ID ${keyset.id}`);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Get a keyset by ID or the cheapest keyset if no ID is provided.\n\t *\n\t * @param id Optional keyset ID.\n\t * @returns Keyset with keys.\n\t * @throws If keyset not found or uninitialized.\n\t */\n\tgetKeyset(id?: string): Keyset {\n\t\tconst keyset = id ? this.keysets[id] : this.getCheapestKeyset();\n\t\tif (!keyset) {\n\t\t\tthrow new Error(`Keyset '${id}' not found`);\n\t\t}\n\t\treturn keyset;\n\t}\n\n\t/**\n\t * Get the cheapest active keyset.\n\t *\n\t * @remarks\n\t * Selects active keyset with lowest fee and hex ID.\n\t * @returns Active Keyset.\n\t * @throws If none found or uninitialized.\n\t */\n\tgetCheapestKeyset(): Keyset {\n\t\tif (Object.keys(this.keysets).length === 0) {\n\t\t\tthrow new Error('KeyChain not initialized');\n\t\t}\n\t\tconst activeKeysets = Object.values(this.keysets).filter(\n\t\t\t(k) => k.isActive && k.hasHexId && k.hasKeys,\n\t\t);\n\t\tif (activeKeysets.length === 0) {\n\t\t\tthrow new Error('No active keyset found');\n\t\t}\n\t\treturn activeKeysets.sort((a, b) => a.fee - b.fee)[0];\n\t}\n\n\t/**\n\t * Get list of all keysets for the unit.\n\t *\n\t * @returns Array of Keysets.\n\t * @throws If uninitialized.\n\t */\n\tgetKeysets(): Keyset[] {\n\t\tif (Object.keys(this.keysets).length === 0) {\n\t\t\tthrow new Error('KeyChain not initialized');\n\t\t}\n\t\treturn Object.values(this.keysets);\n\t}\n\n\t/**\n\t * Extract the Mint API data from the keychain.\n\t *\n\t * @remarks\n\t * Useful for instantiating new wallets / keychains without repeatedly calling the mint API.\n\t */\n\tgetCache(): {\n\t\tkeysets: MintKeyset[];\n\t\tkeys: MintKeys[];\n\t\tunit: string;\n\t\tmintUrl: string;\n\t} {\n\t\tconst allKeysets = this.getKeysets();\n\t\tconst allKeys = allKeysets\n\t\t\t.filter((k) => k.hasKeys)\n\t\t\t.map((k) => k.toMintKeys())\n\t\t\t.filter((mk): mk is MintKeys => mk !== null);\n\t\treturn {\n\t\t\tkeysets: allKeysets.map((k) => k.toMintKeyset()),\n\t\t\tkeys: allKeys,\n\t\t\tunit: this.unit,\n\t\t\tmintUrl: this.mint.mintUrl,\n\t\t};\n\t}\n}\n","import { type SerializedBlindedMessage } from './types/index';\nimport { type WeierstrassPoint } from '@noble/curves/abstract/weierstrass';\n\nclass BlindedMessage {\n\tamount: number;\n\tB_: WeierstrassPoint<bigint>;\n\tid: string;\n\tconstructor(amount: number, B_: WeierstrassPoint<bigint>, id: string) {\n\t\tthis.amount = amount;\n\t\tthis.B_ = B_;\n\t\tthis.id = id;\n\t}\n\tgetSerializedBlindedMessage(): SerializedBlindedMessage {\n\t\treturn { amount: this.amount, B_: this.B_.toHex(true), id: this.id };\n\t}\n}\nexport { BlindedMessage };\n","import {\n\ttype MintKeys,\n\ttype Proof,\n\ttype SerializedBlindedMessage,\n\ttype SerializedBlindedSignature,\n\ttype SerializedDLEQ,\n} from './types';\nimport { type P2PKOptions, type Keyset } from '../wallet';\nimport {\n\tblindMessage,\n\tconstructProofFromPromise,\n\tderiveP2BKBlindedPubkeys,\n\tderiveBlindingFactor,\n\tderiveSecret,\n\tpointFromHex,\n\tserializeProof,\n\ttype DLEQ,\n} from '../crypto';\nimport { BlindedMessage } from './BlindedMessage';\nimport { bytesToHex, hexToBytes, randomBytes } from '@noble/hashes/utils';\nimport { bytesToNumber, numberToHexPadded64, splitAmount } from '../utils';\n\nexport interface OutputDataLike {\n\tblindedMessage: SerializedBlindedMessage;\n\tblindingFactor: bigint;\n\tsecret: Uint8Array;\n\n\ttoProof: (signature: SerializedBlindedSignature, keyset: MintKeys | Keyset) => Proof;\n}\n\nexport type OutputDataFactory = (amount: number, keys: MintKeys | Keyset) => OutputDataLike;\n\n/**\n * Core P2PK tags that must not be settable in additional tags.\n *\n * @internal\n */\nexport const RESERVED_P2PK_TAGS = new Set([\n\t'locktime',\n\t'pubkeys',\n\t'n_sigs',\n\t'refund',\n\t'n_sigs_refund',\n]);\n\n/**\n * Asserts P2PK Tag key is valid.\n *\n * @param key Tag Key.\n * @throws If not a string, or is a reserved string.\n */\nexport function assertValidTagKey(key: string) {\n\tif (!key || typeof key !== 'string') throw new Error('tag key must be a non empty string');\n\tif (RESERVED_P2PK_TAGS.has(key)) {\n\t\tthrow new Error(`additionalTags must not use reserved key \"${key}\"`);\n\t}\n}\n\n/**\n * Maximum secret length.\n *\n * @remarks\n * Based on the Nutshell default mint_max_secret_length.\n * @internal\n */\nexport const MAX_SECRET_LENGTH = 1024;\n\nexport function isOutputDataFactory(\n\tvalue: OutputData[] | OutputDataFactory,\n): value is OutputDataFactory {\n\treturn typeof value === 'function';\n}\n\n// Holds the map of Pubkey blinding factors for a given OutputData\n// This avoids changing the shape of the OutputDataLike interface\nconst EPHEMERAL_E = new WeakMap<OutputData, string>(); // one-shot\nfunction setEphemeralE(target: OutputData, Ehex?: string) {\n\tif (Ehex) EPHEMERAL_E.set(target, Ehex);\n}\nfunction takeEphemeralE(target: OutputData): string | undefined {\n\tconst e = EPHEMERAL_E.get(target);\n\tif (!e) return;\n\tEPHEMERAL_E.delete(target); // one-shot to avoid leakage\n\treturn e;\n}\n\nexport class OutputData implements OutputDataLike {\n\tblindedMessage: SerializedBlindedMessage;\n\tblindingFactor: bigint;\n\tsecret: Uint8Array;\n\n\tconstructor(\n\t\tblindedMessage: SerializedBlindedMessage,\n\t\tblindingFactor: bigint,\n\t\tsecret: Uint8Array,\n\t) {\n\t\tthis.secret = secret;\n\t\tthis.blindingFactor = blindingFactor;\n\t\tthis.blindedMessage = blindedMessage;\n\t}\n\n\ttoProof(sig: SerializedBlindedSignature, keyset: MintKeys | Keyset) {\n\t\tlet dleq: DLEQ | undefined;\n\t\tif (sig.dleq) {\n\t\t\tdleq = {\n\t\t\t\ts: hexToBytes(sig.dleq.s),\n\t\t\t\te: hexToBytes(sig.dleq.e),\n\t\t\t\tr: this.blindingFactor,\n\t\t\t};\n\t\t}\n\t\tconst blindSignature = {\n\t\t\tid: sig.id,\n\t\t\tamount: sig.amount,\n\t\t\tC_: pointFromHex(sig.C_),\n\t\t\tdleq: dleq,\n\t\t};\n\t\tconst A = pointFromHex(keyset.keys[sig.amount]);\n\t\tconst proof = constructProofFromPromise(blindSignature, this.blindingFactor, this.secret, A);\n\t\tconst serializedProof = {\n\t\t\t...serializeProof(proof),\n\t\t\t...(dleq && {\n\t\t\t\tdleq: {\n\t\t\t\t\ts: bytesToHex(dleq.s),\n\t\t\t\t\te: bytesToHex(dleq.e),\n\t\t\t\t\tr: numberToHexPadded64(dleq.r ?? BigInt(0)),\n\t\t\t\t} as SerializedDLEQ,\n\t\t\t}),\n\t\t} as Proof;\n\n\t\t// Add P2BK (Pay to Blinded Key) blinding factors if needed\n\t\tconst Ehex = takeEphemeralE(this);\n\t\tif (Ehex) serializedProof.p2pk_e = Ehex;\n\n\t\treturn serializedProof;\n\t}\n\n\tstatic createP2PKData(\n\t\tp2pk: P2PKOptions,\n\t\tamount: number,\n\t\tkeyset: MintKeys | Keyset,\n\t\tcustomSplit?: number[],\n\t) {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a) => this.createSingleP2PKData(p2pk, a, keyset.id));\n\t}\n\n\tstatic createSingleP2PKData(p2pk: P2PKOptions, amount: number, keysetId: string) {\n\t\t// normalise keys and clamp required signature counts to available keys\n\t\tconst lockKeys: string[] = Array.isArray(p2pk.pubkey) ? p2pk.pubkey : [p2pk.pubkey];\n\t\tconst refundKeys: string[] = p2pk.refundKeys ?? [];\n\t\tconst reqLock = Math.max(1, Math.min(p2pk.requiredSignatures ?? 1, lockKeys.length));\n\t\tconst reqRefund = Math.max(\n\t\t\t1,\n\t\t\tMath.min(p2pk.requiredRefundSignatures ?? 1, refundKeys.length || 1),\n\t\t);\n\n\t\t// Init vars\n\t\tlet data = lockKeys[0];\n\t\tlet pubkeys = lockKeys.slice(1);\n\t\tlet refund = refundKeys;\n\n\t\t// Optional key blinding (P2BK)\n\t\tlet Ehex: string | undefined;\n\t\tif (p2pk.blindKeys) {\n\t\t\tconst ordered = [data, ...pubkeys, ...refundKeys];\n\t\t\tconst { blinded, Ehex: _E } = deriveP2BKBlindedPubkeys(ordered, keysetId);\n\t\t\tdata = blinded[0];\n\t\t\tpubkeys = blinded.slice(1, lockKeys.length);\n\t\t\trefund = blinded.slice(lockKeys.length);\n\t\t\tEhex = _E;\n\t\t}\n\n\t\t// build P2PK Tags (NUT-11)\n\t\tconst tags: string[][] = [];\n\n\t\tconst ts = p2pk.locktime ?? NaN;\n\t\tif (Number.isSafeInteger(ts) && ts >= 0) {\n\t\t\ttags.push(['locktime', String(ts)]);\n\t\t}\n\n\t\tif (pubkeys.length > 0) {\n\t\t\ttags.push(['pubkeys', ...pubkeys]);\n\t\t\tif (reqLock > 1) {\n\t\t\t\ttags.push(['n_sigs', String(reqLock)]);\n\t\t\t}\n\t\t}\n\n\t\tif (refund.length > 0) {\n\t\t\ttags.push(['refund', ...refund]);\n\t\t\tif (reqRefund > 1) {\n\t\t\t\ttags.push(['n_sigs_refund', String(reqRefund)]);\n\t\t\t}\n\t\t}\n\n\t\t// Append additional tags if any\n\t\tif (p2pk.additionalTags?.length) {\n\t\t\tconst normalized = p2pk.additionalTags.map(([k, ...vals]) => {\n\t\t\t\tassertValidTagKey(k); // Validate key\n\t\t\t\treturn [k, ...vals.map(String)]; // all to strings\n\t\t\t});\n\t\t\ttags.push(...normalized);\n\t\t}\n\n\t\t// Construct secret\n\t\tconst newSecret: [string, { nonce: string; data: string; tags: string[][] }] = [\n\t\t\t'P2PK',\n\t\t\t{\n\t\t\t\tnonce: bytesToHex(randomBytes(32)),\n\t\t\t\tdata: data,\n\t\t\t\ttags,\n\t\t\t},\n\t\t];\n\n\t\t// blind the message\n\t\tconst parsed = JSON.stringify(newSecret);\n\n\t\t// Check secret length, counting Unicode code points\n\t\t// Same semantics as Nutshell python: len(str)\n\t\tconst charCount = [...parsed].length;\n\t\tif (charCount > MAX_SECRET_LENGTH) {\n\t\t\tthrow new Error(`Secret too long (${charCount} characters), maximum is ${MAX_SECRET_LENGTH}`);\n\t\t}\n\t\t// blind the message\n\t\tconst secretBytes = new TextEncoder().encode(parsed);\n\t\tconst { r, B_ } = blindMessage(secretBytes);\n\n\t\t// create OutputData\n\t\tconst od = new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tsecretBytes,\n\t\t);\n\n\t\t// stash Ehex - we add it to Proof later @see: toProof()\n\t\tif (p2pk.blindKeys && Ehex) setEphemeralE(od, Ehex);\n\n\t\treturn od;\n\t}\n\n\tstatic createRandomData(amount: number, keyset: MintKeys | Keyset, customSplit?: number[]) {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a) => this.createSingleRandomData(a, keyset.id));\n\t}\n\n\tstatic createSingleRandomData(amount: number, keysetId: string) {\n\t\tconst randomHex = bytesToHex(randomBytes(32));\n\t\tconst secretBytes = new TextEncoder().encode(randomHex);\n\t\tconst { r, B_ } = blindMessage(secretBytes);\n\t\treturn new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tsecretBytes,\n\t\t);\n\t}\n\n\tstatic createDeterministicData(\n\t\tamount: number,\n\t\tseed: Uint8Array,\n\t\tcounter: number,\n\t\tkeyset: MintKeys | Keyset,\n\t\tcustomSplit?: number[],\n\t): OutputData[] {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a, i) =>\n\t\t\tthis.createSingleDeterministicData(a, seed, counter + i, keyset.id),\n\t\t);\n\t}\n\n\tstatic createSingleDeterministicData(\n\t\tamount: number,\n\t\tseed: Uint8Array,\n\t\tcounter: number,\n\t\tkeysetId: string,\n\t) {\n\t\tconst secretBytes = deriveSecret(seed, keysetId, counter);\n\t\tconst secretBytesAsHex = bytesToHex(secretBytes);\n\t\tconst utf8SecretBytes = new TextEncoder().encode(secretBytesAsHex);\n\t\tconst deterministicR = bytesToNumber(deriveBlindingFactor(seed, keysetId, counter));\n\t\tconst { r, B_ } = blindMessage(utf8SecretBytes, deterministicR);\n\t\treturn new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tutf8SecretBytes,\n\t\t);\n\t}\n\n\t/**\n\t * Calculates the sum of amounts in an array of OutputDataLike objects.\n\t *\n\t * @param outputs Array of OutputDataLike objects.\n\t * @returns The total sum of amounts.\n\t */\n\tstatic sumOutputAmounts(outputs: OutputDataLike[]): number {\n\t\treturn outputs.reduce((sum, output) => sum + output.blindedMessage.amount, 0);\n\t}\n}\n","import { assertValidTagKey, OutputData } from '../model/OutputData';\nimport { type P2PKOptions, type P2PKTag } from './types/config';\n\n// Accept 33 byte compressed (02|03...), or 32 byte x-only,\n// normalised to lowercase 33 byte with 02 prefix for x only\nfunction normalisePubkey(pk: string): string {\n\tconst hex = pk.toLowerCase();\n\tif (hex.length === 66 && (hex.startsWith('02') || hex.startsWith('03'))) return hex;\n\tif (hex.length === 64) return `02${hex}`;\n\tthrow new Error(\n\t\t`Invalid pubkey, expected 33 byte compressed or 32 byte x only, got length ${hex.length}`,\n\t);\n}\n\nfunction toUnixSeconds(input: Date | number): number {\n\tif (input instanceof Date) return Math.floor(input.getTime() / 1000);\n\treturn input < 1e12 ? Math.floor(input) : Math.floor(input / 1000); // > 1e12 = ms\n}\n\nexport class P2PKBuilder {\n\t// A Set enforces uniqueness and preserves insertion order, which means\n\t// the first added lock key also becomes primary (data) pubkey\n\tprivate lockSet = new Set<string>();\n\tprivate refundSet = new Set<string>();\n\tprivate locktime?: number;\n\tprivate nSigs?: number;\n\tprivate nSigsRefund?: number;\n\tprivate extraTags: P2PKTag[] = [];\n\tprivate _blindKeys?: boolean;\n\n\taddLockPubkey(pk: string | string[]) {\n\t\tconst arr = Array.isArray(pk) ? pk : [pk];\n\t\tfor (const k of arr) this.lockSet.add(normalisePubkey(k));\n\t\treturn this;\n\t}\n\n\taddRefundPubkey(pk: string | string[]) {\n\t\tconst arr = Array.isArray(pk) ? pk : [pk];\n\t\tfor (const k of arr) this.refundSet.add(normalisePubkey(k));\n\t\treturn this;\n\t}\n\n\tlockUntil(when: Date | number) {\n\t\tthis.locktime = toUnixSeconds(when);\n\t\treturn this;\n\t}\n\n\trequireLockSignatures(n: number) {\n\t\tthis.nSigs = Math.max(1, Math.trunc(n));\n\t\treturn this;\n\t}\n\n\trequireRefundSignatures(n: number) {\n\t\tthis.nSigsRefund = Math.max(1, Math.trunc(n));\n\t\treturn this;\n\t}\n\n\taddTag(key: string, values?: string[] | string) {\n\t\tassertValidTagKey(key); //  Validate key\n\t\tconst vals = values === undefined ? [] : Array.isArray(values) ? values : [values];\n\t\tthis.extraTags.push([key, ...vals.map(String)]); // all to strings\n\t\treturn this;\n\t}\n\n\taddTags(tags: P2PKTag[]) {\n\t\tfor (const [k, ...vals] of tags) this.addTag(k, vals);\n\t\treturn this;\n\t}\n\t/**\n\t * @alpha\n\t */\n\tblindKeys() {\n\t\tthis._blindKeys = true;\n\t\treturn this;\n\t}\n\n\ttoOptions(): P2PKOptions {\n\t\tconst locks = Array.from(this.lockSet);\n\t\tconst refunds = Array.from(this.refundSet);\n\n\t\tif (locks.length === 0) throw new Error('At least one lock pubkey is required');\n\t\tif (refunds.length > 0 && this.locktime === undefined) {\n\t\t\tthrow new Error(\n\t\t\t\t'Refund pubkeys require a locktime, add lockUntil(...) or remove refund keys',\n\t\t\t);\n\t\t}\n\n\t\tconst total = locks.length + refunds.length;\n\t\tif (total > 10)\n\t\t\tthrow new Error(`Too many pubkeys, ${total} provided, maximum allowed is 10 in total`);\n\n\t\t// Clamp required signatures to available keys\n\t\tconst reqLock = this.nSigs ? Math.min(Math.max(1, this.nSigs), locks.length) : undefined;\n\t\tconst reqRefund = this.nSigsRefund\n\t\t\t? Math.min(Math.max(1, this.nSigsRefund), Math.max(1, refunds.length))\n\t\t\t: undefined;\n\n\t\tconst pubkey: string | string[] = locks.length === 1 ? locks[0] : locks;\n\n\t\tconst p2pk: P2PKOptions = {\n\t\t\tpubkey,\n\t\t\t...(this.locktime !== undefined ? { locktime: this.locktime } : {}),\n\t\t\t...(refunds.length ? { refundKeys: refunds } : {}),\n\t\t\t...(reqLock && reqLock > 1 ? { requiredSignatures: reqLock } : {}),\n\t\t\t...(reqRefund && reqRefund > 1 ? { requiredRefundSignatures: reqRefund } : {}),\n\t\t\t...(this.extraTags.length ? { additionalTags: this.extraTags.slice() } : {}),\n\t\t\t...(this._blindKeys ? { blindKeys: true } : {}),\n\t\t};\n\n\t\t// Ensure the secret is valid (not too long etc)\n\t\tconst smokeTest = OutputData.createSingleP2PKData(p2pk, 1, 'deedbeef');\n\t\tvoid smokeTest; // intentionally unused\n\n\t\treturn p2pk;\n\t}\n\n\tstatic fromOptions(opts: P2PKOptions): P2PKBuilder {\n\t\tconst b = new P2PKBuilder();\n\t\tconst locks = Array.isArray(opts.pubkey) ? opts.pubkey : [opts.pubkey];\n\t\tb.addLockPubkey(locks);\n\t\tif (opts.locktime !== undefined) b.lockUntil(opts.locktime);\n\t\tif (opts.refundKeys?.length) b.addRefundPubkey(opts.refundKeys);\n\t\tif (opts.requiredSignatures !== undefined) b.requireLockSignatures(opts.requiredSignatures);\n\t\tif (opts.requiredRefundSignatures !== undefined)\n\t\t\tb.requireRefundSignatures(opts.requiredRefundSignatures);\n\t\tif (opts.additionalTags?.length) b.addTags(opts.additionalTags);\n\t\tif (opts.blindKeys) b.blindKeys();\n\t\treturn b;\n\t}\n}\n","// Minimal types to avoid importing the whole wallet, keeps this module independent\nimport type { Proof } from '../model/types/proof';\nimport { fail, failIf, failIfNullish, type Logger, NULL_LOGGER, measureTime } from '../logger';\nimport { type SendResponse } from './types';\nimport { type KeyChain } from './KeyChain';\n\nexport type SelectProofs = (\n\tproofs: Proof[],\n\tamountToSend: number,\n\tkeyChain: KeyChain,\n\tincludeFees?: boolean,\n\texactMatch?: boolean,\n\tlogger?: Logger,\n) => SendResponse;\n\nexport const selectProofsRGLI: SelectProofs = (\n\tproofs: Proof[],\n\tamountToSend: number,\n\tkeyChain: KeyChain,\n\tincludeFees: boolean = false,\n\texactMatch: boolean = false,\n\t_logger: Logger = NULL_LOGGER,\n): SendResponse => {\n\t// Init vars\n\tconst MAX_TRIALS = 60; // 40-80 is optimal (per RGLI paper)\n\tconst MAX_OVRPCT = 0; // Acceptable close match overage (percent)\n\tconst MAX_OVRAMT = 0; // Acceptable close match overage (absolute)\n\tconst MAX_TIMEMS = 1000; // Halt new trials if over time (in ms)\n\tconst MAX_P2SWAP = 5000; // Max number of Phase 2 improvement swaps\n\tconst timer = measureTime(); // start the clock\n\tlet bestSubset: ProofWithFee[] | null = null;\n\tlet bestDelta = Infinity;\n\tlet bestAmount = 0;\n\tlet bestFeePPK = 0;\n\n\t/**\n\t * Helper Functions.\n\t */\n\tinterface ProofWithFee {\n\t\tproof: Proof;\n\t\texFee: number;\n\t\tppkfee: number;\n\t}\n\t// Looks up fee for a proof\n\tconst feeForProof = (proof: Proof): number => {\n\t\ttry {\n\t\t\treturn keyChain.getKeyset(proof.id).fee;\n\t\t} catch (e) {\n\t\t\tfail(`Could not get fee. No keyset found for keyset id: ${proof.id}`, _logger, {\n\t\t\t\terror: e,\n\t\t\t\tkeychain: keyChain.getKeysets(),\n\t\t\t});\n\t\t}\n\t};\n\t// Calculate net amount after fees\n\tconst sumExFees = (amount: number, feePPK: number): number => {\n\t\treturn amount - (includeFees ? Math.ceil(feePPK / 1000) : 0);\n\t};\n\t// Shuffle array for randomization\n\tconst shuffleArray = <T>(array: T[]): T[] => {\n\t\tconst shuffled = [...array];\n\t\tfor (let i = shuffled.length - 1; i > 0; i--) {\n\t\t\tconst j = Math.floor(Math.random() * (i + 1));\n\t\t\t[shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n\t\t}\n\t\treturn shuffled;\n\t};\n\t// Performs a binary search on a sorted (ascending) array of ProofWithFee objects by exFee.\n\t// If lessOrEqual=true, returns the rightmost index where exFee <= value\n\t// If lessOrEqual=false, returns the leftmost index where exFee >= value\n\tconst binarySearchIndex = (\n\t\tarr: ProofWithFee[],\n\t\tvalue: number,\n\t\tlessOrEqual: boolean,\n\t): number | null => {\n\t\tlet left = 0,\n\t\t\tright = arr.length - 1,\n\t\t\tresult: number | null = null;\n\t\twhile (left <= right) {\n\t\t\tconst mid = Math.floor((left + right) / 2);\n\t\t\tconst midValue = arr[mid].exFee;\n\t\t\tif (lessOrEqual ? midValue <= value : midValue >= value) {\n\t\t\t\tresult = mid;\n\t\t\t\tif (lessOrEqual) left = mid + 1;\n\t\t\t\telse right = mid - 1;\n\t\t\t} else {\n\t\t\t\tif (lessOrEqual) right = mid - 1;\n\t\t\t\telse left = mid + 1;\n\t\t\t}\n\t\t}\n\t\treturn lessOrEqual ? result : left < arr.length ? left : null;\n\t};\n\t// Insert into array of ProofWithFee objects sorted by exFee\n\tconst insertSorted = (arr: ProofWithFee[], obj: ProofWithFee): void => {\n\t\tconst value = obj.exFee;\n\t\tlet left = 0,\n\t\t\tright = arr.length;\n\t\twhile (left < right) {\n\t\t\tconst mid = Math.floor((left + right) / 2);\n\t\t\tif (arr[mid].exFee < value) left = mid + 1;\n\t\t\telse right = mid;\n\t\t}\n\t\tarr.splice(left, 0, obj);\n\t};\n\t// \"Delta\" is the excess over amountToSend including fees\n\t// plus a tiebreaker to favour lower PPK keysets\n\t// NB: Solutions under amountToSend are invalid (delta: Infinity)\n\tconst calculateDelta = (amount: number, feePPK: number): number => {\n\t\tconst netSum = sumExFees(amount, feePPK);\n\t\tif (netSum < amountToSend) return Infinity; // no good\n\t\treturn amount + feePPK / 1000 - amountToSend;\n\t};\n\n\t/**\n\t * Pre-processing.\n\t */\n\tlet totalAmount = 0;\n\tlet totalFeePPK = 0;\n\tconst proofWithFees = proofs.map((p) => {\n\t\tconst ppkfee = feeForProof(p);\n\t\tconst exFee = includeFees ? p.amount - ppkfee / 1000 : p.amount;\n\t\tconst obj = { proof: p, exFee, ppkfee };\n\t\t// Sum all economical proofs (filtered below)\n\t\tif (!includeFees || exFee > 0) {\n\t\t\ttotalAmount += p.amount;\n\t\t\ttotalFeePPK += ppkfee;\n\t\t}\n\t\treturn obj;\n\t});\n\n\t// Filter uneconomical proofs (totals computed above)\n\tlet spendableProofs = includeFees ? proofWithFees.filter((obj) => obj.exFee > 0) : proofWithFees;\n\n\t// Sort by exFee ascending\n\tspendableProofs.sort((a, b) => a.exFee - b.exFee);\n\n\t// Remove proofs too large to be useful and adjust totals\n\t// Exact Match: Keep proofs where exFee <= amountToSend\n\t// Close Match: Keep proofs where exFee <= nextBiggerExFee\n\tif (spendableProofs.length > 0) {\n\t\tlet endIndex;\n\t\tif (exactMatch) {\n\t\t\tconst rightIndex = binarySearchIndex(spendableProofs, amountToSend, true);\n\t\t\tendIndex = rightIndex !== null ? rightIndex + 1 : 0;\n\t\t} else {\n\t\t\tconst biggerIndex = binarySearchIndex(spendableProofs, amountToSend, false);\n\t\t\tif (biggerIndex !== null) {\n\t\t\t\tconst nextBiggerExFee = spendableProofs[biggerIndex].exFee;\n\t\t\t\tconst rightIndex = binarySearchIndex(spendableProofs, nextBiggerExFee, true);\n\t\t\t\tfailIfNullish(rightIndex, 'Unexpected null rightIndex in binary search', _logger);\n\t\t\t\tendIndex = rightIndex + 1;\n\t\t\t} else {\n\t\t\t\t// Keep all proofs if all exFee < amountToSend\n\t\t\t\tendIndex = spendableProofs.length;\n\t\t\t}\n\t\t}\n\t\t// Adjust totals for removed proofs\n\t\tfor (let i = endIndex; i < spendableProofs.length; i++) {\n\t\t\ttotalAmount -= spendableProofs[i].proof.amount;\n\t\t\ttotalFeePPK -= spendableProofs[i].ppkfee;\n\t\t}\n\t\tspendableProofs = spendableProofs.slice(0, endIndex);\n\t}\n\n\t// Validate using precomputed totals\n\tconst totalNetSum = sumExFees(totalAmount, totalFeePPK);\n\tif (amountToSend <= 0 || amountToSend > totalNetSum) {\n\t\treturn { keep: proofs, send: [] };\n\t}\n\n\t// Max acceptable amount for non-exact matches\n\tconst maxOverAmount = Math.min(\n\t\tMath.ceil(amountToSend * (1 + MAX_OVRPCT / 100)),\n\t\tamountToSend + MAX_OVRAMT,\n\t\ttotalNetSum,\n\t);\n\n\t/**\n\t * RGLI algorithm: Runs multiple trials (up to MAX_TRIALS) Each trial starts with randomized\n\t * greedy subset (S) and then tries to improve that subset to get a valid solution. NOTE: Fees are\n\t * dynamic, based on number of proofs (PPK), so we perform all calculations based on net amounts.\n\t */\n\tfor (let trial = 0; trial < MAX_TRIALS; trial++) {\n\t\t// PHASE 1: Randomized Greedy Selection\n\t\t// Add proofs up to amountToSend (after adjusting for fees)\n\t\t// for exact match or the first amount over target otherwise\n\t\tconst S: ProofWithFee[] = [];\n\t\tlet amount = 0;\n\t\tlet feePPK = 0;\n\t\tfor (const obj of shuffleArray(spendableProofs)) {\n\t\t\tconst newAmount = amount + obj.proof.amount;\n\t\t\tconst newFeePPK = feePPK + obj.ppkfee;\n\t\t\tconst netSum = sumExFees(newAmount, newFeePPK);\n\t\t\tif (exactMatch && netSum > amountToSend) break;\n\t\t\tS.push(obj);\n\t\t\tamount = newAmount;\n\t\t\tfeePPK = newFeePPK;\n\t\t\tif (netSum >= amountToSend) break;\n\t\t}\n\n\t\t// PHASE 2: Local Improvement\n\t\t// Examine all the amounts found in the first phase, and find the\n\t\t// amount not in the current solution (others), which would get us\n\t\t// closest to the amountToSend.\n\n\t\t// Calculate the \"others\" array (note: spendableProofs is sorted ASC)\n\t\t// Using set.has() for filtering gives faster lookups: O(n+m)\n\t\t// Using array.includes() would be way slower: O(n*m)\n\t\tconst SSet = new Set(S);\n\t\tconst others = spendableProofs.filter((obj) => !SSet.has(obj));\n\t\t// Generate a random order for accessing the trial subset ('S')\n\t\tconst indices = shuffleArray(Array.from({ length: S.length }, (_, i) => i)).slice(\n\t\t\t0,\n\t\t\tMAX_P2SWAP,\n\t\t);\n\t\tfor (const i of indices) {\n\t\t\t// Exact or acceptable close match solution found?\n\t\t\tconst netSum = sumExFees(amount, feePPK);\n\t\t\tif (\n\t\t\t\tnetSum === amountToSend ||\n\t\t\t\t(!exactMatch && netSum >= amountToSend && netSum <= maxOverAmount)\n\t\t\t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Get details for proof being replaced (objP), and temporarily\n\t\t\t// calculate the subset amount/fee with that proof removed.\n\t\t\tconst objP = S[i];\n\t\t\tconst tempAmount = amount - objP.proof.amount;\n\t\t\tconst tempFeePPK = feePPK - objP.ppkfee;\n\t\t\tconst tempNetSum = sumExFees(tempAmount, tempFeePPK);\n\t\t\tconst target = amountToSend - tempNetSum;\n\n\t\t\t// Find a better replacement proof (objQ) and swap it in\n\t\t\t// Exact match can only replace larger to close on the target\n\t\t\t// Close match can replace larger or smaller as needed, but will\n\t\t\t// not replace larger unless it closes on the target\n\t\t\tconst qIndex = binarySearchIndex(others, target, exactMatch);\n\t\t\tif (qIndex !== null) {\n\t\t\t\tconst objQ = others[qIndex];\n\t\t\t\tif (!exactMatch || objQ.exFee > objP.exFee) {\n\t\t\t\t\tif (target >= 0 || objQ.exFee <= objP.exFee) {\n\t\t\t\t\t\tS[i] = objQ;\n\t\t\t\t\t\tamount = tempAmount + objQ.proof.amount;\n\t\t\t\t\t\tfeePPK = tempFeePPK + objQ.ppkfee;\n\t\t\t\t\t\tothers.splice(qIndex, 1);\n\t\t\t\t\t\tinsertSorted(others, objP);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Update best solution\n\t\tconst delta = calculateDelta(amount, feePPK);\n\t\tif (delta < bestDelta) {\n\t\t\t_logger.debug(\n\t\t\t\t`selectProofsToSend: best solution found in trial #${trial} - amount: ${amount}, delta: ${delta}`,\n\t\t\t);\n\t\t\tbestSubset = [...S].sort((a, b) => b.exFee - a.exFee); // copy & sort\n\t\t\tbestDelta = delta;\n\t\t\tbestAmount = amount;\n\t\t\tbestFeePPK = feePPK;\n\n\t\t\t// \"PHASE 3\": Final check to make sure we haven't overpaid fees\n\t\t\t// and see if we can improve the solution. This is an adaptation\n\t\t\t// to the original RGLI, which helps us identify close match and\n\t\t\t// optimal fee solutions more consistently\n\t\t\tconst tempS = [...bestSubset]; // copy\n\t\t\twhile (tempS.length > 1 && bestDelta > 0) {\n\t\t\t\tconst objP = tempS.pop() as ProofWithFee;\n\t\t\t\tconst tempAmount = amount - objP.proof.amount;\n\t\t\t\tconst tempFeePPK = feePPK - objP.ppkfee;\n\t\t\t\tconst tempDelta = calculateDelta(tempAmount, tempFeePPK);\n\t\t\t\tif (tempDelta == Infinity) break;\n\t\t\t\tif (tempDelta < bestDelta) {\n\t\t\t\t\tbestSubset = [...tempS];\n\t\t\t\t\tbestDelta = tempDelta;\n\t\t\t\t\tbestAmount = tempAmount;\n\t\t\t\t\tbestFeePPK = tempFeePPK;\n\t\t\t\t\tamount = tempAmount;\n\t\t\t\t\tfeePPK = tempFeePPK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Check if solution is acceptable\n\t\tif (bestSubset && bestDelta < Infinity) {\n\t\t\tconst bestSum = sumExFees(bestAmount, bestFeePPK);\n\t\t\tif (\n\t\t\t\tbestSum === amountToSend ||\n\t\t\t\t(!exactMatch && bestSum >= amountToSend && bestSum <= maxOverAmount)\n\t\t\t) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// Time limit reached?\n\t\tif (timer.elapsed() > MAX_TIMEMS) {\n\t\t\tfailIf(\n\t\t\t\texactMatch,\n\t\t\t\t'Proof selection took too long. Try again with a smaller proof set.',\n\t\t\t\t_logger,\n\t\t\t);\n\t\t\t_logger.warn('Proof selection took too long. Returning best selection so far.');\n\t\t\tbreak;\n\t\t}\n\t}\n\t// Return Result\n\tif (bestSubset && bestDelta < Infinity) {\n\t\tconst bestProofs = bestSubset.map((obj) => obj.proof);\n\t\tconst bestSubsetSet = new Set(bestProofs);\n\t\tconst keep = proofs.filter((p) => !bestSubsetSet.has(p));\n\t\t_logger.info(`Proof selection took ${timer.elapsed()}ms`);\n\t\treturn { keep, send: bestProofs };\n\t}\n\treturn { keep: proofs, send: [] };\n};\n","/**\n * Usable counters in range is [start, start+count-1]\n *\n * @example // Start: 5, count: 3 => 5,6,7.\n */\nexport interface CounterRange {\n\tstart: number;\n\tcount: number;\n}\n\n// CounterSource.ts\nexport interface CounterSource {\n\t/**\n\t * Reserve n counters for a keyset.\n\t *\n\t * N may be 0. In that case the call MUST NOT mutate state and MUST return { start: currentNext,\n\t * count: 0 }, effectively a read only peek of the cursor.\n\t */\n\treserve(keysetId: string, n: number): Promise<CounterRange>;\n\t/**\n\t * Monotonic bump, ensure the next counter is at least minNext.\n\t */\n\tadvanceToAtLeast(keysetId: string, minNext: number): Promise<void>;\n\t/**\n\t * Optional introspection.\n\t */\n\tsnapshot?(): Promise<Record<string, number>>;\n\t/**\n\t * Optional hard set, useful for tests or migrations.\n\t */\n\tsetNext?(keysetId: string, next: number): Promise<void>;\n}\n\n/**\n * Counter summary for an operation.\n *\n * - `keysetId` - of the transaction.\n * - `start` - beginning of reservation.\n * - `count` - number of reservations.\n * - `next` - counter available after reservation.\n *\n * @example // Start: 5, Count: 3 => 5,6,7. Next: 8.\n */\nexport type OperationCounters = {\n\tkeysetId: string;\n\tstart: number;\n\tcount: number;\n\tnext: number;\n};\n\n/**\n * In memory implementation with per keyset locks for atomic counters.\n */\nexport class EphemeralCounterSource implements CounterSource {\n\tprivate next = new Map<string, number>();\n\tprivate locks = new Map<string, Promise<void>>();\n\n\tconstructor(initial?: Record<string, number>) {\n\t\tif (initial) {\n\t\t\tfor (const [k, v] of Object.entries(initial)) this.next.set(k, v);\n\t\t}\n\t}\n\n\tprivate async withLock<T>(k: string, fn: () => T | Promise<T>): Promise<T> {\n\t\tconst prev = this.locks.get(k) ?? Promise.resolve();\n\t\tlet release!: () => void;\n\t\tconst p = new Promise<void>((resolve) => (release = resolve));\n\t\tconst chain = prev.then(() => p);\n\t\tthis.locks.set(k, chain);\n\t\ttry {\n\t\t\tawait prev;\n\t\t\treturn await fn();\n\t\t} finally {\n\t\t\trelease();\n\t\t\tif (this.locks.get(k) === chain) {\n\t\t\t\tthis.locks.delete(k);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync reserve(keysetId: string, n: number): Promise<CounterRange> {\n\t\tif (n < 0) throw new Error('reserve called with negative count');\n\t\treturn this.withLock(keysetId, () => {\n\t\t\tconst cur = this.next.get(keysetId) ?? 0;\n\t\t\tif (n === 0) return { start: cur, count: 0 }; // report current, do not move\n\t\t\tthis.next.set(keysetId, cur + n);\n\t\t\treturn { start: cur, count: n };\n\t\t});\n\t}\n\n\tasync advanceToAtLeast(keysetId: string, minNext: number): Promise<void> {\n\t\tawait this.withLock(keysetId, () => {\n\t\t\tconst cur = this.next.get(keysetId) ?? 0;\n\t\t\tif (minNext > cur) this.next.set(keysetId, minNext);\n\t\t});\n\t}\n\n\tasync setNext(keysetId: string, next: number): Promise<void> {\n\t\tawait this.withLock(keysetId, () => {\n\t\t\tif (next < 0) throw new Error('setNext: negative next not allowed');\n\t\t\tthis.next.set(keysetId, next);\n\t\t});\n\t}\n\n\tsnapshot(): Promise<Record<string, number>> {\n\t\treturn Promise.resolve(Object.fromEntries(this.next.entries()));\n\t}\n}\n","import {\n\ttype MeltQuoteResponse,\n\ttype MintQuoteResponse,\n\ttype Bolt12MeltQuoteResponse,\n\ttype Bolt12MintQuoteResponse,\n} from '../mint/types';\nimport { type OutputData, type OutputDataFactory } from '../model/OutputData';\nimport type { Proof } from '../model/types/proof';\nimport type { Token } from '../model/types/token';\nimport {\n\ttype OutputType,\n\ttype OutputConfig,\n\ttype SendConfig,\n\ttype ReceiveConfig,\n\ttype MintProofsConfig,\n\ttype P2PKOptions,\n\ttype OnCountersReserved,\n\ttype MeltProofsConfig,\n} from './types';\nimport type { Wallet } from './Wallet';\n\n/**\n * Fluent operations builder for a Wallet instance.\n *\n * @remarks\n * Provides chainable builders for sending, receiving, and minting. Each builder is single use. If\n * you do not customise an output side, the wallet’s policy defaults apply.\n */\nexport class WalletOps {\n\tconstructor(private wallet: Wallet) {}\n\tsend(amount: number, proofs: Proof[]) {\n\t\treturn new SendBuilder(this.wallet, amount, proofs);\n\t}\n\treceive(token: Token | string) {\n\t\treturn new ReceiveBuilder(this.wallet, token);\n\t}\n\tmintBolt11(amount: number, quote: string | MintQuoteResponse) {\n\t\treturn new MintBuilder<'bolt11'>(this.wallet, 'bolt11', amount, quote);\n\t}\n\tmintBolt12(amount: number, quote: Bolt12MintQuoteResponse) {\n\t\treturn new MintBuilder<'bolt12'>(this.wallet, 'bolt12', amount, quote);\n\t}\n\tmeltBolt11(quote: MeltQuoteResponse, proofs: Proof[]) {\n\t\treturn new MeltBuilder(this.wallet, 'bolt11', quote, proofs);\n\t}\n\tmeltBolt12(quote: Bolt12MeltQuoteResponse, proofs: Proof[]) {\n\t\treturn new MeltBuilder(this.wallet, 'bolt12', quote, proofs);\n\t}\n}\n\n/**\n * Builder for composing a send or swap.\n *\n * @remarks\n * If you only customise the send side, keep is omitted so the wallet may still attempt an offline\n * exact match selection where possible.\n * @example\n *\n *     const { keep, send } = await wallet.ops\n *     \t.send(5, proofs)\n *     \t.asDeterministic() // counter 0 means auto reserve via CounterSource\n *     \t.keepAsRandom()\n *     \t.includeFees(true) // sender pays receiver’s future spend fee\n *     \t.run();\n */\nexport class SendBuilder {\n\tprivate sendOT?: OutputType;\n\tprivate keepOT?: OutputType;\n\tprivate config: SendConfig = {};\n\tprivate offlineExact?: { requireDleq: boolean };\n\tprivate offlineClose?: { requireDleq: boolean };\n\n\tconstructor(\n\t\tprivate wallet: Wallet,\n\t\tprivate amount: number,\n\t\tprivate proofs: Proof[],\n\t) {}\n\n\t/**\n\t * Use random blinding for the sent outputs.\n\t *\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasRandom(denoms?: number[]) {\n\t\tthis.sendOT = { type: 'random', denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use deterministic outputs for the sent proofs.\n\t *\n\t * @param counter Starting counter. Zero means auto reserve using the wallet’s CounterSource.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasDeterministic(counter = 0, denoms?: number[]) {\n\t\tthis.sendOT = { type: 'deterministic', counter, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use P2PK locked outputs for the sent proofs.\n\t *\n\t * @param options NUT 11 options like pubkey and locktime.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasP2PK(options: P2PKOptions, denoms?: number[]) {\n\t\tthis.sendOT = { type: 'p2pk', options, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use a factory to generate OutputData for the sent proofs.\n\t *\n\t * @param factory OutputDataFactory used to produce blinded messages.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasFactory(factory: OutputDataFactory, denoms?: number[]) {\n\t\tthis.sendOT = { type: 'factory', factory, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Provide pre created OutputData for the sent proofs.\n\t *\n\t * @param data Fully formed OutputData. Their amounts must sum to the send amount, otherwise the\n\t *   wallet will throw.\n\t */\n\tasCustom(data: OutputData[]) {\n\t\tthis.sendOT = { type: 'custom', data };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use random blinding for change outputs.\n\t *\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tkeepAsRandom(denoms?: number[]) {\n\t\tthis.keepOT = { type: 'random', denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use deterministic outputs for change.\n\t *\n\t * @param counter Starting counter. Zero means auto reserve using the wallet’s CounterSource.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tkeepAsDeterministic(counter = 0, denoms?: number[]) {\n\t\tthis.keepOT = { type: 'deterministic', counter, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use P2PK locked change (NUT 11).\n\t *\n\t * @param options Locking options applied to the kept proofs.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tkeepAsP2PK(options: P2PKOptions, denoms?: number[]) {\n\t\tthis.keepOT = { type: 'p2pk', options, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use a factory to generate OutputData for change.\n\t *\n\t * @param factory OutputDataFactory used to produce blinded messages.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tkeepAsFactory(factory: OutputDataFactory, denoms?: number[]) {\n\t\tthis.keepOT = { type: 'factory', factory, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Provide pre created OutputData for change.\n\t *\n\t * @param data Fully formed OutputData for the keep (change) amount.\n\t */\n\tkeepAsCustom(data: OutputData[]) {\n\t\tthis.keepOT = { type: 'custom', data };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Make the sender cover the receiver’s future spend fee.\n\t *\n\t * @param on When true, include fees in the sent amount. Default true if called.\n\t */\n\tincludeFees(on = true) {\n\t\tthis.config.includeFees = on;\n\t\treturn this;\n\t}\n\t/**\n\t * Use a specific keyset for the operation.\n\t *\n\t * @param id Keyset id to use for mint keys and fee lookup.\n\t */\n\tkeyset(id: string) {\n\t\tthis.config.keysetId = id;\n\t\treturn this;\n\t} /**\n\t * Provide existing proofs to help optimise denomination selection.\n\t *\n\t * @remarks\n\t * Has no effect if denominations (custom split) was specified.\n\t * @param p Proofs currently held by the wallet, used to hit denomination targets.\n\t */\n\tproofsWeHave(p: Proof[]) {\n\t\tthis.config.proofsWeHave = p;\n\t\treturn this;\n\t}\n\t/**\n\t * Receive a callback once counters are atomically reserved for deterministic outputs.\n\t *\n\t * @param cb Called with OperationCounters when counters are reserved.\n\t */\n\tonCountersReserved(cb: OnCountersReserved) {\n\t\tthis.config.onCountersReserved = cb;\n\t\treturn this;\n\t}\n\t/**\n\t * Force a pure offline, exact match selection. No mint calls are made. If an exact match cannot\n\t * be found, this throws.\n\t *\n\t * @param requireDleq Only consider proofs with a DLEQ when true.\n\t */\n\tofflineExactOnly(requireDleq = false) {\n\t\tthis.offlineExact = { requireDleq };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Force a pure offline selection that allows a close match, overspend permitted per wallet RGLI.\n\t * No mint calls are made. Returns the best offline subset found, or throws if funds are\n\t * insufficient.\n\t *\n\t * @param requireDleq Only consider proofs with a DLEQ when true.\n\t */\n\tofflineCloseMatch(requireDleq = false) {\n\t\tthis.offlineClose = { requireDleq };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Execute the send or swap.\n\t *\n\t * @returns The split result with kept and sent proofs.\n\t */\n\tasync run() {\n\t\t// If an offline mode is requested, forbid custom OutputTypes,\n\t\t// because offline uses existing proofs and cannot honour new outputs.\n\t\tif ((this.offlineExact || this.offlineClose) && (this.sendOT || this.keepOT)) {\n\t\t\tthrow new Error(\n\t\t\t\t'Offline selection cannot be combined with custom output types. Remove send/keep output configuration, or use an online swap.',\n\t\t\t);\n\t\t}\n\n\t\t// Strict offline, exact match only\n\t\tif (this.offlineExact) {\n\t\t\treturn this.wallet.sendOffline(this.amount, this.proofs, {\n\t\t\t\tincludeFees: this.config.includeFees,\n\t\t\t\texactMatch: true,\n\t\t\t\trequireDleq: this.offlineExact.requireDleq,\n\t\t\t});\n\t\t}\n\n\t\t// Offline close match, may overshoot\n\t\tif (this.offlineClose) {\n\t\t\treturn this.wallet.sendOffline(this.amount, this.proofs, {\n\t\t\t\tincludeFees: this.config.includeFees,\n\t\t\t\texactMatch: false,\n\t\t\t\trequireDleq: this.offlineClose.requireDleq,\n\t\t\t});\n\t\t}\n\n\t\t// Construct an OutputConfig using default send if no customizations\n\t\tconst outputConfig: OutputConfig = {\n\t\t\tsend: this.sendOT ?? this.wallet.defaultOutputType(),\n\t\t\t...(this.keepOT ? { keep: this.keepOT } : {}),\n\t\t};\n\t\treturn this.wallet.send(this.amount, this.proofs, this.config, outputConfig);\n\t}\n}\n\n/**\n * Builder for receiving a token.\n *\n * @remarks\n * If you do not call a type method, the wallet’s policy default is used.\n * @example\n *\n *     const proofs = await wallet.ops\n *     \t.receive(token)\n *     \t.asDeterministic() // counter 0 auto reserves\n *     \t.requireDleq(true)\n *     \t.run();\n */\nexport class ReceiveBuilder {\n\tprivate outputType?: OutputType;\n\tprivate config: ReceiveConfig = {};\n\n\tconstructor(\n\t\tprivate wallet: Wallet,\n\t\tprivate token: Token | string,\n\t) {}\n\n\t/**\n\t * Use random blinding for the received outputs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasRandom(denoms?: number[]) {\n\t\tthis.outputType = { type: 'random', denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use deterministic outputs for the received proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param counter Starting counter. Zero means auto reserve using the wallet’s CounterSource.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasDeterministic(counter = 0, denoms?: number[]) {\n\t\tthis.outputType = { type: 'deterministic', counter, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use P2PK locked outputs for the received proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param options NUT 11 options like pubkey and locktime.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasP2PK(options: P2PKOptions, denoms?: number[]) {\n\t\tthis.outputType = { type: 'p2pk', options, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use a factory to generate OutputData for received proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param factory OutputDataFactory used to produce blinded messages.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasFactory(factory: OutputDataFactory, denoms?: number[]) {\n\t\tthis.outputType = { type: 'factory', factory, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Provide pre created OutputData for received proofs.\n\t *\n\t * @param data Fully formed OutputData for the final amount.\n\t */\n\tasCustom(data: OutputData[]) {\n\t\tthis.outputType = { type: 'custom', data };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a specific keyset for the operation.\n\t *\n\t * @param id Keyset id to use for mint keys and fee lookup.\n\t */\n\tkeyset(id: string) {\n\t\tthis.config.keysetId = id;\n\t\treturn this;\n\t}\n\t/**\n\t * Require all incoming proofs to have a valid DLEQ for the selected keyset.\n\t *\n\t * @param on When true, proofs without DLEQ are rejected.\n\t */\n\trequireDleq(on = true) {\n\t\tthis.config.requireDleq = on;\n\t\treturn this;\n\t}\n\t/**\n\t * Private key used to sign P2PK locked incoming proofs.\n\t *\n\t * @param k Single key or array of multisig keys.\n\t */\n\tprivkey(k: string | string[]) {\n\t\tthis.config.privkey = k;\n\t\treturn this;\n\t}\n\t/**\n\t * Provide existing proofs to help optimise denomination selection.\n\t *\n\t * @remarks\n\t * Has no effect if denominations (custom split) was specified.\n\t * @param p Proofs currently held by the wallet, used to hit denomination targets.\n\t */\n\tproofsWeHave(p: Proof[]) {\n\t\tthis.config.proofsWeHave = p;\n\t\treturn this;\n\t}\n\t/**\n\t * Receive a callback once counters are atomically reserved for deterministic outputs.\n\t *\n\t * @param cb Called with OperationCounters when counters are reserved.\n\t */\n\tonCountersReserved(cb: OnCountersReserved) {\n\t\tthis.config.onCountersReserved = cb;\n\t\treturn this;\n\t}\n\n\tasync run() {\n\t\treturn this.wallet.receive(this.token, this.config, this.outputType);\n\t}\n}\n\n/**\n * Builder for minting proofs from a quote.\n *\n * @remarks\n * Bolt12 requires privkey by default, bolt11 only for locked quotes. The compiler will throw an\n * error if bolt12 and privkey() is omitted: MintBuilder<\"bolt12\", false>' is not assignable...\n * @example\n *\n *     const proofs = await wallet.ops\n *     \t.mint(100, quote)\n *     \t.asDeterministic() // counter 0 auto reserves\n *     \t.onCountersReserved((info) => console.log(info))\n *     \t.privkey('sk')\n *     \t.run();\n */\nexport class MintBuilder<\n\tM extends 'bolt11' | 'bolt12',\n\tHasPrivKey extends boolean = M extends 'bolt12' ? false : true,\n> {\n\tprivate outputType?: OutputType;\n\tprivate config: MintProofsConfig = {};\n\n\t// phantom field to satisfy linter (erased at emit)\n\tprivate readonly _hasPrivkey!: HasPrivKey;\n\n\tconstructor(\n\t\tprivate wallet: Wallet,\n\t\tprivate method: M,\n\t\tprivate amount: number,\n\t\tprivate quote: string | MintQuoteResponse | Bolt12MintQuoteResponse,\n\t) {\n\t\tvoid this._hasPrivkey; // intentionally unused (phantom field)\n\t}\n\n\t/**\n\t * Use random blinding for the minted proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasRandom(denoms?: number[]) {\n\t\tthis.outputType = { type: 'random', denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use deterministic outputs for the minted proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param counter Starting counter. Zero means auto reserve using the wallet’s CounterSource.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasDeterministic(counter = 0, denoms?: number[]) {\n\t\tthis.outputType = { type: 'deterministic', counter, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use P2PK locked outputs for the minted proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param options NUT 11 options like pubkey and locktime.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasP2PK(options: P2PKOptions, denoms?: number[]) {\n\t\tthis.outputType = { type: 'p2pk', options, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use a factory to generate OutputData for minted proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param factory OutputDataFactory used to produce blinded messages.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasFactory(factory: OutputDataFactory, denoms?: number[]) {\n\t\tthis.outputType = { type: 'factory', factory, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Provide pre created OutputData for minted proofs.\n\t *\n\t * @param data Fully formed OutputData for the final amount.\n\t */\n\tasCustom(data: OutputData[]) {\n\t\tthis.outputType = { type: 'custom', data };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a specific keyset for the operation.\n\t *\n\t * @param id Keyset id to use for mint keys and fee lookup.\n\t */\n\tkeyset(id: string) {\n\t\tthis.config.keysetId = id;\n\t\treturn this;\n\t}\n\t/**\n\t * Private key to sign locked mint quotes.\n\t *\n\t * @param k Private key for locked quotes.\n\t */\n\tprivkey(k: string): MintBuilder<M, true> {\n\t\t// For bolt11 - privkey is sent in the config\n\t\t// For bolt12 - privkey is sent positionally in run()\n\t\tthis.config.privkey = k;\n\t\treturn this as MintBuilder<M, true>;\n\t}\n\t/**\n\t * Provide existing proofs to help optimise denomination selection.\n\t *\n\t * @remarks\n\t * Has no effect if denominations (custom split) was specified.\n\t * @param p Proofs currently held by the wallet, used to hit denomination targets.\n\t */\n\tproofsWeHave(p: Proof[]) {\n\t\tthis.config.proofsWeHave = p;\n\t\treturn this;\n\t}\n\t/**\n\t * Receive a callback once counters are atomically reserved for deterministic outputs.\n\t *\n\t * @param cb Called with OperationCounters when counters are reserved.\n\t */\n\tonCountersReserved(cb: OnCountersReserved) {\n\t\tthis.config.onCountersReserved = cb;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Execute minting against the quote.\n\t *\n\t * @remarks\n\t * This method can only be called for bolt12 quotes when .privkey() is set.\n\t * @returns The newly minted proofs.\n\t */\n\tasync run(this: MintBuilder<M, true>) {\n\t\t// BOLT 11\n\t\tif (this.method === 'bolt11') {\n\t\t\tconst bolt11 = this.quote as MintQuoteResponse;\n\t\t\tif (bolt11.pubkey && !this.config.privkey) {\n\t\t\t\tthrow new Error('privkey is required for locked BOLT11 mint quotes');\n\t\t\t}\n\t\t\treturn this.wallet.mintProofsBolt11(this.amount, bolt11, this.config, this.outputType);\n\t\t}\n\n\t\t// BOLT 12\n\t\tconst bolt12 = this.quote as Bolt12MintQuoteResponse;\n\t\tif (!this.config.privkey) {\n\t\t\tthrow new Error('privkey is required for BOLT12 mint quotes');\n\t\t}\n\t\treturn this.wallet.mintProofsBolt12(\n\t\t\tthis.amount,\n\t\t\tbolt12,\n\t\t\tthis.config.privkey,\n\t\t\tthis.config,\n\t\t\tthis.outputType,\n\t\t);\n\t}\n}\n\n/**\n * Builder for melting proofs to pay a Lightning invoice or BOLT12 offer.\n *\n * @remarks\n * Supports both BOLT11 and BOLT12. You can optionally receive a callback when NUT-08 blanks are\n * created for async melts.\n * @example\n *\n * ```typescript\n * // Basic BOLT11 melt\n * await wallet.ops.meltBolt11(quote, proofs).run();\n *\n * // BOLT12 melt with deterministic change and NUT-08 blanks callback\n * await wallet.ops\n * \t.meltBolt12(quote12, proofs)\n * \t.asDeterministic() // counter 0 auto reserves\n * \t.onChangeOutputsCreated((blanks) => {\n * \t\t// Persist blanks and retry later with wallet.completeMelt(blanks)\n * \t})\n * \t.onCountersReserved((info) => console.log('Reserved', info))\n * \t.run();\n * ```\n */\nexport class MeltBuilder {\n\tprivate outputType?: OutputType;\n\tprivate config: MeltProofsConfig = {};\n\n\tconstructor(\n\t\tprivate wallet: Wallet,\n\t\tprivate method: 'bolt11' | 'bolt12',\n\t\tprivate quote: MeltQuoteResponse,\n\t\tprivate proofs: Proof[],\n\t) {}\n\n\t/**\n\t * Use random blinding for change outputs.\n\t *\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasRandom(denoms?: number[]) {\n\t\tthis.outputType = { type: 'random', denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use deterministic outputs for change.\n\t *\n\t * @param counter Starting counter. Zero means auto reserve using the wallet’s CounterSource.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasDeterministic(counter = 0, denoms?: number[]) {\n\t\tthis.outputType = { type: 'deterministic', counter, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use P2PK-locked change (NUT-11).\n\t *\n\t * @param options NUT-11 locking options (e.g., pubkey, locktime).\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasP2PK(options: P2PKOptions, denoms?: number[]) {\n\t\tthis.outputType = { type: 'p2pk', options, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a factory to generate OutputData for change.\n\t *\n\t * @param factory Factory used to produce blinded messages.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasFactory(factory: OutputDataFactory, denoms?: number[]) {\n\t\tthis.outputType = { type: 'factory', factory, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Provide pre-created OutputData for change.\n\t *\n\t * @param data Fully formed OutputData for the change amount.\n\t */\n\tasCustom(data: OutputData[]) {\n\t\tthis.outputType = { type: 'custom', data };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a specific keyset for the melt operation.\n\t *\n\t * @param id Keyset id to use for mint keys and fee lookup.\n\t */\n\tkeyset(id: string) {\n\t\tthis.config.keysetId = id;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Receive a callback once counters are atomically reserved for deterministic outputs.\n\t *\n\t * @param cb Called with OperationCounters when counters are reserved.\n\t */\n\tonCountersReserved(cb: OnCountersReserved) {\n\t\tthis.config.onCountersReserved = cb;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Receive a callback when NUT-08 blanks (0-sat change outputs) are created for async melts.\n\t *\n\t * @remarks\n\t * You can persist these blanks and later call `wallet.completeMelt(blanks)` to finalize and\n\t * recover change once the invoice/offer is paid.\n\t * @param cb Callback invoked with the created blanks payload.\n\t */\n\tonChangeOutputsCreated(cb: NonNullable<MeltProofsConfig['onChangeOutputsCreated']>) {\n\t\tthis.config.onChangeOutputsCreated = cb;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Execute the melt against the quote.\n\t *\n\t * @returns The melt result: `{ quote, change }`.\n\t */\n\tasync run() {\n\t\t// BOLT11\n\t\tif (this.method === 'bolt11') {\n\t\t\treturn this.wallet.meltProofsBolt11(this.quote, this.proofs, this.config, this.outputType);\n\t\t}\n\n\t\t// BOLT 12\n\t\treturn this.wallet.meltProofsBolt12(this.quote, this.proofs, this.config, this.outputType);\n\t}\n}\n","import type { Wallet } from './Wallet';\nimport type { Proof, ProofState } from '../model/types';\nimport {\n\tMintQuoteState,\n\tMeltQuoteState,\n\ttype MintQuoteResponse,\n\ttype MeltQuoteResponse,\n} from '../mint/types';\nimport type { MeltBlanks, SubscriptionCanceller } from './types';\nimport { hashToCurve } from '../crypto';\nimport { type OperationCounters } from './CounterSource';\nimport { safeCallback } from '../logger';\n\nexport type CancellerLike = SubscriptionCanceller | Promise<SubscriptionCanceller>;\n\nexport type SubscribeOpts = { signal?: AbortSignal };\n\ntype ErrorWithCause = Error & { cause?: unknown };\n\nfunction safeStringify(obj: unknown): string {\n\tconst seen = new WeakSet<object>();\n\ttry {\n\t\treturn JSON.stringify(obj, (_k: string, v: unknown) => {\n\t\t\tif (typeof v === 'object' && v !== null) {\n\t\t\t\tif (seen.has(v)) return '[Circular]';\n\t\t\t\tseen.add(v);\n\t\t\t}\n\t\t\treturn v; // returning `unknown` is fine\n\t\t});\n\t} catch {\n\t\treturn Object.prototype.toString.call(obj);\n\t}\n}\n\nfunction normalizeError(err: unknown): Error {\n\tif (err instanceof Error) return err;\n\tconst message = typeof err === 'string' ? err : safeStringify(err);\n\tconst e: ErrorWithCause = new Error(message);\n\te.cause = err;\n\treturn e;\n}\n\nfunction makeAbortError(): Error {\n\tconst e = new Error('Aborted');\n\tObject.defineProperty(e, 'name', { value: 'AbortError' });\n\treturn e;\n}\n\nfunction cancelSafely(c: CancellerLike | null | undefined): void {\n\tif (!c) return;\n\tvoid Promise.resolve(c)\n\t\t.then((fn) => {\n\t\t\ttry {\n\t\t\t\tfn();\n\t\t\t} catch {\n\t\t\t\t/* ignore canceller errors */\n\t\t\t}\n\t\t\treturn;\n\t\t})\n\t\t.catch(() => {\n\t\t\t/* ignore awaiting-canceller errors */\n\t\t});\n}\n\nexport class WalletEvents {\n\tconstructor(private wallet: Wallet) {}\n\n\t// Callbacks registered for Counters Reserved events\n\tprivate countersReservedHandlers = new Set<(payload: OperationCounters) => void>();\n\n\t// Callbacks registered for Melt blanks created events\n\tprivate meltBlanksHandlers = new Set<(payload: MeltBlanks) => void>();\n\n\t// Binds an abort signal to each subscription canceller\n\tprivate withAbort(\n\t\tsignal: AbortSignal | undefined,\n\t\tcancel: SubscriptionCanceller,\n\t): SubscriptionCanceller {\n\t\tif (!signal) return cancel;\n\t\tif (signal.aborted) {\n\t\t\tcancel();\n\t\t\treturn () => {\n\t\t\t\t/* noop */\n\t\t\t};\n\t\t}\n\t\tconst onAbort = () => cancel();\n\t\tsignal.addEventListener('abort', onAbort, { once: true });\n\t\treturn () => {\n\t\t\tsignal.removeEventListener('abort', onAbort);\n\t\t\tcancel();\n\t\t};\n\t}\n\n\t// Subscribe to a quote-paid event and resolve when it fires.\n\t// Supports AbortSignal and timeout, and always cleans up.\n\tprivate waitUntilPaid<T>(\n\t\tsubscribeFn: (\n\t\t\tid: string,\n\t\t\tcb: (p: T) => void, // called when the entity becomes PAID\n\t\t\terr: (e: Error) => void, // called if the subscription itself errors\n\t\t\topts?: { signal?: AbortSignal },\n\t\t) => Promise<SubscriptionCanceller>,\n\t\tid: string, // identifier of the mint/melt/etc. to watch\n\t\topts?: SubscribeOpts & { timeoutMs?: number },\n\t\ttimeoutMsg = 'Timeout waiting for paid',\n\t): Promise<T> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlet cancelP: Promise<SubscriptionCanceller> | null = null; // handle to unsub later\n\t\t\tlet to: ReturnType<typeof setTimeout> | null = null; // optional timeout timer\n\n\t\t\t// Common cleanup: cancels subscription, clears timer, detaches abort listener.\n\t\t\t// If an error is provided, rejects the promise with it.\n\t\t\tconst cleanup = (err?: unknown) => {\n\t\t\t\tcancelSafely(cancelP);\n\t\t\t\tif (to) {\n\t\t\t\t\tclearTimeout(to);\n\t\t\t\t\tto = null;\n\t\t\t\t}\n\t\t\t\tif (opts?.signal) opts.signal.removeEventListener('abort', onAbort);\n\t\t\t\tif (err) reject(normalizeError(err));\n\t\t\t};\n\n\t\t\t// Abort handler produces a standardized AbortError and rejects.\n\t\t\tconst onAbort = () => cleanup(makeAbortError());\n\n\t\t\t// Hook up AbortSignal if provided.\n\t\t\tif (opts?.signal) {\n\t\t\t\tif (opts.signal.aborted) return onAbort(); // already aborted\n\t\t\t\topts.signal.addEventListener('abort', onAbort, { once: true });\n\t\t\t}\n\n\t\t\t// Start a timeout if requested.\n\t\t\tif (opts?.timeoutMs && opts.timeoutMs > 0) {\n\t\t\t\tto = setTimeout(() => cleanup(new Error(timeoutMsg)), opts.timeoutMs);\n\t\t\t}\n\n\t\t\t// Subscribe to the actual event. Canceller returned is saved to cancelP.\n\t\t\tcancelP = subscribeFn(\n\t\t\t\tid,\n\t\t\t\t(p) => {\n\t\t\t\t\tcleanup(); // clean up resources\n\t\t\t\t\tresolve(p); // resolve promise with payload\n\t\t\t\t},\n\t\t\t\t(e) => cleanup(e), // reject if subscription itself errors\n\t\t\t\t{ signal: opts?.signal }, // delegate abort to subscription as well\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * Register a callback that fires whenever deterministic counters are reserved.\n\t *\n\t * Timing: the callback is invoked synchronously _after_ a successful reservation and _before_ the\n\t * enclosing wallet method returns. The wallet does **not** await your callback, it is\n\t * fire-and-forget.\n\t *\n\t * Responsibility for async work is on the consumer. If your handler calls an async function (e.g.\n\t * persisting `start + count` to storage), make sure to handle errors inside it to avoid unhandled\n\t * rejections.\n\t *\n\t * Typical use: persist `start + count` for the `keysetId` so counters survive restarts.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * wallet.on.countersReserved(({ keysetId, start, count, next }) => {\n\t * \tsaveNextToDb(keysetId, start + count); // handle async errors inside saveNextToDb\n\t * });\n\t * ```\n\t *\n\t * @param cb Handler called with { keysetId, start, count }.\n\t * @returns A function that unsubscribes the handler.\n\t */\n\tpublic countersReserved(\n\t\tcb: (payload: OperationCounters) => void,\n\t\topts?: SubscribeOpts,\n\t): SubscriptionCanceller {\n\t\tthis.countersReservedHandlers.add(cb);\n\t\tconst cancel = () => this.countersReservedHandlers.delete(cb);\n\t\treturn this.withAbort(opts?.signal, cancel);\n\t}\n\t/**\n\t * @internal\n\t */\n\tpublic _emitCountersReserved(payload: OperationCounters) {\n\t\tfor (const h of this.countersReservedHandlers) {\n\t\t\tsafeCallback(h, payload, this.wallet.logger, { event: 'countersReserved' });\n\t\t}\n\t}\n\n\t/**\n\t * Register a callback fired whenever NUT-08 blanks are created during a melt.\n\t *\n\t * Called synchronously right after blanks are prepared (before the melt request), and the wallet\n\t * does not await your handler.\n\t *\n\t * Typical use: persist `payload` so you can later call `wallet.completeMelt(payload)`.\n\t */\n\tpublic meltBlanksCreated(\n\t\tcb: (payload: MeltBlanks) => void,\n\t\topts?: SubscribeOpts,\n\t): SubscriptionCanceller {\n\t\tthis.meltBlanksHandlers.add(cb);\n\t\tconst cancel = () => this.meltBlanksHandlers.delete(cb);\n\t\treturn this.withAbort(opts?.signal, cancel);\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tpublic _emitMeltBlanksCreated(payload: MeltBlanks) {\n\t\tfor (const h of this.meltBlanksHandlers) {\n\t\t\tsafeCallback(h, payload, this.wallet.logger, { event: 'meltBlanksCreated' });\n\t\t}\n\t}\n\n\t/**\n\t * Register a callback to be called whenever a mint quote's state changes.\n\t *\n\t * @param quoteIds List of mint quote IDs that should be subscribed to.\n\t * @param callback Callback function that will be called whenever a mint quote state changes.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync mintQuoteUpdates(\n\t\tids: string[],\n\t\tcb: (p: MintQuoteResponse) => void,\n\t\terr: (e: Error) => void,\n\t\topts?: SubscribeOpts,\n\t): Promise<SubscriptionCanceller> {\n\t\tawait this.wallet.mint.connectWebSocket();\n\t\tconst ws = this.wallet.mint.webSocketConnection;\n\t\tif (!ws) throw new Error('Failed to establish WebSocket connection.');\n\n\t\tconst uniq = Array.from(new Set(ids));\n\t\tconst subId = ws.createSubscription({ kind: 'bolt11_mint_quote', filters: uniq }, cb, err);\n\t\tconst cancel = () => ws.cancelSubscription(subId, cb);\n\t\treturn this.withAbort(opts?.signal, cancel);\n\t}\n\n\t/**\n\t * Register a callback to be called when a single mint quote gets paid.\n\t *\n\t * @param quoteId Mint quote id that should be subscribed to.\n\t * @param callback Callback function that will be called when this mint quote gets paid.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync mintQuotePaid(\n\t\tid: string,\n\t\tcb: (p: MintQuoteResponse) => void,\n\t\terr: (e: Error) => void,\n\t\topts?: SubscribeOpts,\n\t): Promise<SubscriptionCanceller> {\n\t\treturn this.mintQuoteUpdates(\n\t\t\t[id],\n\t\t\t(p) => {\n\t\t\t\tif (p.state === MintQuoteState.PAID) cb(p);\n\t\t\t},\n\t\t\terr,\n\t\t\topts,\n\t\t);\n\t}\n\n\t/**\n\t * Register a callback to be called whenever a melt quote’s state changes.\n\t *\n\t * @param quoteId Melt quote id that should be subscribed to.\n\t * @param callback Callback function that will be called when this melt quote gets paid.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync meltQuoteUpdates(\n\t\tids: string[],\n\t\tcb: (p: MeltQuoteResponse) => void,\n\t\terr: (e: Error) => void,\n\t\topts?: SubscribeOpts,\n\t): Promise<SubscriptionCanceller> {\n\t\tawait this.wallet.mint.connectWebSocket();\n\t\tconst ws = this.wallet.mint.webSocketConnection;\n\t\tif (!ws) throw new Error('Failed to establish WebSocket connection.');\n\n\t\tconst uniq = Array.from(new Set(ids));\n\t\tconst subId = ws.createSubscription({ kind: 'bolt11_melt_quote', filters: uniq }, cb, err);\n\t\tconst cancel = () => ws.cancelSubscription(subId, cb);\n\t\treturn this.withAbort(opts?.signal, cancel);\n\t}\n\n\t/**\n\t * Register a callback to be called when a single melt quote gets paid.\n\t *\n\t * @param quoteIds List of melt quote IDs that should be subscribed to.\n\t * @param callback Callback function that will be called whenever a melt quote state changes.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync meltQuotePaid(\n\t\tid: string,\n\t\tcb: (p: MeltQuoteResponse) => void,\n\t\terr: (e: Error) => void,\n\t\topts?: SubscribeOpts,\n\t): Promise<SubscriptionCanceller> {\n\t\treturn this.meltQuoteUpdates(\n\t\t\t[id],\n\t\t\t(p) => {\n\t\t\t\tif (p.state === MeltQuoteState.PAID) cb(p);\n\t\t\t},\n\t\t\terr,\n\t\t\topts,\n\t\t);\n\t}\n\n\t/**\n\t * Register a callback to be called whenever a subscribed proof state changes.\n\t *\n\t * @param proofs List of proofs that should be subscribed to.\n\t * @param callback Callback function that will be called whenever a proof's state changes.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync proofStateUpdates(\n\t\tproofs: Proof[],\n\t\tcb: (payload: ProofState & { proof: Proof }) => void,\n\t\terr: (e: Error) => void,\n\t\topts?: SubscribeOpts,\n\t): Promise<SubscriptionCanceller> {\n\t\tawait this.wallet.mint.connectWebSocket();\n\t\tconst ws = this.wallet.mint.webSocketConnection;\n\t\tif (!ws) throw new Error('Failed to establish WebSocket connection.');\n\n\t\tconst enc = new TextEncoder();\n\t\tconst proofMap: Record<string, Proof> = {};\n\t\tfor (const p of proofs) {\n\t\t\tconst y = hashToCurve(enc.encode(p.secret)).toHex(true);\n\t\t\tproofMap[y] = p;\n\t\t}\n\t\tconst ys = Object.keys(proofMap);\n\n\t\tconst handler = (payload: ProofState) => {\n\t\t\tcb({ ...payload, proof: proofMap[payload.Y] });\n\t\t};\n\t\tconst subId = ws.createSubscription({ kind: 'proof_state', filters: ys }, handler, err);\n\t\tconst cancel = () => ws.cancelSubscription(subId, handler);\n\n\t\treturn this.withAbort(opts?.signal, cancel);\n\t}\n\n\t/**\n\t * Resolve once a mint quote transitions to PAID, with automatic unsubscription, optional abort\n\t * signal, and optional timeout.\n\t *\n\t * The underlying subscription is always cancelled after resolution or rejection, including on\n\t * timeout or abort.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const ac = new AbortController();\n\t * // Cancel if the user navigates away\n\t * window.addEventListener('beforeunload', () => ac.abort(), { once: true });\n\t *\n\t * try {\n\t * \tconst paid = await wallet.on.onceMintPaid(quoteId, {\n\t * \t\tsignal: ac.signal,\n\t * \t\ttimeoutMs: 60_000,\n\t * \t});\n\t * \tconsole.log('Mint paid, amount', paid.amount);\n\t * } catch (e) {\n\t * \tif ((e as Error).name === 'AbortError') {\n\t * \t\tconsole.log('User aborted');\n\t * \t} else {\n\t * \t\tconsole.error('Mint not paid', e);\n\t * \t}\n\t * }\n\t * ```\n\t *\n\t * @param id Mint quote id to watch.\n\t * @param opts Optional controls.\n\t * @param opts.signal AbortSignal to cancel the wait early.\n\t * @param opts.timeoutMs Milliseconds to wait before rejecting with a timeout error.\n\t * @returns A promise that resolves with the latest `MintQuoteResponse` once PAID.\n\t */\n\tonceMintPaid(\n\t\tid: string,\n\t\topts?: { signal?: AbortSignal; timeoutMs?: number },\n\t): Promise<MintQuoteResponse> {\n\t\treturn this.waitUntilPaid<MintQuoteResponse>(\n\t\t\tthis.mintQuotePaid.bind(this),\n\t\t\tid,\n\t\t\topts,\n\t\t\t'Timeout waiting for mint paid',\n\t\t);\n\t}\n\n\t/**\n\t * Resolve when ANY of several mint quotes is PAID, cancelling the rest.\n\t *\n\t * Subscribes to all distinct ids, resolves with `{ id, quote }` for the first PAID, and cancels\n\t * all remaining subscriptions.\n\t *\n\t * Errors from individual subscriptions are ignored by default so a single noisy stream does not\n\t * abort the whole race. Set `failOnError: true` to reject on the first error instead. If all\n\t * subscriptions error and none paid, the promise rejects with the last seen error.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Race multiple quotes obtained from splitting a large top up\n\t * const { id, quote } = await wallet.on.onceAnyMintPaid(batchQuoteIds, {\n\t * \ttimeoutMs: 120_000,\n\t * });\n\t * console.log('First top up paid', id, quote.preimage?.length);\n\t * ```\n\t *\n\t * @param ids Array of mint quote ids (duplicates are ignored).\n\t * @param opts Optional controls.\n\t * @param opts.signal AbortSignal to cancel the wait early.\n\t * @param opts.timeoutMs Milliseconds to wait before rejecting with a timeout error.\n\t * @param opts.failOnError When true, reject on first error. Default false.\n\t * @returns A promise resolving to the id that won and its `MintQuoteResponse`.\n\t */\n\tonceAnyMintPaid(\n\t\tids: string[],\n\t\topts?: { signal?: AbortSignal; timeoutMs?: number; failOnError?: boolean },\n\t): Promise<{ id: string; quote: MintQuoteResponse }> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst unique = Array.from(new Set(ids));\n\t\t\tconst cancels: Map<string, CancellerLike> = new Map();\n\t\t\tlet to: ReturnType<typeof setTimeout> | null = null;\n\t\t\tlet lastError: unknown = null;\n\t\t\tlet fullyRegistered = false;\n\n\t\t\tconst cleanup = (err?: unknown) => {\n\t\t\t\tfor (const c of cancels.values()) cancelSafely(c);\n\t\t\t\tcancels.clear();\n\t\t\t\tif (to) {\n\t\t\t\t\tclearTimeout(to);\n\t\t\t\t\tto = null;\n\t\t\t\t}\n\t\t\t\tif (opts?.signal) opts.signal.removeEventListener('abort', onAbort);\n\t\t\t\tif (err) reject(normalizeError(err));\n\t\t\t};\n\n\t\t\tconst onAbort = () => cleanup(makeAbortError());\n\n\t\t\tif (opts?.signal) {\n\t\t\t\tif (opts.signal.aborted) return onAbort();\n\t\t\t\topts.signal.addEventListener('abort', onAbort, { once: true });\n\t\t\t}\n\t\t\tif (opts?.timeoutMs && opts.timeoutMs > 0) {\n\t\t\t\tto = setTimeout(\n\t\t\t\t\t() => cleanup(new Error('Timeout waiting for any mint paid')),\n\t\t\t\t\topts.timeoutMs,\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (unique.length === 0) return cleanup(new Error('No quote ids provided'));\n\n\t\t\tfor (const quoteId of unique) {\n\t\t\t\tconst c = this.mintQuotePaid(\n\t\t\t\t\tquoteId,\n\t\t\t\t\t(p) => {\n\t\t\t\t\t\tcleanup();\n\t\t\t\t\t\tresolve({ id: quoteId, quote: p });\n\t\t\t\t\t},\n\t\t\t\t\t(e) => {\n\t\t\t\t\t\tif (opts?.failOnError) {\n\t\t\t\t\t\t\tcleanup(e);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastError = e;\n\t\t\t\t\t\tconst thisCanceller = cancels.get(quoteId);\n\t\t\t\t\t\tif (thisCanceller) {\n\t\t\t\t\t\t\tcancelSafely(thisCanceller);\n\t\t\t\t\t\t\tcancels.delete(quoteId);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Only decide to fail once we've finished installing all subs\n\t\t\t\t\t\tif (fullyRegistered && cancels.size === 0) {\n\t\t\t\t\t\t\tcleanup(lastError ?? new Error('No subscriptions remaining'));\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t\tcancels.set(quoteId, c);\n\t\t\t}\n\t\t\tfullyRegistered = true;\n\t\t});\n\t}\n\n\t/**\n\t * Resolve once a melt quote transitions to PAID, with automatic unsubscription, optional abort\n\t * signal, and optional timeout.\n\t *\n\t * Mirrors onceMintPaid, but for melts.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * try {\n\t * \tconst paid = await wallet.on.onceMeltPaid(meltId, { timeoutMs: 45_000 });\n\t * \tconsole.log('Invoice paid by mint, paid msat', paid.paid ?? 0);\n\t * } catch (e) {\n\t * \tconsole.error('Payment did not complete in time', e);\n\t * }\n\t * ```\n\t *\n\t * @param id Melt quote id to watch.\n\t * @param opts Optional controls.\n\t * @param opts.signal AbortSignal to cancel the wait early.\n\t * @param opts.timeoutMs Milliseconds to wait before rejecting with a timeout error.\n\t * @returns A promise that resolves with the `MeltQuoteResponse` once PAID.\n\t */\n\tonceMeltPaid(\n\t\tid: string,\n\t\topts?: { signal?: AbortSignal; timeoutMs?: number },\n\t): Promise<MeltQuoteResponse> {\n\t\treturn this.waitUntilPaid<MeltQuoteResponse>(\n\t\t\tthis.meltQuotePaid.bind(this),\n\t\t\tid,\n\t\t\topts,\n\t\t\t'Timeout waiting for melt paid',\n\t\t);\n\t}\n\n\t/**\n\t * Async iterable that yields proof state updates for the provided proofs.\n\t *\n\t * Adds a bounded buffer option:\n\t *\n\t * - If `maxBuffer` is set and the queue is full when a new payload arrives, either drop the oldest\n\t *   queued payload (`drop: 'oldest'`, default) or the incoming payload (`drop: 'newest'`). In\n\t *   both cases `onDrop` is invoked with the dropped payload.\n\t *\n\t * The stream ends and cleans up on abort or on the wallet error callback. Errors from the wallet\n\t * are treated as a graceful end for this iterator.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const ac = new AbortController();\n\t * try {\n\t * \tfor await (const update of wallet.on.proofStatesStream(myProofs)) {\n\t * \t\tif (update.state === CheckStateEnum.SPENT) {\n\t * \t\t\tconsole.warn('Spent proof', update.proof.id);\n\t * \t\t}\n\t * \t}\n\t * } catch (e) {\n\t * \tif ((e as Error).name !== 'AbortError') {\n\t * \t\tconsole.error('Stream error', e);\n\t * \t}\n\t * }\n\t * ```\n\t *\n\t * @param proofs The proofs to subscribe to. Only `secret` is required.\n\t * @param opts Optional controls.\n\t * @param opts.signal AbortSignal that stops the stream when aborted.\n\t * @param opts.maxBuffer Maximum number of queued items before applying the drop strategy.\n\t * @param opts.drop Overflow strategy when `maxBuffer` is reached, 'oldest' | 'newest'. Default\n\t *   'oldest'.\n\t * @param opts.onDrop Callback invoked with the payload that was dropped.\n\t * @returns An async iterable of update payloads.\n\t */\n\tproofStatesStream<T = unknown>(\n\t\tproofs: Proof[],\n\t\topts?: {\n\t\t\tsignal?: AbortSignal;\n\t\t\tmaxBuffer?: number;\n\t\t\tdrop?: 'oldest' | 'newest';\n\t\t\tonDrop?: (payload: T) => void;\n\t\t},\n\t): AsyncIterable<T> {\n\t\treturn async function* (this: WalletEvents) {\n\t\t\tconst queue: T[] = [];\n\t\t\tlet done = false;\n\t\t\tlet notify: (() => void) | null = null;\n\n\t\t\tconst max = opts?.maxBuffer && opts.maxBuffer > 0 ? opts.maxBuffer : Infinity;\n\t\t\tconst dropMode: 'oldest' | 'newest' = opts?.drop ?? 'oldest';\n\n\t\t\tconst wake = () => {\n\t\t\t\tconst n = notify;\n\t\t\t\tnotify = null;\n\t\t\t\tif (n) n();\n\t\t\t};\n\n\t\t\tconst push = (payload: T) => {\n\t\t\t\tif (queue.length >= max) {\n\t\t\t\t\tif (dropMode === 'oldest') {\n\t\t\t\t\t\tconst dropped = queue.shift();\n\t\t\t\t\t\tif (dropped !== undefined) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\topts?.onDrop?.(dropped);\n\t\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t\t/* noop */\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqueue.push(payload);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\topts?.onDrop?.(payload);\n\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t/* noop */\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn; // drop newest\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push(payload);\n\t\t\t\t}\n\t\t\t\twake();\n\t\t\t};\n\n\t\t\tconst cancelP: Promise<SubscriptionCanceller> = this.proofStateUpdates(\n\t\t\t\tproofs,\n\t\t\t\t(payload: ProofState & { proof: Proof }) => {\n\t\t\t\t\t// Accept wallet payload type and expose as generic T to consumer\n\t\t\t\t\tpush(payload as unknown as T);\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\tdone = true;\n\t\t\t\t\twake();\n\t\t\t\t},\n\t\t\t\t{ signal: opts?.signal },\n\t\t\t);\n\n\t\t\tconst onAbort = () => {\n\t\t\t\tdone = true;\n\t\t\t\twake();\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\tif (opts?.signal) {\n\t\t\t\t\tif (opts.signal.aborted) onAbort();\n\t\t\t\t\telse opts.signal.addEventListener('abort', onAbort, { once: true });\n\t\t\t\t}\n\t\t\t\twhile (!done || queue.length) {\n\t\t\t\t\twhile (queue.length) yield queue.shift()!;\n\t\t\t\t\tif (done) break;\n\t\t\t\t\tawait new Promise<void>((resolve) => (notify = resolve));\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tcancelSafely(cancelP);\n\t\t\t\tif (opts?.signal) opts.signal.removeEventListener('abort', onAbort);\n\t\t\t}\n\t\t}.call(this);\n\t}\n\n\t/**\n\t * Create a composite canceller that can collect many subscriptions and dispose them all in one\n\t * call.\n\t *\n\t * Accepts both a `SubscriptionCanceller` and a `Promise<SubscriptionCanceller>`. When the\n\t * composite canceller is called, all collected cancellations are invoked. Errors from individual\n\t * cancellers are caught and ignored.\n\t *\n\t * The returned function also has an `.add()` method to register more cancellers, and a\n\t * `.cancelled` boolean property for debugging.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const cancelAll = wallet.on.group();\n\t * cancelAll.add(wallet.on.mintQuotes(ids, onUpdate, onErr));\n\t * cancelAll.add(asyncSubscribeElsewhere());\n\t *\n\t * // later\n\t * cancelAll(); // disposes everything\n\t * ```\n\t *\n\t * @returns Composite canceller function with `.add()` and `.cancelled` members.\n\t */\n\tgroup(): SubscriptionCanceller & {\n\t\tadd: (c: CancellerLike) => CancellerLike;\n\t\tcancelled: boolean;\n\t} {\n\t\tconst cancels: CancellerLike[] = [];\n\t\tlet cancelled = false;\n\n\t\tconst cancelAll = (() => {\n\t\t\tif (cancelled) return;\n\t\t\tcancelled = true;\n\t\t\twhile (cancels.length) cancelSafely(cancels.pop());\n\t\t}) as SubscriptionCanceller & {\n\t\t\tadd: (c: CancellerLike) => CancellerLike;\n\t\t\tcancelled: boolean;\n\t\t};\n\n\t\tcancelAll.add = (c: CancellerLike) => {\n\t\t\tif (cancelled) {\n\t\t\t\t// already cancelled, immediately dispose newly added subscription\n\t\t\t\tcancelSafely(c);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t\tcancels.push(c);\n\t\t\treturn c;\n\t\t};\n\n\t\tObject.defineProperty(cancelAll, 'cancelled', {\n\t\t\tget: () => cancelled,\n\t\t\tenumerable: true,\n\t\t});\n\n\t\treturn cancelAll;\n\t}\n}\n","import type { CounterSource } from './CounterSource';\n\n/**\n * Developer friendly view of the wallet's deterministic output counters.\n */\nexport class WalletCounters {\n\tconstructor(private readonly src: CounterSource) {}\n\t/**\n\t * Returns the \"next\" counter for a specified keyset.\n\t */\n\tasync peekNext(keysetId: string): Promise<number> {\n\t\tconst r = await this.src.reserve(keysetId, 0);\n\t\treturn r.start;\n\t}\n\n\t/**\n\t * Bumps the counter if it is behind `minNext` (no-op if ahead).\n\t */\n\tasync advanceToAtLeast(keysetId: string, minNext: number): Promise<void> {\n\t\t// Mandatory on CounterSource\n\t\tawait this.src.advanceToAtLeast(keysetId, minNext);\n\t}\n\n\t/**\n\t * Hard-sets the cursor (useful for tests or migrations).\n\t *\n\t * @throws If the CounterSource does not support setNext()\n\t */\n\tasync setNext(keysetId: string, next: number): Promise<void> {\n\t\t// Optional capability\n\t\tif (typeof this.src.setNext === 'function') {\n\t\t\tawait this.src.setNext(keysetId, next);\n\t\t\treturn;\n\t\t}\n\t\tthrow new Error('CounterSource does not support setNext()');\n\t}\n\t/**\n\t * Returns the current \"next\" per keyset (what will be reserved next).\n\t *\n\t * @throws If the CounterSource does not support snapshot()\n\t */\n\tasync snapshot(): Promise<Record<string, number>> {\n\t\t// Optional capability\n\t\tif (typeof this.src.snapshot === 'function') {\n\t\t\treturn await this.src.snapshot();\n\t\t}\n\t\tthrow new Error('CounterSource does not support snapshot()');\n\t}\n}\n","/**\n * Entries of CheckStateResponse with state of the proof.\n */\nexport type ProofState = {\n\tY: string;\n\tstate: CheckStateEnum;\n\twitness: string | null;\n};\n\n/**\n * Enum for the state of a proof.\n */\nexport const CheckStateEnum = {\n\tUNSPENT: 'UNSPENT',\n\tPENDING: 'PENDING',\n\tSPENT: 'SPENT',\n} as const;\nexport type CheckStateEnum = (typeof CheckStateEnum)[keyof typeof CheckStateEnum];\n","/**\n * Cashu Wallet Class.\n *\n * @remarks\n * This is the instantiation point for the Cashu-TS library.\n */\n\nimport {\n\ttype MeltBlanks,\n\ttype OutputType,\n\ttype OutputConfig,\n\ttype SendConfig,\n\ttype SendOfflineConfig,\n\ttype ReceiveConfig,\n\ttype MintProofsConfig,\n\ttype MeltProofsConfig,\n\ttype MeltPayload,\n\ttype MeltQuotePayload,\n\ttype MintPayload,\n\ttype MintQuotePayload,\n\ttype MPPOption,\n\ttype MeltQuoteOptions,\n\ttype SwapTransaction,\n\ttype Bolt12MintQuotePayload,\n\ttype SwapPayload,\n\ttype MeltProofsResponse,\n\ttype SendResponse,\n\ttype RestoreConfig,\n\ttype SecretsPolicy,\n} from './types';\nimport {\n\ttype CounterSource,\n\tEphemeralCounterSource,\n\ttype OperationCounters,\n\ttype CounterRange,\n} from './CounterSource';\n\nimport { signMintQuote, signP2PKProofs, hashToCurve } from '../crypto';\nimport { Mint } from '../mint';\nimport { MintInfo } from '../model/MintInfo';\nimport { KeyChain } from './KeyChain';\nimport { type Keyset } from './Keyset';\nimport { WalletOps } from './WalletOps';\nimport { WalletEvents } from './WalletEvents';\nimport { WalletCounters } from './WalletCounters';\nimport { selectProofsRGLI, type SelectProofs } from './SelectProofs';\nimport { type Logger, NULL_LOGGER, fail, failIf, failIfNullish, safeCallback } from '../logger';\n\n// shared primitives and options\nimport type { Proof } from '../model/types/proof';\nimport type { Token } from '../model/types/token';\nimport type { SerializedBlindedSignature } from '../model/types/blinded';\nimport { CheckStateEnum, type ProofState } from '../model/types/proof-state';\nimport type { MintKeys, MintKeyset } from '../model/types/keyset';\n\n// mint wire DTOs and enums\nimport type {\n\tGetInfoResponse,\n\tMintQuoteResponse,\n\tMeltQuoteResponse,\n\tPartialMintQuoteResponse,\n\tPartialMeltQuoteResponse,\n\tLockedMintQuoteResponse,\n\tBolt12MintQuoteResponse,\n\tBolt12MeltQuoteResponse,\n} from '../mint/types';\n\n// model helpers\nimport { OutputData, type OutputDataLike } from '../model/OutputData';\n\nimport {\n\tgetDecodedToken,\n\tgetKeepAmounts,\n\thasValidDleq,\n\tsplitAmount,\n\tsumProofs,\n\tsanitizeUrl,\n} from '../utils';\nimport { type AuthProvider } from '../auth/AuthProvider';\n\nconst PENDING_KEYSET_ID = '__PENDING__';\n\n/**\n * Class that represents a Cashu wallet.\n *\n * @remarks\n * This class should act as the entry point for this library. Can be instantiated with a mint\n * instance or mint url.\n * @example\n *\n * ```typescript\n * import { Wallet } from '@cashu/cashu-ts';\n * const wallet = new Wallet('http://localhost:3338', { unit: 'sat' });\n * await wallet.loadMint(); // Initialize mint info, keysets, and keys\n * // Wallet is now ready to use, eg:\n * const proofs = [...]; // your array of unspent proofs\n * const { keep, send } = await wallet.send(32, proofs);\n * ```\n */\nclass Wallet {\n\t/**\n\t * Mint instance - allows direct calls to the mint.\n\t */\n\tpublic readonly mint: Mint;\n\t/**\n\t * KeyChain instance - contains wallet keysets/keys.\n\t */\n\tpublic readonly keyChain: KeyChain;\n\t/**\n\t * Entry point for the builder.\n\t *\n\t * @example\n\t *\n\t *     const { keep, send } = await wallet.ops\n\t *     \t.send(5, proofs)\n\t *     \t.asDeterministic() // counter: 0 = auto\n\t *     \t.keepAsRandom()\n\t *     \t.includeFees(true)\n\t *     \t.run();\n\t *\n\t *     const proofs = await wallet.ops\n\t *     \t.receive(token)\n\t *     \t.asDeterministic()\n\t *     \t.keyset(wallet.keysetId)\n\t *     \t.run();\n\t */\n\tpublic readonly ops: WalletOps;\n\t/**\n\t * Convenience wrapper for events.\n\t */\n\tpublic readonly on: WalletEvents;\n\t/**\n\t * Developer-friendly counters API.\n\t */\n\tpublic readonly counters: WalletCounters;\n\tprivate _seed: Uint8Array | undefined = undefined;\n\tprivate _unit = 'sat';\n\tprivate _mintInfo: MintInfo | undefined = undefined;\n\tprivate _denominationTarget = 3;\n\tprivate _secretsPolicy: SecretsPolicy = 'auto';\n\tprivate _counterSource: CounterSource;\n\tprivate _boundKeysetId: string = PENDING_KEYSET_ID;\n\tprivate _selectProofs: SelectProofs;\n\tprivate _logger: Logger;\n\n\t/**\n\t * Create a wallet for a given mint and unit. Call `loadMint` before use.\n\t *\n\t * Binding, if `options.keysetId` is omitted, the wallet binds to the cheapest active keyset for\n\t * this unit during `loadMint`. The keychain only loads keysets for this unit.\n\t *\n\t * Caching, to preload, provide both `keysets` and `keys`, otherwise the cache is ignored.\n\t *\n\t * Deterministic secrets, pass `bip39seed` and optionally `secretsPolicy`. Deterministic outputs\n\t * reserve counters from `counterSource`, or an ephemeral in memory source if not supplied.\n\t * `initialCounter` applies only with a supplied `keysetId` and the ephemeral source.\n\t *\n\t * Splitting, `denominationTarget` guides proof splits, default is 3. Override coin selection with\n\t * `selectProofs` if needed. Logging defaults to a null logger.\n\t *\n\t * @param mint Mint instance or URL.\n\t * @param options Optional settings.\n\t * @param options.unit Wallet unit, default 'sat'.\n\t * @param options.keysetId Bind to this keyset id, else bind on `loadMint`.\n\t * @param options.bip39seed BIP39 seed for deterministic secrets.\n\t * @param options.secretsPolicy Secrets policy, default 'auto'.\n\t * @param options.counterSource Counter source for deterministic outputs. If provided, this takes\n\t *   precedence over counterInit. Use when you need persistence across processes or devices.\n\t * @param options.counterInit Seed values for the built-in EphemeralCounterSource. Ignored if\n\t *   counterSource is also provided.\n\t * @param options.keys Cached keys for this unit, only used when `keysets` is also provided.\n\t * @param options.keysets Cached keysets for this unit, only used when `keys` is also provided.\n\t * @param options.mintInfo Optional cached mint info.\n\t * @param options.denominationTarget Target proofs per denomination, default 3.\n\t * @param options.selectProofs Custom proof selection function.\n\t * @param options.logger Logger instance, default null logger.\n\t */\n\tconstructor(\n\t\tmint: Mint | string,\n\t\toptions?: {\n\t\t\tunit?: string;\n\t\t\tauthProvider?: AuthProvider;\n\t\t\tkeysetId?: string; // if omitted, wallet binds to cheapest in loadMint\n\t\t\tbip39seed?: Uint8Array;\n\t\t\tsecretsPolicy?: SecretsPolicy; // optional, auto\n\t\t\tcounterSource?: CounterSource; // optional, otherwise ephemeral\n\t\t\tcounterInit?: Record<string, number>; // optional, starting \"next\" per keyset\n\t\t\tkeys?: MintKeys[] | MintKeys;\n\t\t\tkeysets?: MintKeyset[];\n\t\t\tmintInfo?: GetInfoResponse;\n\t\t\tdenominationTarget?: number;\n\t\t\tselectProofs?: SelectProofs; // optional override\n\t\t\tlogger?: Logger;\n\t\t},\n\t) {\n\t\tthis.ops = new WalletOps(this);\n\t\tthis.on = new WalletEvents(this);\n\t\tthis._logger = options?.logger ?? NULL_LOGGER; // init early (seed can throw)\n\t\tthis._selectProofs = options?.selectProofs ?? selectProofsRGLI; // vital\n\t\tthis.mint =\n\t\t\ttypeof mint === 'string'\n\t\t\t\t? new Mint(mint, { authProvider: options?.authProvider, logger: this._logger })\n\t\t\t\t: mint;\n\t\tthis._unit = options?.unit ?? this._unit;\n\t\tthis._boundKeysetId = options?.keysetId ?? this._boundKeysetId;\n\t\tif (options?.bip39seed) {\n\t\t\tthis.failIf(\n\t\t\t\t!(options.bip39seed instanceof Uint8Array),\n\t\t\t\t'bip39seed must be a valid Uint8Array',\n\t\t\t\t{\n\t\t\t\t\tbip39seed: options.bip39seed,\n\t\t\t\t},\n\t\t\t);\n\t\t\tthis._seed = options.bip39seed;\n\t\t}\n\t\tthis._secretsPolicy = options?.secretsPolicy ?? this._secretsPolicy;\n\t\tif (options?.counterSource) {\n\t\t\tthis._counterSource = options.counterSource;\n\t\t} else {\n\t\t\tthis._counterSource = new EphemeralCounterSource(options?.counterInit);\n\t\t}\n\t\tthis.counters = new WalletCounters(this._counterSource);\n\t\tthis.keyChain = new KeyChain(this.mint, this._unit, options?.keysets, options?.keys);\n\t\tthis._mintInfo = options?.mintInfo ? new MintInfo(options.mintInfo) : this._mintInfo;\n\t\tthis._denominationTarget = options?.denominationTarget ?? this._denominationTarget;\n\t}\n\n\t// Convenience wrappers for \"log and throw\"\n\tprivate fail(message: string, context?: Record<string, unknown>): never {\n\t\treturn fail(message, this._logger, context);\n\t}\n\tprivate failIf(\n\t\tcondition: boolean,\n\t\tmessage: string,\n\t\tcontext?: Record<string, unknown>,\n\t): asserts condition is false {\n\t\treturn failIf(condition, message, this._logger, context);\n\t}\n\tprivate failIfNullish<T>(\n\t\tvalue: T,\n\t\tmessage: string,\n\t\tcontext?: Record<string, unknown>,\n\t): asserts value is Exclude<T, null | undefined> {\n\t\treturn failIfNullish(value, message, this._logger, context);\n\t}\n\tprivate safeCallback<T>(\n\t\tcb: ((p: T) => void) | undefined,\n\t\tpayload: T,\n\t\tcontext?: Record<string, unknown>,\n\t): void {\n\t\tsafeCallback(cb, payload, this._logger, context);\n\t}\n\n\t/**\n\t * Load mint information, keysets, and keys. Must be called before using other methods.\n\t *\n\t * @param forceRefresh If true, re-fetches data even if cached.\n\t * @throws If fetching mint info, keysets, or keys fails.\n\t */\n\tasync loadMint(forceRefresh?: boolean): Promise<void> {\n\t\tconst promises = [];\n\n\t\t// Load mint info\n\t\tif (!this._mintInfo || forceRefresh) {\n\t\t\tpromises.push(\n\t\t\t\tthis.mint.getInfo().then((info) => {\n\t\t\t\t\tthis._mintInfo = new MintInfo(info);\n\t\t\t\t\treturn null;\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\t// Load KeyChain\n\t\tpromises.push(this.keyChain.init(forceRefresh).then(() => null));\n\n\t\tawait Promise.all(promises);\n\t\tthis._logger.debug('KeyChain', { keychain: this.keyChain.getCache() });\n\n\t\tif (this._boundKeysetId === PENDING_KEYSET_ID) {\n\t\t\tthis._boundKeysetId = this.keyChain.getCheapestKeyset().id;\n\t\t} else {\n\t\t\t// Ensure the bound id is still present and keyed\n\t\t\tconst k = this.keyChain.getKeyset(this._boundKeysetId);\n\t\t\tthis.failIf(!k.hasKeys, 'Wallet keyset has no keys after refresh', { keyset: k.id });\n\t\t}\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Getters\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * Get the wallet's unit.\n\t *\n\t * @returns The unit (e.g., 'sat').\n\t */\n\tget unit(): string {\n\t\treturn this._unit;\n\t}\n\n\t/**\n\t * Get information about the mint.\n\t *\n\t * @remarks\n\t * Returns cached mint info. Call `loadMint` first to initialize the wallet.\n\t * @returns Mint info.\n\t * @throws If mint info is not initialized.\n\t */\n\tgetMintInfo(): MintInfo {\n\t\tthis.failIfNullish(this._mintInfo, 'Mint info not initialized; call loadMint first');\n\t\treturn this._mintInfo;\n\t}\n\n\t/**\n\t * The keyset ID bound to this wallet instance.\n\t */\n\tget keysetId(): string {\n\t\tthis.failIf(this._boundKeysetId === PENDING_KEYSET_ID, 'Wallet not initialised, call loadMint');\n\t\treturn this._boundKeysetId;\n\t}\n\n\t/**\n\t * Gets the requested keyset or the keyset bound to the wallet.\n\t *\n\t * @remarks\n\t * This method enforces wallet policies. If `id` is omitted, it returns the keyset bound to this\n\t * wallet, including validation that:\n\t *\n\t * - The keyset exists in the keychain,\n\t * - The unit matches the wallet's unit,\n\t * - Keys are loaded for that keyset.\n\t *\n\t * Contrast with `keyChain.getKeyset(id?)`, which, when called without an id, returns the cheapest\n\t * active keyset for the unit, ignoring the wallet binding.\n\t * @param id Optional keyset id to resolve. If omitted, the wallet's bound keyset is used.\n\t * @returns The resolved `Keyset`.\n\t * @throws If the keyset is not found, has no keys, or its unit differs from the wallet.\n\t */\n\tpublic getKeyset(id?: string): Keyset {\n\t\tconst keyset = this.keyChain.getKeyset(id ?? this.keysetId);\n\t\tthis.failIf(keyset.unit !== this._unit, 'Keyset unit does not match wallet unit', {\n\t\t\tkeyset: keyset.id,\n\t\t\tunit: keyset.unit,\n\t\t\twalletUnit: this._unit,\n\t\t});\n\t\tthis.failIf(!keyset.hasKeys, 'Keyset has no keys loaded', { keyset: keyset.id });\n\t\treturn keyset;\n\t}\n\n\tpublic get logger(): Logger {\n\t\treturn this._logger;\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Counters\n\t// -----------------------------------------------------------------\n\n\tprivate async reserveFor(keysetId: string, totalOutputs: number): Promise<CounterRange> {\n\t\tif (totalOutputs <= 0) return { start: 0, count: 0 };\n\t\treturn this._counterSource.reserve(keysetId, totalOutputs);\n\t}\n\n\tprivate countersNeeded(ot: OutputType): number {\n\t\tif (ot.type !== 'deterministic' || ot.counter !== 0) return 0;\n\t\treturn (ot.denominations ?? []).length;\n\t}\n\n\tprivate async addCountersToOutputTypes(\n\t\tkeysetId: string,\n\t\t...outputTypes: OutputType[]\n\t): Promise<{ outputTypes: OutputType[]; used?: OperationCounters }> {\n\t\tconst total = outputTypes.reduce((n, ot) => n + this.countersNeeded(ot), 0);\n\t\tif (total === 0) return { outputTypes };\n\n\t\tconst range = await this.reserveFor(keysetId, total);\n\t\tlet cursor = range.start;\n\n\t\tconst patched = outputTypes.map((ot): OutputType => {\n\t\t\tif (ot.type === 'deterministic' && ot.counter === 0) {\n\t\t\t\tconst need = (ot.denominations ?? []).length;\n\t\t\t\tif (need > 0) {\n\t\t\t\t\tconst patched: typeof ot = { ...ot, counter: cursor };\n\t\t\t\t\tcursor += need;\n\t\t\t\t\treturn patched;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ot;\n\t\t});\n\n\t\t// Fire event after successful reservation (wallet does not await handlers)\n\t\tconst used = {\n\t\t\tkeysetId,\n\t\t\tstart: range.start,\n\t\t\tcount: range.count,\n\t\t\tnext: range.start + range.count,\n\t\t} as OperationCounters;\n\t\tthis.on._emitCountersReserved(used);\n\t\treturn { outputTypes: patched, used };\n\t}\n\n\t/**\n\t * Bind this wallet to a specific keyset id.\n\t *\n\t * @remarks\n\t * This changes the default keyset used by all operations that do not explicitly pass a keysetId.\n\t * The method validates that the keyset exists in the keychain, matches the wallet unit, and has\n\t * keys loaded.\n\t *\n\t * Typical uses:\n\t *\n\t * 1. After loadMint, to pin the wallet to a particular active keyset.\n\t * 2. After a refresh, to rebind deliberately rather than falling back to cheapest.\n\t *\n\t * @param id The keyset identifier to bind to.\n\t * @throws If keyset not found, if it has no keys loaded, or if its unit is not the wallet unit.\n\t */\n\tpublic bindKeyset(id: string): void {\n\t\tconst ks = this.keyChain.getKeyset(id);\n\t\tthis.failIf(ks.unit !== this._unit, 'Keyset unit does not match wallet unit', {\n\t\t\tkeyset: ks.id,\n\t\t\tunit: ks.unit,\n\t\t\twalletUnit: this._unit,\n\t\t});\n\t\tthis.failIf(!ks.hasKeys, 'Keyset has no keys loaded', { keyset: ks.id });\n\t\tthis._boundKeysetId = ks.id;\n\t\tthis._logger.debug('Wallet bound to keyset', {\n\t\t\tkeysetId: ks.id,\n\t\t\tunit: ks.unit,\n\t\t\tfeePPK: ks.fee,\n\t\t});\n\t}\n\n\t/**\n\t * Creates a new Wallet bound to a different keyset, sharing the same CounterSource.\n\t *\n\t * Use this to operate on multiple keysets concurrently without mutating your original wallet.\n\t * Counters remain monotonic across instances because the same CounterSource is reused.\n\t *\n\t * Do NOT pass a fresh CounterSource for the same seed unless you know exactly why. Reusing\n\t * counters can recreate secrets that a mint will reject.\n\t *\n\t * @param id The keyset identifier to bind to.\n\t * @throws If keyset not found, if it has no keys loaded, or if its unit is not the wallet unit.\n\t */\n\tpublic withKeyset(id: string, opts?: { counterSource?: CounterSource }): Wallet {\n\t\treturn new Wallet(this.mint, {\n\t\t\tkeysetId: id,\n\t\t\tbip39seed: this._seed,\n\t\t\tsecretsPolicy: this._secretsPolicy,\n\t\t\tlogger: this._logger,\n\t\t\tcounterSource: opts?.counterSource ?? this._counterSource,\n\t\t\t...this.keyChain.getCache(),\n\t\t});\n\t}\n\n\t/**\n\t * Returns the default OutputType for this wallet, based on its configured secrets policy\n\t * (options?.secretsPolicy) and seed state.\n\t *\n\t * - If the secrets policy is 'random', returns { type: 'random' }.\n\t * - If the policy is 'deterministic', requires a seed and returns { type: 'deterministic', counter:\n\t *   0 }. Counter 0 is a flag meaning \"auto-increment from current state\".\n\t * - If no explicit policy is set, falls back to:\n\t *\n\t *   - Deterministic if a seed is present.\n\t *   - Random if no seed is present.\n\t *\n\t * @returns An OutputType object describing the default output strategy.\n\t * @throws Error if the policy is 'deterministic' but no seed has been set.\n\t */\n\tpublic defaultOutputType(): OutputType {\n\t\tif (this._secretsPolicy === 'random') return { type: 'random' };\n\t\tif (this._secretsPolicy === 'deterministic') {\n\t\t\tthis.failIfNullish(this._seed, 'Deterministic policy requires a seed');\n\t\t\treturn { type: 'deterministic', counter: 0 }; // 0 = auto flag\n\t\t}\n\t\treturn this._seed ? { type: 'deterministic', counter: 0 } : { type: 'random' };\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Output Creation\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * Configures output denominations with fee adjustments and optimization.\n\t *\n\t * @remarks\n\t * If 'custom' outputType, data outputs MUST sum to the amount. Other outputTypes may supply\n\t * denominations. If no denominations are passed in, they will be calculated based on proofsWeHave\n\t * or the default split. If partial denominations are passed in, the balance will be added using\n\t * default split. Additional denominations to cover fees will then be added if required.\n\t * @param amount The total amount for outputs.\n\t * @param keyset The mint keyset.\n\t * @param outputType The output configuration.\n\t * @param includeFees Whether to include swap fees in the output amount.\n\t * @param proofsWeHave Optional proofs for optimizing denomination splitting.\n\t * @returns OutputType with required denominations.\n\t */\n\tprivate configureOutputs(\n\t\tamount: number,\n\t\tkeyset: Keyset,\n\t\toutputType: OutputType,\n\t\tincludeFees: boolean = false,\n\t\tproofsWeHave: Proof[] = [],\n\t): OutputType {\n\t\tlet newAmount = amount;\n\n\t\t// Custom outputs don't have automatic optimizations or fee inclusion)\n\t\tif (outputType.type === 'custom') {\n\t\t\tthis.failIf(includeFees, 'The custom OutputType does not support automatic fee inclusion');\n\n\t\t\t// Validate sum early, as no denominations to fill\n\t\t\tconst customTotal = OutputData.sumOutputAmounts(outputType.data);\n\t\t\tthis.failIf(\n\t\t\t\tcustomTotal !== amount,\n\t\t\t\t`Custom output data total (${customTotal}) does not match amount (${amount})`,\n\t\t\t);\n\t\t\treturn outputType;\n\t\t}\n\n\t\t// Start with any denominations provided.\n\t\t// Note: These MAY be partial (\"give me a [16,8], anything for the rest\")\n\t\t// We will complete the denomination set before we are done.\n\t\tlet denominations = outputType.denominations ?? [];\n\n\t\t// If no denominations, but proofsWeHave was provided - optimize\n\t\t// to get around _denominationTarget proofs of each denomination.\n\t\tif (denominations.length === 0 && proofsWeHave.length > 0) {\n\t\t\tdenominations = getKeepAmounts(\n\t\t\t\tproofsWeHave,\n\t\t\t\tnewAmount,\n\t\t\t\tkeyset.keys,\n\t\t\t\tthis._denominationTarget,\n\t\t\t);\n\t\t}\n\n\t\t// Fill in any missing denominations with default split.\n\t\t// NOTE: If we have to fill, the result will be in ASC order.\n\t\t// Original order is only maintained for exact denomination sets.\n\t\tdenominations = splitAmount(newAmount, keyset.keys, denominations);\n\n\t\t// If includeFees, we create additional output amounts to cover the\n\t\t// fee the receiver will pay when they spend the proofs (ie sender pays fees)\n\t\tif (includeFees) {\n\t\t\tlet receiveFee = this.getFeesForKeyset(denominations.length, keyset.id);\n\t\t\tlet receiveFeeAmounts = splitAmount(receiveFee, keyset.keys);\n\t\t\twhile (\n\t\t\t\tthis.getFeesForKeyset(denominations.length + receiveFeeAmounts.length, keyset.id) >\n\t\t\t\treceiveFee\n\t\t\t) {\n\t\t\t\treceiveFee++;\n\t\t\t\treceiveFeeAmounts = splitAmount(receiveFee, keyset.keys);\n\t\t\t}\n\t\t\tnewAmount += receiveFee;\n\t\t\tdenominations = [...denominations, ...receiveFeeAmounts];\n\t\t}\n\t\treturn { ...outputType, denominations };\n\t}\n\n\t/**\n\t * Sum total implied by a prepared OutputType. Note: Empty denomination is valid (e.g: zero\n\t * change).\n\t */\n\tprivate preparedTotal(ot: OutputType): number {\n\t\tif (ot.type === 'custom') return OutputData.sumOutputAmounts(ot.data);\n\t\tconst denoms = ot.denominations ?? [];\n\t\treturn denoms.reduce((a, b) => a + b, 0);\n\t}\n\n\t/**\n\t * Generates blinded messages based on the specified output type.\n\t *\n\t * @param amount The total amount for outputs.\n\t * @param keyset The mint keys.\n\t * @param outputType The output configuration.\n\t * @returns Prepared output data.\n\t */\n\tprivate createOutputData(\n\t\tamount: number,\n\t\tkeyset: Keyset,\n\t\toutputType: OutputType,\n\t): OutputDataLike[] {\n\t\t// we can accept zero (for blanks) or positive values\n\t\tthis.failIf(amount < 0, 'Amount was negative', { amount });\n\t\tif (\n\t\t\t// 'custom' OutputType has no denominations. Every other OutputType does.\n\t\t\t// so let's sanity check those were filled properly (eg: configureOutputs)\n\t\t\t'custom' != outputType.type &&\n\t\t\toutputType.denominations &&\n\t\t\toutputType.denominations.length > 0\n\t\t) {\n\t\t\tconst splitSum = outputType.denominations.reduce((sum, a) => sum + a, 0);\n\t\t\tthis.failIf(splitSum !== amount, 'Denominations do not sum to the expected amount', {\n\t\t\t\tsplitSum,\n\t\t\t\texpected: amount,\n\t\t\t});\n\t\t}\n\t\tlet outputData: OutputDataLike[];\n\t\tswitch (outputType.type) {\n\t\t\tcase 'random':\n\t\t\t\toutputData = OutputData.createRandomData(amount, keyset, outputType.denominations);\n\t\t\t\tbreak;\n\t\t\tcase 'deterministic':\n\t\t\t\tthis.failIfNullish(\n\t\t\t\t\tthis._seed,\n\t\t\t\t\t'Deterministic outputs require a seed configured in the wallet',\n\t\t\t\t);\n\t\t\t\toutputData = OutputData.createDeterministicData(\n\t\t\t\t\tamount,\n\t\t\t\t\tthis._seed,\n\t\t\t\t\toutputType.counter,\n\t\t\t\t\tkeyset,\n\t\t\t\t\toutputType.denominations,\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'p2pk':\n\t\t\t\toutputData = OutputData.createP2PKData(\n\t\t\t\t\toutputType.options,\n\t\t\t\t\tamount,\n\t\t\t\t\tkeyset,\n\t\t\t\t\toutputType.denominations,\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'factory': {\n\t\t\t\tconst factorySplit = splitAmount(amount, keyset.keys, outputType.denominations);\n\t\t\t\toutputData = factorySplit.map((a) => outputType.factory(a, keyset));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'custom': {\n\t\t\t\toutputData = outputType.data;\n\t\t\t\tconst customTotal = OutputData.sumOutputAmounts(outputData);\n\t\t\t\tthis.failIf(\n\t\t\t\t\tcustomTotal !== amount,\n\t\t\t\t\t`Custom output data total (${customTotal}) does not match amount (${amount})`,\n\t\t\t\t);\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthis.fail('Invalid OutputType');\n\t\t\t}\n\t\t}\n\t\treturn outputData;\n\t}\n\n\t/**\n\t * Creates a swap transaction with sorted outputs for privacy. This prevents a mint working out\n\t * which proofs will be sent or kept.\n\t *\n\t * @param inputs Prepared input proofs.\n\t * @param keepOutputs Outputs to keep (change or receiver's proofs).\n\t * @param sendOutputs Outputs to send (optional, default empty for receive/mint).\n\t * @returns Swap transaction with payload and metadata for processing signatures.\n\t */\n\tprivate createSwapTransaction(\n\t\tinputs: Proof[],\n\t\tkeepOutputs: OutputDataLike[],\n\t\tsendOutputs: OutputDataLike[] = [],\n\t): SwapTransaction {\n\t\t// Prepare inputs for mint\n\t\tinputs = this._prepareInputsForMint(inputs);\n\n\t\t// Sort ASC by amount for privacy, but keep indices to return order afterwards\n\t\tconst mergedBlindingData = [...keepOutputs, ...sendOutputs];\n\t\tconst indices = mergedBlindingData\n\t\t\t.map((_, i) => i)\n\t\t\t.sort(\n\t\t\t\t(a, b) =>\n\t\t\t\t\tmergedBlindingData[a].blindedMessage.amount - mergedBlindingData[b].blindedMessage.amount,\n\t\t\t);\n\t\tconst keepVector: boolean[] = [\n\t\t\t...Array.from({ length: keepOutputs.length }, () => true),\n\t\t\t...Array.from({ length: sendOutputs.length }, () => false),\n\t\t];\n\t\tconst sortedOutputData: OutputDataLike[] = indices.map((i) => mergedBlindingData[i]);\n\t\tconst sortedKeepVector: boolean[] = indices.map((i) => keepVector[i]);\n\t\tconst outputs = sortedOutputData.map((d) => d.blindedMessage);\n\t\tthis._logger.debug('createSwapTransaction:', {\n\t\t\tindices,\n\t\t\tsortedKeepVector,\n\t\t\t// outputs, // <-- removed for security\n\t\t});\n\t\tconst payload: SwapPayload = {\n\t\t\tinputs,\n\t\t\toutputs,\n\t\t};\n\t\treturn {\n\t\t\tpayload,\n\t\t\toutputData: sortedOutputData,\n\t\t\tkeepVector: sortedKeepVector,\n\t\t\tsortedIndices: indices,\n\t\t};\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Send and Receive\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * Receive a token (swaps with mint for new proofs)\n\t *\n\t * @example\n\t *\n\t * ```typescript\n\t * const result = await wallet.receive(\n\t * \ttoken,\n\t * \t{ includeFees: true },\n\t * \t{ type: 'deterministic', counter: 0 },\n\t * );\n\t * ```\n\t *\n\t * @param token Token string or decoded token.\n\t * @param config Optional receive config.\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns Newly minted proofs.\n\t */\n\tasync receive(\n\t\ttoken: Token | string,\n\t\tconfig?: ReceiveConfig,\n\t\toutputType?: OutputType,\n\t): Promise<Proof[]> {\n\t\tconst { keysetId, privkey, requireDleq, proofsWeHave, onCountersReserved } = config || {};\n\t\toutputType = outputType ?? this.defaultOutputType(); // Fallback to policy\n\n\t\t// Decode and validate token\n\t\tconst decodedToken = typeof token === 'string' ? this.decodeToken(token) : token;\n\t\tconst tokenMintUrl = sanitizeUrl(decodedToken.mint);\n\t\tthis.failIf(tokenMintUrl !== this.mint.mintUrl, 'Token belongs to a different mint', {\n\t\t\ttoken: tokenMintUrl,\n\t\t\twallet: this.mint.mintUrl,\n\t\t});\n\t\tthis.failIf(decodedToken.unit !== this._unit, 'Token is not in wallet unit', {\n\t\t\ttoken: decodedToken.unit,\n\t\t\twallet: this._unit,\n\t\t});\n\n\t\t// Extract token proofs\n\t\tlet proofs: Proof[] = [];\n\t\t({ proofs } = decodedToken);\n\t\tconst totalAmount = sumProofs(proofs);\n\t\tif (totalAmount === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// Sign proofs if needed\n\t\tif (privkey) {\n\t\t\tproofs = this.signP2PKProofs(proofs, privkey);\n\t\t}\n\n\t\t// Check DLEQs if needed\n\t\tconst keyset = this.getKeyset(keysetId); // specified or wallet keyset\n\t\tif (requireDleq) {\n\t\t\tfor (const p of proofs) {\n\t\t\t\tconst ks = this.keyChain.getKeyset(p.id);\n\t\t\t\tif (!hasValidDleq(p, ks)) {\n\t\t\t\t\tthis.fail('Token contains proofs with invalid or missing DLEQ');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Shape receive output type and denominations\n\t\tconst netAmount = totalAmount - this.getFeesForProofs(proofs);\n\t\tlet receiveOT = this.configureOutputs(\n\t\t\tnetAmount,\n\t\t\tkeyset,\n\t\t\toutputType,\n\t\t\tfalse, // includeFees is not applicable for receive\n\t\t\tproofsWeHave,\n\t\t);\n\n\t\t// Assign counter atomically if OutputType is deterministic\n\t\t// and the counter is zero (auto-assign)\n\t\tconst autoCounters = await this.addCountersToOutputTypes(keyset.id, receiveOT);\n\t\t[receiveOT] = autoCounters.outputTypes;\n\t\tif (autoCounters.used) {\n\t\t\tthis.safeCallback(onCountersReserved, autoCounters.used, { op: 'receive' });\n\t\t}\n\t\tthis._logger.debug('receive counter', { counter: autoCounters.used, receiveOT });\n\n\t\t// Create outputs and execute swap\n\t\tconst outputs = this.createOutputData(this.preparedTotal(receiveOT), keyset, receiveOT);\n\t\tconst swapTransaction = this.createSwapTransaction(proofs, outputs, []);\n\t\tconst { signatures } = await this.mint.swap(swapTransaction.payload);\n\n\t\t// Construct and return proofs\n\t\tconst proofsReceived = swapTransaction.outputData.map((d, i) =>\n\t\t\td.toProof(signatures[i], keyset),\n\t\t);\n\t\tconst orderedProofs: Proof[] = [];\n\t\tswapTransaction.sortedIndices.forEach((s, o) => {\n\t\t\torderedProofs[s] = proofsReceived[o];\n\t\t});\n\t\tthis._logger.debug('RECEIVE COMPLETED', { amounts: orderedProofs.map((p) => p.amount) });\n\t\treturn orderedProofs;\n\t}\n\n\t/**\n\t * Sends proofs of a given amount from provided proofs.\n\t *\n\t * @remarks\n\t * If proofs are P2PK-locked to your public key, call signP2PKProofs first to sign them. The\n\t * default config uses exact match selection, and does not includeFees or requireDleq. Because the\n\t * send is offline, the user will unlock the signed proofs when they receive them online.\n\t * @param amount Amount to send.\n\t * @param proofs Array of proofs (must sum >= amount; pre-sign if P2PK-locked).\n\t * @param config Optional parameters for the send.\n\t * @returns SendResponse with keep/send proofs.\n\t * @throws Throws if the send cannot be completed offline.\n\t */\n\tsendOffline(amount: number, proofs: Proof[], config?: SendOfflineConfig): SendResponse {\n\t\tconst { requireDleq = false, includeFees = false, exactMatch = true } = config || {};\n\t\tif (requireDleq) {\n\t\t\t// Only use proofs that have a DLEQ\n\t\t\tproofs = proofs.filter((p: Proof) => p.dleq != undefined);\n\t\t}\n\t\tthis.failIf(sumProofs(proofs) < amount, 'Not enough funds available to send');\n\n\t\tconst { keep, send } = this.selectProofsToSend(proofs, amount, includeFees, exactMatch);\n\t\t// Ensure witnesses are serialized, strip DLEQ if not required\n\t\tconst sendPrepared = this._prepareInputsForMint(send, requireDleq);\n\t\treturn { keep, send: sendPrepared };\n\t}\n\n\t/**\n\t * Send proofs with online swap if necessary.\n\t *\n\t * @remarks\n\t * If proofs are P2PK-locked to your public key, call signP2PKProofs first to sign them.\n\t * @example\n\t *\n\t * ```typescript\n\t * // Simple send\n\t * const result = await wallet.send(5, proofs);\n\t *\n\t * // With a SendConfig\n\t * const result = await wallet.send(5, proofs, { includeFees: true });\n\t *\n\t * // With Custom output configuration\n\t * const customConfig: OutputConfig = {\n\t * \tsend: { type: 'p2pk', options: { pubkey: '...' } },\n\t * \tkeep: { type: 'deterministic', counter: 0 },\n\t * };\n\t * const customResult = await wallet.send(5, proofs, { includeFees: true }, customConfig);\n\t * ```\n\t *\n\t * @param amount Amount to send (receiver gets this net amount).\n\t * @param proofs Array of proofs to split.\n\t * @param config Optional parameters for the swap.\n\t * @returns SendResponse with keep/send proofs.\n\t * @throws Throws if the send cannot be completed offline or if funds are insufficient.\n\t */\n\tasync send(\n\t\tamount: number,\n\t\tproofs: Proof[],\n\t\tconfig?: SendConfig,\n\t\toutputConfig?: OutputConfig,\n\t): Promise<SendResponse> {\n\t\tconst { keysetId, includeFees = false, onCountersReserved } = config || {};\n\t\t// Fallback to policy defaults if no outputConfig\n\t\toutputConfig = outputConfig ?? {\n\t\t\tsend: this.defaultOutputType(),\n\t\t\tkeep: this.defaultOutputType(),\n\t\t};\n\n\t\t// First, let's see if we can avoid a swap (and fees)\n\t\t// by trying an exact match offline selection, including fees if\n\t\t// we are giving the receiver the amount + their fee to receive\n\t\t// In Wallet.ts, near send()\n\n\t\ttry {\n\t\t\t// Offline exact-match only allowed for plain-random defaults; deterministic implies swap.\n\t\t\tconst wantsDeterministicByPolicy = this.defaultOutputType().type === 'deterministic';\n\t\t\tconst isPlainRandom = (ot?: OutputType) =>\n\t\t\t\t!ot || (ot.type === 'random' && (!ot.denominations || ot.denominations.length === 0));\n\n\t\t\tif (\n\t\t\t\tkeysetId ||\n\t\t\t\twantsDeterministicByPolicy ||\n\t\t\t\t!isPlainRandom(outputConfig.send) ||\n\t\t\t\t(outputConfig.keep && !isPlainRandom(outputConfig.keep))\n\t\t\t) {\n\t\t\t\t// Explain why we must fall back to swap\n\t\t\t\tconst reasons: string[] = [];\n\t\t\t\tif (keysetId) reasons.push('keysetId override');\n\t\t\t\tif (wantsDeterministicByPolicy) reasons.push('wallet default is deterministic');\n\t\t\t\tif (!isPlainRandom(outputConfig.send)) reasons.push('non-default send output type');\n\t\t\t\tif (outputConfig.keep && !isPlainRandom(outputConfig.keep))\n\t\t\t\t\treasons.push('non-default keep output type');\n\n\t\t\t\tthrow new Error(`Options require a swap: ${reasons.join(', ')}`);\n\t\t\t}\n\n\t\t\t// Proceed with offline exact-match attempt\n\t\t\tconst { keep, send } = this.sendOffline(amount, proofs, {\n\t\t\t\tincludeFees,\n\t\t\t\texactMatch: true,\n\t\t\t\trequireDleq: false, // safety\n\t\t\t});\n\t\t\tconst expectedFee = includeFees ? this.getFeesForProofs(send) : 0;\n\n\t\t\tif (sumProofs(send) === amount + expectedFee) {\n\t\t\t\tthis._logger.info('Successful exactMatch offline selection!');\n\t\t\t\treturn { keep, send };\n\t\t\t}\n\t\t} catch (e: unknown) {\n\t\t\tconst message = e instanceof Error ? e.message : 'Unknown error';\n\t\t\tthis._logger.debug('ExactMatch offline selection failed.', { e: message });\n\t\t}\n\n\t\t// Fetch keys\n\t\tconst keyset = this.getKeyset(keysetId); // specified or wallet keyset\n\n\t\t// Shape SEND output type and denominations\n\t\tlet sendOT = this.configureOutputs(\n\t\t\tamount,\n\t\t\tkeyset,\n\t\t\toutputConfig.send ?? this.defaultOutputType(),\n\t\t\tincludeFees,\n\t\t);\n\t\tconst sendAmount = this.preparedTotal(sendOT);\n\n\t\t// Select the subset of proofs needed to cover the swap (sendTarget + swap fee)\n\t\tconst { keep: unselectedProofs, send: selectedProofs } = this.selectProofsToSend(\n\t\t\tproofs,\n\t\t\tsendAmount,\n\t\t\ttrue, // Include fees to cover swap fee\n\t\t);\n\t\t// this._logger.debug('PROOFS SELECTED', {\n\t\t// \tunselectedProofs: unselectedProofs.map(p=>p.amount),\n\t\t// \tselectedProofs: selectedProofs.map(p=>p.amount),\n\t\t// });\n\t\tif (selectedProofs.length === 0) {\n\t\t\tthrow new Error('Not enough funds available to send');\n\t\t}\n\n\t\t// Calculate our expected change from the swap (and sanity check!)\n\t\tconst selectedSum = sumProofs(selectedProofs);\n\t\tconst swapFee = this.getFeesForProofs(selectedProofs);\n\t\tconst changeAmount = selectedSum - swapFee - sendAmount;\n\t\tthis.failIf(changeAmount < 0, 'Not enough funds available for swap', {\n\t\t\tselectedSum,\n\t\t\tswapFee,\n\t\t\tsendAmount,\n\t\t\tchangeAmount,\n\t\t});\n\n\t\t// Shape KEEP (change) output type and denominations\n\t\t// No includeFees, as we are the receiver of the change\n\t\tlet keepOT = this.configureOutputs(\n\t\t\tchangeAmount,\n\t\t\tkeyset,\n\t\t\toutputConfig.keep ?? this.defaultOutputType(),\n\t\t\tfalse,\n\t\t\tconfig?.proofsWeHave,\n\t\t);\n\t\tconst keepAmount = this.preparedTotal(keepOT);\n\n\t\t// Assign counters atomically if either/both OutputTypes are deterministic\n\t\t// and the counter is zero (auto-assign)\n\t\tconst autoCounters = await this.addCountersToOutputTypes(keyset.id, sendOT, keepOT);\n\t\t[sendOT, keepOT] = autoCounters.outputTypes;\n\t\tif (autoCounters.used) {\n\t\t\tthis.safeCallback(onCountersReserved, autoCounters.used, { op: 'send' });\n\t\t}\n\t\tthis._logger.debug('send counters', { counter: autoCounters.used, sendOT, keepOT });\n\n\t\t// Create the output data\n\t\tconst sendOutputs = this.createOutputData(sendAmount, keyset, sendOT);\n\t\tconst keepOutputs = this.createOutputData(keepAmount, keyset, keepOT);\n\n\t\t// Execute swap\n\t\tconst swapTransaction = this.createSwapTransaction(selectedProofs, keepOutputs, sendOutputs);\n\t\tconst { signatures } = await this.mint.swap(swapTransaction.payload);\n\n\t\t// Construct proofs\n\t\tconst swapProofs = swapTransaction.outputData.map((d, i) => d.toProof(signatures[i], keyset));\n\t\tconst reorderedProofs = Array(swapProofs.length);\n\t\tconst reorderedKeepVector = Array(swapTransaction.keepVector.length);\n\t\tswapTransaction.sortedIndices.forEach((s, i) => {\n\t\t\treorderedKeepVector[s] = swapTransaction.keepVector[i];\n\t\t\treorderedProofs[s] = swapProofs[i];\n\t\t});\n\t\tconst keepProofs: Proof[] = [];\n\t\tconst sendProofs: Proof[] = [];\n\t\treorderedProofs.forEach((p: Proof, i) => {\n\t\t\tif (reorderedKeepVector[i]) {\n\t\t\t\tkeepProofs.push(p);\n\t\t\t} else {\n\t\t\t\tsendProofs.push(p);\n\t\t\t}\n\t\t});\n\t\tthis._logger.debug('SEND COMPLETED', {\n\t\t\tunselectedProofs: unselectedProofs.map((p) => p.amount),\n\t\t\tkeepProofs: keepProofs.map((p) => p.amount),\n\t\t\tsendProofs: sendProofs.map((p) => p.amount),\n\t\t});\n\t\treturn {\n\t\t\tkeep: [...keepProofs, ...unselectedProofs],\n\t\t\tsend: sendProofs,\n\t\t};\n\t}\n\t/**\n\t * Swap is an alias of send.\n\t */\n\tpublic readonly swap = this.send.bind(this);\n\n\t// -----------------------------------------------------------------\n\t// Section: Transaction Helpers\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * Selects proofs to send based on amount and fee inclusion.\n\t *\n\t * @remarks\n\t * Uses an adapted Randomized Greedy with Local Improvement (RGLI) algorithm, which has a time\n\t * complexity O(n log n) and space complexity O(n).\n\t * @param proofs Array of Proof objects available to select from.\n\t * @param amountToSend The target amount to send.\n\t * @param includeFees Optional boolean to include fees; Default: false.\n\t * @param exactMatch Optional boolean to require exact match; Default: false.\n\t * @returns SendResponse containing proofs to keep and proofs to send.\n\t * @throws Throws an error if an exact match cannot be found within MAX_TIMEMS.\n\t * @see https://crypto.ethz.ch/publications/files/Przyda02.pdf\n\t */\n\tselectProofsToSend(\n\t\tproofs: Proof[],\n\t\tamountToSend: number,\n\t\tincludeFees = false,\n\t\texactMatch = false,\n\t): SendResponse {\n\t\tconst { keep, send } = this._selectProofs(\n\t\t\tproofs,\n\t\t\tamountToSend,\n\t\t\tthis.keyChain,\n\t\t\tincludeFees,\n\t\t\texactMatch,\n\t\t);\n\t\treturn { keep, send };\n\t}\n\n\t/**\n\t * Prepares proofs for sending by signing P2PK-locked proofs.\n\t *\n\t * @remarks\n\t * Call this method before operations like send if the proofs are P2PK-locked and need unlocking.\n\t * This is a public wrapper for signing.\n\t * @param proofs The proofs to sign.\n\t * @param privkey The private key for signing.\n\t * @returns Signed proofs.\n\t */\n\tsignP2PKProofs(proofs: Proof[], privkey: string | string[]): Proof[] {\n\t\treturn signP2PKProofs(proofs, privkey);\n\t}\n\n\t/**\n\t * Calculates the fees based on inputs (proofs)\n\t *\n\t * @param proofs Input proofs to calculate fees for.\n\t * @returns Fee amount.\n\t * @throws Throws an error if the proofs keyset is unknown.\n\t */\n\tgetFeesForProofs(proofs: Proof[]): number {\n\t\tconst sumPPK = proofs.reduce((a, c) => a + this.getProofFeePPK(c), 0);\n\t\treturn Math.ceil(sumPPK / 1000);\n\t}\n\n\t/**\n\t * Returns the current fee PPK for a proof according to the cached keyset.\n\t *\n\t * @param proof {Proof} A single proof.\n\t * @returns FeePPK {number} The feePPK for the selected proof.\n\t * @throws Throws an error if the proofs keyset is unknown.\n\t */\n\tprivate getProofFeePPK(proof: Proof): number {\n\t\ttry {\n\t\t\t// We need the proof's keyset so use keyChain here\n\t\t\t// We must NOT fallback to wallet's keyset\n\t\t\treturn this.keyChain.getKeyset(proof.id).fee;\n\t\t} catch (e) {\n\t\t\tthis.fail(`Could not get fee. No keyset found for keyset id: ${proof.id}`, {\n\t\t\t\te,\n\t\t\t\tkeychain: this.keyChain.getKeysets(),\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Calculates the fees based on inputs for a given keyset.\n\t *\n\t * @param nInputs Number of inputs.\n\t * @param keysetId KeysetId used to lookup `input_fee_ppk`\n\t * @returns Fee amount.\n\t */\n\tgetFeesForKeyset(nInputs: number, keysetId: string): number {\n\t\ttry {\n\t\t\t// We must NOT fallback to wallet's keyset\n\t\t\tconst feePPK = this.keyChain.getKeyset(keysetId).fee;\n\t\t\treturn Math.floor(Math.max((nInputs * feePPK + 999) / 1000, 0));\n\t\t} catch (e) {\n\t\t\tthis.fail(`No keyset found with ID ${keysetId}`, { e });\n\t\t}\n\t}\n\n\t/**\n\t * Prepares inputs for a mint operation.\n\t *\n\t * @remarks\n\t * Internal method; strips DLEQ (NUT-12) and p2pk_e (NUT-26) for privacy and serializes witnesses.\n\t * Returns an array of new proof objects - does not mutate the originals.\n\t * @param proofs The proofs to prepare.\n\t * @param keepDleq Optional boolean to keep DLEQ (default: false, strips for privacy).\n\t * @returns Prepared proofs for mint payload.\n\t */\n\tprivate _prepareInputsForMint(proofs: Proof[], keepDleq: boolean = false): Proof[] {\n\t\treturn proofs.map((p) => {\n\t\t\tconst witness =\n\t\t\t\tp.witness && typeof p.witness !== 'string' ? JSON.stringify(p.witness) : p.witness;\n\t\t\tconst { dleq, p2pk_e, ...rest } = p; // isolate dleq and p2pk_e\n\t\t\tvoid p2pk_e; // intentionally unused (linter)\n\t\t\t// New proof object\n\t\t\treturn keepDleq && dleq ? { ...rest, dleq, witness } : { ...rest, witness };\n\t\t});\n\t}\n\n\t/**\n\t * Decodes a string token.\n\t *\n\t * @remarks\n\t * Rehydrates a token from the space-saving CBOR format, including mapping short keyset ids to\n\t * their full representation.\n\t * @param token The token in string format (cashuB...)\n\t * @returns Token object.\n\t */\n\tpublic decodeToken(token: string): Token {\n\t\tconst keysets = this.keyChain.getKeysets();\n\t\treturn getDecodedToken(token, keysets);\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Restore\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * Restores batches of deterministic proofs until no more signatures are returned from the mint.\n\t *\n\t * @param [gapLimit=300] The amount of empty counters that should be returned before restoring\n\t *   ends (defaults to 300). Default is `300`\n\t * @param [batchSize=100] The amount of proofs that should be restored at a time (defaults to\n\t *   100). Default is `100`\n\t * @param [counter=0] The counter that should be used as a starting point (defaults to 0). Default\n\t *   is `0`\n\t * @param [keysetId] Which keysetId to use for the restoration. If none is passed the instance's\n\t *   default one will be used.\n\t */\n\tasync batchRestore(\n\t\tgapLimit = 300,\n\t\tbatchSize = 100,\n\t\tcounter = 0,\n\t\tkeysetId?: string,\n\t): Promise<{ proofs: Proof[]; lastCounterWithSignature?: number }> {\n\t\tconst requiredEmptyBatches = Math.ceil(gapLimit / batchSize);\n\t\tconst restoredProofs: Proof[] = [];\n\n\t\tlet lastCounterWithSignature: undefined | number;\n\t\tlet emptyBatchesFound = 0;\n\n\t\twhile (emptyBatchesFound < requiredEmptyBatches) {\n\t\t\tconst restoreRes = await this.restore(counter, batchSize, { keysetId });\n\t\t\tif (restoreRes.proofs.length > 0) {\n\t\t\t\temptyBatchesFound = 0;\n\t\t\t\trestoredProofs.push(...restoreRes.proofs);\n\t\t\t\tlastCounterWithSignature = restoreRes.lastCounterWithSignature;\n\t\t\t} else {\n\t\t\t\temptyBatchesFound++;\n\t\t\t}\n\t\t\tcounter += batchSize;\n\t\t}\n\t\treturn { proofs: restoredProofs, lastCounterWithSignature };\n\t}\n\n\t/**\n\t * Regenerates.\n\t *\n\t * @param start Set starting point for count (first cycle for each keyset should usually be 0)\n\t * @param count Set number of blinded messages that should be generated.\n\t * @param options.keysetId Set a custom keysetId to restore from. @see `keyChain)`\n\t */\n\tasync restore(\n\t\tstart: number,\n\t\tcount: number,\n\t\tconfig?: RestoreConfig,\n\t): Promise<{ proofs: Proof[]; lastCounterWithSignature?: number }> {\n\t\tconst { keysetId } = config || {};\n\t\tconst keyset = this.getKeyset(keysetId); // specified or wallet keyset\n\t\tthis.failIfNullish(this._seed, 'Cashu Wallet must be initialized with a seed to use restore');\n\n\t\t// create deterministic blank outputs for unknown restore amounts\n\t\t// Note: zero amount + zero denomination passes splitAmount validation\n\t\tconst zeros = Array(count).fill(0);\n\t\tconst outputData = OutputData.createDeterministicData(0, this._seed, start, keyset, zeros);\n\n\t\tconst { outputs, signatures } = await this.mint.restore({\n\t\t\toutputs: outputData.map((d) => d.blindedMessage),\n\t\t});\n\n\t\tconst signatureMap: { [sig: string]: SerializedBlindedSignature } = {};\n\t\toutputs.forEach((o, i) => (signatureMap[o.B_] = signatures[i]));\n\n\t\tconst restoredProofs: Proof[] = [];\n\t\tlet lastCounterWithSignature: number | undefined;\n\n\t\tfor (let i = 0; i < outputData.length; i++) {\n\t\t\tconst matchingSig = signatureMap[outputData[i].blindedMessage.B_];\n\t\t\tif (matchingSig) {\n\t\t\t\tlastCounterWithSignature = start + i;\n\t\t\t\toutputData[i].blindedMessage.amount = matchingSig.amount;\n\t\t\t\trestoredProofs.push(outputData[i].toProof(matchingSig, keyset));\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tproofs: restoredProofs,\n\t\t\tlastCounterWithSignature,\n\t\t};\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Create Mint Quote\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * @deprecated Use createMintQuoteBolt11()\n\t */\n\tasync createMintQuote(amount: number, description?: string): Promise<MintQuoteResponse> {\n\t\treturn this.createMintQuoteBolt11(amount, description);\n\t}\n\n\t/**\n\t * Requests a mint quote from the mint. Response returns a Lightning payment request for the\n\t * requested given amount and unit.\n\t *\n\t * @param amount Amount requesting for mint.\n\t * @param description Optional description for the mint quote.\n\t * @param pubkey Optional public key to lock the quote to.\n\t * @returns The mint will return a mint quote with a Lightning invoice for minting tokens of the\n\t *   specified amount and unit.\n\t */\n\tasync createMintQuoteBolt11(amount: number, description?: string): Promise<MintQuoteResponse> {\n\t\t// Check if mint supports description for bolt11\n\t\tif (description) {\n\t\t\tconst mintInfo = this.getMintInfo();\n\t\t\tif (!mintInfo.supportsNut04Description('bolt11', this._unit)) {\n\t\t\t\tthis.fail('Mint does not support description for bolt11');\n\t\t\t}\n\t\t}\n\n\t\tconst mintQuotePayload: MintQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\tamount: amount,\n\t\t\tdescription: description,\n\t\t};\n\t\tconst res = await this.mint.createMintQuoteBolt11(mintQuotePayload);\n\t\treturn { ...res, amount: res.amount || amount, unit: res.unit || this._unit };\n\t}\n\n\t/**\n\t * Requests a mint quote from the mint that is locked to a public key.\n\t *\n\t * @param amount Amount requesting for mint.\n\t * @param pubkey Public key to lock the quote to.\n\t * @param description Optional description for the mint quote.\n\t * @returns The mint will return a mint quote with a Lightning invoice for minting tokens of the\n\t *   specified amount and unit. The quote will be locked to the specified `pubkey`.\n\t */\n\tasync createLockedMintQuote(\n\t\tamount: number,\n\t\tpubkey: string,\n\t\tdescription?: string,\n\t): Promise<LockedMintQuoteResponse> {\n\t\tconst { supported } = this.getMintInfo().isSupported(20);\n\t\tthis.failIf(!supported, 'Mint does not support NUT-20');\n\t\tconst mintQuotePayload: MintQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\tamount: amount,\n\t\t\tdescription: description,\n\t\t\tpubkey: pubkey,\n\t\t};\n\t\tconst res = await this.mint.createMintQuoteBolt11(mintQuotePayload);\n\t\tthis.failIf(typeof res.pubkey !== 'string', 'Mint returned unlocked mint quote');\n\t\tconst resPubkey = res.pubkey!;\n\t\treturn {\n\t\t\t...res,\n\t\t\tpubkey: resPubkey,\n\t\t\tamount: res.amount || amount,\n\t\t\tunit: res.unit || this._unit,\n\t\t};\n\t}\n\n\t/**\n\t * Requests a mint quote from the mint. Response returns a Lightning BOLT12 offer for the\n\t * requested given amount and unit.\n\t *\n\t * @param pubkey Public key to lock the quote to.\n\t * @param options.amount BOLT12 offer amount requesting for mint. If not specified, the offer will\n\t *   be amountless.\n\t * @param options.description Description for the mint quote.\n\t * @returns The mint will return a mint quote with a BOLT12 offer for minting tokens of the\n\t *   specified amount and unit.\n\t */\n\tasync createMintQuoteBolt12(\n\t\tpubkey: string,\n\t\toptions?: {\n\t\t\tamount?: number;\n\t\t\tdescription?: string;\n\t\t},\n\t): Promise<Bolt12MintQuoteResponse> {\n\t\t// Check if mint supports description for bolt12\n\t\tconst mintInfo = this.getMintInfo();\n\t\tif (options?.description && !mintInfo.supportsNut04Description('bolt12', this._unit)) {\n\t\t\tthis.fail('Mint does not support description for bolt12');\n\t\t}\n\n\t\tconst mintQuotePayload: Bolt12MintQuotePayload = {\n\t\t\tpubkey: pubkey,\n\t\t\tunit: this._unit,\n\t\t\tamount: options?.amount,\n\t\t\tdescription: options?.description,\n\t\t};\n\n\t\treturn this.mint.createMintQuoteBolt12(mintQuotePayload);\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Check Mint Quote\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * @deprecated Use checkMintQuoteBolt11()\n\t */\n\tasync checkMintQuote(\n\t\tquote: string | MintQuoteResponse,\n\t): Promise<MintQuoteResponse | PartialMintQuoteResponse> {\n\t\treturn this.checkMintQuoteBolt11(quote);\n\t}\n\n\t/**\n\t * Gets an existing mint quote from the mint.\n\t *\n\t * @param quote Quote ID.\n\t * @returns The mint will create and return a Lightning invoice for the specified amount.\n\t */\n\tasync checkMintQuoteBolt11(\n\t\tquote: string | MintQuoteResponse,\n\t): Promise<MintQuoteResponse | PartialMintQuoteResponse> {\n\t\tconst quoteId = typeof quote === 'string' ? quote : quote.quote;\n\t\tconst baseRes = await this.mint.checkMintQuoteBolt11(quoteId);\n\t\tif (typeof quote === 'string') {\n\t\t\treturn baseRes;\n\t\t}\n\t\treturn { ...baseRes, amount: baseRes.amount || quote.amount, unit: baseRes.unit || quote.unit };\n\t}\n\n\t/**\n\t * Gets an existing BOLT12 mint quote from the mint.\n\t *\n\t * @param quote Quote ID.\n\t * @returns The latest mint quote for the given quote ID.\n\t */\n\tasync checkMintQuoteBolt12(quote: string): Promise<Bolt12MintQuoteResponse> {\n\t\treturn this.mint.checkMintQuoteBolt12(quote);\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Mint Proofs\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * @deprecated Use mintProofsBolt11()\n\t */\n\tasync mintProofs(\n\t\tamount: number,\n\t\tquote: string | MintQuoteResponse,\n\t\tconfig?: MintProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<Proof[]> {\n\t\treturn this._mintProofs('bolt11', amount, quote, config, outputType);\n\t}\n\n\t/**\n\t * Mint proofs for a bolt11 quote.\n\t *\n\t * @param amount Amount to mint.\n\t * @param quote Mint quote ID or object (bolt11).\n\t * @param config Optional parameters (e.g. privkey for locked quotes).\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns Minted proofs.\n\t */\n\tasync mintProofsBolt11(\n\t\tamount: number,\n\t\tquote: string | MintQuoteResponse,\n\t\tconfig?: MintProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<Proof[]> {\n\t\treturn this._mintProofs('bolt11', amount, quote, config, outputType);\n\t}\n\n\t/**\n\t * Mints proofs for a bolt12 quote.\n\t *\n\t * @param amount Amount to mint.\n\t * @param quote Bolt12 mint quote.\n\t * @param privkey Private key to unlock the quote.\n\t * @param config Optional parameters (e.g. keysetId).\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns Minted proofs.\n\t */\n\tasync mintProofsBolt12(\n\t\tamount: number,\n\t\tquote: Bolt12MintQuoteResponse,\n\t\tprivkey: string,\n\t\tconfig?: { keysetId?: string },\n\t\toutputType?: OutputType,\n\t): Promise<Proof[]> {\n\t\treturn this._mintProofs('bolt12', amount, quote, { ...config, privkey }, outputType);\n\t}\n\n\t/**\n\t * Internal helper for minting proofs with bolt11 or bolt12.\n\t *\n\t * @remarks\n\t * Handles blinded messages, signatures, and proof construction. Use public methods like\n\t * mintProofs or helpers for API access.\n\t * @param method 'bolt11' or 'bolt12'.\n\t * @param amount Amount to mint (must be positive).\n\t * @param quote Quote ID or object.\n\t * @param config Optional (privkey, keysetId).\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns Minted proofs.\n\t * @throws If params are invalid or mint returns errors.\n\t */\n\tprivate async _mintProofs<T extends 'bolt11' | 'bolt12'>(\n\t\tmethod: T,\n\t\tamount: number,\n\t\tquote: string | (T extends 'bolt11' ? MintQuoteResponse : Bolt12MintQuoteResponse),\n\t\tconfig?: MintProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<Proof[]> {\n\t\toutputType = outputType ?? this.defaultOutputType(); // Fallback to policy\n\t\tconst { privkey, keysetId, proofsWeHave, onCountersReserved } = config ?? {};\n\t\tthis.failIf(amount <= 0, 'Invalid mint amount: must be positive', { amount });\n\n\t\t// Shape output type and denominations for our proofs\n\t\t// we are receiving, so no includeFees.\n\t\tconst keyset = this.getKeyset(keysetId); // specified or wallet keyset\n\t\tlet mintOT = this.configureOutputs(\n\t\t\tamount,\n\t\t\tkeyset,\n\t\t\toutputType,\n\t\t\tfalse, // no fees\n\t\t\tproofsWeHave,\n\t\t);\n\t\tconst mintAmount = this.preparedTotal(mintOT);\n\n\t\t// Assign counters atomically if OutputType is deterministic\n\t\t// and the counter is zero (auto-assign)\n\t\tconst autoCounters = await this.addCountersToOutputTypes(keyset.id, mintOT);\n\t\t[mintOT] = autoCounters.outputTypes;\n\t\tif (autoCounters.used) {\n\t\t\tthis.safeCallback(onCountersReserved, autoCounters.used, { op: 'mintProofs' });\n\t\t}\n\t\tthis._logger.debug('mint counter', { counter: autoCounters.used, mintOT });\n\n\t\t// Create outputs and mint payload\n\t\tconst outputs = this.createOutputData(mintAmount, keyset, mintOT);\n\t\tconst blindedMessages = outputs.map((d) => d.blindedMessage);\n\t\tconst mintPayload: MintPayload = {\n\t\t\toutputs: blindedMessages,\n\t\t\tquote: typeof quote === 'string' ? quote : quote.quote,\n\t\t};\n\n\t\t// Sign payload if the quote carries a public key\n\t\tif (typeof quote !== 'string' && quote.pubkey) {\n\t\t\tthis.failIf(!privkey, 'Can not sign locked quote without private key');\n\t\t\tconst mintQuoteSignature = signMintQuote(privkey!, quote.quote, blindedMessages);\n\t\t\tmintPayload.signature = mintQuoteSignature;\n\t\t}\n\t\t// Mint proofs\n\t\tlet signatures;\n\t\tif (method === 'bolt12') {\n\t\t\t({ signatures } = await this.mint.mintBolt12(mintPayload));\n\t\t} else {\n\t\t\t({ signatures } = await this.mint.mintBolt11(mintPayload));\n\t\t}\n\t\tthis.failIf(\n\t\t\tsignatures.length !== outputs.length,\n\t\t\t`Mint returned ${signatures.length} signatures, expected ${outputs.length}`,\n\t\t);\n\n\t\tthis._logger.debug('MINT COMPLETED', { amounts: outputs.map((o) => o.blindedMessage.amount) });\n\t\treturn outputs.map((d, i) => d.toProof(signatures[i], keyset));\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Create Melt Quote\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * @deprecated Use createMeltQuoteBolt11.\n\t */\n\tasync createMeltQuote(invoice: string): Promise<MeltQuoteResponse> {\n\t\treturn this.createMeltQuoteBolt11(invoice);\n\t}\n\n\t/**\n\t * Requests a melt quote from the mint. Response returns amount and fees for a given unit in order\n\t * to pay a Lightning invoice.\n\t *\n\t * @param invoice LN invoice that needs to get a fee estimate.\n\t * @returns The mint will create and return a melt quote for the invoice with an amount and fee\n\t *   reserve.\n\t */\n\tasync createMeltQuoteBolt11(invoice: string): Promise<MeltQuoteResponse> {\n\t\tconst meltQuotePayload: MeltQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\trequest: invoice,\n\t\t};\n\t\tconst meltQuote = await this.mint.createMeltQuoteBolt11(meltQuotePayload);\n\t\treturn {\n\t\t\t...meltQuote,\n\t\t\tunit: meltQuote.unit || this._unit,\n\t\t\trequest: meltQuote.request || invoice,\n\t\t};\n\t}\n\n\t/**\n\t * Requests a melt quote from the mint. Response returns amount and fees for a given unit in order\n\t * to pay a BOLT12 offer.\n\t *\n\t * @param offer BOLT12 offer that needs to get a fee estimate.\n\t * @param amountMsat Amount in millisatoshis for amount-less offers. If this is defined and the\n\t *   offer has an amount, they **MUST** be equal.\n\t * @returns The mint will create and return a melt quote for the offer with an amount and fee\n\t *   reserve.\n\t */\n\tasync createMeltQuoteBolt12(\n\t\toffer: string,\n\t\tamountMsat?: number,\n\t): Promise<Bolt12MeltQuoteResponse> {\n\t\treturn this.mint.createMeltQuoteBolt12({\n\t\t\tunit: this._unit,\n\t\t\trequest: offer,\n\t\t\toptions: amountMsat\n\t\t\t\t? {\n\t\t\t\t\t\tamountless: {\n\t\t\t\t\t\t\tamount_msat: amountMsat,\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t: undefined,\n\t\t});\n\t}\n\n\t/**\n\t * Requests a multi path melt quote from the mint.\n\t *\n\t * @remarks\n\t * Uses NUT-15 Partial multi-path payments for BOLT11.\n\t * @param invoice LN invoice that needs to get a fee estimate.\n\t * @param partialAmount The partial amount of the invoice's total to be paid by this instance.\n\t * @returns The mint will create and return a melt quote for the invoice with an amount and fee\n\t *   reserve.\n\t * @see https://github.com/cashubtc/nuts/blob/main/15.md\n\t */\n\tasync createMultiPathMeltQuote(\n\t\tinvoice: string,\n\t\tmillisatPartialAmount: number,\n\t): Promise<MeltQuoteResponse> {\n\t\tconst { supported, params } = this.getMintInfo().isSupported(15);\n\t\tthis.failIf(!supported, 'Mint does not support NUT-15');\n\t\tthis.failIf(\n\t\t\t!params?.some((p) => p.method === 'bolt11' && p.unit === this._unit),\n\t\t\t`Mint does not support MPP for bolt11 and ${this._unit}`,\n\t\t);\n\t\tconst mppOption: MPPOption = {\n\t\t\tamount: millisatPartialAmount,\n\t\t};\n\t\tconst meltOptions: MeltQuoteOptions = {\n\t\t\tmpp: mppOption,\n\t\t};\n\t\tconst meltQuotePayload: MeltQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\trequest: invoice,\n\t\t\toptions: meltOptions,\n\t\t};\n\t\tconst meltQuote = await this.mint.createMeltQuoteBolt11(meltQuotePayload);\n\t\treturn { ...meltQuote, request: invoice, unit: this._unit };\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Check Melt Quote\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * @deprecated Use checkMeltQuoteBolt11()\n\t */\n\tasync checkMeltQuote(\n\t\tquote: string | MeltQuoteResponse,\n\t): Promise<MeltQuoteResponse | PartialMeltQuoteResponse> {\n\t\treturn this.checkMeltQuoteBolt11(quote);\n\t}\n\n\t/**\n\t * Returns an existing bolt11 melt quote from the mint.\n\t *\n\t * @param quote ID of the melt quote.\n\t * @returns The mint will return an existing melt quote.\n\t */\n\tasync checkMeltQuoteBolt11(\n\t\tquote: string | MeltQuoteResponse,\n\t): Promise<MeltQuoteResponse | PartialMeltQuoteResponse> {\n\t\tconst quoteId = typeof quote === 'string' ? quote : quote.quote;\n\t\tconst meltQuote = await this.mint.checkMeltQuoteBolt11(quoteId);\n\t\tif (typeof quote === 'string') {\n\t\t\treturn meltQuote;\n\t\t}\n\t\treturn { ...meltQuote, request: quote.request, unit: quote.unit };\n\t}\n\n\t/**\n\t * Returns an existing bolt12 melt quote from the mint.\n\t *\n\t * @param quote ID of the melt quote.\n\t * @returns The mint will return an existing melt quote.\n\t */\n\tasync checkMeltQuoteBolt12(quote: string): Promise<Bolt12MeltQuoteResponse> {\n\t\treturn this.mint.checkMeltQuoteBolt12(quote);\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Melt Proofs\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * @deprecated Use meltProofsBolt11()\n\t */\n\tasync meltProofs(\n\t\tmeltQuote: MeltQuoteResponse,\n\t\tproofsToSend: Proof[],\n\t\tconfig?: MeltProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<MeltProofsResponse> {\n\t\treturn this._meltProofs('bolt11', meltQuote, proofsToSend, config, outputType);\n\t}\n\n\t/**\n\t * Melt proofs for a bolt11 melt quote.\n\t *\n\t * @remarks\n\t * ProofsToSend must be at least amount+fee_reserve from the melt quote. This function does not\n\t * perform coin selection!.\n\t * @param meltQuote ID of the melt quote.\n\t * @param proofsToSend Proofs to melt.\n\t * @param config Optional parameters.\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns MeltProofsResponse with quote and change proofs.\n\t */\n\tasync meltProofsBolt11(\n\t\tmeltQuote: MeltQuoteResponse,\n\t\tproofsToSend: Proof[],\n\t\tconfig?: MeltProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<MeltProofsResponse> {\n\t\treturn this._meltProofs('bolt11', meltQuote, proofsToSend, config, outputType);\n\t}\n\n\t/**\n\t * Melt proofs for a bolt12 melt quote, returns change proofs using specified outputType.\n\t *\n\t * @remarks\n\t * ProofsToSend must be at least amount+fee_reserve from the melt quote. This function does not\n\t * perform coin selection!.\n\t * @param meltQuote ID of the melt quote.\n\t * @param proofsToSend Proofs to melt.\n\t * @param config Optional parameters.\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns MeltProofsResponse with quote and change proofs.\n\t */\n\tasync meltProofsBolt12(\n\t\tmeltQuote: Bolt12MeltQuoteResponse,\n\t\tproofsToSend: Proof[],\n\t\tconfig?: MeltProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<MeltProofsResponse> {\n\t\treturn this._meltProofs('bolt12', meltQuote, proofsToSend, config, outputType);\n\t}\n\n\t/**\n\t * Melt proofs for a given melt quote created with the bolt11 or bolt12 method.\n\t *\n\t * @remarks\n\t * Creates NUT-08 blanks (1-sat) for Lightning fee return. Get these by setting a\n\t * config.onChangeOutputsCreated callback for async melting. @see completeMelt.\n\t * @param method Payment method of the quote.\n\t * @param meltQuote The bolt11 or bolt12 melt quote.\n\t * @param proofsToSend Proofs to melt.\n\t * @param config Optional (keysetId, onChangeOutputsCreated).\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns MeltProofsResponse.\n\t * @throws If params are invalid or mint returns errors.\n\t * @see https://github.com/cashubtc/nuts/blob/main/08.md.\n\t */\n\tprivate async _meltProofs<T extends 'bolt11' | 'bolt12'>(\n\t\tmethod: T,\n\t\tmeltQuote: T extends 'bolt11' ? MeltQuoteResponse : Bolt12MeltQuoteResponse,\n\t\tproofsToSend: Proof[],\n\t\tconfig?: MeltProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<MeltProofsResponse> {\n\t\toutputType = outputType ?? this.defaultOutputType(); // Fallback to policy\n\t\tconst { keysetId, onChangeOutputsCreated, onCountersReserved } = config || {};\n\t\tconst keyset = this.getKeyset(keysetId); // specified or wallet keyset\n\t\tconst sendAmount = sumProofs(proofsToSend);\n\n\t\t// feeReserve is the overage above the invoice/offer amount.\n\t\t// In the common case where selected proofs = amount + fee_reserve,\n\t\t// this equals the quote’s fee_reserve. If you overshoot more,\n\t\t// the extra also becomes NUT-08 lightning fee change.\n\t\tconst feeReserve = sendAmount - meltQuote.amount;\n\t\tlet outputData: OutputDataLike[] = [];\n\n\t\t// bolt11 does not allow partial payment, and although bolt12 could, mints\n\t\t// like CDK forbids it. So let's fail loudly up front...\n\t\tthis.failIf(feeReserve < 0, 'Not enough proofs to cover amount + fee reserve', {\n\t\t\tsendAmount,\n\t\t\tquoteAmount: meltQuote.amount,\n\t\t});\n\n\t\t// Create NUT-08 blanks for return of Lightning fee change\n\t\t// Note: zero amount + zero denomination passes splitAmount validation\n\t\tif (feeReserve > 0) {\n\t\t\tlet count = Math.ceil(Math.log2(feeReserve)) || 1;\n\t\t\tif (count < 0) count = 0; // Prevents: -Infinity\n\t\t\tconst denominations: number[] = count ? new Array<number>(count).fill(0) : [];\n\t\t\tthis._logger.debug('Creating NUT-08 blanks for fee reserve', {\n\t\t\t\tfeeReserve,\n\t\t\t\tdenominations,\n\t\t\t});\n\n\t\t\t// Build effective OutputType and merge denominations\n\t\t\tif (outputType.type === 'custom') {\n\t\t\t\tthis.fail('Custom OutputType not supported for melt change (must be 0-sat blanks)');\n\t\t\t}\n\t\t\tlet meltOT: OutputType = { ...outputType, denominations };\n\t\t\t// Assign counter atomically if OutputType is deterministic\n\t\t\t// and the counter is zero (auto-assign)\n\t\t\tconst autoCounters = await this.addCountersToOutputTypes(keyset.id, meltOT);\n\t\t\t[meltOT] = autoCounters.outputTypes;\n\t\t\tif (autoCounters.used) {\n\t\t\t\tthis.safeCallback(onCountersReserved, autoCounters.used, { op: 'meltProofs' });\n\t\t\t}\n\t\t\tthis._logger.debug('melt counter', { counter: autoCounters.used, meltOT });\n\n\t\t\t// Generate the blank outputs (no fees as we are receiving change)\n\t\t\t// Remember, zero amount + zero denomination passes splitAmount validation\n\t\t\toutputData = this.createOutputData(0, keyset, meltOT);\n\t\t}\n\n\t\t// Prepare proofs for mint\n\t\tproofsToSend = this._prepareInputsForMint(proofsToSend);\n\n\t\tconst meltPayload: MeltPayload = {\n\t\t\tquote: meltQuote.quote,\n\t\t\tinputs: proofsToSend,\n\t\t\toutputs: outputData.map((d) => d.blindedMessage),\n\t\t};\n\n\t\t// Fire event(s) after blanks creation\n\t\tif (outputData.length > 0) {\n\t\t\tconst blanks: MeltBlanks = {\n\t\t\t\tmethod,\n\t\t\t\tpayload: meltPayload,\n\t\t\t\toutputData,\n\t\t\t\tkeyset,\n\t\t\t\tquote: meltQuote,\n\t\t\t};\n\t\t\tthis.safeCallback(onChangeOutputsCreated, blanks, { op: 'meltProofs' });\n\t\t\tthis.on._emitMeltBlanksCreated(blanks); // global callback\n\t\t}\n\n\t\t// Proceed with melt, setting preferredAsync header if an onChangeOutputsCreated callback was used\n\t\tlet meltResponse;\n\t\tconst preferAsync: boolean = typeof onChangeOutputsCreated === 'function';\n\t\tif (method === 'bolt12') {\n\t\t\tmeltResponse = await this.mint.meltBolt12(meltPayload, { preferAsync });\n\t\t} else {\n\t\t\tmeltResponse = await this.mint.meltBolt11(meltPayload, { preferAsync });\n\t\t}\n\n\t\t// Sanity check mint didn't send too many signatures before mapping\n\t\t// Should not happen, except in case of a broken or malicious mint\n\t\tthis.failIf(\n\t\t\t(meltResponse.change?.length ?? 0) > outputData.length,\n\t\t\t`Mint returned ${meltResponse.change?.length ?? 0} signatures, but only ${outputData.length} blanks were provided`,\n\t\t);\n\n\t\t// Construct change if provided (empty if pending/not paid; shorter ok if less overfee)\n\t\tconst change = meltResponse.change?.map((s, i) => outputData[i].toProof(s, keyset)) ?? [];\n\t\tthis._logger.debug('MELT COMPLETED', { changeAmounts: change.map((p) => p.amount) });\n\t\treturn { quote: { ...meltResponse, unit: meltQuote.unit, request: meltQuote.request }, change };\n\t}\n\n\t/**\n\t * Completes a pending melt by re-calling the melt endpoint and constructing change proofs.\n\t *\n\t * @remarks\n\t * Use with blanks from onChangeOutputsCreated to retry pending melts. Works for Bolt11/Bolt12.\n\t * Returns change proofs if paid, else empty change.\n\t * @param blanks The blanks from onChangeOutputsCreated.\n\t * @returns Updated MeltProofsResponse.\n\t * @throws If melt fails or signatures don't match output count.\n\t */\n\tasync completeMelt<T extends MeltQuoteResponse>(\n\t\tblanks: MeltBlanks<T>,\n\t): Promise<MeltProofsResponse> {\n\t\tconst meltResponse =\n\t\t\tblanks.method === 'bolt12'\n\t\t\t\t? await this.mint.meltBolt12(blanks.payload)\n\t\t\t\t: await this.mint.meltBolt11(blanks.payload);\n\n\t\t// Check for too many signatures before mapping\n\t\tthis.failIf(\n\t\t\t(meltResponse.change?.length ?? 0) > blanks.outputData.length,\n\t\t\t`Mint returned ${meltResponse.change?.length ?? 0} signatures, but only ${blanks.outputData.length} blanks were provided`,\n\t\t);\n\n\t\t// Construct change (shorter ok)\n\t\tconst change =\n\t\t\tmeltResponse.change?.map((s, i) => blanks.outputData[i].toProof(s, blanks.keyset)) ?? [];\n\n\t\tthis._logger.debug('COMPLETE MELT', { changeAmounts: change.map((p) => p.amount) });\n\t\treturn {\n\t\t\tquote: { ...meltResponse, unit: blanks.quote.unit, request: blanks.quote.request },\n\t\t\tchange,\n\t\t};\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Proof States\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * Get an array of the states of proofs from the mint (as an array of CheckStateEnum's)\n\t *\n\t * @param proofs (only the `secret` field is required)\n\t * @returns NUT-07 state for each proof, in same order.\n\t */\n\tasync checkProofsStates(proofs: Array<Pick<Proof, 'secret'>>): Promise<ProofState[]> {\n\t\tconst enc = new TextEncoder();\n\t\tconst Ys = proofs.map((p: Pick<Proof, 'secret'>) =>\n\t\t\thashToCurve(enc.encode(p.secret)).toHex(true),\n\t\t);\n\t\t// TODO: Replace this with a value from the info endpoint of the mint eventually\n\t\tconst BATCH_SIZE = 100;\n\t\tconst states: ProofState[] = [];\n\t\tfor (let i = 0; i < Ys.length; i += BATCH_SIZE) {\n\t\t\tconst YsSlice = Ys.slice(i, i + BATCH_SIZE);\n\t\t\tconst { states: batchStates } = await this.mint.check({\n\t\t\t\tYs: YsSlice,\n\t\t\t});\n\t\t\tconst stateMap: { [y: string]: ProofState } = {};\n\t\t\tbatchStates.forEach((s) => {\n\t\t\t\tstateMap[s.Y] = s;\n\t\t\t});\n\t\t\tfor (let j = 0; j < YsSlice.length; j++) {\n\t\t\t\tconst state = stateMap[YsSlice[j]];\n\t\t\t\tthis.failIfNullish(state, 'Could not find state for proof with Y: ' + YsSlice[j]);\n\t\t\t\tstates.push(state);\n\t\t\t}\n\t\t}\n\t\treturn states;\n\t}\n\n\t/**\n\t * Groups proofs by their corresponding state, preserving order within each group.\n\t *\n\t * @param proofs (only the `secret` field is required)\n\t * @returns An object with arrays of proofs grouped by CheckStateEnum state.\n\t */\n\tasync groupProofsByState(\n\t\tproofs: Proof[],\n\t): Promise<{ unspent: Proof[]; pending: Proof[]; spent: Proof[] }> {\n\t\tconst states: ProofState[] = await this.checkProofsStates(proofs);\n\t\tconst result = {\n\t\t\tunspent: [] as Proof[],\n\t\t\tpending: [] as Proof[],\n\t\t\tspent: [] as Proof[],\n\t\t};\n\t\tfor (let i = 0; i < states.length; i++) {\n\t\t\tconst proof = proofs[i];\n\t\t\tswitch (states[i].state) {\n\t\t\t\tcase CheckStateEnum.UNSPENT:\n\t\t\t\t\tresult.unspent.push(proof);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CheckStateEnum.PENDING:\n\t\t\t\t\tresult.pending.push(proof);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CheckStateEnum.SPENT:\n\t\t\t\t\tresult.spent.push(proof);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n\nexport { Wallet };\n","import { type Proof } from '../../model/types/proof';\n\nexport type RawTransport = {\n\tt: PaymentRequestTransportType; // type\n\ta: string; // target\n\tg?: string[][]; // tags\n};\n\nexport type RawNUT10Option = {\n\tk: string; // kind\n\td: string; // data\n\tt: string[][]; // tags\n};\n\nexport type RawPaymentRequest = {\n\ti?: string; // id\n\ta?: number; // amount\n\tu?: string; // unit\n\ts?: boolean; // single use\n\tm?: string[]; // mints\n\td?: string; // description\n\tt?: RawTransport[]; // transports\n\tnut10?: RawNUT10Option;\n\tnut26?: boolean; // P2BK\n};\n\nexport type PaymentRequestTransport = {\n\ttype: PaymentRequestTransportType;\n\ttarget: string;\n\ttags?: string[][];\n};\n\nexport enum PaymentRequestTransportType {\n\tPOST = 'post',\n\tNOSTR = 'nostr',\n}\n\nexport type PaymentRequestPayload = {\n\tid?: string;\n\tmemo?: string;\n\tunit: string;\n\tmint: string;\n\tproofs: Proof[];\n};\n\n/**\n * Used to express a spending condition that proofs should be encumbered with.\n */\nexport type NUT10Option = {\n\t/**\n\t * The kind of spending condition.\n\t */\n\tkind: string;\n\t/**\n\t * Expresses the spending condition relative to the kind.\n\t */\n\tdata: string;\n\t/**\n\t * Tags associated with the spending condition for additional data.\n\t */\n\ttags: string[][];\n};\n","import type { AuthProvider } from './AuthProvider';\nimport request, { type RequestFn } from '../transport';\nimport { joinUrls, hasValidDleq, encodeJsonToBase64, Bytes } from '../utils';\nimport { MintInfo } from '../model/MintInfo';\nimport { OutputData } from '../model/OutputData';\nimport type { MintActiveKeys, MintAllKeysets, Proof } from '../model/types';\nimport { type GetInfoResponse, type BlindAuthMintResponse } from '../mint/types';\nimport { type Logger, NULL_LOGGER } from '../logger';\nimport { type OIDCAuth, type TokenResponse } from './OIDCAuth';\nimport { KeyChain, type Keyset } from '../wallet';\n\nexport type AuthManagerOptions = {\n\t/**\n\t * Hard limit to target when minting BATs in one request. If omitted, we'll read\n\t * `nuts['22'].bat_max_mint` from the mint \"/v1/info\" endpoint.\n\t */\n\tmaxPerMint?: number;\n\t/**\n\t * Desired BAT pool size. We’ll top-up to min(desiredPoolSize, bat_max_mint) on demand.\n\t */\n\tdesiredPoolSize?: number;\n\t/**\n\t * Custom request fn (e.g. for tests or host env).\n\t */\n\trequest?: RequestFn;\n\t/**\n\t * Logger.\n\t */\n\tlogger?: Logger;\n};\n\ntype StoredTokens = {\n\taccessToken?: string;\n\trefreshToken?: string;\n\t/**\n\t * Epoch timestamp (ms).\n\t */\n\texpiresAt?: number;\n};\n\n/**\n * AuthManager.\n *\n * - Owns CAT lifecycle (stores, optional refresh via attached OIDCAuth)\n * - Mints and serves BATs (NUT-22)\n * - Validates DLEQs for BATs per NUT-12.\n * - Supplies serialized BATs for 'Blind-auth' and CAT for 'Clear-auth'\n */\nexport class AuthManager implements AuthProvider {\n\tprivate readonly mintUrl: string;\n\tprivate readonly req: RequestFn;\n\tprivate readonly logger: Logger;\n\tprivate info?: MintInfo;\n\tprivate lockChain?: Promise<void>;\n\tprivate inflightRefresh?: Promise<void>;\n\tprivate static readonly MIN_VALID_SECS = 30;\n\n\t// Open ID Connect (OIDC)\n\tprivate oidc?: OIDCAuth;\n\tprivate tokens: StoredTokens = {};\n\n\t// Blind Auth Token (BAT) pool\n\tprivate pool: Proof[] = [];\n\tprivate desiredPoolSize = 10;\n\tprivate maxPerMint = 10;\n\n\t// Keychain for 'auth' unit\n\tprivate keychain?: KeyChain;\n\n\tconstructor(mintUrl: string, opts?: AuthManagerOptions) {\n\t\tthis.mintUrl = mintUrl;\n\t\tthis.req = opts?.request ?? request;\n\t\tthis.logger = opts?.logger ?? NULL_LOGGER;\n\t\tthis.desiredPoolSize = Math.max(1, opts?.desiredPoolSize ?? this.desiredPoolSize);\n\t\tthis.maxPerMint = Math.max(1, opts?.maxPerMint ?? this.maxPerMint);\n\t}\n\n\t// ------------------------------\n\t// Public API\n\t// ------------------------------\n\n\t/**\n\t * Attach an OIDCAuth instance so this manager can refresh CATs. Registers a listener to update\n\t * internal CAT/refresh state on new tokens.\n\t */\n\tattachOIDC(oidc: OIDCAuth): this {\n\t\tthis.oidc = oidc;\n\t\tthis.oidc.addTokenListener((t) => this.updateFromOIDC(t));\n\t\treturn this;\n\t}\n\n\tget poolSize(): number {\n\t\treturn this.pool.length;\n\t}\n\tget poolTarget(): number {\n\t\treturn this.desiredPoolSize;\n\t}\n\tget activeAuthKeysetId(): string | undefined {\n\t\ttry {\n\t\t\treturn this.keychain?.getCheapestKeyset().id;\n\t\t} catch {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\tget hasCAT(): boolean {\n\t\treturn !!this.tokens.accessToken;\n\t}\n\n\t// ------------------------------\n\t// AuthProvider (NUT-21, Clear-auth)\n\t// ------------------------------\n\n\tgetCAT(): string | undefined {\n\t\treturn this.tokens.accessToken;\n\t}\n\n\tsetCAT(cat: string | undefined): void {\n\t\tthis.tokens.accessToken = cat;\n\t\tif (!cat) {\n\t\t\tthis.tokens.refreshToken = undefined;\n\t\t\tthis.tokens.expiresAt = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Ensure a valid CAT is available (refresh if expiring soon). Returns a token safe to send right\n\t * now, or undefined if unobtainable.\n\t */\n\tasync ensureCAT(minValidSecs?: number): Promise<string | undefined> {\n\t\tif (this.validForAtLeast(minValidSecs)) {\n\t\t\treturn this.tokens.accessToken;\n\t\t}\n\n\t\tif (!this.oidc || !this.tokens.refreshToken) {\n\t\t\treturn this.tokens.accessToken; // nothing we can do\n\t\t}\n\n\t\t// One refresh at a time\n\t\tif (!this.inflightRefresh) {\n\t\t\tthis.inflightRefresh = (async () => {\n\t\t\t\ttry {\n\t\t\t\t\tconst tok = await this.oidc!.refresh(this.tokens.refreshToken!);\n\t\t\t\t\tthis.updateFromOIDC(tok);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tthis.logger.warn('AuthManager: CAT refresh failed', { err });\n\t\t\t\t} finally {\n\t\t\t\t\tthis.inflightRefresh = undefined;\n\t\t\t\t}\n\t\t\t})();\n\t\t}\n\t\tawait this.inflightRefresh;\n\t\treturn this.validForAtLeast(0) ? this.tokens.accessToken : undefined;\n\t}\n\n\t// Returns true if expiry date is >minValidSecs away\n\tprivate validForAtLeast(minValidSecs: number = AuthManager.MIN_VALID_SECS): boolean {\n\t\tconst { accessToken, expiresAt } = this.tokens;\n\t\tif (!accessToken) return false;\n\t\tif (!expiresAt) return true; // Unknown expiry, allow and rely on server to reject if invalid\n\t\treturn Date.now() + minValidSecs * 1000 < expiresAt;\n\t}\n\n\t// Updates access and refresh tokens in our store, using either the explicit expires_in key or falling back to the JWT expiry.\n\tprivate updateFromOIDC(t: TokenResponse): void {\n\t\tif (!t.access_token) return;\n\t\tconst nowMs = Date.now();\n\t\tthis.tokens.accessToken = t.access_token;\n\t\tif (t.refresh_token) this.tokens.refreshToken = t.refresh_token;\n\t\tif (typeof t.expires_in === 'number' && t.expires_in > 0) {\n\t\t\tthis.tokens.expiresAt = nowMs + t.expires_in * 1000; // Prefer expires_in\n\t\t} else {\n\t\t\t// Fall back to JWT exp, else undefined\n\t\t\tconst expSec = this.parseJwtExpSec(t.access_token);\n\t\t\tthis.tokens.expiresAt = expSec ? expSec * 1000 : undefined;\n\t\t}\n\t\tthis.logger.debug('AuthManager: OIDC tokens updated', { expiresAt: this.tokens.expiresAt });\n\t}\n\n\t// ------------------------------\n\t// AuthProvider (NUT-22, Blind-auth)\n\t// ------------------------------\n\n\t/**\n\t * Ensure there are enough BAT tokens (topping up if needed)\n\t *\n\t * @param minTokens Minimum tokens needed.\n\t */\n\tasync ensure(minTokens: number): Promise<void> {\n\t\tawait this.init();\n\t\tif (this.pool.length >= minTokens) return;\n\t\tconst toTarget = Math.max(this.desiredPoolSize, minTokens);\n\t\tconst batMax = this.getBatMaxMint();\n\t\tconst batch = Math.min(toTarget - this.pool.length, batMax);\n\t\tif (batch <= 0) return;\n\t\tawait this.topUp(batch);\n\t}\n\n\t/**\n\t * Gets a Blind Authentication Token (BAT)\n\t *\n\t * @param {method, path} to Call (not used in our implementation)\n\t * @returns The serialized BAT ready to insert into request header.\n\t */\n\tasync getBlindAuthToken({\n\t\tmethod,\n\t\tpath,\n\t}: {\n\t\tmethod: 'GET' | 'POST';\n\t\tpath: string;\n\t}): Promise<string> {\n\t\tif (this.info && !this.info.requiresBlindAuthToken(method, path)) {\n\t\t\tthis.logger.warn('Endpoint is not marked as protected by NUT-22; still issuing BAT', {\n\t\t\t\tmethod,\n\t\t\t\tpath,\n\t\t\t});\n\t\t}\n\n\t\treturn this.withLock(async () => {\n\t\t\tawait this.ensure(1);\n\t\t\tif (this.pool.length === 0) {\n\t\t\t\tthrow new Error('AuthManager: no BATs available and minting failed');\n\t\t\t}\n\t\t\t// Pop one BAT and serialize without DLEQ for the header. Per NUT-22, wallets\n\t\t\t// SHOULD delete BAT even on error, so no need to track it in-flight.\n\t\t\tconst proof = this.pool.pop()!;\n\t\t\tthis.logger.debug('AuthManager: BAT requested', {\n\t\t\t\tmethod,\n\t\t\t\tpath,\n\t\t\t\tremaining: this.pool.length,\n\t\t\t});\n\t\t\treturn serializeBAT(proof);\n\t\t});\n\t}\n\n\t/**\n\t * Replace or merge the current BAT pool with previously persisted BATs.\n\t */\n\timportPool(proofs: Proof[], mode: 'replace' | 'merge' = 'replace'): void {\n\t\tif (mode === 'replace') {\n\t\t\tthis.pool = [];\n\t\t}\n\t\tconst seen = new Map(this.pool.map((p) => [p.secret, p]));\n\t\tfor (const p of proofs) {\n\t\t\tif (!p || !p.secret || !p.C || !p.id) continue; // shape check\n\t\t\tif (!seen.has(p.secret)) {\n\t\t\t\tthis.pool.push(p);\n\t\t\t\tseen.set(p.secret, p);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Return a deep-copied snapshot of the current BAT pool (full Proofs, including dleq).\n\t */\n\texportPool(): Proof[] {\n\t\treturn this.pool.map((p) => ({ ...p, dleq: p.dleq ? { ...p.dleq } : undefined }));\n\t}\n\n\t// ------------------------------\n\t// Internals\n\t// ------------------------------\n\n\t/**\n\t * Extract exp, seconds since epoch, from a JWT access token.\n\t */\n\tprivate parseJwtExpSec(token?: string): number | undefined {\n\t\tif (!token) return;\n\t\tconst parts = token.split('.');\n\t\tif (parts.length !== 3) return;\n\t\ttry {\n\t\t\tconst jsonStr = Bytes.toString(Bytes.fromBase64(parts[1]));\n\t\t\tconst obj = JSON.parse(jsonStr) as { exp?: unknown };\n\t\t\tconst exp = typeof obj.exp === 'number' ? obj.exp : Number(obj.exp);\n\t\t\tif (Number.isFinite(exp) && exp > 0) return exp;\n\t\t} catch {\n\t\t\tthis.logger.warn('JWT access token was malformed.', {\n\t\t\t\ttoken,\n\t\t\t});\n\t\t}\n\t\treturn;\n\t}\n\n\t/**\n\t * Simple mutex lock - chains promises in order.\n\t */\n\tprivate async withLock<T>(fn: () => T | Promise<T>): Promise<T> {\n\t\tconst prev = this.lockChain ?? Promise.resolve();\n\t\tlet release!: () => void;\n\t\tconst lock = new Promise<void>((resolve) => {\n\t\t\trelease = resolve;\n\t\t});\n\t\tconst chain = prev.then(() => lock); // capture the exact Promise we assign\n\t\tthis.lockChain = chain;\n\t\ttry {\n\t\t\tawait prev;\n\t\t\treturn await fn();\n\t\t} finally {\n\t\t\trelease();\n\t\t\t// Only clear if no newer chain has been installed\n\t\t\tif (this.lockChain === chain) this.lockChain = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Initialise mint info and auth keysets/keys as needed.\n\t */\n\tprivate async init(): Promise<void> {\n\t\tif (!this.info) {\n\t\t\tconst info = await this.req<GetInfoResponse>({\n\t\t\t\tendpoint: joinUrls(this.mintUrl, '/v1/info'),\n\t\t\t\tmethod: 'GET',\n\t\t\t});\n\t\t\tthis.info = new MintInfo(info);\n\t\t}\n\t\tif (!this.keychain) {\n\t\t\t// fetch blind keysets and keys for unit 'auth'\n\t\t\tconst [allKeysets, allKeys] = await Promise.all([\n\t\t\t\tthis.req<MintAllKeysets>({\n\t\t\t\t\tendpoint: joinUrls(this.mintUrl, '/v1/auth/blind/keysets'),\n\t\t\t\t\tmethod: 'GET',\n\t\t\t\t}),\n\t\t\t\tthis.req<MintActiveKeys>({\n\t\t\t\t\tendpoint: joinUrls(this.mintUrl, '/v1/auth/blind/keys'),\n\t\t\t\t\tmethod: 'GET',\n\t\t\t\t}),\n\t\t\t]);\n\t\t\t// build a KeyChain preloaded with caches, unit 'auth'\n\t\t\t// Then smoke test to surface errors early - no need to init() with cached keys\n\t\t\tthis.keychain = new KeyChain(this.mintUrl, 'auth', allKeysets.keysets, allKeys.keysets);\n\t\t\tthis.keychain.getCheapestKeyset();\n\t\t}\n\t}\n\n\t/**\n\t * Gets the BAT minting limit: lower of manager limit and Mint’s NUT-22 limit.\n\t */\n\tprivate getBatMaxMint(): number {\n\t\tif (!this.info) throw new Error('AuthManager: mint info not loaded');\n\t\tconst n22 = this.info.nuts['22'];\n\t\tconst mintMax = n22?.bat_max_mint ?? this.maxPerMint;\n\t\treturn Math.max(1, Math.min(this.maxPerMint, mintMax));\n\t}\n\n\tprivate getActiveKeys(): Keyset {\n\t\tif (!this.keychain) throw new Error('AuthManager: keyset not loaded for active keyset');\n\t\treturn this.keychain.getCheapestKeyset();\n\t}\n\n\t/**\n\t * Mint a batch of BATs using the current CAT if the endpoint is protected by NUT-21.\n\t */\n\tprivate async topUp(n: number): Promise<void> {\n\t\tif (!this.info) throw new Error('AuthManager: mint info not loaded');\n\n\t\t// Check NUT-21 protection of the BAT mint endpoint\n\t\tconst needsCAT = this.info.requiresClearAuthToken('POST', '/v1/auth/blind/mint');\n\t\tlet cat: string | undefined;\n\t\tif (needsCAT) {\n\t\t\tcat = await this.ensureCAT();\n\t\t\tif (!cat) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'AuthManager: Clear-auth token required for /v1/auth/blind/mint but not available. Authenticate with the mint to obtain a CAT first.',\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\t// Create blinded messages for amount n in unit 'auth' (supports only 1s)\n\t\tconst keys = this.getActiveKeys();\n\t\tconst outputs = OutputData.createRandomData(n, keys);\n\t\tconst payload = { outputs: outputs.map((d) => d.blindedMessage) };\n\t\t// Set CAT header if needed\n\t\tconst headers: Record<string, string> = {};\n\t\tif (cat) headers['Clear-auth'] = cat;\n\t\t// Do the topup\n\t\tconst res = await this.req<BlindAuthMintResponse>({\n\t\t\tendpoint: joinUrls(this.mintUrl, '/v1/auth/blind/mint'),\n\t\t\tmethod: 'POST',\n\t\t\theaders,\n\t\t\trequestBody: payload as unknown as Record<string, unknown>,\n\t\t});\n\t\tif (!Array.isArray(res?.signatures) || res.signatures.length !== outputs.length) {\n\t\t\tthrow new Error('AuthManager: bad BAT mint response');\n\t\t}\n\t\t// Create BAT proofs and check DLEQ\n\t\tconst proofs = outputs.map((d, i) => d.toProof(res.signatures[i], keys));\n\t\tfor (const p of proofs) {\n\t\t\tif (!hasValidDleq(p, keys)) {\n\t\t\t\tthrow new Error('AuthManager: mint returned BAT with invalid DLEQ');\n\t\t\t}\n\t\t}\n\t\t// Add BAT proofs to pool\n\t\tthis.pool.push(...proofs);\n\t\tthis.logger.debug('AuthManager: performed topUp', {\n\t\t\tminted: proofs.length,\n\t\t\tpool: this.pool.length,\n\t\t});\n\t}\n}\n\n// ------------------------------\n// Helpers\n// ------------------------------\n\n/**\n * Serialize an Auth Proof as a BAT header value: \"authA\" + base64(JSON_without_dleq)\n */\nfunction serializeBAT(proof: Proof): string {\n\t// strip dleq per NUT-22\n\tconst token = { id: proof.id, secret: proof.secret, C: proof.C };\n\tconst base64Data = encodeJsonToBase64(token);\n\treturn `authA${base64Data}`;\n}\n","import { type Logger } from '../logger';\nimport { Mint } from '../mint/Mint';\nimport { Wallet } from '../wallet/Wallet';\nimport { AuthManager } from './AuthManager';\nimport type { OIDCAuth, OIDCAuthOptions } from './OIDCAuth';\n\n/**\n * High-level helper to create a fully authenticated wallet session.\n *\n * @remarks\n * Like a dependency injector, it wires AuthManager->Mint->OIDCAuth->Wallet in the correct order.\n * Wallet is returned ready to use.\n * @param mintUrl URL of the mint to connect to.\n * @param options.authPool Optional. Desired BAT pool size (default 10)\n * @param options.oidc Optional. Options for OIDCAuth (scope, clientId, logger, etc.)\n * @returns {mint, auth, oidc, wallet} — hydrated, ready to use.\n * @throws If mint does not require authentication.\n */\nexport async function createAuthWallet(\n\tmintUrl: string,\n\toptions?: {\n\t\tauthPool?: number;\n\t\toidc?: OIDCAuthOptions;\n\t\tlogger?: Logger;\n\t},\n): Promise<{ mint: Mint; auth: AuthManager; oidc: OIDCAuth; wallet: Wallet }> {\n\t// 1. Create an AuthManager for both BAT and CAT handling\n\tconst auth = new AuthManager(mintUrl, {\n\t\tdesiredPoolSize: options?.authPool ?? 10,\n\t\tlogger: options?.logger,\n\t});\n\n\t// 2. Create a Mint instance using the AuthManager\n\tconst mint = new Mint(mintUrl, { authProvider: auth, logger: options?.logger });\n\n\t// 3. Discover and configure OIDCAuth from the mint\n\tconst oidc = await mint.oidcAuth({\n\t\t...options?.oidc,\n\t\tlogger: options?.logger,\n\t\tonTokens: (t) => auth.setCAT(t.access_token), // set CAT automatically\n\t});\n\n\t// 4. Attach OIDCAuth back into AuthManager for refresh, etc.\n\tauth.attachOIDC(oidc);\n\n\t// 5. Hydrate wallet using the same mint and auth provider\n\tconst wallet = new Wallet(mint, { authProvider: auth, logger: options?.logger });\n\tawait wallet.loadMint();\n\n\treturn { mint, auth, oidc, wallet };\n}\n"],"names":["MeltQuoteState","MintQuoteState","HttpResponseError","message","status","NetworkError","MintOperationError","code","detail","NULL_LOGGER","fail","logger","context","failIf","condition","failIfNullish","value","safeCallback","cb","payload","maybePromise","error","LEVEL_ORDER","ConsoleLogger","minLevel","level","ctx","out","k","v","line","fn","msg","measureTime","start","globalRequestOptions","requestLogger","setGlobalRequestOptions","options","setRequestLogger","_request","endpoint","requestBody","requestHeaders","body","headers","response","err","errorData","errorMessage","request","_WS","injectWebSocketImpl","ws","getWebSocketImpl","Bytes","hex","matches","byte","bytes","str","arrays","totalLength","sum","arr","result","offset","size","buffer","i","chunk","base64","normalizedBase64","c","a","b","minLength","encodeUint8toBase64Url","encodeBase64toUint8","base64String","encodeJsonToBase64","jsonObj","jsonString","base64urlFromBase64","encodeBase64ToJson","base64urlToBase64","isBase64String","base64url","normalized","padLength","padded","decoded","reStandard","reUrl","originalNoPad","isResultKeyType","encodeCBOR","encodeItem","encodeNumber","encodeString","encodeArray","encodeByteString","encodeObject","encodeUnsigned","encodeSigned","unsigned","encodeFloat64","ab","dv","length","utf8","item","keys","key","decodeCBOR","data","view","decodeItem","initialByte","majorType","additionalInfo","decodeUnsigned","decodeSigned","decodeByteString","decodeString","decodeArray","decodeMap","decodeSimpleAndFloat","ensureAvailable","needed","decodeLength","hi","lo","newOffset","array","currentOffset","map","keyResult","valueResult","decodeFloat16","uint16","exponent","fraction","sign","P2BK_DST","utf8ToBytes","deriveP2BKBlindedPubkeys","pubkeys","keysetId","eBytes","secp256k1","e","E","kid","hexToBytes","pubkey","P","pointFromHex","r","deriveP2BKBlindingTweakFromECDH","P_","bytesToHex","deriveP2BKSecretKeys","Ehex","privateKey","blindPubKey","keysetIdHex","privs","pubs","privHex","p","hexP_","kHex","deriveP2BKSecretKey","privkey","rBlind","blindPubkey","naturalPub","n","hexToNumber","skStd","skNeg","numberToHexPadded64","R","xP","xNaturalPub","yP","yNaturalPub","point","scalar","slotIndex","Zx","iByte","bytesToNumber","sha256","createP2PKsecret","newSecret","randomBytes","parseP2PKSecret","secret","signP2PKSecret","msghash","sig","schnorr","signBlindedMessage","B_","msgHash","verifyP2PKSecretSignature","signature","pubkeyX","hasP2PKSignedProof","proof","getP2PKWitnessSignatures","getP2PKExpectedKWitnessPubkeys","secretStr","now","getP2PKLocktime","getP2PKWitnessPubkeys","getP2PKWitnessRefundkeys","tags","pubkeysTag","tag","refundTag","locktimeTag","getP2PKNSigs","n_sigsTag","n_sigs_refundTag","getP2PKSigFlag","sigFlagTag","witness","signP2PKProofs","proofs","index","privateKeys","maybeDeriveP2BKPrivateKeys","signedProof","priv","signP2PKProof","parsed","witnesses","w","signatures","verifyP2PKSig","parsedSecret","signatories","requiredSigs","verifyP2PKSigOutput","output","publicKey","getSignedOutput","getSignedOutputs","outputs","o","DOMAIN_SEPARATOR","hashToCurve","msgToHash","counter","maxIterations","counterBytes","hash","hash_e","e_","pointFromBytes","getKeysetIdInt","keysetIdInt","createRandomSecretKey","createBlindSignature","amount","id","createRandomBlindedMessage","blindMessage","Y","rG","unblindSignature","C_","A","constructProofFromPromise","promise","C","serializeProof","deserializeProof","DERIVATION_PATH","serializeMintKeys","mintKeys","serializedMintKeys","deserializeMintKeys","getPubKeyFromPrivKey","privKey","createNewMintKeys","pow2height","seed","pubKeys","privKeys","masterKey","HDKey","deriveKeysetId","verifyProof","STANDARD_DERIVATION_PATH","deriveSecret","isValidHex","derive_deprecated","derive","deriveBlindingFactor","secretOrBlinding","hmac","hdkey","derivationPath","derived","arraysEqual","arr1","arr2","verifyDLEQProof","dleq","sG","eA","sB_","eC_","R_1","R_2","verifyDLEQProof_reblind","bG","createDLEQProof","scalar_a","scalar_e","s_scalar","numberToBytesBE","constructMessage","quote","blindedMessages","blindedMessage","msgbytes","signMintQuote","privkeyBytes","verifyMintQuoteSignature","sigbytes","pubkeyBytes","PaymentRequest","transport","unit","mints","description","singleUse","nut10","nut26","rawRequest","t","type","rawPaymentRequest","transports","encodedRequest","encodedData","splitAmount","keyset","split","order","totalSplitAmount","sumArray","positive","amt","totalPositive","hasCorrespondingKey","sortedKeyAmounts","getKeysetAmounts","requireCount","getKeepAmounts","proofsWeHave","amountToKeep","targetCount","amountsWeWant","amountsWeHave","countWeHave","countWeWant","amountDiff","number","hasNonHexId","bigIntStringify","_key","getEncodedTokenV3","token","removeDleq","convertToShortKeysetId","stripDleq","v3TokenObj","newP","getEncodedToken","opts","getEncodedTokenV4","tokenTemplate","templateFromToken","prefix","version","base64Data","idMap","mint","tokenFromTemplate","template","decodedToken","getDecodedToken","tokenString","keysets","removePrefix","tokenObj","handleTokens","mapShortKeysetIds","getTokenMetadata","sumProofs","encodedToken","parsedV3Token","entry","uInt8Token","tokenData","expiry","versionByte","isDeprecatedBase64","pubkeysConcat","pubKey","prev","curr","mergeUInt8Arrays","hashHex","a1","a2","mergedArray","sortProofsById","isObj","checkResponse","joinUrls","parts","part","sanitizeUrl","url","acc","decodePaymentRequest","paymentRequest","MessageNode","node","MessageQueue","messageNode","newNode","verifyKeysetId","isBase64","newProofs","idBytes","found","hasValidDleq","concatByteArrays","byteArray","pointer","getEncodedTokenBinary","utf8Encoder","binaryTemplate","getDecodedTokenBinary","utfDecoder","binaryToken","deepEqual","keysA","keysB","ConnectionManager","newConn","WSConnection","resolve","reject","method","params","subId","callback","errorCallback","notification","handleMeltQuoteResponseDeprecated","handleMintQuoteResponseDeprecated","handleMintInfoContactFieldDeprecated","contact","MintInfo","info","pe22","pe21","num","path","idx","cacheKey","cached","exactHit","regexHit","res","mintMeltInfo","maybe","rec","mm","pp","endpoints","exact","regex","metachar","met","OIDCAuth","discoveryUrl","n21","clientId","scope","text","json","cfg","rnd","verifier","vBytes","chBytes","challenge","input","form","tok","ep","device_code","intervalSec","delay","interval","aborted","refresh_token","username","password","listener","enc","formBody","ms","Mint","mintUrl","customRequest","swapPayload","errDetail","mintQuotePayload","mintPayload","meltQuotePayload","meltPayload","checkPayload","targetUrl","restorePayload","wsSegment","bat","init","requestInstance","cat","Keyset","active","input_fee_ppk","final_expiry","KeyChain","cachedKeysets","cachedKeys","arrayOfKeys","forceRefresh","allKeysetsResponse","allKeysResponse","allKeysets","allKeys","keysMap","mk","activeKeysets","BlindedMessage","RESERVED_P2PK_TAGS","assertValidTagKey","MAX_SECRET_LENGTH","EPHEMERAL_E","setEphemeralE","target","takeEphemeralE","OutputData","blindingFactor","blindSignature","serializedProof","p2pk","customSplit","lockKeys","refundKeys","reqLock","reqRefund","refund","ordered","blinded","_E","ts","vals","charCount","secretBytes","od","randomHex","secretBytesAsHex","utf8SecretBytes","deterministicR","normalisePubkey","pk","toUnixSeconds","P2PKBuilder","when","values","locks","refunds","total","selectProofsRGLI","amountToSend","keyChain","includeFees","exactMatch","_logger","timer","bestSubset","bestDelta","bestAmount","bestFeePPK","feeForProof","sumExFees","feePPK","shuffleArray","shuffled","j","binarySearchIndex","lessOrEqual","left","right","mid","midValue","insertSorted","obj","calculateDelta","totalAmount","totalFeePPK","proofWithFees","ppkfee","exFee","spendableProofs","endIndex","rightIndex","biggerIndex","nextBiggerExFee","totalNetSum","maxOverAmount","trial","S","newAmount","newFeePPK","netSum","SSet","others","indices","_","objP","tempAmount","tempFeePPK","tempNetSum","qIndex","objQ","delta","tempS","tempDelta","bestSum","bestProofs","bestSubsetSet","keep","EphemeralCounterSource","initial","release","chain","cur","minNext","next","WalletOps","wallet","SendBuilder","ReceiveBuilder","MintBuilder","MeltBuilder","denoms","factory","on","requireDleq","outputConfig","bolt11","bolt12","safeStringify","seen","_k","normalizeError","makeAbortError","cancelSafely","WalletEvents","signal","cancel","onAbort","subscribeFn","timeoutMsg","cancelP","to","cleanup","h","ids","uniq","proofMap","y","ys","handler","unique","cancels","lastError","fullyRegistered","quoteId","thisCanceller","queue","done","notify","max","dropMode","wake","push","dropped","cancelled","cancelAll","WalletCounters","src","CheckStateEnum","PENDING_KEYSET_ID","Wallet","promises","totalOutputs","ot","outputTypes","range","cursor","patched","need","used","ks","outputType","customTotal","denominations","receiveFee","receiveFeeAmounts","splitSum","outputData","inputs","keepOutputs","sendOutputs","mergedBlindingData","keepVector","sortedOutputData","sortedKeepVector","d","config","onCountersReserved","tokenMintUrl","netAmount","receiveOT","autoCounters","swapTransaction","proofsReceived","orderedProofs","s","send","sendPrepared","wantsDeterministicByPolicy","isPlainRandom","reasons","expectedFee","sendOT","sendAmount","unselectedProofs","selectedProofs","selectedSum","swapFee","changeAmount","keepOT","keepAmount","swapProofs","reorderedProofs","reorderedKeepVector","keepProofs","sendProofs","sumPPK","nInputs","keepDleq","p2pk_e","rest","gapLimit","batchSize","requiredEmptyBatches","restoredProofs","lastCounterWithSignature","emptyBatchesFound","restoreRes","count","zeros","signatureMap","matchingSig","supported","resPubkey","mintInfo","baseRes","mintOT","mintAmount","mintQuoteSignature","invoice","meltQuote","offer","amountMsat","millisatPartialAmount","meltOptions","proofsToSend","onChangeOutputsCreated","feeReserve","meltOT","blanks","meltResponse","preferAsync","change","Ys","BATCH_SIZE","states","YsSlice","batchStates","stateMap","state","PaymentRequestTransportType","_AuthManager","oidc","minValidSecs","accessToken","expiresAt","nowMs","expSec","minTokens","toTarget","batMax","batch","serializeBAT","mode","jsonStr","exp","lock","mintMax","needsCAT","AuthManager","createAuthWallet","auth"],"mappings":"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"}