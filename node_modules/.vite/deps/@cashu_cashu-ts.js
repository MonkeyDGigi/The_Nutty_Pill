import "./chunk-UXIASGQL.js";

// node_modules/@noble/hashes/esm/crypto.js
var crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/@noble/hashes/esm/utils.js
function isBytes(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function anumber(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error("positive integer expected, got " + n);
}
function abytes(b, ...lengths) {
  if (!isBytes(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function ahash(h) {
  if (typeof h !== "function" || typeof h.create !== "function")
    throw new Error("Hash should be wrapped by utils.createHasher");
  anumber(h.outputLen);
  anumber(h.blockLen);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
function clean(...arrays) {
  for (let i = 0; i < arrays.length; i++) {
    arrays[i].fill(0);
  }
}
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word, shift) {
  return word << 32 - shift | word >>> shift;
}
function rotl(word, shift) {
  return word << shift | word >>> 32 - shift >>> 0;
}
var isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
var hasHexBuiltin = (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();
var hexes = Array.from({ length: 256 }, (_2, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(bytes) {
  abytes(bytes);
  if (hasHexBuiltin)
    return bytes.toHex();
  let hex2 = "";
  for (let i = 0; i < bytes.length; i++) {
    hex2 += hexes[bytes[i]];
  }
  return hex2;
}
var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9)
    return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F)
    return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f)
    return ch - (asciis.a - 10);
  return;
}
function hexToBytes(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  if (hasHexBuiltin)
    return Uint8Array.fromHex(hex2);
  const hl = hex2.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex2.charCodeAt(hi));
    const n2 = asciiToBase16(hex2.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex2[hi] + hex2[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes(data);
  return data;
}
function concatBytes(...arrays) {
  let sum = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    abytes(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}
var Hash = class {
};
function createHasher(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto && typeof crypto.getRandomValues === "function") {
    return crypto.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto && typeof crypto.randomBytes === "function") {
    return Uint8Array.from(crypto.randomBytes(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l, wl, isLE2);
}
function Chi(a, b, c) {
  return a & b ^ ~a & c;
}
function Maj(a, b, c) {
  return a & b ^ a & c ^ b & c;
}
var HashMD = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    aexists(this);
    data = toBytes(data);
    abytes(data);
    const { view, buffer, blockLen } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    clean(this.buffer.subarray(pos));
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.destroyed = destroyed;
    to.finished = finished;
    to.length = length;
    to.pos = pos;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
};
var SHA256_IV = Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA224_IV = Uint32Array.from([
  3238371032,
  914150663,
  812702999,
  4144912697,
  4290775857,
  1750603025,
  1694076839,
  3204075428
]);
var SHA384_IV = Uint32Array.from([
  3418070365,
  3238371032,
  1654270250,
  914150663,
  2438529370,
  812702999,
  355462360,
  4144912697,
  1731405415,
  4290775857,
  2394180231,
  1750603025,
  3675008525,
  1694076839,
  1203062813,
  3204075428
]);
var SHA512_IV = Uint32Array.from([
  1779033703,
  4089235720,
  3144134277,
  2227873595,
  1013904242,
  4271175723,
  2773480762,
  1595750129,
  1359893119,
  2917565137,
  2600822924,
  725511199,
  528734635,
  4215389547,
  1541459225,
  327033209
]);

// node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
function fromBig(n, le2 = false) {
  if (le2)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le2 = false) {
  const len = lst.length;
  let Ah = new Uint32Array(len);
  let Al = new Uint32Array(len);
  for (let i = 0; i < len; i++) {
    const { h, l } = fromBig(lst[i], le2);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
var shrSH = (h, _l, s) => h >>> s;
var shrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
function add(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;

// node_modules/@noble/hashes/esm/sha2.js
var SHA256_K = Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends HashMD {
  constructor(outputLen = 32) {
    super(64, outputLen, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G: G2, H } = this;
    return [A, B, C, D, E, F, G2, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G2, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G2 | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G: G2, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G2) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G2;
      G2 = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G2 = G2 + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G2, H);
  }
  roundClean() {
    clean(SHA256_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    clean(this.buffer);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super(28);
    this.A = SHA224_IV[0] | 0;
    this.B = SHA224_IV[1] | 0;
    this.C = SHA224_IV[2] | 0;
    this.D = SHA224_IV[3] | 0;
    this.E = SHA224_IV[4] | 0;
    this.F = SHA224_IV[5] | 0;
    this.G = SHA224_IV[6] | 0;
    this.H = SHA224_IV[7] | 0;
  }
};
var K512 = (() => split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n) => BigInt(n))))();
var SHA512_Kh = (() => K512[0])();
var SHA512_Kl = (() => K512[1])();
var SHA512_W_H = new Uint32Array(80);
var SHA512_W_L = new Uint32Array(80);
var SHA512 = class extends HashMD {
  constructor(outputLen = 64) {
    super(128, outputLen, 16, false);
    this.Ah = SHA512_IV[0] | 0;
    this.Al = SHA512_IV[1] | 0;
    this.Bh = SHA512_IV[2] | 0;
    this.Bl = SHA512_IV[3] | 0;
    this.Ch = SHA512_IV[4] | 0;
    this.Cl = SHA512_IV[5] | 0;
    this.Dh = SHA512_IV[6] | 0;
    this.Dl = SHA512_IV[7] | 0;
    this.Eh = SHA512_IV[8] | 0;
    this.El = SHA512_IV[9] | 0;
    this.Fh = SHA512_IV[10] | 0;
    this.Fl = SHA512_IV[11] | 0;
    this.Gh = SHA512_IV[12] | 0;
    this.Gl = SHA512_IV[13] | 0;
    this.Hh = SHA512_IV[14] | 0;
    this.Hl = SHA512_IV[15] | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4) {
      SHA512_W_H[i] = view.getUint32(offset);
      SHA512_W_L[i] = view.getUint32(offset += 4);
    }
    for (let i = 16; i < 80; i++) {
      const W15h = SHA512_W_H[i - 15] | 0;
      const W15l = SHA512_W_L[i - 15] | 0;
      const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
      const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i - 2] | 0;
      const W2l = SHA512_W_L[i - 2] | 0;
      const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
      const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
      const SUMl = add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
      const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
      SHA512_W_H[i] = SUMh | 0;
      SHA512_W_L[i] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i = 0; i < 80; i++) {
      const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);
      const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
      const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
      const T1l = T1ll | 0;
      const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);
      const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = add3L(T1l, sigma0l, MAJl);
      Ah = add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    clean(SHA512_W_H, SHA512_W_L);
  }
  destroy() {
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var SHA384 = class extends SHA512 {
  constructor() {
    super(48);
    this.Ah = SHA384_IV[0] | 0;
    this.Al = SHA384_IV[1] | 0;
    this.Bh = SHA384_IV[2] | 0;
    this.Bl = SHA384_IV[3] | 0;
    this.Ch = SHA384_IV[4] | 0;
    this.Cl = SHA384_IV[5] | 0;
    this.Dh = SHA384_IV[6] | 0;
    this.Dl = SHA384_IV[7] | 0;
    this.Eh = SHA384_IV[8] | 0;
    this.El = SHA384_IV[9] | 0;
    this.Fh = SHA384_IV[10] | 0;
    this.Fl = SHA384_IV[11] | 0;
    this.Gh = SHA384_IV[12] | 0;
    this.Gl = SHA384_IV[13] | 0;
    this.Hh = SHA384_IV[14] | 0;
    this.Hl = SHA384_IV[15] | 0;
  }
};
var T224_IV = Uint32Array.from([
  2352822216,
  424955298,
  1944164710,
  2312950998,
  502970286,
  855612546,
  1738396948,
  1479516111,
  258812777,
  2077511080,
  2011393907,
  79989058,
  1067287976,
  1780299464,
  286451373,
  2446758561
]);
var T256_IV = Uint32Array.from([
  573645204,
  4230739756,
  2673172387,
  3360449730,
  596883563,
  1867755857,
  2520282905,
  1497426621,
  2519219938,
  2827943907,
  3193839141,
  1401305490,
  721525244,
  746961066,
  246885852,
  2177182882
]);
var SHA512_224 = class extends SHA512 {
  constructor() {
    super(28);
    this.Ah = T224_IV[0] | 0;
    this.Al = T224_IV[1] | 0;
    this.Bh = T224_IV[2] | 0;
    this.Bl = T224_IV[3] | 0;
    this.Ch = T224_IV[4] | 0;
    this.Cl = T224_IV[5] | 0;
    this.Dh = T224_IV[6] | 0;
    this.Dl = T224_IV[7] | 0;
    this.Eh = T224_IV[8] | 0;
    this.El = T224_IV[9] | 0;
    this.Fh = T224_IV[10] | 0;
    this.Fl = T224_IV[11] | 0;
    this.Gh = T224_IV[12] | 0;
    this.Gl = T224_IV[13] | 0;
    this.Hh = T224_IV[14] | 0;
    this.Hl = T224_IV[15] | 0;
  }
};
var SHA512_256 = class extends SHA512 {
  constructor() {
    super(32);
    this.Ah = T256_IV[0] | 0;
    this.Al = T256_IV[1] | 0;
    this.Bh = T256_IV[2] | 0;
    this.Bl = T256_IV[3] | 0;
    this.Ch = T256_IV[4] | 0;
    this.Cl = T256_IV[5] | 0;
    this.Dh = T256_IV[6] | 0;
    this.Dl = T256_IV[7] | 0;
    this.Eh = T256_IV[8] | 0;
    this.El = T256_IV[9] | 0;
    this.Fh = T256_IV[10] | 0;
    this.Fl = T256_IV[11] | 0;
    this.Gh = T256_IV[12] | 0;
    this.Gl = T256_IV[13] | 0;
    this.Hh = T256_IV[14] | 0;
    this.Hl = T256_IV[15] | 0;
  }
};
var sha256 = createHasher(() => new SHA256());
var sha224 = createHasher(() => new SHA224());
var sha512 = createHasher(() => new SHA512());
var sha384 = createHasher(() => new SHA384());
var sha512_256 = createHasher(() => new SHA512_256());
var sha512_224 = createHasher(() => new SHA512_224());

// node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
  constructor(hash, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    ahash(hash);
    const key = toBytes(_key);
    this.iHash = hash.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash.create();
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    clean(pad);
  }
  update(buf) {
    aexists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    aexists(this);
    abytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
hmac.create = (hash, key) => new HMAC(hash, key);

// node_modules/@noble/curves/esm/utils.js
var _0n = BigInt(0);
var _1n = BigInt(1);
function _abool2(value, title = "") {
  if (typeof value !== "boolean") {
    const prefix = title && `"${title}"`;
    throw new Error(prefix + "expected boolean, got type=" + typeof value);
  }
  return value;
}
function _abytes2(value, length, title = "") {
  const bytes = isBytes(value);
  const len = value == null ? void 0 : value.length;
  const needsLen = length !== void 0;
  if (!bytes || needsLen && len !== length) {
    const prefix = title && `"${title}" `;
    const ofLen = needsLen ? ` of length ${length}` : "";
    const got = bytes ? `length=${len}` : `type=${typeof value}`;
    throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
  }
  return value;
}
function numberToHexUnpadded(num2) {
  const hex2 = num2.toString(16);
  return hex2.length & 1 ? "0" + hex2 : hex2;
}
function hexToNumber(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  return hex2 === "" ? _0n : BigInt("0x" + hex2);
}
function bytesToNumberBE(bytes) {
  return hexToNumber(bytesToHex(bytes));
}
function bytesToNumberLE(bytes) {
  abytes(bytes);
  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE(n, len) {
  return hexToBytes(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
  return numberToBytesBE(n, len).reverse();
}
function ensureBytes(title, hex2, expectedLength) {
  let res;
  if (typeof hex2 === "string") {
    try {
      res = hexToBytes(hex2);
    } catch (e) {
      throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
    }
  } else if (isBytes(hex2)) {
    res = Uint8Array.from(hex2);
  } else {
    throw new Error(title + " must be hex string or Uint8Array");
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(title + " of length " + expectedLength + " expected, got " + len);
  return res;
}
var isPosBig = (n) => typeof n === "bigint" && _0n <= n;
function inRange(n, min, max) {
  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}
function aInRange(title, n, min, max) {
  if (!inRange(n, min, max))
    throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
}
function bitLen(n) {
  let len;
  for (len = 0; n > _0n; n >>= _1n, len += 1)
    ;
  return len;
}
var bitMask = (n) => (_1n << BigInt(n)) - _1n;
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  const u8n = (len) => new Uint8Array(len);
  const u8of = (byte) => Uint8Array.of(byte);
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h = (...b) => hmacFn(k, v, ...b);
  const reseed = (seed = u8n(0)) => {
    k = h(u8of(0), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8of(1), seed);
    v = h();
  };
  const gen = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
function isHash(val) {
  return typeof val === "function" && Number.isSafeInteger(val.outputLen);
}
function _validateObject(object, fields, optFields = {}) {
  if (!object || typeof object !== "object")
    throw new Error("expected valid options object");
  function checkField(fieldName, expectedType, isOpt) {
    const val = object[fieldName];
    if (isOpt && val === void 0)
      return;
    const current = typeof val;
    if (current !== expectedType || val === null)
      throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
  }
  Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
  Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
}
function memoized(fn2) {
  const map = /* @__PURE__ */ new WeakMap();
  return (arg, ...args) => {
    const val = map.get(arg);
    if (val !== void 0)
      return val;
    const computed = fn2(arg, ...args);
    map.set(arg, computed);
    return computed;
  };
}

// node_modules/@noble/curves/esm/abstract/modular.js
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _7n = BigInt(7);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
function mod(a, b) {
  const result = a % b;
  return result >= _0n2 ? result : b + result;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number, modulo) {
  if (number === _0n2)
    throw new Error("invert: expected non-zero number");
  if (modulo <= _0n2)
    throw new Error("invert: expected positive modulus, got " + modulo);
  let a = mod(number, modulo);
  let b = modulo;
  let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
  while (a !== _0n2) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd2 = b;
  if (gcd2 !== _1n2)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function assertIsSquare(Fp, root, n) {
  if (!Fp.eql(Fp.sqr(root), n))
    throw new Error("Cannot find square root");
}
function sqrt3mod4(Fp, n) {
  const p1div4 = (Fp.ORDER + _1n2) / _4n;
  const root = Fp.pow(n, p1div4);
  assertIsSquare(Fp, root, n);
  return root;
}
function sqrt5mod8(Fp, n) {
  const p5div8 = (Fp.ORDER - _5n) / _8n;
  const n2 = Fp.mul(n, _2n);
  const v = Fp.pow(n2, p5div8);
  const nv = Fp.mul(n, v);
  const i = Fp.mul(Fp.mul(nv, _2n), v);
  const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
  assertIsSquare(Fp, root, n);
  return root;
}
function sqrt9mod16(P) {
  const Fp_ = Field(P);
  const tn2 = tonelliShanks(P);
  const c1 = tn2(Fp_, Fp_.neg(Fp_.ONE));
  const c2 = tn2(Fp_, c1);
  const c3 = tn2(Fp_, Fp_.neg(c1));
  const c4 = (P + _7n) / _16n;
  return (Fp, n) => {
    let tv1 = Fp.pow(n, c4);
    let tv2 = Fp.mul(tv1, c1);
    const tv3 = Fp.mul(tv1, c2);
    const tv4 = Fp.mul(tv1, c3);
    const e1 = Fp.eql(Fp.sqr(tv2), n);
    const e2 = Fp.eql(Fp.sqr(tv3), n);
    tv1 = Fp.cmov(tv1, tv2, e1);
    tv2 = Fp.cmov(tv4, tv3, e2);
    const e3 = Fp.eql(Fp.sqr(tv2), n);
    const root = Fp.cmov(tv1, tv2, e3);
    assertIsSquare(Fp, root, n);
    return root;
  };
}
function tonelliShanks(P) {
  if (P < _3n)
    throw new Error("sqrt is not defined for small field");
  let Q2 = P - _1n2;
  let S = 0;
  while (Q2 % _2n === _0n2) {
    Q2 /= _2n;
    S++;
  }
  let Z = _2n;
  const _Fp = Field(P);
  while (FpLegendre(_Fp, Z) === 1) {
    if (Z++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  }
  if (S === 1)
    return sqrt3mod4;
  let cc = _Fp.pow(Z, Q2);
  const Q1div2 = (Q2 + _1n2) / _2n;
  return function tonelliSlow(Fp, n) {
    if (Fp.is0(n))
      return n;
    if (FpLegendre(Fp, n) !== 1)
      throw new Error("Cannot find square root");
    let M = S;
    let c = Fp.mul(Fp.ONE, cc);
    let t = Fp.pow(n, Q2);
    let R = Fp.pow(n, Q1div2);
    while (!Fp.eql(t, Fp.ONE)) {
      if (Fp.is0(t))
        return Fp.ZERO;
      let i = 1;
      let t_tmp = Fp.sqr(t);
      while (!Fp.eql(t_tmp, Fp.ONE)) {
        i++;
        t_tmp = Fp.sqr(t_tmp);
        if (i === M)
          throw new Error("Cannot find square root");
      }
      const exponent = _1n2 << BigInt(M - i - 1);
      const b = Fp.pow(c, exponent);
      M = i;
      c = Fp.sqr(b);
      t = Fp.mul(t, c);
      R = Fp.mul(R, b);
    }
    return R;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n)
    return sqrt3mod4;
  if (P % _8n === _5n)
    return sqrt5mod8;
  if (P % _16n === _9n)
    return sqrt9mod16(P);
  return tonelliShanks(P);
}
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "number",
    BITS: "number"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  _validateObject(field, opts);
  return field;
}
function FpPow(Fp, num2, power) {
  if (power < _0n2)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n2)
    return Fp.ONE;
  if (power === _1n2)
    return num2;
  let p = Fp.ONE;
  let d = num2;
  while (power > _0n2) {
    if (power & _1n2)
      p = Fp.mul(p, d);
    d = Fp.sqr(d);
    power >>= _1n2;
  }
  return p;
}
function FpInvertBatch(Fp, nums, passZero = false) {
  const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : void 0);
  const multipliedAcc = nums.reduce((acc, num2, i) => {
    if (Fp.is0(num2))
      return acc;
    inverted[i] = acc;
    return Fp.mul(acc, num2);
  }, Fp.ONE);
  const invertedAcc = Fp.inv(multipliedAcc);
  nums.reduceRight((acc, num2, i) => {
    if (Fp.is0(num2))
      return acc;
    inverted[i] = Fp.mul(acc, inverted[i]);
    return Fp.mul(acc, num2);
  }, invertedAcc);
  return inverted;
}
function FpLegendre(Fp, n) {
  const p1mod2 = (Fp.ORDER - _1n2) / _2n;
  const powered = Fp.pow(n, p1mod2);
  const yes = Fp.eql(powered, Fp.ONE);
  const zero = Fp.eql(powered, Fp.ZERO);
  const no = Fp.eql(powered, Fp.neg(Fp.ONE));
  if (!yes && !zero && !no)
    throw new Error("invalid Legendre symbol result");
  return yes ? 1 : zero ? 0 : -1;
}
function nLength(n, nBitLength) {
  if (nBitLength !== void 0)
    anumber(nBitLength);
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLenOrOpts, isLE2 = false, opts = {}) {
  if (ORDER <= _0n2)
    throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
  let _nbitLength = void 0;
  let _sqrt = void 0;
  let modFromBytes = false;
  let allowedLengths = void 0;
  if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
    if (opts.sqrt || isLE2)
      throw new Error("cannot specify opts in two arguments");
    const _opts = bitLenOrOpts;
    if (_opts.BITS)
      _nbitLength = _opts.BITS;
    if (_opts.sqrt)
      _sqrt = _opts.sqrt;
    if (typeof _opts.isLE === "boolean")
      isLE2 = _opts.isLE;
    if (typeof _opts.modFromBytes === "boolean")
      modFromBytes = _opts.modFromBytes;
    allowedLengths = _opts.allowedLengths;
  } else {
    if (typeof bitLenOrOpts === "number")
      _nbitLength = bitLenOrOpts;
    if (opts.sqrt)
      _sqrt = opts.sqrt;
  }
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
  if (BYTES > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let sqrtP;
  const f = Object.freeze({
    ORDER,
    isLE: isLE2,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n2,
    ONE: _1n2,
    allowedLengths,
    create: (num2) => mod(num2, ORDER),
    isValid: (num2) => {
      if (typeof num2 !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof num2);
      return _0n2 <= num2 && num2 < ORDER;
    },
    is0: (num2) => num2 === _0n2,
    // is valid and invertible
    isValidNot0: (num2) => !f.is0(num2) && f.isValid(num2),
    isOdd: (num2) => (num2 & _1n2) === _1n2,
    neg: (num2) => mod(-num2, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num2) => mod(num2 * num2, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num2, power) => FpPow(f, num2, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num2) => num2 * num2,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num2) => invert(num2, ORDER),
    sqrt: _sqrt || ((n) => {
      if (!sqrtP)
        sqrtP = FpSqrt(ORDER);
      return sqrtP(f, n);
    }),
    toBytes: (num2) => isLE2 ? numberToBytesLE(num2, BYTES) : numberToBytesBE(num2, BYTES),
    fromBytes: (bytes, skipValidation = true) => {
      if (allowedLengths) {
        if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {
          throw new Error("Field.fromBytes: expected " + allowedLengths + " bytes, got " + bytes.length);
        }
        const padded = new Uint8Array(BYTES);
        padded.set(bytes, isLE2 ? 0 : padded.length - bytes.length);
        bytes = padded;
      }
      if (bytes.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
      let scalar = isLE2 ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
      if (modFromBytes)
        scalar = mod(scalar, ORDER);
      if (!skipValidation) {
        if (!f.isValid(scalar))
          throw new Error("invalid field element: outside of range 0..ORDER");
      }
      return scalar;
    },
    // TODO: we don't need it here, move out to separate fn
    invertBatch: (lst) => FpInvertBatch(f, lst),
    // We can't move this out because Fp6, Fp12 implement it
    // and it's unclear what to return in there.
    cmov: (a, b, c) => c ? b : a
  });
  return Object.freeze(f);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE2 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
  const num2 = isLE2 ? bytesToNumberLE(key) : bytesToNumberBE(key);
  const reduced = mod(num2, fieldOrder - _1n2) + _1n2;
  return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

// node_modules/@noble/curves/esm/abstract/curve.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
function negateCt(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function normalizeZ(c, points) {
  const invertedZs = FpInvertBatch(c.Fp, points.map((p) => p.Z));
  return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));
}
function validateW(W2, bits) {
  if (!Number.isSafeInteger(W2) || W2 <= 0 || W2 > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W2);
}
function calcWOpts(W2, scalarBits) {
  validateW(W2, scalarBits);
  const windows = Math.ceil(scalarBits / W2) + 1;
  const windowSize = 2 ** (W2 - 1);
  const maxNumber = 2 ** W2;
  const mask = bitMask(W2);
  const shiftBy = BigInt(W2);
  return { windows, windowSize, mask, maxNumber, shiftBy };
}
function calcOffsets(n, window, wOpts) {
  const { windowSize, mask, maxNumber, shiftBy } = wOpts;
  let wbits = Number(n & mask);
  let nextN = n >> shiftBy;
  if (wbits > windowSize) {
    wbits -= maxNumber;
    nextN += _1n3;
  }
  const offsetStart = window * windowSize;
  const offset = offsetStart + Math.abs(wbits) - 1;
  const isZero = wbits === 0;
  const isNeg = wbits < 0;
  const isNegF = window % 2 !== 0;
  const offsetF = offsetStart;
  return { nextN, offset, isZero, isNeg, isNegF, offsetF };
}
function validateMSMPoints(points, c) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  points.forEach((p, i) => {
    if (!(p instanceof c))
      throw new Error("invalid point at index " + i);
  });
}
function validateMSMScalars(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  scalars.forEach((s, i) => {
    if (!field.isValid(s))
      throw new Error("invalid scalar at index " + i);
  });
}
var pointPrecomputes = /* @__PURE__ */ new WeakMap();
var pointWindowSizes = /* @__PURE__ */ new WeakMap();
function getW(P) {
  return pointWindowSizes.get(P) || 1;
}
function assert0(n) {
  if (n !== _0n3)
    throw new Error("invalid wNAF");
}
var wNAF = class {
  // Parametrized with a given Point class (not individual point)
  constructor(Point2, bits) {
    this.BASE = Point2.BASE;
    this.ZERO = Point2.ZERO;
    this.Fn = Point2.Fn;
    this.bits = bits;
  }
  // non-const time multiplication ladder
  _unsafeLadder(elm, n, p = this.ZERO) {
    let d = elm;
    while (n > _0n3) {
      if (n & _1n3)
        p = p.add(d);
      d = d.double();
      n >>= _1n3;
    }
    return p;
  }
  /**
   * Creates a wNAF precomputation window. Used for caching.
   * Default window size is set by `utils.precompute()` and is equal to 8.
   * Number of precomputed points depends on the curve size:
   * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:
   * - ùëä is the window size
   * - ùëõ is the bitlength of the curve order.
   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
   * @param point Point instance
   * @param W window size
   * @returns precomputed point tables flattened to a single array
   */
  precomputeWindow(point, W2) {
    const { windows, windowSize } = calcWOpts(W2, this.bits);
    const points = [];
    let p = point;
    let base = p;
    for (let window = 0; window < windows; window++) {
      base = p;
      points.push(base);
      for (let i = 1; i < windowSize; i++) {
        base = base.add(p);
        points.push(base);
      }
      p = base.double();
    }
    return points;
  }
  /**
   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
   * More compact implementation:
   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
   * @returns real and fake (for const-time) points
   */
  wNAF(W2, precomputes, n) {
    if (!this.Fn.isValid(n))
      throw new Error("invalid scalar");
    let p = this.ZERO;
    let f = this.BASE;
    const wo = calcWOpts(W2, this.bits);
    for (let window = 0; window < wo.windows; window++) {
      const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);
      n = nextN;
      if (isZero) {
        f = f.add(negateCt(isNegF, precomputes[offsetF]));
      } else {
        p = p.add(negateCt(isNeg, precomputes[offset]));
      }
    }
    assert0(n);
    return { p, f };
  }
  /**
   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
   * @param acc accumulator point to add result of multiplication
   * @returns point
   */
  wNAFUnsafe(W2, precomputes, n, acc = this.ZERO) {
    const wo = calcWOpts(W2, this.bits);
    for (let window = 0; window < wo.windows; window++) {
      if (n === _0n3)
        break;
      const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);
      n = nextN;
      if (isZero) {
        continue;
      } else {
        const item = precomputes[offset];
        acc = acc.add(isNeg ? item.negate() : item);
      }
    }
    assert0(n);
    return acc;
  }
  getPrecomputes(W2, point, transform) {
    let comp = pointPrecomputes.get(point);
    if (!comp) {
      comp = this.precomputeWindow(point, W2);
      if (W2 !== 1) {
        if (typeof transform === "function")
          comp = transform(comp);
        pointPrecomputes.set(point, comp);
      }
    }
    return comp;
  }
  cached(point, scalar, transform) {
    const W2 = getW(point);
    return this.wNAF(W2, this.getPrecomputes(W2, point, transform), scalar);
  }
  unsafe(point, scalar, transform, prev) {
    const W2 = getW(point);
    if (W2 === 1)
      return this._unsafeLadder(point, scalar, prev);
    return this.wNAFUnsafe(W2, this.getPrecomputes(W2, point, transform), scalar, prev);
  }
  // We calculate precomputes for elliptic curve point multiplication
  // using windowed method. This specifies window size and
  // stores precomputed values. Usually only base point would be precomputed.
  createCache(P, W2) {
    validateW(W2, this.bits);
    pointWindowSizes.set(P, W2);
    pointPrecomputes.delete(P);
  }
  hasCache(elm) {
    return getW(elm) !== 1;
  }
};
function mulEndoUnsafe(Point2, point, k1, k2) {
  let acc = point;
  let p1 = Point2.ZERO;
  let p2 = Point2.ZERO;
  while (k1 > _0n3 || k2 > _0n3) {
    if (k1 & _1n3)
      p1 = p1.add(acc);
    if (k2 & _1n3)
      p2 = p2.add(acc);
    acc = acc.double();
    k1 >>= _1n3;
    k2 >>= _1n3;
  }
  return { p1, p2 };
}
function pippenger(c, fieldN, points, scalars) {
  validateMSMPoints(points, c);
  validateMSMScalars(scalars, fieldN);
  const plength = points.length;
  const slength = scalars.length;
  if (plength !== slength)
    throw new Error("arrays of points and scalars must have equal length");
  const zero = c.ZERO;
  const wbits = bitLen(BigInt(plength));
  let windowSize = 1;
  if (wbits > 12)
    windowSize = wbits - 3;
  else if (wbits > 4)
    windowSize = wbits - 2;
  else if (wbits > 0)
    windowSize = 2;
  const MASK = bitMask(windowSize);
  const buckets = new Array(Number(MASK) + 1).fill(zero);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum = zero;
  for (let i = lastBits; i >= 0; i -= windowSize) {
    buckets.fill(zero);
    for (let j = 0; j < slength; j++) {
      const scalar = scalars[j];
      const wbits2 = Number(scalar >> BigInt(i) & MASK);
      buckets[wbits2] = buckets[wbits2].add(points[j]);
    }
    let resI = zero;
    for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
      sumI = sumI.add(buckets[j]);
      resI = resI.add(sumI);
    }
    sum = sum.add(resI);
    if (i !== 0)
      for (let j = 0; j < windowSize; j++)
        sum = sum.double();
  }
  return sum;
}
function createField(order, field, isLE2) {
  if (field) {
    if (field.ORDER !== order)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    validateField(field);
    return field;
  } else {
    return Field(order, { isLE: isLE2 });
  }
}
function _createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {
  if (FpFnLE === void 0)
    FpFnLE = type === "edwards";
  if (!CURVE || typeof CURVE !== "object")
    throw new Error(`expected valid ${type} CURVE object`);
  for (const p of ["p", "n", "h"]) {
    const val = CURVE[p];
    if (!(typeof val === "bigint" && val > _0n3))
      throw new Error(`CURVE.${p} must be positive bigint`);
  }
  const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);
  const Fn2 = createField(CURVE.n, curveOpts.Fn, FpFnLE);
  const _b = type === "weierstrass" ? "b" : "d";
  const params = ["Gx", "Gy", "a", _b];
  for (const p of params) {
    if (!Fp.isValid(CURVE[p]))
      throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
  }
  CURVE = Object.freeze(Object.assign({}, CURVE));
  return { CURVE, Fp, Fn: Fn2 };
}

// node_modules/@noble/curves/esm/abstract/weierstrass.js
var divNearest = (num2, den) => (num2 + (num2 >= 0 ? den : -den) / _2n2) / den;
function _splitEndoScalar(k, basis, n) {
  const [[a1, b1], [a2, b2]] = basis;
  const c1 = divNearest(b2 * k, n);
  const c2 = divNearest(-b1 * k, n);
  let k1 = k - c1 * a1 - c2 * a2;
  let k2 = -c1 * b1 - c2 * b2;
  const k1neg = k1 < _0n4;
  const k2neg = k2 < _0n4;
  if (k1neg)
    k1 = -k1;
  if (k2neg)
    k2 = -k2;
  const MAX_NUM = bitMask(Math.ceil(bitLen(n) / 2)) + _1n4;
  if (k1 < _0n4 || k1 >= MAX_NUM || k2 < _0n4 || k2 >= MAX_NUM) {
    throw new Error("splitScalar (endomorphism): failed, k=" + k);
  }
  return { k1neg, k1, k2neg, k2 };
}
function validateSigFormat(format) {
  if (!["compact", "recovered", "der"].includes(format))
    throw new Error('Signature format must be "compact", "recovered", or "der"');
  return format;
}
function validateSigOpts(opts, def) {
  const optsn = {};
  for (let optName of Object.keys(def)) {
    optsn[optName] = opts[optName] === void 0 ? def[optName] : opts[optName];
  }
  _abool2(optsn.lowS, "lowS");
  _abool2(optsn.prehash, "prehash");
  if (optsn.format !== void 0)
    validateSigFormat(optsn.format);
  return optsn;
}
var DERErr = class extends Error {
  constructor(m = "") {
    super(m);
  }
};
var DER = {
  // asn.1 DER encoding utils
  Err: DERErr,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (tag, data) => {
      const { Err: E } = DER;
      if (tag < 0 || tag > 256)
        throw new E("tlv.encode: wrong tag");
      if (data.length & 1)
        throw new E("tlv.encode: unpadded data");
      const dataLen = data.length / 2;
      const len = numberToHexUnpadded(dataLen);
      if (len.length / 2 & 128)
        throw new E("tlv.encode: long form length too big");
      const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : "";
      const t = numberToHexUnpadded(tag);
      return t + lenLen + len + data;
    },
    // v - value, l - left bytes (unparsed)
    decode(tag, data) {
      const { Err: E } = DER;
      let pos = 0;
      if (tag < 0 || tag > 256)
        throw new E("tlv.encode: wrong tag");
      if (data.length < 2 || data[pos++] !== tag)
        throw new E("tlv.decode: wrong tlv");
      const first = data[pos++];
      const isLong = !!(first & 128);
      let length = 0;
      if (!isLong)
        length = first;
      else {
        const lenLen = first & 127;
        if (!lenLen)
          throw new E("tlv.decode(long): indefinite length not supported");
        if (lenLen > 4)
          throw new E("tlv.decode(long): byte length is too big");
        const lengthBytes = data.subarray(pos, pos + lenLen);
        if (lengthBytes.length !== lenLen)
          throw new E("tlv.decode: length bytes not complete");
        if (lengthBytes[0] === 0)
          throw new E("tlv.decode(long): zero leftmost byte");
        for (const b of lengthBytes)
          length = length << 8 | b;
        pos += lenLen;
        if (length < 128)
          throw new E("tlv.decode(long): not minimal encoding");
      }
      const v = data.subarray(pos, pos + length);
      if (v.length !== length)
        throw new E("tlv.decode: wrong value length");
      return { v, l: data.subarray(pos + length) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(num2) {
      const { Err: E } = DER;
      if (num2 < _0n4)
        throw new E("integer: negative integers are not allowed");
      let hex2 = numberToHexUnpadded(num2);
      if (Number.parseInt(hex2[0], 16) & 8)
        hex2 = "00" + hex2;
      if (hex2.length & 1)
        throw new E("unexpected DER parsing assertion: unpadded hex");
      return hex2;
    },
    decode(data) {
      const { Err: E } = DER;
      if (data[0] & 128)
        throw new E("invalid signature integer: negative");
      if (data[0] === 0 && !(data[1] & 128))
        throw new E("invalid signature integer: unnecessary leading zero");
      return bytesToNumberBE(data);
    }
  },
  toSig(hex2) {
    const { Err: E, _int: int, _tlv: tlv } = DER;
    const data = ensureBytes("signature", hex2);
    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
    if (seqLeftBytes.length)
      throw new E("invalid signature: left bytes after parsing");
    const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
    const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
    if (sLeftBytes.length)
      throw new E("invalid signature: left bytes after parsing");
    return { r: int.decode(rBytes), s: int.decode(sBytes) };
  },
  hexFromSig(sig) {
    const { _tlv: tlv, _int: int } = DER;
    const rs2 = tlv.encode(2, int.encode(sig.r));
    const ss2 = tlv.encode(2, int.encode(sig.s));
    const seq = rs2 + ss2;
    return tlv.encode(48, seq);
  }
};
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
var _2n2 = BigInt(2);
var _3n2 = BigInt(3);
var _4n2 = BigInt(4);
function _normFnElement(Fn2, key) {
  const { BYTES: expected } = Fn2;
  let num2;
  if (typeof key === "bigint") {
    num2 = key;
  } else {
    let bytes = ensureBytes("private key", key);
    try {
      num2 = Fn2.fromBytes(bytes);
    } catch (error) {
      throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
    }
  }
  if (!Fn2.isValidNot0(num2))
    throw new Error("invalid private key: out of range [1..N-1]");
  return num2;
}
function weierstrassN(params, extraOpts = {}) {
  const validated = _createCurveFields("weierstrass", params, extraOpts);
  const { Fp, Fn: Fn2 } = validated;
  let CURVE = validated.CURVE;
  const { h: cofactor, n: CURVE_ORDER } = CURVE;
  _validateObject(extraOpts, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object",
    wrapPrivateKey: "boolean"
  });
  const { endo } = extraOpts;
  if (endo) {
    if (!Fp.is0(CURVE.a) || typeof endo.beta !== "bigint" || !Array.isArray(endo.basises)) {
      throw new Error('invalid endo: expected "beta": bigint and "basises": array');
    }
  }
  const lengths = getWLengths(Fp, Fn2);
  function assertCompressionIsSupported() {
    if (!Fp.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function pointToBytes2(_c, point, isCompressed) {
    const { x, y } = point.toAffine();
    const bx = Fp.toBytes(x);
    _abool2(isCompressed, "isCompressed");
    if (isCompressed) {
      assertCompressionIsSupported();
      const hasEvenY = !Fp.isOdd(y);
      return concatBytes(pprefix(hasEvenY), bx);
    } else {
      return concatBytes(Uint8Array.of(4), bx, Fp.toBytes(y));
    }
  }
  function pointFromBytes(bytes) {
    _abytes2(bytes, void 0, "Point");
    const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths;
    const length = bytes.length;
    const head = bytes[0];
    const tail = bytes.subarray(1);
    if (length === comp && (head === 2 || head === 3)) {
      const x = Fp.fromBytes(tail);
      if (!Fp.isValid(x))
        throw new Error("bad point: is not on curve, wrong x");
      const y2 = weierstrassEquation(x);
      let y;
      try {
        y = Fp.sqrt(y2);
      } catch (sqrtError) {
        const err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + err);
      }
      assertCompressionIsSupported();
      const isYOdd = Fp.isOdd(y);
      const isHeadOdd = (head & 1) === 1;
      if (isHeadOdd !== isYOdd)
        y = Fp.neg(y);
      return { x, y };
    } else if (length === uncomp && head === 4) {
      const L2 = Fp.BYTES;
      const x = Fp.fromBytes(tail.subarray(0, L2));
      const y = Fp.fromBytes(tail.subarray(L2, L2 * 2));
      if (!isValidXY(x, y))
        throw new Error("bad point: is not on curve");
      return { x, y };
    } else {
      throw new Error(`bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`);
    }
  }
  const encodePoint = extraOpts.toBytes || pointToBytes2;
  const decodePoint = extraOpts.fromBytes || pointFromBytes;
  function weierstrassEquation(x) {
    const x2 = Fp.sqr(x);
    const x3 = Fp.mul(x2, x);
    return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b);
  }
  function isValidXY(x, y) {
    const left = Fp.sqr(y);
    const right = weierstrassEquation(x);
    return Fp.eql(left, right);
  }
  if (!isValidXY(CURVE.Gx, CURVE.Gy))
    throw new Error("bad curve params: generator point");
  const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n2), _4n2);
  const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));
  if (Fp.is0(Fp.add(_4a3, _27b2)))
    throw new Error("bad curve params: a or b");
  function acoord(title, n, banZero = false) {
    if (!Fp.isValid(n) || banZero && Fp.is0(n))
      throw new Error(`bad point coordinate ${title}`);
    return n;
  }
  function aprjpoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ProjectivePoint expected");
  }
  function splitEndoScalarN(k) {
    if (!endo || !endo.basises)
      throw new Error("no endo");
    return _splitEndoScalar(k, endo.basises, Fn2.ORDER);
  }
  const toAffineMemo = memoized((p, iz) => {
    const { X: X2, Y, Z } = p;
    if (Fp.eql(Z, Fp.ONE))
      return { x: X2, y: Y };
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? Fp.ONE : Fp.inv(Z);
    const x = Fp.mul(X2, iz);
    const y = Fp.mul(Y, iz);
    const zz = Fp.mul(Z, iz);
    if (is0)
      return { x: Fp.ZERO, y: Fp.ZERO };
    if (!Fp.eql(zz, Fp.ONE))
      throw new Error("invZ was invalid");
    return { x, y };
  });
  const assertValidMemo = memoized((p) => {
    if (p.is0()) {
      if (extraOpts.allowInfinityPoint && !Fp.is0(p.Y))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x, y } = p.toAffine();
    if (!Fp.isValid(x) || !Fp.isValid(y))
      throw new Error("bad point: x or y not field elements");
    if (!isValidXY(x, y))
      throw new Error("bad point: equation left != right");
    if (!p.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
    k2p = new Point2(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
    k1p = negateCt(k1neg, k1p);
    k2p = negateCt(k2neg, k2p);
    return k1p.add(k2p);
  }
  class Point2 {
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(X2, Y, Z) {
      this.X = acoord("x", X2);
      this.Y = acoord("y", Y, true);
      this.Z = acoord("z", Z);
      Object.freeze(this);
    }
    static CURVE() {
      return CURVE;
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp.isValid(x) || !Fp.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point2)
        throw new Error("projective point not allowed");
      if (Fp.is0(x) && Fp.is0(y))
        return Point2.ZERO;
      return new Point2(x, y, Fp.ONE);
    }
    static fromBytes(bytes) {
      const P = Point2.fromAffine(decodePoint(_abytes2(bytes, void 0, "point")));
      P.assertValidity();
      return P;
    }
    static fromHex(hex2) {
      return Point2.fromBytes(ensureBytes("pointHex", hex2));
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(windowSize = 8, isLazy = true) {
      wnaf.createCache(this, windowSize);
      if (!isLazy)
        this.multiply(_3n2);
      return this;
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (!Fp.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !Fp.isOdd(y);
    }
    /** Compare one point to another. */
    equals(other) {
      aprjpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
      return U1 && U2;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new Point2(this.X, Fp.neg(this.Y), this.Z);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a, b } = CURVE;
      const b3 = Fp.mul(b, _3n2);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
      let t0 = Fp.mul(X1, X1);
      let t1 = Fp.mul(Y1, Y1);
      let t2 = Fp.mul(Z1, Z1);
      let t3 = Fp.mul(X1, Y1);
      t3 = Fp.add(t3, t3);
      Z3 = Fp.mul(X1, Z1);
      Z3 = Fp.add(Z3, Z3);
      X3 = Fp.mul(a, Z3);
      Y3 = Fp.mul(b3, t2);
      Y3 = Fp.add(X3, Y3);
      X3 = Fp.sub(t1, Y3);
      Y3 = Fp.add(t1, Y3);
      Y3 = Fp.mul(X3, Y3);
      X3 = Fp.mul(t3, X3);
      Z3 = Fp.mul(b3, Z3);
      t2 = Fp.mul(a, t2);
      t3 = Fp.sub(t0, t2);
      t3 = Fp.mul(a, t3);
      t3 = Fp.add(t3, Z3);
      Z3 = Fp.add(t0, t0);
      t0 = Fp.add(Z3, t0);
      t0 = Fp.add(t0, t2);
      t0 = Fp.mul(t0, t3);
      Y3 = Fp.add(Y3, t0);
      t2 = Fp.mul(Y1, Z1);
      t2 = Fp.add(t2, t2);
      t0 = Fp.mul(t2, t3);
      X3 = Fp.sub(X3, t0);
      Z3 = Fp.mul(t2, t1);
      Z3 = Fp.add(Z3, Z3);
      Z3 = Fp.add(Z3, Z3);
      return new Point2(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      aprjpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
      const a = CURVE.a;
      const b3 = Fp.mul(CURVE.b, _3n2);
      let t0 = Fp.mul(X1, X2);
      let t1 = Fp.mul(Y1, Y2);
      let t2 = Fp.mul(Z1, Z2);
      let t3 = Fp.add(X1, Y1);
      let t4 = Fp.add(X2, Y2);
      t3 = Fp.mul(t3, t4);
      t4 = Fp.add(t0, t1);
      t3 = Fp.sub(t3, t4);
      t4 = Fp.add(X1, Z1);
      let t5 = Fp.add(X2, Z2);
      t4 = Fp.mul(t4, t5);
      t5 = Fp.add(t0, t2);
      t4 = Fp.sub(t4, t5);
      t5 = Fp.add(Y1, Z1);
      X3 = Fp.add(Y2, Z2);
      t5 = Fp.mul(t5, X3);
      X3 = Fp.add(t1, t2);
      t5 = Fp.sub(t5, X3);
      Z3 = Fp.mul(a, t4);
      X3 = Fp.mul(b3, t2);
      Z3 = Fp.add(X3, Z3);
      X3 = Fp.sub(t1, Z3);
      Z3 = Fp.add(t1, Z3);
      Y3 = Fp.mul(X3, Z3);
      t1 = Fp.add(t0, t0);
      t1 = Fp.add(t1, t0);
      t2 = Fp.mul(a, t2);
      t4 = Fp.mul(b3, t4);
      t1 = Fp.add(t1, t2);
      t2 = Fp.sub(t0, t2);
      t2 = Fp.mul(a, t2);
      t4 = Fp.add(t4, t2);
      t0 = Fp.mul(t1, t4);
      Y3 = Fp.add(Y3, t0);
      t0 = Fp.mul(t5, t4);
      X3 = Fp.mul(t3, X3);
      X3 = Fp.sub(X3, t0);
      t0 = Fp.mul(t3, t1);
      Z3 = Fp.mul(t5, Z3);
      Z3 = Fp.add(Z3, t0);
      return new Point2(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const { endo: endo2 } = extraOpts;
      if (!Fn2.isValidNot0(scalar))
        throw new Error("invalid scalar: out of range");
      let point, fake;
      const mul = (n) => wnaf.cached(this, n, (p) => normalizeZ(Point2, p));
      if (endo2) {
        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);
        const { p: k1p, f: k1f } = mul(k1);
        const { p: k2p, f: k2f } = mul(k2);
        fake = k1f.add(k2f);
        point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
      } else {
        const { p, f } = mul(scalar);
        point = p;
        fake = f;
      }
      return normalizeZ(Point2, [point, fake])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed secret key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc) {
      const { endo: endo2 } = extraOpts;
      const p = this;
      if (!Fn2.isValid(sc))
        throw new Error("invalid scalar: out of range");
      if (sc === _0n4 || p.is0())
        return Point2.ZERO;
      if (sc === _1n4)
        return p;
      if (wnaf.hasCache(this))
        return this.multiply(sc);
      if (endo2) {
        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);
        const { p1, p2 } = mulEndoUnsafe(Point2, p, k1, k2);
        return finishEndo(endo2.beta, p1, p2, k1neg, k2neg);
      } else {
        return wnaf.unsafe(p, sc);
      }
    }
    multiplyAndAddUnsafe(Q2, a, b) {
      const sum = this.multiplyUnsafe(a).add(Q2.multiplyUnsafe(b));
      return sum.is0() ? void 0 : sum;
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree } = extraOpts;
      if (cofactor === _1n4)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point2, this);
      return wnaf.unsafe(this, CURVE_ORDER).is0();
    }
    clearCofactor() {
      const { clearCofactor } = extraOpts;
      if (cofactor === _1n4)
        return this;
      if (clearCofactor)
        return clearCofactor(Point2, this);
      return this.multiplyUnsafe(cofactor);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    toBytes(isCompressed = true) {
      _abool2(isCompressed, "isCompressed");
      this.assertValidity();
      return encodePoint(Point2, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toBytes(isCompressed));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
    // TODO: remove
    get px() {
      return this.X;
    }
    get py() {
      return this.X;
    }
    get pz() {
      return this.Z;
    }
    toRawBytes(isCompressed = true) {
      return this.toBytes(isCompressed);
    }
    _setWindowSize(windowSize) {
      this.precompute(windowSize);
    }
    static normalizeZ(points) {
      return normalizeZ(Point2, points);
    }
    static msm(points, scalars) {
      return pippenger(Point2, Fn2, points, scalars);
    }
    static fromPrivateKey(privateKey) {
      return Point2.BASE.multiply(_normFnElement(Fn2, privateKey));
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp.ONE);
  Point2.ZERO = new Point2(Fp.ZERO, Fp.ONE, Fp.ZERO);
  Point2.Fp = Fp;
  Point2.Fn = Fn2;
  const bits = Fn2.BITS;
  const wnaf = new wNAF(Point2, extraOpts.endo ? Math.ceil(bits / 2) : bits);
  Point2.BASE.precompute(8);
  return Point2;
}
function pprefix(hasEvenY) {
  return Uint8Array.of(hasEvenY ? 2 : 3);
}
function SWUFpSqrtRatio(Fp, Z) {
  const q = Fp.ORDER;
  let l = _0n4;
  for (let o = q - _1n4; o % _2n2 === _0n4; o /= _2n2)
    l += _1n4;
  const c1 = l;
  const _2n_pow_c1_1 = _2n2 << c1 - _1n4 - _1n4;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n2;
  const c2 = (q - _1n4) / _2n_pow_c1;
  const c3 = (c2 - _1n4) / _2n2;
  const c4 = _2n_pow_c1 - _1n4;
  const c5 = _2n_pow_c1_1;
  const c6 = Fp.pow(Z, c2);
  const c7 = Fp.pow(Z, (c2 + _1n4) / _2n2);
  let sqrtRatio = (u, v) => {
    let tv1 = c6;
    let tv2 = Fp.pow(v, c4);
    let tv3 = Fp.sqr(tv2);
    tv3 = Fp.mul(tv3, v);
    let tv5 = Fp.mul(u, tv3);
    tv5 = Fp.pow(tv5, c3);
    tv5 = Fp.mul(tv5, tv2);
    tv2 = Fp.mul(tv5, v);
    tv3 = Fp.mul(tv5, u);
    let tv4 = Fp.mul(tv3, tv2);
    tv5 = Fp.pow(tv4, c5);
    let isQR = Fp.eql(tv5, Fp.ONE);
    tv2 = Fp.mul(tv3, c7);
    tv5 = Fp.mul(tv4, tv1);
    tv3 = Fp.cmov(tv2, tv3, isQR);
    tv4 = Fp.cmov(tv5, tv4, isQR);
    for (let i = c1; i > _1n4; i--) {
      let tv52 = i - _2n2;
      tv52 = _2n2 << tv52 - _1n4;
      let tvv5 = Fp.pow(tv4, tv52);
      const e1 = Fp.eql(tvv5, Fp.ONE);
      tv2 = Fp.mul(tv3, tv1);
      tv1 = Fp.mul(tv1, tv1);
      tvv5 = Fp.mul(tv4, tv1);
      tv3 = Fp.cmov(tv2, tv3, e1);
      tv4 = Fp.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp.ORDER % _4n2 === _3n2) {
    const c12 = (Fp.ORDER - _3n2) / _4n2;
    const c22 = Fp.sqrt(Fp.neg(Z));
    sqrtRatio = (u, v) => {
      let tv1 = Fp.sqr(v);
      const tv2 = Fp.mul(u, v);
      tv1 = Fp.mul(tv1, tv2);
      let y1 = Fp.pow(tv1, c12);
      y1 = Fp.mul(y1, tv2);
      const y2 = Fp.mul(y1, c22);
      const tv3 = Fp.mul(Fp.sqr(y1), v);
      const isQR = Fp.eql(tv3, u);
      let y = Fp.cmov(y2, y1, isQR);
      return { isValid: isQR, value: y };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU(Fp, opts) {
  validateField(Fp);
  const { A, B, Z } = opts;
  if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio(Fp, Z);
  if (!Fp.isOdd)
    throw new Error("Field does not have .isOdd()");
  return (u) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
    tv1 = Fp.sqr(u);
    tv1 = Fp.mul(tv1, Z);
    tv2 = Fp.sqr(tv1);
    tv2 = Fp.add(tv2, tv1);
    tv3 = Fp.add(tv2, Fp.ONE);
    tv3 = Fp.mul(tv3, B);
    tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
    tv4 = Fp.mul(tv4, A);
    tv2 = Fp.sqr(tv3);
    tv6 = Fp.sqr(tv4);
    tv5 = Fp.mul(tv6, A);
    tv2 = Fp.add(tv2, tv5);
    tv2 = Fp.mul(tv2, tv3);
    tv6 = Fp.mul(tv6, tv4);
    tv5 = Fp.mul(tv6, B);
    tv2 = Fp.add(tv2, tv5);
    x = Fp.mul(tv1, tv3);
    const { isValid, value } = sqrtRatio(tv2, tv6);
    y = Fp.mul(tv1, u);
    y = Fp.mul(y, value);
    x = Fp.cmov(x, tv3, isValid);
    y = Fp.cmov(y, value, isValid);
    const e1 = Fp.isOdd(u) === Fp.isOdd(y);
    y = Fp.cmov(Fp.neg(y), y, e1);
    const tv4_inv = FpInvertBatch(Fp, [tv4], true)[0];
    x = Fp.mul(x, tv4_inv);
    return { x, y };
  };
}
function getWLengths(Fp, Fn2) {
  return {
    secretKey: Fn2.BYTES,
    publicKey: 1 + Fp.BYTES,
    publicKeyUncompressed: 1 + 2 * Fp.BYTES,
    publicKeyHasPrefix: true,
    signature: 2 * Fn2.BYTES
  };
}
function ecdh(Point2, ecdhOpts = {}) {
  const { Fn: Fn2 } = Point2;
  const randomBytes_ = ecdhOpts.randomBytes || randomBytes;
  const lengths = Object.assign(getWLengths(Point2.Fp, Fn2), { seed: getMinHashLength(Fn2.ORDER) });
  function isValidSecretKey(secretKey) {
    try {
      return !!_normFnElement(Fn2, secretKey);
    } catch (error) {
      return false;
    }
  }
  function isValidPublicKey(publicKey, isCompressed) {
    const { publicKey: comp, publicKeyUncompressed } = lengths;
    try {
      const l = publicKey.length;
      if (isCompressed === true && l !== comp)
        return false;
      if (isCompressed === false && l !== publicKeyUncompressed)
        return false;
      return !!Point2.fromBytes(publicKey);
    } catch (error) {
      return false;
    }
  }
  function randomSecretKey(seed = randomBytes_(lengths.seed)) {
    return mapHashToField(_abytes2(seed, lengths.seed, "seed"), Fn2.ORDER);
  }
  function getPublicKey(secretKey, isCompressed = true) {
    return Point2.BASE.multiply(_normFnElement(Fn2, secretKey)).toBytes(isCompressed);
  }
  function keygen(seed) {
    const secretKey = randomSecretKey(seed);
    return { secretKey, publicKey: getPublicKey(secretKey) };
  }
  function isProbPub(item) {
    if (typeof item === "bigint")
      return false;
    if (item instanceof Point2)
      return true;
    const { secretKey, publicKey, publicKeyUncompressed } = lengths;
    if (Fn2.allowedLengths || secretKey === publicKey)
      return void 0;
    const l = ensureBytes("key", item).length;
    return l === publicKey || l === publicKeyUncompressed;
  }
  function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {
    if (isProbPub(secretKeyA) === true)
      throw new Error("first arg must be private key");
    if (isProbPub(publicKeyB) === false)
      throw new Error("second arg must be public key");
    const s = _normFnElement(Fn2, secretKeyA);
    const b = Point2.fromHex(publicKeyB);
    return b.multiply(s).toBytes(isCompressed);
  }
  const utils = {
    isValidSecretKey,
    isValidPublicKey,
    randomSecretKey,
    // TODO: remove
    isValidPrivateKey: isValidSecretKey,
    randomPrivateKey: randomSecretKey,
    normPrivateKeyToScalar: (key) => _normFnElement(Fn2, key),
    precompute(windowSize = 8, point = Point2.BASE) {
      return point.precompute(windowSize, false);
    }
  };
  return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point: Point2, utils, lengths });
}
function ecdsa(Point2, hash, ecdsaOpts = {}) {
  ahash(hash);
  _validateObject(ecdsaOpts, {}, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  });
  const randomBytes2 = ecdsaOpts.randomBytes || randomBytes;
  const hmac2 = ecdsaOpts.hmac || ((key, ...msgs) => hmac(hash, key, concatBytes(...msgs)));
  const { Fp, Fn: Fn2 } = Point2;
  const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn2;
  const { keygen, getPublicKey, getSharedSecret, utils, lengths } = ecdh(Point2, ecdsaOpts);
  const defaultSigOpts = {
    prehash: false,
    lowS: typeof ecdsaOpts.lowS === "boolean" ? ecdsaOpts.lowS : false,
    format: void 0,
    //'compact' as ECDSASigFormat,
    extraEntropy: false
  };
  const defaultSigOpts_format = "compact";
  function isBiggerThanHalfOrder(number) {
    const HALF = CURVE_ORDER >> _1n4;
    return number > HALF;
  }
  function validateRS(title, num2) {
    if (!Fn2.isValidNot0(num2))
      throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);
    return num2;
  }
  function validateSigLength(bytes, format) {
    validateSigFormat(format);
    const size = lengths.signature;
    const sizer = format === "compact" ? size : format === "recovered" ? size + 1 : void 0;
    return _abytes2(bytes, sizer, `${format} signature`);
  }
  class Signature {
    constructor(r, s, recovery) {
      this.r = validateRS("r", r);
      this.s = validateRS("s", s);
      if (recovery != null)
        this.recovery = recovery;
      Object.freeze(this);
    }
    static fromBytes(bytes, format = defaultSigOpts_format) {
      validateSigLength(bytes, format);
      let recid;
      if (format === "der") {
        const { r: r2, s: s2 } = DER.toSig(_abytes2(bytes));
        return new Signature(r2, s2);
      }
      if (format === "recovered") {
        recid = bytes[0];
        format = "compact";
        bytes = bytes.subarray(1);
      }
      const L2 = Fn2.BYTES;
      const r = bytes.subarray(0, L2);
      const s = bytes.subarray(L2, L2 * 2);
      return new Signature(Fn2.fromBytes(r), Fn2.fromBytes(s), recid);
    }
    static fromHex(hex2, format) {
      return this.fromBytes(hexToBytes(hex2), format);
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(messageHash) {
      const FIELD_ORDER = Fp.ORDER;
      const { r, s, recovery: rec } = this;
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const hasCofactor = CURVE_ORDER * _2n2 < FIELD_ORDER;
      if (hasCofactor && rec > 1)
        throw new Error("recovery id is ambiguous for h>1 curve");
      const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
      if (!Fp.isValid(radj))
        throw new Error("recovery id 2 or 3 invalid");
      const x = Fp.toBytes(radj);
      const R = Point2.fromBytes(concatBytes(pprefix((rec & 1) === 0), x));
      const ir = Fn2.inv(radj);
      const h = bits2int_modN(ensureBytes("msgHash", messageHash));
      const u1 = Fn2.create(-h * ir);
      const u2 = Fn2.create(s * ir);
      const Q2 = Point2.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
      if (Q2.is0())
        throw new Error("point at infinify");
      Q2.assertValidity();
      return Q2;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    toBytes(format = defaultSigOpts_format) {
      validateSigFormat(format);
      if (format === "der")
        return hexToBytes(DER.hexFromSig(this));
      const r = Fn2.toBytes(this.r);
      const s = Fn2.toBytes(this.s);
      if (format === "recovered") {
        if (this.recovery == null)
          throw new Error("recovery bit must be present");
        return concatBytes(Uint8Array.of(this.recovery), r, s);
      }
      return concatBytes(r, s);
    }
    toHex(format) {
      return bytesToHex(this.toBytes(format));
    }
    // TODO: remove
    assertValidity() {
    }
    static fromCompact(hex2) {
      return Signature.fromBytes(ensureBytes("sig", hex2), "compact");
    }
    static fromDER(hex2) {
      return Signature.fromBytes(ensureBytes("sig", hex2), "der");
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, Fn2.neg(this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return bytesToHex(this.toBytes("der"));
    }
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return bytesToHex(this.toBytes("compact"));
    }
  }
  const bits2int = ecdsaOpts.bits2int || function bits2int_def(bytes) {
    if (bytes.length > 8192)
      throw new Error("input is too large");
    const num2 = bytesToNumberBE(bytes);
    const delta = bytes.length * 8 - fnBits;
    return delta > 0 ? num2 >> BigInt(delta) : num2;
  };
  const bits2int_modN = ecdsaOpts.bits2int_modN || function bits2int_modN_def(bytes) {
    return Fn2.create(bits2int(bytes));
  };
  const ORDER_MASK = bitMask(fnBits);
  function int2octets(num2) {
    aInRange("num < 2^" + fnBits, num2, _0n4, ORDER_MASK);
    return Fn2.toBytes(num2);
  }
  function validateMsgAndHash(message, prehash) {
    _abytes2(message, void 0, "message");
    return prehash ? _abytes2(hash(message), void 0, "prehashed message") : message;
  }
  function prepSig(message, privateKey, opts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);
    message = validateMsgAndHash(message, prehash);
    const h1int = bits2int_modN(message);
    const d = _normFnElement(Fn2, privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (extraEntropy != null && extraEntropy !== false) {
      const e = extraEntropy === true ? randomBytes2(lengths.secretKey) : extraEntropy;
      seedArgs.push(ensureBytes("extraEntropy", e));
    }
    const seed = concatBytes(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!Fn2.isValidNot0(k))
        return;
      const ik = Fn2.inv(k);
      const q = Point2.BASE.multiply(k).toAffine();
      const r = Fn2.create(q.x);
      if (r === _0n4)
        return;
      const s = Fn2.create(ik * Fn2.create(m + r * d));
      if (s === _0n4)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n4);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = Fn2.neg(s);
        recovery ^= 1;
      }
      return new Signature(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  function sign(message, secretKey, opts = {}) {
    message = ensureBytes("message", message);
    const { seed, k2sig } = prepSig(message, secretKey, opts);
    const drbg = createHmacDrbg(hash.outputLen, Fn2.BYTES, hmac2);
    const sig = drbg(seed, k2sig);
    return sig;
  }
  function tryParsingSig(sg) {
    let sig = void 0;
    const isHex = typeof sg === "string" || isBytes(sg);
    const isObj = !isHex && sg !== null && typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint";
    if (!isHex && !isObj)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    if (isObj) {
      sig = new Signature(sg.r, sg.s);
    } else if (isHex) {
      try {
        sig = Signature.fromBytes(ensureBytes("sig", sg), "der");
      } catch (derError) {
        if (!(derError instanceof DER.Err))
          throw derError;
      }
      if (!sig) {
        try {
          sig = Signature.fromBytes(ensureBytes("sig", sg), "compact");
        } catch (error) {
          return false;
        }
      }
    }
    if (!sig)
      return false;
    return sig;
  }
  function verify(signature, message, publicKey, opts = {}) {
    const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);
    publicKey = ensureBytes("publicKey", publicKey);
    message = validateMsgAndHash(ensureBytes("message", message), prehash);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const sig = format === void 0 ? tryParsingSig(signature) : Signature.fromBytes(ensureBytes("sig", signature), format);
    if (sig === false)
      return false;
    try {
      const P = Point2.fromBytes(publicKey);
      if (lowS && sig.hasHighS())
        return false;
      const { r, s } = sig;
      const h = bits2int_modN(message);
      const is2 = Fn2.inv(s);
      const u1 = Fn2.create(h * is2);
      const u2 = Fn2.create(r * is2);
      const R = Point2.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
      if (R.is0())
        return false;
      const v = Fn2.create(R.x);
      return v === r;
    } catch (e) {
      return false;
    }
  }
  function recoverPublicKey(signature, message, opts = {}) {
    const { prehash } = validateSigOpts(opts, defaultSigOpts);
    message = validateMsgAndHash(message, prehash);
    return Signature.fromBytes(signature, "recovered").recoverPublicKey(message).toBytes();
  }
  return Object.freeze({
    keygen,
    getPublicKey,
    getSharedSecret,
    utils,
    lengths,
    Point: Point2,
    sign,
    verify,
    recoverPublicKey,
    Signature,
    hash
  });
}
function _weierstrass_legacy_opts_to_new(c) {
  const CURVE = {
    a: c.a,
    b: c.b,
    p: c.Fp.ORDER,
    n: c.n,
    h: c.h,
    Gx: c.Gx,
    Gy: c.Gy
  };
  const Fp = c.Fp;
  let allowedLengths = c.allowedPrivateKeyLengths ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l) => Math.ceil(l / 2)))) : void 0;
  const Fn2 = Field(CURVE.n, {
    BITS: c.nBitLength,
    allowedLengths,
    modFromBytes: c.wrapPrivateKey
  });
  const curveOpts = {
    Fp,
    Fn: Fn2,
    allowInfinityPoint: c.allowInfinityPoint,
    endo: c.endo,
    isTorsionFree: c.isTorsionFree,
    clearCofactor: c.clearCofactor,
    fromBytes: c.fromBytes,
    toBytes: c.toBytes
  };
  return { CURVE, curveOpts };
}
function _ecdsa_legacy_opts_to_new(c) {
  const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
  const ecdsaOpts = {
    hmac: c.hmac,
    randomBytes: c.randomBytes,
    lowS: c.lowS,
    bits2int: c.bits2int,
    bits2int_modN: c.bits2int_modN
  };
  return { CURVE, curveOpts, hash: c.hash, ecdsaOpts };
}
function _ecdsa_new_output_to_legacy(c, _ecdsa) {
  const Point2 = _ecdsa.Point;
  return Object.assign({}, _ecdsa, {
    ProjectivePoint: Point2,
    CURVE: Object.assign({}, c, nLength(Point2.Fn.ORDER, Point2.Fn.BITS))
  });
}
function weierstrass(c) {
  const { CURVE, curveOpts, hash, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);
  const Point2 = weierstrassN(CURVE, curveOpts);
  const signs = ecdsa(Point2, hash, ecdsaOpts);
  return _ecdsa_new_output_to_legacy(c, signs);
}

// node_modules/@noble/curves/esm/_shortw_utils.js
function createCurve(curveDef, defHash) {
  const create = (hash) => weierstrass({ ...curveDef, hash });
  return { ...create(defHash), create };
}

// node_modules/@noble/curves/esm/abstract/hash-to-curve.js
var os2ip = bytesToNumberBE;
function i2osp(value, length) {
  anum(value);
  anum(length);
  if (value < 0 || value >= 1 << 8 * length)
    throw new Error("invalid I2OSP input: " + value);
  const res = Array.from({ length }).fill(0);
  for (let i = length - 1; i >= 0; i--) {
    res[i] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a, b) {
  const arr = new Uint8Array(a.length);
  for (let i = 0; i < a.length; i++) {
    arr[i] = a[i] ^ b[i];
  }
  return arr;
}
function anum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function normDST(DST) {
  if (!isBytes(DST) && typeof DST !== "string")
    throw new Error("DST must be Uint8Array or string");
  return typeof DST === "string" ? utf8ToBytes(DST) : DST;
}
function expand_message_xmd(msg, DST, lenInBytes, H) {
  abytes(msg);
  anum(lenInBytes);
  DST = normDST(DST);
  if (DST.length > 255)
    DST = H(concatBytes(utf8ToBytes("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (lenInBytes > 65535 || ell > 255)
    throw new Error("expand_message_xmd: invalid lenInBytes");
  const DST_prime = concatBytes(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b = new Array(ell);
  const b_0 = H(concatBytes(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b[0] = H(concatBytes(b_0, i2osp(1, 1), DST_prime));
  for (let i = 1; i <= ell; i++) {
    const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
    b[i] = H(concatBytes(...args));
  }
  const pseudo_random_bytes = concatBytes(...b);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k, H) {
  abytes(msg);
  anum(lenInBytes);
  DST = normDST(DST);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k / 8);
    DST = H.create({ dkLen }).update(utf8ToBytes("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count, options) {
  _validateObject(options, {
    p: "bigint",
    m: "number",
    k: "number",
    hash: "function"
  });
  const { p, k, m, hash, expand, DST } = options;
  if (!isHash(options.hash))
    throw new Error("expected valid hash");
  abytes(msg);
  anum(count);
  const log2p = p.toString(2).length;
  const L2 = Math.ceil((log2p + k) / 8);
  const len_in_bytes = count * m * L2;
  let prb;
  if (expand === "xmd") {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
  } else if (expand === "xof") {
    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
  } else if (expand === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u = new Array(count);
  for (let i = 0; i < count; i++) {
    const e = new Array(m);
    for (let j = 0; j < m; j++) {
      const elm_offset = L2 * (j + i * m);
      const tv = prb.subarray(elm_offset, elm_offset + L2);
      e[j] = mod(os2ip(tv), p);
    }
    u[i] = e;
  }
  return u;
}
function isogenyMap(field, map) {
  const coeff = map.map((i) => Array.from(i).reverse());
  return (x, y) => {
    const [xn2, xd, yn2, yd] = coeff.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
    const [xd_inv, yd_inv] = FpInvertBatch(field, [xd, yd], true);
    x = field.mul(xn2, xd_inv);
    y = field.mul(y, field.mul(yn2, yd_inv));
    return { x, y };
  };
}
var _DST_scalar = utf8ToBytes("HashToScalar-");
function createHasher2(Point2, mapToCurve, defaults) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  function map(num2) {
    return Point2.fromAffine(mapToCurve(num2));
  }
  function clear(initial) {
    const P = initial.clearCofactor();
    if (P.equals(Point2.ZERO))
      return Point2.ZERO;
    P.assertValidity();
    return P;
  }
  return {
    defaults,
    hashToCurve(msg, options) {
      const opts = Object.assign({}, defaults, options);
      const u = hash_to_field(msg, 2, opts);
      const u0 = map(u[0]);
      const u1 = map(u[1]);
      return clear(u0.add(u1));
    },
    encodeToCurve(msg, options) {
      const optsDst = defaults.encodeDST ? { DST: defaults.encodeDST } : {};
      const opts = Object.assign({}, defaults, optsDst, options);
      const u = hash_to_field(msg, 1, opts);
      const u0 = map(u[0]);
      return clear(u0);
    },
    /** See {@link H2CHasher} */
    mapToCurve(scalars) {
      if (!Array.isArray(scalars))
        throw new Error("expected array of bigints");
      for (const i of scalars)
        if (typeof i !== "bigint")
          throw new Error("expected array of bigints");
      return clear(map(scalars));
    },
    // hash_to_scalar can produce 0: https://www.rfc-editor.org/errata/eid8393
    // RFC 9380, draft-irtf-cfrg-bbs-signatures-08
    hashToScalar(msg, options) {
      const N2 = Point2.Fn.ORDER;
      const opts = Object.assign({}, defaults, { p: N2, m: 1, DST: _DST_scalar }, options);
      return hash_to_field(msg, 1, opts)[0][0];
    }
  };
}

// node_modules/@noble/curves/esm/secp256k1.js
var secp256k1_CURVE = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
};
var secp256k1_ENDO = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  basises: [
    [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
    [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
  ]
};
var _0n5 = BigInt(0);
var _1n5 = BigInt(1);
var _2n3 = BigInt(2);
function sqrtMod(y) {
  const P = secp256k1_CURVE.p;
  const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n3, P) * b3 % P;
  const b9 = pow2(b6, _3n3, P) * b3 % P;
  const b11 = pow2(b9, _2n3, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n3, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n3, P);
  if (!Fpk1.eql(Fpk1.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fpk1 = Field(secp256k1_CURVE.p, { sqrt: sqrtMod });
var secp256k1 = createCurve({ ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO }, sha256);
var TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === void 0) {
    const tagH = sha256(utf8ToBytes(tag));
    tagP = concatBytes(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha256(concatBytes(tagP, ...messages));
}
var pointToBytes = (point) => point.toBytes(true).slice(1);
var Pointk1 = (() => secp256k1.Point)();
var hasEven = (y) => y % _2n3 === _0n5;
function schnorrGetExtPubKey(priv) {
  const { Fn: Fn2, BASE } = Pointk1;
  const d_ = _normFnElement(Fn2, priv);
  const p = BASE.multiply(d_);
  const scalar = hasEven(p.y) ? d_ : Fn2.neg(d_);
  return { scalar, bytes: pointToBytes(p) };
}
function lift_x(x) {
  const Fp = Fpk1;
  if (!Fp.isValidNot0(x))
    throw new Error("invalid x: Fail if x ‚â• p");
  const xx = Fp.create(x * x);
  const c = Fp.create(xx * x + BigInt(7));
  let y = Fp.sqrt(c);
  if (!hasEven(y))
    y = Fp.neg(y);
  const p = Pointk1.fromAffine({ x, y });
  p.assertValidity();
  return p;
}
var num = bytesToNumberBE;
function challenge(...args) {
  return Pointk1.Fn.create(num(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(secretKey) {
  return schnorrGetExtPubKey(secretKey).bytes;
}
function schnorrSign(message, secretKey, auxRand = randomBytes(32)) {
  const { Fn: Fn2 } = Pointk1;
  const m = ensureBytes("message", message);
  const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey);
  const a = ensureBytes("auxRand", auxRand, 32);
  const t = Fn2.toBytes(d ^ num(taggedHash("BIP0340/aux", a)));
  const rand = taggedHash("BIP0340/nonce", t, px, m);
  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(rand);
  const e = challenge(rx, px, m);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(Fn2.toBytes(Fn2.create(k + e * d)), 32);
  if (!schnorrVerify(sig, m, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature, message, publicKey) {
  const { Fn: Fn2, BASE } = Pointk1;
  const sig = ensureBytes("signature", signature, 64);
  const m = ensureBytes("message", message);
  const pub = ensureBytes("publicKey", publicKey, 32);
  try {
    const P = lift_x(num(pub));
    const r = num(sig.subarray(0, 32));
    if (!inRange(r, _1n5, secp256k1_CURVE.p))
      return false;
    const s = num(sig.subarray(32, 64));
    if (!inRange(s, _1n5, secp256k1_CURVE.n))
      return false;
    const e = challenge(Fn2.toBytes(r), pointToBytes(P), m);
    const R = BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(Fn2.neg(e)));
    const { x, y } = R.toAffine();
    if (R.is0() || !hasEven(y) || x !== r)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var schnorr = (() => {
  const size = 32;
  const seedLength = 48;
  const randomSecretKey = (seed = randomBytes(seedLength)) => {
    return mapHashToField(seed, secp256k1_CURVE.n);
  };
  secp256k1.utils.randomSecretKey;
  function keygen(seed) {
    const secretKey = randomSecretKey(seed);
    return { secretKey, publicKey: schnorrGetPublicKey(secretKey) };
  }
  return {
    keygen,
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    Point: Pointk1,
    utils: {
      randomSecretKey,
      randomPrivateKey: randomSecretKey,
      taggedHash,
      // TODO: remove
      lift_x,
      pointToBytes,
      numberToBytesBE,
      bytesToNumberBE,
      mod
    },
    lengths: {
      secretKey: size,
      publicKey: size,
      publicKeyHasPrefix: false,
      signature: size * 2,
      seed: seedLength
    }
  };
})();
var isoMap = (() => isogenyMap(Fpk1, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i) => i.map((j) => BigInt(j)))))();
var mapSWU = (() => mapToCurveSimpleSWU(Fpk1, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Fpk1.create(BigInt("-11"))
}))();
var secp256k1_hasher = (() => createHasher2(secp256k1.Point, (scalars) => {
  const { x, y } = mapSWU(Fpk1.create(scalars[0]));
  return isoMap(x, y);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Fpk1.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha256
}))();
var hashToCurve = (() => secp256k1_hasher.hashToCurve)();
var encodeToCurve = (() => secp256k1_hasher.encodeToCurve)();

// node_modules/@noble/hashes/esm/legacy.js
var SHA1_IV = Uint32Array.from([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]);
var SHA1_W = new Uint32Array(80);
var SHA1 = class extends HashMD {
  constructor() {
    super(64, 20, 8, false);
    this.A = SHA1_IV[0] | 0;
    this.B = SHA1_IV[1] | 0;
    this.C = SHA1_IV[2] | 0;
    this.D = SHA1_IV[3] | 0;
    this.E = SHA1_IV[4] | 0;
  }
  get() {
    const { A, B, C, D, E } = this;
    return [A, B, C, D, E];
  }
  set(A, B, C, D, E) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA1_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 80; i++)
      SHA1_W[i] = rotl(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);
    let { A, B, C, D, E } = this;
    for (let i = 0; i < 80; i++) {
      let F, K2;
      if (i < 20) {
        F = Chi(B, C, D);
        K2 = 1518500249;
      } else if (i < 40) {
        F = B ^ C ^ D;
        K2 = 1859775393;
      } else if (i < 60) {
        F = Maj(B, C, D);
        K2 = 2400959708;
      } else {
        F = B ^ C ^ D;
        K2 = 3395469782;
      }
      const T2 = rotl(A, 5) + F + E + K2 + SHA1_W[i] | 0;
      E = D;
      D = C;
      C = rotl(B, 30);
      B = A;
      A = T2;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    this.set(A, B, C, D, E);
  }
  roundClean() {
    clean(SHA1_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0);
    clean(this.buffer);
  }
};
var sha1 = createHasher(() => new SHA1());
var p32 = Math.pow(2, 32);
var K = Array.from({ length: 64 }, (_2, i) => Math.floor(p32 * Math.abs(Math.sin(i + 1))));
var MD5_IV = SHA1_IV.slice(0, 4);
var MD5_W = new Uint32Array(16);
var MD5 = class extends HashMD {
  constructor() {
    super(64, 16, 8, true);
    this.A = MD5_IV[0] | 0;
    this.B = MD5_IV[1] | 0;
    this.C = MD5_IV[2] | 0;
    this.D = MD5_IV[3] | 0;
  }
  get() {
    const { A, B, C, D } = this;
    return [A, B, C, D];
  }
  set(A, B, C, D) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      MD5_W[i] = view.getUint32(offset, true);
    let { A, B, C, D } = this;
    for (let i = 0; i < 64; i++) {
      let F, g, s;
      if (i < 16) {
        F = Chi(B, C, D);
        g = i;
        s = [7, 12, 17, 22];
      } else if (i < 32) {
        F = Chi(D, B, C);
        g = (5 * i + 1) % 16;
        s = [5, 9, 14, 20];
      } else if (i < 48) {
        F = B ^ C ^ D;
        g = (3 * i + 5) % 16;
        s = [4, 11, 16, 23];
      } else {
        F = C ^ (B | ~D);
        g = 7 * i % 16;
        s = [6, 10, 15, 21];
      }
      F = F + A + K[i] + MD5_W[g];
      A = D;
      D = C;
      C = B;
      B = B + rotl(F, s[i % 4]);
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    this.set(A, B, C, D);
  }
  roundClean() {
    clean(MD5_W);
  }
  destroy() {
    this.set(0, 0, 0, 0);
    clean(this.buffer);
  }
};
var md5 = createHasher(() => new MD5());
var Rho160 = Uint8Array.from([
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8
]);
var Id160 = (() => Uint8Array.from(new Array(16).fill(0).map((_2, i) => i)))();
var Pi160 = (() => Id160.map((i) => (9 * i + 5) % 16))();
var idxLR = (() => {
  const L2 = [Id160];
  const R = [Pi160];
  const res = [L2, R];
  for (let i = 0; i < 4; i++)
    for (let j of res)
      j.push(j[i].map((k) => Rho160[k]));
  return res;
})();
var idxL = (() => idxLR[0])();
var idxR = (() => idxLR[1])();
var shifts160 = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i) => Uint8Array.from(i));
var shiftsL160 = idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));
var shiftsR160 = idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));
var Kl160 = Uint32Array.from([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr160 = Uint32Array.from([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function ripemd_f(group, x, y, z) {
  if (group === 0)
    return x ^ y ^ z;
  if (group === 1)
    return x & y | ~x & z;
  if (group === 2)
    return (x | ~y) ^ z;
  if (group === 3)
    return x & z | y & ~z;
  return x ^ (y | ~z);
}
var BUF_160 = new Uint32Array(16);
var RIPEMD160 = class extends HashMD {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2, h3, h4 } = this;
    return [h0, h1, h2, h3, h4];
  }
  set(h0, h1, h2, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h2 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      BUF_160[i] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl160[group], hbr = Kr160[group];
      const rl = idxL[group], rr = idxR[group];
      const sl = shiftsL160[group], sr = shiftsR160[group];
      for (let i = 0; i < 16; i++) {
        const tl = rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i = 0; i < 16; i++) {
        const tr = rotl(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er | 0;
        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
      }
    }
    this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
  }
  roundClean() {
    clean(BUF_160);
  }
  destroy() {
    this.destroyed = true;
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = createHasher(() => new RIPEMD160());

// node_modules/@scure/base/lib/esm/index.js
function isBytes2(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abytes2(b, ...lengths) {
  if (!isBytes2(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function isArrayOf(isString, arr) {
  if (!Array.isArray(arr))
    return false;
  if (arr.length === 0)
    return true;
  if (isString) {
    return arr.every((item) => typeof item === "string");
  } else {
    return arr.every((item) => Number.isSafeInteger(item));
  }
}
function afn(input) {
  if (typeof input !== "function")
    throw new Error("function expected");
  return true;
}
function astr(label, input) {
  if (typeof input !== "string")
    throw new Error(`${label}: string expected`);
  return true;
}
function anumber2(n) {
  if (!Number.isSafeInteger(n))
    throw new Error(`invalid integer: ${n}`);
}
function aArr(input) {
  if (!Array.isArray(input))
    throw new Error("array expected");
}
function astrArr(label, input) {
  if (!isArrayOf(true, input))
    throw new Error(`${label}: array of strings expected`);
}
function anumArr(label, input) {
  if (!isArrayOf(false, input))
    throw new Error(`${label}: array of numbers expected`);
}
function chain(...args) {
  const id = (a) => a;
  const wrap = (a, b) => (c) => a(b(c));
  const encode = args.map((x) => x.encode).reduceRight(wrap, id);
  const decode = args.map((x) => x.decode).reduce(wrap, id);
  return { encode, decode };
}
function alphabet(letters) {
  const lettersA = typeof letters === "string" ? letters.split("") : letters;
  const len = lettersA.length;
  astrArr("alphabet", lettersA);
  const indexes = new Map(lettersA.map((l, i) => [l, i]));
  return {
    encode: (digits) => {
      aArr(digits);
      return digits.map((i) => {
        if (!Number.isSafeInteger(i) || i < 0 || i >= len)
          throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${letters}`);
        return lettersA[i];
      });
    },
    decode: (input) => {
      aArr(input);
      return input.map((letter) => {
        astr("alphabet.decode", letter);
        const i = indexes.get(letter);
        if (i === void 0)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
        return i;
      });
    }
  };
}
function join(separator = "") {
  astr("join", separator);
  return {
    encode: (from) => {
      astrArr("join.decode", from);
      return from.join(separator);
    },
    decode: (to) => {
      astr("join.decode", to);
      return to.split(separator);
    }
  };
}
function padding(bits, chr = "=") {
  anumber2(bits);
  astr("padding", chr);
  return {
    encode(data) {
      astrArr("padding.encode", data);
      while (data.length * bits % 8)
        data.push(chr);
      return data;
    },
    decode(input) {
      astrArr("padding.decode", input);
      let end = input.length;
      if (end * bits % 8)
        throw new Error("padding: invalid, string should have whole number of bytes");
      for (; end > 0 && input[end - 1] === chr; end--) {
        const last = end - 1;
        const byte = last * bits;
        if (byte % 8 === 0)
          throw new Error("padding: invalid, string has too much padding");
      }
      return input.slice(0, end);
    }
  };
}
function normalize(fn2) {
  afn(fn2);
  return { encode: (from) => from, decode: (to) => fn2(to) };
}
function convertRadix(data, from, to) {
  if (from < 2)
    throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);
  if (to < 2)
    throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);
  aArr(data);
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data, (d) => {
    anumber2(d);
    if (d < 0 || d >= from)
      throw new Error(`invalid integer: ${d}`);
    return d;
  });
  const dlen = digits.length;
  while (true) {
    let carry = 0;
    let done = true;
    for (let i = pos; i < dlen; i++) {
      const digit = digits[i];
      const fromCarry = from * carry;
      const digitBase = fromCarry + digit;
      if (!Number.isSafeInteger(digitBase) || fromCarry / from !== carry || digitBase - digit !== fromCarry) {
        throw new Error("convertRadix: carry overflow");
      }
      const div = digitBase / to;
      carry = digitBase % to;
      const rounded = Math.floor(div);
      digits[i] = rounded;
      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!rounded)
        pos = i;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i = 0; i < data.length - 1 && data[i] === 0; i++)
    res.push(0);
  return res.reverse();
}
var gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
var radix2carry = (from, to) => from + (to - gcd(from, to));
var powers = (() => {
  let res = [];
  for (let i = 0; i < 40; i++)
    res.push(2 ** i);
  return res;
})();
function convertRadix2(data, from, to, padding2) {
  aArr(data);
  if (from <= 0 || from > 32)
    throw new Error(`convertRadix2: wrong from=${from}`);
  if (to <= 0 || to > 32)
    throw new Error(`convertRadix2: wrong to=${to}`);
  if (radix2carry(from, to) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
  }
  let carry = 0;
  let pos = 0;
  const max = powers[from];
  const mask = powers[to] - 1;
  const res = [];
  for (const n of data) {
    anumber2(n);
    if (n >= max)
      throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
    carry = carry << from | n;
    if (pos + from > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
    pos += from;
    for (; pos >= to; pos -= to)
      res.push((carry >> pos - to & mask) >>> 0);
    const pow = powers[pos];
    if (pow === void 0)
      throw new Error("invalid carry");
    carry &= pow - 1;
  }
  carry = carry << to - pos & mask;
  if (!padding2 && pos >= from)
    throw new Error("Excess padding");
  if (!padding2 && carry > 0)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding2 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
function radix(num2) {
  anumber2(num2);
  const _256 = 2 ** 8;
  return {
    encode: (bytes) => {
      if (!isBytes2(bytes))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes), _256, num2);
    },
    decode: (digits) => {
      anumArr("radix.decode", digits);
      return Uint8Array.from(convertRadix(digits, num2, _256));
    }
  };
}
function radix2(bits, revPadding = false) {
  anumber2(bits);
  if (bits <= 0 || bits > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes) => {
      if (!isBytes2(bytes))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
    },
    decode: (digits) => {
      anumArr("radix2.decode", digits);
      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
    }
  };
}
function unsafeWrapper(fn2) {
  afn(fn2);
  return function(...args) {
    try {
      return fn2.apply(null, args);
    } catch (e) {
    }
  };
}
function checksum(len, fn2) {
  anumber2(len);
  afn(fn2);
  return {
    encode(data) {
      if (!isBytes2(data))
        throw new Error("checksum.encode: input should be Uint8Array");
      const sum = fn2(data).slice(0, len);
      const res = new Uint8Array(data.length + len);
      res.set(data);
      res.set(sum, data.length);
      return res;
    },
    decode(data) {
      if (!isBytes2(data))
        throw new Error("checksum.decode: input should be Uint8Array");
      const payload = data.slice(0, -len);
      const oldChecksum = data.slice(-len);
      const newChecksum = fn2(payload).slice(0, len);
      for (let i = 0; i < len; i++)
        if (newChecksum[i] !== oldChecksum[i])
          throw new Error("Invalid checksum");
      return payload;
    }
  };
}
var base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
var base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
var base32nopad = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), join(""));
var base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
var base32hexnopad = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), join(""));
var base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s) => s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
var hasBase64Builtin = (() => typeof Uint8Array.from([]).toBase64 === "function" && typeof Uint8Array.fromBase64 === "function")();
var decodeBase64Builtin = (s, isUrl) => {
  astr("base64", s);
  const re2 = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;
  const alphabet2 = isUrl ? "base64url" : "base64";
  if (s.length > 0 && !re2.test(s))
    throw new Error("invalid base64");
  return Uint8Array.fromBase64(s, { alphabet: alphabet2, lastChunkHandling: "strict" });
};
var base64 = hasBase64Builtin ? {
  encode(b) {
    abytes2(b);
    return b.toBase64();
  },
  decode(s) {
    return decodeBase64Builtin(s, false);
  }
} : chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
var base64nopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), join(""));
var base64url = hasBase64Builtin ? {
  encode(b) {
    abytes2(b);
    return b.toBase64({ alphabet: "base64url" });
  },
  decode(s) {
    return decodeBase64Builtin(s, true);
  }
} : chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
var base64urlnopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), join(""));
var genBase58 = (abc) => chain(radix(58), alphabet(abc), join(""));
var base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
var base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
var createBase58check = (sha2562) => chain(checksum(4, (data) => sha2562(sha2562(data))), base58);
var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod(pre) {
  const b = pre >> 25;
  let chk = (pre & 33554431) << 5;
  for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {
    if ((b >> i & 1) === 1)
      chk ^= POLYMOD_GENERATORS[i];
  }
  return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
  const len = prefix.length;
  let chk = 1;
  for (let i = 0; i < len; i++) {
    const c = prefix.charCodeAt(i);
    if (c < 33 || c > 126)
      throw new Error(`Invalid prefix (${prefix})`);
    chk = bech32Polymod(chk) ^ c >> 5;
  }
  chk = bech32Polymod(chk);
  for (let i = 0; i < len; i++)
    chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 31;
  for (let v of words)
    chk = bech32Polymod(chk) ^ v;
  for (let i = 0; i < 6; i++)
    chk = bech32Polymod(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));
}
function genBech32(encoding) {
  const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
  const _words = radix2(5);
  const fromWords = _words.decode;
  const toWords = _words.encode;
  const fromWordsUnsafe = unsafeWrapper(fromWords);
  function encode(prefix, words, limit = 90) {
    astr("bech32.encode prefix", prefix);
    if (isBytes2(words))
      words = Array.from(words);
    anumArr("bech32.encode", words);
    const plen = prefix.length;
    if (plen === 0)
      throw new TypeError(`Invalid prefix length ${plen}`);
    const actualLength = plen + 7 + words.length;
    if (limit !== false && actualLength > limit)
      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
    const lowered = prefix.toLowerCase();
    const sum = bechChecksum(lowered, words, ENCODING_CONST);
    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
  }
  function decode(str, limit = 90) {
    astr("bech32.decode input", str);
    const slen = str.length;
    if (slen < 8 || limit !== false && slen > limit)
      throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);
    const lowered = str.toLowerCase();
    if (str !== lowered && str !== str.toUpperCase())
      throw new Error(`String must be lowercase or uppercase`);
    const sepIndex = lowered.lastIndexOf("1");
    if (sepIndex === 0 || sepIndex === -1)
      throw new Error(`Letter "1" must be present between prefix and data only`);
    const prefix = lowered.slice(0, sepIndex);
    const data = lowered.slice(sepIndex + 1);
    if (data.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const words = BECH_ALPHABET.decode(data).slice(0, -6);
    const sum = bechChecksum(prefix, words, ENCODING_CONST);
    if (!data.endsWith(sum))
      throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
    return { prefix, words };
  }
  const decodeUnsafe = unsafeWrapper(decode);
  function decodeToBytes(str) {
    const { prefix, words } = decode(str, false);
    return { prefix, words, bytes: fromWords(words) };
  }
  function encodeFromBytes(prefix, bytes) {
    return encode(prefix, toWords(bytes));
  }
  return {
    encode,
    decode,
    encodeFromBytes,
    decodeToBytes,
    decodeUnsafe,
    fromWords,
    fromWordsUnsafe,
    toWords
  };
}
var bech32 = genBech32("bech32");
var bech32m = genBech32("bech32m");
var hasHexBuiltin2 = (() => typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function")();
var hexBuiltin = {
  encode(data) {
    abytes2(data);
    return data.toHex();
  },
  decode(s) {
    astr("hex", s);
    return Uint8Array.fromHex(s);
  }
};
var hex = hasHexBuiltin2 ? hexBuiltin : chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s) => {
  if (typeof s !== "string" || s.length % 2 !== 0)
    throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
  return s.toLowerCase();
}));

// node_modules/@scure/bip32/lib/esm/index.js
var Point = secp256k1.ProjectivePoint;
var base58check = createBase58check(sha256);
function bytesToNumber(bytes) {
  abytes(bytes);
  const h = bytes.length === 0 ? "0" : bytesToHex(bytes);
  return BigInt("0x" + h);
}
function numberToBytes(num2) {
  if (typeof num2 !== "bigint")
    throw new Error("bigint expected");
  return hexToBytes(num2.toString(16).padStart(64, "0"));
}
var MASTER_SECRET = utf8ToBytes("Bitcoin seed");
var BITCOIN_VERSIONS = { private: 76066276, public: 76067358 };
var HARDENED_OFFSET = 2147483648;
var hash160 = (data) => ripemd160(sha256(data));
var fromU32 = (data) => createView(data).getUint32(0, false);
var toU32 = (n) => {
  if (!Number.isSafeInteger(n) || n < 0 || n > 2 ** 32 - 1) {
    throw new Error("invalid number, should be from 0 to 2**32-1, got " + n);
  }
  const buf = new Uint8Array(4);
  createView(buf).setUint32(0, n, false);
  return buf;
};
var HDKey = class _HDKey {
  get fingerprint() {
    if (!this.pubHash) {
      throw new Error("No publicKey set!");
    }
    return fromU32(this.pubHash);
  }
  get identifier() {
    return this.pubHash;
  }
  get pubKeyHash() {
    return this.pubHash;
  }
  get privateKey() {
    return this.privKeyBytes || null;
  }
  get publicKey() {
    return this.pubKey || null;
  }
  get privateExtendedKey() {
    const priv = this.privateKey;
    if (!priv) {
      throw new Error("No private key");
    }
    return base58check.encode(this.serialize(this.versions.private, concatBytes(new Uint8Array([0]), priv)));
  }
  get publicExtendedKey() {
    if (!this.pubKey) {
      throw new Error("No public key");
    }
    return base58check.encode(this.serialize(this.versions.public, this.pubKey));
  }
  static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {
    abytes(seed);
    if (8 * seed.length < 128 || 8 * seed.length > 512) {
      throw new Error("HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got " + seed.length);
    }
    const I = hmac(sha512, MASTER_SECRET, seed);
    return new _HDKey({
      versions,
      chainCode: I.slice(32),
      privateKey: I.slice(0, 32)
    });
  }
  static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {
    const keyBuffer = base58check.decode(base58key);
    const keyView = createView(keyBuffer);
    const version = keyView.getUint32(0, false);
    const opt = {
      versions,
      depth: keyBuffer[4],
      parentFingerprint: keyView.getUint32(5, false),
      index: keyView.getUint32(9, false),
      chainCode: keyBuffer.slice(13, 45)
    };
    const key = keyBuffer.slice(45);
    const isPriv = key[0] === 0;
    if (version !== versions[isPriv ? "private" : "public"]) {
      throw new Error("Version mismatch");
    }
    if (isPriv) {
      return new _HDKey({ ...opt, privateKey: key.slice(1) });
    } else {
      return new _HDKey({ ...opt, publicKey: key });
    }
  }
  static fromJSON(json) {
    return _HDKey.fromExtendedKey(json.xpriv);
  }
  constructor(opt) {
    this.depth = 0;
    this.index = 0;
    this.chainCode = null;
    this.parentFingerprint = 0;
    if (!opt || typeof opt !== "object") {
      throw new Error("HDKey.constructor must not be called directly");
    }
    this.versions = opt.versions || BITCOIN_VERSIONS;
    this.depth = opt.depth || 0;
    this.chainCode = opt.chainCode || null;
    this.index = opt.index || 0;
    this.parentFingerprint = opt.parentFingerprint || 0;
    if (!this.depth) {
      if (this.parentFingerprint || this.index) {
        throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");
      }
    }
    if (opt.publicKey && opt.privateKey) {
      throw new Error("HDKey: publicKey and privateKey at same time.");
    }
    if (opt.privateKey) {
      if (!secp256k1.utils.isValidPrivateKey(opt.privateKey)) {
        throw new Error("Invalid private key");
      }
      this.privKey = typeof opt.privateKey === "bigint" ? opt.privateKey : bytesToNumber(opt.privateKey);
      this.privKeyBytes = numberToBytes(this.privKey);
      this.pubKey = secp256k1.getPublicKey(opt.privateKey, true);
    } else if (opt.publicKey) {
      this.pubKey = Point.fromHex(opt.publicKey).toRawBytes(true);
    } else {
      throw new Error("HDKey: no public or private key provided");
    }
    this.pubHash = hash160(this.pubKey);
  }
  derive(path) {
    if (!/^[mM]'?/.test(path)) {
      throw new Error('Path must start with "m" or "M"');
    }
    if (/^[mM]'?$/.test(path)) {
      return this;
    }
    const parts = path.replace(/^[mM]'?\//, "").split("/");
    let child = this;
    for (const c of parts) {
      const m = /^(\d+)('?)$/.exec(c);
      const m1 = m && m[1];
      if (!m || m.length !== 3 || typeof m1 !== "string")
        throw new Error("invalid child index: " + c);
      let idx = +m1;
      if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) {
        throw new Error("Invalid index");
      }
      if (m[2] === "'") {
        idx += HARDENED_OFFSET;
      }
      child = child.deriveChild(idx);
    }
    return child;
  }
  deriveChild(index) {
    if (!this.pubKey || !this.chainCode) {
      throw new Error("No publicKey or chainCode set");
    }
    let data = toU32(index);
    if (index >= HARDENED_OFFSET) {
      const priv = this.privateKey;
      if (!priv) {
        throw new Error("Could not derive hardened child key");
      }
      data = concatBytes(new Uint8Array([0]), priv, data);
    } else {
      data = concatBytes(this.pubKey, data);
    }
    const I = hmac(sha512, this.chainCode, data);
    const childTweak = bytesToNumber(I.slice(0, 32));
    const chainCode = I.slice(32);
    if (!secp256k1.utils.isValidPrivateKey(childTweak)) {
      throw new Error("Tweak bigger than curve order");
    }
    const opt = {
      versions: this.versions,
      chainCode,
      depth: this.depth + 1,
      parentFingerprint: this.fingerprint,
      index
    };
    try {
      if (this.privateKey) {
        const added = mod(this.privKey + childTweak, secp256k1.CURVE.n);
        if (!secp256k1.utils.isValidPrivateKey(added)) {
          throw new Error("The tweak was out of range or the resulted private key is invalid");
        }
        opt.privateKey = added;
      } else {
        const added = Point.fromHex(this.pubKey).add(Point.fromPrivateKey(childTweak));
        if (added.equals(Point.ZERO)) {
          throw new Error("The tweak was equal to negative P, which made the result key invalid");
        }
        opt.publicKey = added.toRawBytes(true);
      }
      return new _HDKey(opt);
    } catch (err) {
      return this.deriveChild(index + 1);
    }
  }
  sign(hash) {
    if (!this.privateKey) {
      throw new Error("No privateKey set!");
    }
    abytes(hash, 32);
    return secp256k1.sign(hash, this.privKey).toCompactRawBytes();
  }
  verify(hash, signature) {
    abytes(hash, 32);
    abytes(signature, 64);
    if (!this.publicKey) {
      throw new Error("No publicKey set!");
    }
    let sig;
    try {
      sig = secp256k1.Signature.fromCompact(signature);
    } catch (error) {
      return false;
    }
    return secp256k1.verify(sig, hash, this.publicKey);
  }
  wipePrivateData() {
    this.privKey = void 0;
    if (this.privKeyBytes) {
      this.privKeyBytes.fill(0);
      this.privKeyBytes = void 0;
    }
    return this;
  }
  toJSON() {
    return {
      xpriv: this.privateExtendedKey,
      xpub: this.publicExtendedKey
    };
  }
  serialize(version, key) {
    if (!this.chainCode) {
      throw new Error("No chainCode set");
    }
    abytes(key, 33);
    return concatBytes(toU32(version), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);
  }
};

// node_modules/@cashu/cashu-ts/lib/cashu-ts.es.js
var ut = {
  UNPAID: "UNPAID",
  PENDING: "PENDING",
  PAID: "PAID"
};
var Tt = {
  UNPAID: "UNPAID",
  PAID: "PAID",
  ISSUED: "ISSUED"
};
var ht = class _ht extends Error {
  constructor(t, e) {
    super(t), this.status = e, this.name = "HttpResponseError", Object.setPrototypeOf(this, _ht.prototype);
  }
};
var Kt = class _Kt extends Error {
  constructor(t) {
    super(t), this.name = "NetworkError", Object.setPrototypeOf(this, _Kt.prototype);
  }
};
var Dt = class _Dt extends ht {
  constructor(t, e) {
    super(e || "Unknown mint operation error", 400), this.code = t, this.name = "MintOperationError", Object.setPrototypeOf(this, _Dt.prototype);
  }
};
var L = {
  error() {
  },
  warn() {
  },
  info() {
  },
  debug() {
  },
  trace() {
  },
  log() {
  }
};
function bt(s, t = L, e) {
  throw t.error(s, e), new Error(s);
}
function le(s, t, e = L, n) {
  s && bt(t, e, n);
}
function de(s, t, e = L, n) {
  s == null && bt(t, e, n);
}
function lt(s, t, e = L, n) {
  if (s)
    try {
      const r = s(t);
      r && typeof r.then == "function" && r.catch((i) => {
        try {
          e.warn("callback failed", {
            ...n ?? {},
            error: i,
            cb: s.name ?? ""
          });
        } catch {
        }
      });
    } catch (r) {
      try {
        e.warn("callback failed", {
          ...n ?? {},
          error: r,
          cb: s.name ?? ""
        });
      } catch {
      }
    }
}
var Yt = {
  error: 0,
  warn: 1,
  info: 2,
  debug: 3,
  trace: 4
};
var gs = class {
  constructor(t = "info") {
    this.minLevel = t;
  }
  should(t) {
    return Yt[t] <= Yt[this.minLevel];
  }
  method(t) {
    switch (t) {
      case "error":
        return console.error;
      case "warn":
        return console.warn;
      case "info":
        return console.info;
      case "debug":
        return console.debug;
      case "trace":
        return console.trace;
      default:
        return console.log;
    }
  }
  header(t, e) {
    return `[${t.toUpperCase()}] ${e}`;
  }
  flattenContext(t) {
    if (!t)
      return;
    const e = {};
    for (const [n, r] of Object.entries(t))
      e[n] = r instanceof Error ? { message: r.message, stack: r.stack } : r;
    return e;
  }
  emit(t, e, n) {
    if (!this.should(t))
      return;
    const r = this.header(t, e), i = this.flattenContext(n), o = this.method(t);
    i && Object.keys(i).length ? o(r, i) : o(r);
  }
  error(t, e) {
    this.emit("error", t, e);
  }
  warn(t, e) {
    this.emit("warn", t, e);
  }
  info(t, e) {
    this.emit("info", t, e);
  }
  debug(t, e) {
    this.emit("debug", t, e);
  }
  trace(t, e) {
    this.emit("trace", t, e);
  }
  log(t, e, n) {
    this.emit(t, e, n);
  }
};
function He() {
  const s = Date.now();
  return {
    elapsed: () => Date.now() - s
  };
}
var fe = {};
var ge = L;
function ps(s) {
  fe = s;
}
function je(s) {
  ge = s;
}
async function Qe({
  endpoint: s,
  requestBody: t,
  headers: e,
  ...n
}) {
  const r = t ? JSON.stringify(t) : void 0, i = {
    Accept: "application/json, text/plain, */*",
    ...r ? { "Content-Type": "application/json" } : void 0,
    ...e
  };
  let o;
  try {
    o = await fetch(s, { body: r, headers: i, ...n });
  } catch (a) {
    throw new Kt(a instanceof Error ? a.message : "Network request failed");
  }
  if (!o.ok) {
    let a;
    try {
      a = await o.json();
    } catch {
      a = { error: "bad response" };
    }
    if (o.status === 400 && "code" in a && typeof a.code == "number" && "detail" in a && typeof a.detail == "string")
      throw new Dt(a.code, a.detail);
    let c = "HTTP request failed";
    throw "error" in a && typeof a.error == "string" ? c = a.error : "detail" in a && typeof a.detail == "string" && (c = a.detail), new ht(c, o.status);
  }
  try {
    return await o.json();
  } catch (a) {
    throw ge.error("Failed to parse HTTP response", { err: a }), new ht("bad response", o.status);
  }
}
async function pe(s) {
  return await Qe({ ...s, ...fe });
}
var pt;
typeof WebSocket < "u" && (pt = WebSocket);
function ms(s) {
  pt = s;
}
function ze() {
  if (pt === void 0)
    throw new Error("WebSocket implementation not initialized");
  return pt;
}
var _ = class {
  static fromHex(t) {
    if (t = t.trim(), t.length === 0)
      return new Uint8Array(0);
    if (t.length < 2 || t.length & 1)
      throw new Error("Invalid hex string: odd length.");
    if ((t.startsWith("0x") || t.startsWith("0X")) && (t = t.slice(2)), !t.match(/^[0-9a-fA-F]*$/))
      throw new Error("Invalid hex string: contains non-hex characters");
    const n = t.match(/.{1,2}/g);
    if (!n)
      throw new Error("Invalid hex string");
    return new Uint8Array(n.map((r) => parseInt(r, 16)));
  }
  static toHex(t) {
    return Array.from(t, (e) => e.toString(16).padStart(2, "0")).join("");
  }
  static fromString(t) {
    return t = t.trim(), new TextEncoder().encode(t);
  }
  static toString(t) {
    return new TextDecoder("utf-8").decode(t);
  }
  static concat(...t) {
    const e = t.reduce((i, o) => i + o.length, 0), n = new Uint8Array(e);
    let r = 0;
    for (const i of t)
      n.set(i, r), r += i.length;
    return n;
  }
  static alloc(t) {
    return new Uint8Array(t);
  }
  static writeBigUint64BE(t) {
    const e = new ArrayBuffer(8);
    return new DataView(e).setBigUint64(0, t, false), new Uint8Array(e);
  }
  static toBase64(t) {
    if (typeof Buffer < "u")
      return Buffer.from(t).toString("base64");
    if (t.length > 32768) {
      let e = "";
      for (let n = 0; n < t.length; n += 32768) {
        const r = t.slice(n, n + 32768);
        e += btoa(String.fromCharCode(...r));
      }
      return e;
    }
    return btoa(String.fromCharCode(...t));
  }
  static fromBase64(t) {
    t = t.trim();
    let e = t.replace(/-/g, "+").replace(/_/g, "/");
    for (; e.length % 4; )
      e += "=";
    return typeof Buffer < "u" ? new Uint8Array(Buffer.from(e, "base64")) : new Uint8Array([...atob(e)].map((n) => n.charCodeAt(0)));
  }
  // NOTE: MUST remain a constant-time implementation (full byte check)
  // because callers rely on it (e.g. deriveP2BKSecretKey).
  static equals(t, e) {
    if (t.length !== e.length)
      return false;
    let n = 0;
    for (let r = 0; r < t.length; r++)
      n |= t[r] ^ e[r];
    return n === 0;
  }
  static compare(t, e) {
    const n = Math.min(t.length, e.length);
    for (let r = 0; r < n; r++) {
      if (t[r] < e[r])
        return -1;
      if (t[r] > e[r])
        return 1;
    }
    return t.length - e.length;
  }
};
function It(s) {
  return _.toBase64(s).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
function qt(s) {
  return _.fromBase64(s);
}
function me(s) {
  const t = JSON.stringify(s);
  return Je(_.toBase64(_.fromString(t)));
}
function Ve(s) {
  const t = _.toString(_.fromBase64(Ge(s)));
  return JSON.parse(t);
}
function Ge(s) {
  return s.replace(/-/g, "+").replace(/_/g, "/").split("=")[0];
}
function Je(s) {
  return s.replace(/\+/g, "-").replace(/\//g, "_").split("=")[0];
}
function Ut(s) {
  if (typeof s != "string" || s.length === 0)
    return false;
  const t = /^[A-Za-z0-9\-_]+={0,2}$/, e = /^[A-Za-z0-9+/]+={0,2}$/;
  if (!t.test(s) && !e.test(s))
    return false;
  const n = s.replace(/-/g, "+").replace(/_/g, "/"), r = (4 - n.length % 4) % 4;
  if (r > 2)
    return false;
  const i = n + "=".repeat(r);
  try {
    const o = _.fromBase64(i), a = _.toBase64(o), c = a.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, ""), u = n.replace(/=+$/, "");
    return a.replace(/=+$/, "") === u || c === u;
  } catch {
    return false;
  }
}
function Xe(s) {
  return typeof s == "number" || typeof s == "string";
}
function Rt(s) {
  const t = [];
  return Nt(s, t), new Uint8Array(t);
}
function Nt(s, t) {
  if (s === null)
    t.push(246);
  else if (s === void 0)
    t.push(247);
  else if (typeof s == "boolean")
    t.push(s ? 245 : 244);
  else if (typeof s == "number")
    en(s, t);
  else if (typeof s == "string")
    ye(s, t);
  else if (Array.isArray(s))
    sn(s, t);
  else if (s instanceof Uint8Array)
    nn(s, t);
  else if (
    // Defensive: POJO only (null/array handled above)
    typeof s == "object" && s !== null && !Array.isArray(s)
  )
    rn(s, t);
  else
    throw new Error("Unsupported type");
}
function Ye(s, t) {
  if (s < 24)
    t.push(s);
  else if (s < 256)
    t.push(24, s);
  else if (s < 65536)
    t.push(25, s >>> 8 & 255, s & 255);
  else if (s < 4294967296)
    t.push(
      26,
      s >>> 24 & 255,
      s >>> 16 & 255,
      s >>> 8 & 255,
      s & 255
    );
  else
    throw new Error("Unsupported integer size");
}
function Ze(s, t) {
  const e = -1 - s;
  if (e < 24)
    t.push(32 | e);
  else if (e < 256)
    t.push(56, e & 255);
  else if (e < 65536)
    t.push(57, e >>> 8 & 255, e & 255);
  else if (e < 4294967296)
    t.push(
      58,
      e >>> 24 & 255,
      e >>> 16 & 255,
      e >>> 8 & 255,
      e & 255
    );
  else
    throw new Error("Unsupported integer size");
}
function tn(s, t) {
  const e = new ArrayBuffer(8), n = new DataView(e);
  n.setFloat64(0, s, false), t.push(251);
  for (let r = 0; r < 8; r++)
    t.push(n.getUint8(r));
}
function en(s, t) {
  Number.isInteger(s) ? s >= 0 ? Ye(s, t) : Ze(s, t) : tn(s, t);
}
function nn(s, t) {
  const e = s.length;
  if (e < 24)
    t.push(64 + e);
  else if (e < 256)
    t.push(88, e);
  else if (e < 65536)
    t.push(89, e >> 8 & 255, e & 255);
  else if (e < 4294967296)
    t.push(
      90,
      e >>> 24 & 255,
      e >>> 16 & 255,
      e >>> 8 & 255,
      e & 255
    );
  else
    throw new Error("Byte string too long to encode");
  for (let n = 0; n < s.length; n++)
    t.push(s[n]);
}
function ye(s, t) {
  const e = new TextEncoder().encode(s), n = e.length;
  if (n < 24)
    t.push(96 + n);
  else if (n < 256)
    t.push(120, n);
  else if (n < 65536)
    t.push(121, n >>> 8 & 255, n & 255);
  else if (n < 4294967296)
    t.push(
      122,
      n >>> 24 & 255,
      n >>> 16 & 255,
      n >>> 8 & 255,
      n & 255
    );
  else
    throw new Error("String too long to encode");
  for (let r = 0; r < e.length; r++)
    t.push(e[r]);
}
function sn(s, t) {
  const e = s.length;
  if (e < 24)
    t.push(128 | e);
  else if (e < 256)
    t.push(152, e);
  else if (e < 65536)
    t.push(153, e >>> 8 & 255, e & 255);
  else
    throw new Error("Unsupported array length");
  for (const n of s)
    Nt(n, t);
}
function rn(s, t) {
  const e = Object.keys(s), n = e.length;
  if (n >= 4294967296)
    throw new Error("Object has too many keys to encode");
  n < 24 ? t.push(160 | n) : n < 256 ? t.push(184, n) : n < 65536 ? t.push(185, n >> 8 & 255, n & 255) : t.push(
    186,
    n >> 24 & 255,
    n >> 16 & 255,
    n >> 8 & 255,
    n & 255
  );
  for (const r of e)
    ye(r, t), Nt(s[r], t);
}
function Ft(s) {
  const t = new DataView(s.buffer, s.byteOffset, s.byteLength);
  return mt(t, 0).value;
}
function mt(s, t) {
  if (t >= s.byteLength)
    throw new Error("Unexpected end of data");
  const e = s.getUint8(t++), n = e >> 5, r = e & 31;
  switch (n) {
    case 0:
      return on(s, t, r);
    case 1:
      return an(s, t, r);
    case 2:
      return cn(s, t, r);
    case 3:
      return un(s, t, r);
    case 4:
      return hn(s, t, r);
    case 5:
      return ln(s, t, r);
    case 7:
      return fn(s, t, r);
    default:
      throw new Error(`Unsupported major type: ${n}`);
  }
}
function V(s, t, e) {
  if (t + e > s.byteLength)
    throw new Error("Unexpected end of data");
}
function ot(s, t, e) {
  if (e < 24)
    return { value: e, offset: t };
  if (e === 24)
    return V(s, t, 1), { value: s.getUint8(t++), offset: t };
  if (e === 25) {
    V(s, t, 2);
    const n = s.getUint16(t, false);
    return t += 2, { value: n, offset: t };
  }
  if (e === 26) {
    V(s, t, 4);
    const n = s.getUint32(t, false);
    return t += 4, { value: n, offset: t };
  }
  if (e === 27) {
    V(s, t, 8);
    const n = s.getUint32(t, false), r = s.getUint32(t + 4, false);
    return t += 8, { value: n * 2 ** 32 + r, offset: t };
  }
  throw new Error(`Unsupported length: ${e}`);
}
function on(s, t, e) {
  const { value: n, offset: r } = ot(s, t, e);
  return { value: n, offset: r };
}
function an(s, t, e) {
  const { value: n, offset: r } = ot(s, t, e);
  return { value: -1 - n, offset: r };
}
function cn(s, t, e) {
  const { value: n, offset: r } = ot(s, t, e);
  if (r + n > s.byteLength)
    throw new Error("Byte string length exceeds data length");
  return { value: new Uint8Array(s.buffer, s.byteOffset + r, n), offset: r + n };
}
function un(s, t, e) {
  const { value: n, offset: r } = ot(s, t, e);
  if (r + n > s.byteLength)
    throw new Error("String length exceeds data length");
  const i = new Uint8Array(s.buffer, s.byteOffset + r, n);
  return { value: new TextDecoder().decode(i), offset: r + n };
}
function hn(s, t, e) {
  const { value: n, offset: r } = ot(s, t, e), i = [];
  let o = r;
  for (let a = 0; a < n; a++) {
    const c = mt(s, o);
    i.push(c.value), o = c.offset;
  }
  return { value: i, offset: o };
}
function ln(s, t, e) {
  const { value: n, offset: r } = ot(s, t, e), i = {};
  let o = r;
  for (let a = 0; a < n; a++) {
    const c = mt(s, o);
    if (!Xe(c.value))
      throw new Error("Invalid key type");
    const u = mt(s, c.offset);
    i[c.value] = u.value, o = u.offset;
  }
  return { value: i, offset: o };
}
function dn(s) {
  const t = (s & 31744) >> 10, e = s & 1023, n = s & 32768 ? -1 : 1;
  return t === 0 ? n * 2 ** -14 * (e / 1024) : t === 31 ? e ? NaN : n * (1 / 0) : n * 2 ** (t - 15) * (1 + e / 1024);
}
function fn(s, t, e) {
  if (e < 24)
    switch (e) {
      case 20:
        return { value: false, offset: t };
      case 21:
        return { value: true, offset: t };
      case 22:
        return { value: null, offset: t };
      case 23:
        return { value: void 0, offset: t };
      default:
        throw new Error(`Unknown simple value: ${e}`);
    }
  if (e === 24)
    return V(s, t, 1), { value: s.getUint8(t++), offset: t };
  if (e === 25) {
    V(s, t, 2);
    const n = dn(s.getUint16(t, false));
    return t += 2, { value: n, offset: t };
  }
  if (e === 26) {
    V(s, t, 4);
    const n = s.getFloat32(t, false);
    return t += 4, { value: n, offset: t };
  }
  if (e === 27) {
    V(s, t, 8);
    const n = s.getFloat64(t, false);
    return t += 8, { value: n, offset: t };
  }
  throw new Error(`Unknown simple or float value: ${e}`);
}
var Zt = utf8ToBytes("Cashu_P2BK_v1");
function gn(s, t, e) {
  if (!s.length)
    return { blinded: [], Ehex: "" };
  e = e ?? secp256k1.utils.randomSecretKey();
  const n = secp256k1.Point.Fn.fromBytes(e), r = secp256k1.getPublicKey(e, true), i = hexToBytes(t);
  return { blinded: s.map((a, c) => {
    const u = X(a), l = we(u, n, i, c), h = u.add(secp256k1.Point.BASE.multiply(l));
    if (h.equals(secp256k1.Point.ZERO))
      throw new Error("Blinded key at infinity");
    return h.toHex(true);
  }), Ehex: bytesToHex(r) };
}
function pn(s, t, e, n) {
  const r = Array.isArray(t) ? t : [t], i = Array.isArray(e) ? e : [e], o = /* @__PURE__ */ new Set(), a = secp256k1.Point.fromHex(s), c = hexToBytes(n);
  for (const u of r) {
    const l = secp256k1.Point.Fn.fromBytes(hexToBytes(u)), h = secp256k1.getPublicKey(hexToBytes(u), true);
    i.forEach((d, p) => {
      const m = we(a, l, c, p), P = hexToBytes(d), A = mn(u, m, P, h);
      A && o.add(A);
    });
  }
  return Array.from(o);
}
function mn(s, t, e, n) {
  const r = secp256k1.Point.CURVE().n, i = typeof s == "string" ? dt(s) : s, o = typeof t == "string" ? dt(t) : t;
  if (i <= 0n || i >= r)
    throw new Error("Invalid private key");
  if (o <= 0n || o >= r)
    throw new Error("Invalid scalar r");
  if (n = n ?? secp256k1.Point.BASE.multiply(i).toBytes(true), n.length !== 33)
    throw new Error("naturalPub must be 33 bytes");
  const a = (i + o) % r, c = (r - i + o) % r;
  if (!e) {
    if (a === 0n)
      throw new Error("Derived secret key is zero");
    return Mt(a);
  }
  if (e.length !== 33)
    throw new Error("blindPubkey must be 33 bytes");
  const u = secp256k1.Point.fromHex(e), l = secp256k1.Point.BASE.multiply(o), h = u.subtract(l);
  if (h.equals(secp256k1.Point.ZERO))
    return null;
  const d = h.toBytes(true).slice(1), p = n.slice(1);
  if (!_.equals(d, p))
    return null;
  const m = h.toBytes(true)[0] & 1, P = n[0] & 1, A = m === P ? a : c;
  if (A === 0n)
    throw new Error("Derived secret key is zero");
  return Mt(A);
}
function we(s, t, e, n) {
  const r = s.multiply(t).toBytes(true).slice(1), i = new Uint8Array([n & 255]);
  let o = $(sha256(_.concat(Zt, r, e, i)));
  if ((o === 0n || o >= secp256k1.Point.CURVE().n) && (o = $(sha256(_.concat(Zt, r, e, i, new Uint8Array([255])))), o === 0n || o >= secp256k1.Point.CURVE().n))
    throw new Error("P2BK: tweak derivation failed");
  return o;
}
var ys = (s) => {
  const t = [
    "P2PK",
    {
      nonce: bytesToHex(randomBytes(32)),
      data: s
    }
  ];
  return JSON.stringify(t);
};
var Q = (s) => {
  try {
    return s instanceof Uint8Array && (s = new TextDecoder().decode(s)), JSON.parse(s);
  } catch {
    throw new Error("can't parse secret");
  }
};
var yn = (s, t) => {
  const e = sha256(s), n = schnorr.sign(e, t);
  return bytesToHex(n);
};
var wn = (s, t) => {
  const e = sha256(s), n = schnorr.sign(e, t);
  return bytesToHex(n);
};
var Lt = (s, t, e) => {
  try {
    const n = sha256(t), r = e.length === 66 ? e.slice(2) : e;
    if (schnorr.verify(s, n, hexToBytes(r)))
      return true;
  } catch (n) {
    console.error("verifyP2PKsecret error:", n);
  }
  return false;
};
var ws = (s, t) => t.witness ? Wt(t.witness).some((n) => {
  try {
    return Lt(n, t.secret, s);
  } catch {
    return false;
  }
}) : false;
function $t(s) {
  try {
    const t = typeof s == "string" ? Q(s) : s;
    if (t[0] !== "P2PK")
      throw new Error('Invalid P2PK secret: must start with "P2PK"');
    const e = Math.floor(Date.now() / 1e3);
    return _e(t) > e ? ke(t) : be(t);
  } catch {
  }
  return [];
}
function ke(s) {
  const t = typeof s == "string" ? Q(s) : s;
  if (t[0] !== "P2PK")
    throw new Error('Invalid P2PK secret: must start with "P2PK"');
  const { data: e, tags: n } = t[1], r = n && n.find((o) => o[0] === "pubkeys"), i = r && r.length > 1 ? r.slice(1) : [];
  return [e, ...i].filter(Boolean);
}
function be(s) {
  const t = typeof s == "string" ? Q(s) : s;
  if (t[0] !== "P2PK")
    throw new Error('Invalid P2PK secret: must start with "P2PK"');
  const { tags: e } = t[1], n = e && e.find((r) => r[0] === "refund");
  return n && n.length > 1 ? n.slice(1).filter(Boolean) : [];
}
function _e(s) {
  const t = typeof s == "string" ? Q(s) : s;
  if (t[0] !== "P2PK")
    throw new Error('Invalid P2PK secret: must start with "P2PK"');
  const { tags: e } = t[1], n = e && e.find((r) => r[0] === "locktime");
  return n && n.length > 1 ? parseInt(n[1], 10) : 1 / 0;
}
function kn(s) {
  const t = typeof s == "string" ? Q(s) : s;
  if (t[0] !== "P2PK")
    throw new Error('Invalid P2PK secret: must start with "P2PK"');
  if (!$t(t).length)
    return 0;
  const { tags: n } = t[1], r = Math.floor(Date.now() / 1e3);
  if (_e(t) > r) {
    const a = n && n.find((c) => c[0] === "n_sigs");
    return a && a.length > 1 ? parseInt(a[1], 10) : 1;
  }
  const o = n && n.find((a) => a[0] === "n_sigs_refund");
  return o && o.length > 1 ? parseInt(o[1], 10) : 1;
}
function ks(s) {
  const t = typeof s == "string" ? Q(s) : s;
  if (t[0] !== "P2PK")
    throw new Error('Invalid P2PK secret: must start with "P2PK"');
  const { tags: e } = t[1], n = e && e.find((r) => r[0] === "sigflag");
  return n && n.length > 1 ? n[1] : "SIG_INPUTS";
}
var Wt = (s) => {
  if (!s)
    return [];
  if (typeof s == "string")
    try {
      return JSON.parse(s).signatures || [];
    } catch (t) {
      return console.error("Failed to parse witness string:", t), [];
    }
  return s.signatures || [];
};
var bn = (s, t, e = L) => s.map((n, r) => {
  try {
    const i = Pn(t, n);
    let o = n;
    for (const a of i)
      try {
        o = _n(o, a);
      } catch (c) {
        const u = c instanceof Error ? c.message : "Unknown error";
        e.warn(`Proof #${r + 1}: ${u}`);
      }
    return o;
  } catch (i) {
    const o = i instanceof Error ? i.message : "Unknown error";
    throw e.error(`Proof #${r + 1}: ${o}`), new Error(`Failed signing proof #${r + 1}: ${o}`);
  }
});
var _n = (s, t) => {
  const e = Q(s.secret);
  if (e[0] !== "P2PK")
    throw new Error("not a P2PK secret");
  const n = bytesToHex(schnorr.getPublicKey(t)), r = $t(e);
  if (!r.length || !r.some((c) => c.includes(n)))
    throw new Error(`Signature not required from [02|03]${n}`);
  const i = Wt(s.witness);
  if (i.some((c) => {
    try {
      return Lt(c, s.secret, n);
    } catch {
      return false;
    }
  }))
    throw new Error(`Proof already signed by [02|03]${n}`);
  const a = yn(s.secret, t);
  return { ...s, witness: { signatures: [...i, a] } };
};
var bs = (s) => {
  if (!s.witness)
    throw new Error("could not verify signature, no witness provided");
  const t = Q(s.secret), e = $t(t);
  if (!e.length)
    throw new Error("no signatures required, proof is unlocked");
  let n = 0;
  const r = kn(t), i = Wt(s.witness);
  for (const o of e)
    i.some((c) => {
      try {
        return Lt(c, s.secret, o);
      } catch {
        return false;
      }
    }) && n++;
  return n >= r;
};
var _s = (s, t) => {
  var _a;
  if (!((_a = s.witness) == null ? void 0 : _a.signatures) || s.witness.signatures.length === 0)
    throw new Error("could not verify signature, no witness signatures provided");
  return schnorr.verify(
    s.witness.signatures[0],
    sha256(s.B_.toHex(true)),
    t.slice(2)
  );
};
var Pe = (s, t) => {
  const e = s.B_.toHex(true), n = wn(e, t);
  return s.witness = { signatures: [n] }, s;
};
var Ps = (s, t) => s.map((e) => Pe(e, t));
function Pn(s, t) {
  const e = Array.isArray(s) ? s : [s], n = t == null ? void 0 : t.p2pk_e;
  if (!n)
    return Array.from(new Set(e));
  const r = Q(t.secret), i = [...ke(r), ...be(r)], o = t.id;
  return pn(n, e, i, o);
}
var An = hexToBytes("536563703235366b315f48617368546f43757276655f43617368755f");
function ft(s) {
  const t = sha256(_.concat(An, s)), e = new Uint32Array(1), n = 2 ** 16;
  for (let r = 0; r < n; r++) {
    const i = new Uint8Array(e.buffer), o = sha256(_.concat(t, i));
    try {
      return X(bytesToHex(_.concat(new Uint8Array([2]), o)));
    } catch {
      e[0]++;
    }
  }
  throw new Error("No valid point found");
}
function Ae(s) {
  const e = s.map((n) => n.toHex(false)).join("");
  return sha256(new TextEncoder().encode(e));
}
function As(s) {
  return secp256k1.Point.fromHex(bytesToHex(s));
}
function X(s) {
  return secp256k1.Point.fromHex(s);
}
var vn = (s) => {
  let t;
  return /^[a-fA-F0-9]+$/.test(s) ? t = dt(s) % BigInt(2 ** 31 - 1) : t = $(qt(s)) % BigInt(2 ** 31 - 1), t;
};
function ve() {
  return secp256k1.utils.randomSecretKey();
}
function vs(s, t, e, n) {
  return { C_: s.multiply($(t)), amount: e, id: n };
}
function Es(s) {
  return gt(
    randomBytes(32),
    $(secp256k1.utils.randomSecretKey()),
    s
  );
}
function gt(s, t, e) {
  const n = ft(s);
  t || (t = $(secp256k1.utils.randomSecretKey()));
  const r = secp256k1.Point.BASE.multiply(t), i = n.add(r);
  return e !== void 0 ? Pe({ B_: i, r: t, secret: s }, e) : { B_: i, r: t, secret: s };
}
function En(s, t, e) {
  return s.subtract(e.multiply(t));
}
function Sn(s, t, e, n) {
  const r = n, i = En(s.C_, t, r);
  return {
    id: s.id,
    amount: s.amount,
    secret: e,
    C: i
  };
}
var Tn = (s) => ({
  amount: s.amount,
  C: s.C.toHex(true),
  id: s.id,
  secret: new TextDecoder().decode(s.secret),
  witness: JSON.stringify(s.witness)
});
var Ss = (s) => ({
  amount: s.amount,
  C: X(s.C),
  id: s.id,
  secret: new TextEncoder().encode(s.secret),
  witness: s.witness ? JSON.parse(s.witness) : void 0
});
var te = "m/0'/0'/0'";
function In(s) {
  const t = {};
  return Object.keys(s).forEach((e) => {
    t[e] = bytesToHex(s[e]);
  }), t;
}
function Ts(s) {
  const t = {};
  return Object.keys(s).forEach((e) => {
    t[e] = hexToBytes(s[e]);
  }), t;
}
function Mn(s) {
  return secp256k1.getPublicKey(s, true);
}
function Is(s, t) {
  let e = 0n;
  const n = {}, r = {};
  let i;
  for (t && (i = HDKey.fromMasterSeed(t)); e < s; ) {
    const a = (2n ** e).toString();
    if (i) {
      const c = i.derive(`${te}/${e}`).privateKey;
      if (c)
        r[a] = c;
      else
        throw new Error(`Could not derive Private key from: ${te}/${e}`);
    } else
      r[a] = ve();
    n[a] = Mn(r[a]), e++;
  }
  const o = Qt(In(n));
  return { pubKeys: n, privKeys: r, keysetId: o };
}
function Ms(s, t) {
  return ft(s.secret).multiply($(t)).equals(s.C);
}
var Cn = "m/129372'/0'";
var xn = (s, t, e) => {
  const n = /^[a-fA-F0-9]+$/.test(t);
  if (!n && Ut(t) || n && t.startsWith("00"))
    return yt(
      s,
      t,
      e,
      0
      /* SECRET */
    );
  if (n && t.startsWith("01"))
    return Ee(
      s,
      t,
      e,
      0
      /* SECRET */
    );
  throw new Error(`Unrecognized keyset ID version ${t.slice(0, 2)}`);
};
var Bn = (s, t, e) => {
  const n = /^[a-fA-F0-9]+$/.test(t);
  if (!n && Ut(t) || n && t.startsWith("00"))
    return yt(
      s,
      t,
      e,
      1
      /* BLINDING_FACTOR */
    );
  if (n && t.startsWith("01"))
    return Ee(
      s,
      t,
      e,
      1
      /* BLINDING_FACTOR */
    );
  throw new Error(`Unrecognized keyset ID version ${t.slice(0, 2)}`);
};
var Ee = (s, t, e, n) => {
  let r = _.concat(
    _.fromString("Cashu_KDF_HMAC_SHA256"),
    _.fromHex(t),
    _.writeBigUint64BE(BigInt(e))
  );
  switch (n) {
    case 0:
      r = _.concat(r, _.fromHex("00"));
      break;
    case 1:
      r = _.concat(r, _.fromHex("01"));
  }
  return hmac(sha256, s, r);
};
var yt = (s, t, e, n) => {
  const r = HDKey.fromMasterSeed(s), i = vn(t), o = `${Cn}/${i}'/${e}'/${n}`, a = r.derive(o);
  if (a.privateKey === null)
    throw new Error("Could not derive private key");
  return a.privateKey;
};
function On(s, t) {
  if (s.length !== t.length)
    return false;
  for (let e = 0; e < s.length; e++)
    if (s[e] !== t[e])
      return false;
  return true;
}
var Kn = (s, t, e, n) => {
  const r = secp256k1.Point.BASE.multiply(secp256k1.Point.Fn.fromBytes(s.s)), i = n.multiply($(s.e)), o = t.multiply($(s.s)), a = e.multiply($(s.e)), c = r.subtract(i), u = o.subtract(a), l = Ae([c, u, n, e]);
  return On(l, s.e);
};
var Dn = (s, t, e, n) => {
  if (t.r === void 0)
    throw new Error("verifyDLEQProof_reblind: Undefined blinding factor");
  const r = ft(s), i = e.add(n.multiply(t.r)), o = secp256k1.Point.BASE.multiply(t.r), a = r.add(o);
  return Kn(t, a, i, n);
};
var Cs = (s, t) => {
  const e = secp256k1.Point.Fn.fromBytes(ve()), n = secp256k1.Point.BASE.multiply(e), r = s.multiply(e), i = secp256k1.Point.Fn.fromBytes(t), o = s.multiply(i), a = secp256k1.Point.BASE.multiply(i), c = Ae([n, r, a, o]), u = secp256k1.Point.Fn.fromBytes(c), l = secp256k1.Point.Fn.add(e, secp256k1.Point.Fn.mul(u, i));
  return { s: numberToBytesBE(l, 32), e: c };
};
function Se(s, t) {
  let e = s;
  for (const r of t)
    e += r.B_;
  const n = new TextEncoder().encode(e);
  return sha256(n);
}
function qn(s, t, e) {
  const n = Se(t, e), r = hexToBytes(s), i = schnorr.sign(n, r);
  return bytesToHex(i);
}
function xs(s, t, e, n) {
  const r = hexToBytes(n);
  let i = hexToBytes(s);
  if (i.length !== 33)
    return false;
  i = i.slice(1);
  const o = Se(t, e);
  return schnorr.verify(r, o, i);
}
var Ht = class _Ht {
  constructor(t, e, n, r, i, o, a = false, c, u = false) {
    this.transport = t, this.id = e, this.amount = n, this.unit = r, this.mints = i, this.description = o, this.singleUse = a, this.nut10 = c, this.nut26 = u;
  }
  toRawRequest() {
    const t = {};
    return this.transport && (t.t = this.transport.map((e) => ({
      t: e.type,
      a: e.target,
      g: e.tags
    }))), this.id && (t.i = this.id), this.amount && (t.a = this.amount), this.unit && (t.u = this.unit), this.mints && (t.m = this.mints), this.description && (t.d = this.description), this.singleUse && (t.s = this.singleUse), this.nut10 && (t.nut10 = {
      k: this.nut10.kind,
      d: this.nut10.data,
      t: this.nut10.tags
    }), this.nut26 && (t.nut26 = this.nut26), t;
  }
  toEncodedRequest() {
    const t = this.toRawRequest(), e = Rt(t);
    return "creqA" + _.toBase64(e);
  }
  getTransport(t) {
    var _a;
    return (_a = this.transport) == null ? void 0 : _a.find((e) => e.type === t);
  }
  static fromRawRequest(t) {
    const e = t.t ? t.t.map((r) => ({
      type: r.t,
      target: r.a,
      tags: r.g
    })) : void 0, n = t.nut10 ? {
      kind: t.nut10.k,
      data: t.nut10.d,
      tags: t.nut10.t
    } : void 0;
    return new _Ht(
      e,
      t.i,
      t.a,
      t.u,
      t.m,
      t.d,
      t.s,
      n,
      t.nut26
    );
  }
  static fromEncodedRequest(t) {
    if (!t.startsWith("creq"))
      throw new Error("unsupported pr: invalid prefix");
    if (t[4] !== "A")
      throw new Error("unsupported pr version");
    const n = t.slice(5), r = qt(n), i = Ft(r);
    return this.fromRawRequest(i);
  }
};
function G(s, t, e, n) {
  if (e) {
    const i = ee(e);
    if (s === 0 && i === 0)
      return e;
    const o = e.filter((c) => c > 0), a = ee(o);
    if (a > s)
      throw new Error(`Split is greater than total amount: ${a} > ${s}`);
    if (o.some((c) => !Ie(c, t)))
      throw new Error("Provided amount preferences do not match the amounts of the mint keyset.");
    if (a === s)
      return o;
    e = o, s -= a;
  } else
    e = [];
  const r = Te(t, "desc");
  if (!r || r.length === 0)
    throw new Error("Cannot split amount, keyset is inactive or contains no keys");
  for (const i of r) {
    if (i <= 0)
      continue;
    const o = Math.floor(s / i);
    if (e.push(...Array(o).fill(i)), s -= i * o, s === 0)
      break;
  }
  if (s !== 0)
    throw new Error(`Unable to split remaining amount: ${s}`);
  return n ? e.sort((i, o) => n === "desc" ? o - i : i - o) : e;
}
function Un(s, t, e, n) {
  const r = [], i = s.map((c) => c.amount);
  Te(e, "asc").forEach((c) => {
    const u = i.filter((h) => h === c).length, l = Math.max(n - u, 0);
    for (let h = 0; h < l && !(r.reduce((d, p) => d + p, 0) + c > t); ++h)
      r.push(c);
  });
  const a = t - r.reduce((c, u) => c + u, 0);
  return a && G(a, e).forEach((u) => {
    r.push(u);
  }), r.sort((c, u) => c - u);
}
function Te(s, t = "desc") {
  return t == "desc" ? Object.keys(s).map((e) => parseInt(e)).sort((e, n) => n - e) : Object.keys(s).map((e) => parseInt(e)).sort((e, n) => e - n);
}
function Ie(s, t) {
  return s in t;
}
function $(s) {
  return dt(bytesToHex(s));
}
function dt(s) {
  return BigInt(`0x${s}`);
}
function Mt(s) {
  return s.toString(16).padStart(64, "0");
}
function Ct(s) {
  return /^[a-f0-9]*$/i.test(s);
}
function jt(s) {
  return Array.isArray(s) ? s.some((t) => !Ct(t.id)) : !Ct(s.id);
}
function Bs(s, t) {
  return typeof t == "bigint" ? t.toString() : t;
}
function Rn(s, t) {
  jt(s.proofs) || (s.proofs = Me(s.proofs)), t && (s.proofs = Ke(s.proofs));
  const e = { token: [{ mint: s.mint, proofs: s.proofs }] };
  return s.unit && (e.unit = s.unit), s.memo && (e.memo = s.memo), "cashuA" + me(e);
}
function Me(s) {
  return s.map((t) => {
    const e = { ...t };
    return e.id = e.id.slice(0, 16), e;
  });
}
function Os(s, t) {
  if (jt(s.proofs) || (t == null ? void 0 : t.version) === 3) {
    if ((t == null ? void 0 : t.version) === 4)
      throw new Error("can not encode to v4 token if proofs contain non-hex keyset id");
    return Rn(s, t == null ? void 0 : t.removeDleq);
  }
  return Nn(s, t == null ? void 0 : t.removeDleq);
}
function Nn(s, t) {
  if (t && (s.proofs = Ke(s.proofs)), s.proofs.forEach((c) => {
    if (c.dleq && c.dleq.r == null)
      throw new Error("Missing blinding factor in included DLEQ proof");
  }), jt(s.proofs))
    throw new Error("can not encode to v4 token if proofs contain non-hex keyset id");
  s.proofs = Me(s.proofs);
  const n = Ce(s), r = Rt(n), i = "cashu", o = "B", a = It(r);
  return i + o + a;
}
function Ce(s) {
  const t = {}, e = s.mint;
  for (let r = 0; r < s.proofs.length; r++) {
    const i = s.proofs[r];
    t[i.id] ? t[i.id].push(i) : t[i.id] = [i];
  }
  const n = {
    m: e,
    u: s.unit || "sat",
    t: Object.keys(t).map(
      (r) => ({
        i: hexToBytes(r),
        p: t[r].map(
          (i) => ({
            a: i.amount,
            s: i.secret,
            c: hexToBytes(i.C),
            ...i.dleq && {
              d: {
                e: hexToBytes(i.dleq.e),
                s: hexToBytes(i.dleq.s),
                r: hexToBytes(i.dleq.r ?? "00")
              }
            },
            ...i.p2pk_e && {
              pe: hexToBytes(i.p2pk_e)
            },
            ...i.witness && {
              w: JSON.stringify(i.witness)
            }
          })
        )
      })
    )
  };
  return s.memo && (n.d = s.memo), n;
}
function xe(s) {
  const t = [];
  s.t.forEach(
    (n) => n.p.forEach((r) => {
      t.push({
        secret: r.s,
        C: bytesToHex(r.c),
        amount: r.a,
        id: bytesToHex(n.i),
        ...r.d && {
          dleq: {
            r: bytesToHex(r.d.r),
            s: bytesToHex(r.d.s),
            e: bytesToHex(r.d.e)
          }
        },
        ...r.pe && {
          p2pk_e: bytesToHex(r.pe)
        },
        ...r.w && {
          witness: r.w
        }
      });
    })
  );
  const e = { mint: s.m, proofs: t, unit: s.u || "sat" };
  return s.d && (e.memo = s.d), e;
}
function Fn(s, t) {
  const e = qe(s), n = Be(e);
  return n.proofs = Wn(n.proofs, t), n;
}
function Ks(s) {
  s = qe(s);
  const t = Be(s);
  return {
    unit: t.unit || "sat",
    mint: t.mint,
    amount: rt(t.proofs),
    ...t.memo && { memo: t.memo },
    incompleteProofs: t.proofs.map((e) => ({
      secret: e.secret,
      C: e.C,
      amount: e.amount,
      ...e.dleq && {
        dleq: e.dleq
      },
      ...e.witness && {
        witness: e.witness
      }
    }))
  };
}
function Be(s) {
  const t = s.slice(0, 1), e = s.slice(1);
  if (t === "A") {
    const n = Ve(e);
    if (n.token.length > 1)
      throw new Error("Multi entry token are not supported");
    const r = n.token[0], i = {
      mint: r.mint,
      proofs: r.proofs,
      unit: n.unit || "sat"
    };
    return n.memo && (i.memo = n.memo), i;
  } else if (t === "B") {
    const n = qt(e), r = Ft(n);
    return xe(r);
  }
  throw new Error("Token version is not supported");
}
function Qt(s, t, e, n = 0, r = false) {
  if (r) {
    const c = Object.entries(s).sort((h, d) => +h[0] - +d[0]).map(([, h]) => h).reduce((h, d) => h + d, ""), u = sha256(c);
    return _.toBase64(u).slice(0, 12);
  }
  let i = Object.entries(s).sort((c, u) => +c[0] - +u[0]).map(([, c]) => hexToBytes(c)).reduce((c, u) => Pt(c, u), new Uint8Array()), o, a;
  switch (n) {
    case 0:
      return o = sha256(i), a = _.toHex(o).slice(0, 14), "00" + a;
    case 1:
      if (!t)
        throw new Error("Cannot compute keyset ID version 01: unit is required.");
      return i = Pt(i, _.fromString("unit:" + t)), e && (i = Pt(
        i,
        _.fromString("final_expiry:" + e.toString())
      )), o = sha256(i), a = _.toHex(o), "01" + a;
    default:
      throw new Error(`Unrecognized keyset ID version: ${n}`);
  }
}
function Pt(s, t) {
  const e = new Uint8Array(s.length + t.length);
  return e.set(s), e.set(t, s.length), e;
}
function Ds(s) {
  return s.sort((t, e) => t.id.localeCompare(e.id));
}
function T(s) {
  return typeof s == "object";
}
function qs(s) {
  if (T(s)) {
    if ("error" in s && s.error)
      throw new Error(s.error);
    if ("detail" in s && s.detail)
      throw new Error(s.detail);
  }
}
function W(...s) {
  return s.map((t) => t.replace(/(^\/+|\/+$)/g, "")).join("/");
}
function Oe(s) {
  return s.replace(/\/$/, "");
}
function rt(s) {
  return s.reduce((t, e) => t + e.amount, 0);
}
function Us(s) {
  return Ht.fromEncodedRequest(s);
}
var Ln = class {
  get value() {
    return this._value;
  }
  set value(t) {
    this._value = t;
  }
  get next() {
    return this._next;
  }
  set next(t) {
    this._next = t;
  }
  constructor(t) {
    this._value = t, this._next = null;
  }
};
var $n = class {
  get first() {
    return this._first;
  }
  set first(t) {
    this._first = t;
  }
  get last() {
    return this._last;
  }
  set last(t) {
    this._last = t;
  }
  get size() {
    return this._size;
  }
  set size(t) {
    this._size = t;
  }
  constructor() {
    this._first = null, this._last = null, this._size = 0;
  }
  enqueue(t) {
    const e = new Ln(t);
    return this._size === 0 || !this._last ? (this._first = e, this._last = e) : (this._last.next = e, this._last = e), this._size++, true;
  }
  dequeue() {
    if (this._size === 0 || !this._first)
      return null;
    const t = this._first;
    return this._first = t.next, t.next = null, this._size--, t.value;
  }
};
function Ke(s) {
  return s.map((t) => {
    const e = { ...t };
    return delete e.dleq, e;
  });
}
function Rs(s) {
  const t = Ut(s.id), e = /^[a-fA-F0-9]+$/.test(s.id), n = e ? hexToBytes(s.id)[0] : 0;
  return Qt(
    s.keys,
    s.unit,
    s.final_expiry,
    n,
    t && !e
  ) === s.id;
}
function Wn(s, t) {
  const e = [];
  for (const n of s) {
    let r;
    try {
      r = hexToBytes(n.id);
    } catch {
      e.push(n);
      continue;
    }
    if (r[0] === 0)
      e.push(n);
    else if (r[0] === 1) {
      if (!t)
        throw new Error("A short keyset ID v2 was encountered, but got no keysets to map it to.");
      let i = false;
      for (const o of t)
        if (n.id === o.id.slice(0, n.id.length)) {
          n.id = o.id, e.push(n), i = true;
          break;
        }
      if (!i)
        throw new Error(
          `Couldn't map short keyset ID ${n.id} to any known keysets of the current Mint`
        );
    } else
      throw new Error(`Unknown keyset ID version: ${r[0]}`);
  }
  return e;
}
function De(s, t) {
  if (s.dleq == null)
    return false;
  const e = {
    e: hexToBytes(s.dleq.e),
    s: hexToBytes(s.dleq.s),
    r: dt(s.dleq.r ?? "00")
  };
  if (!Ie(s.amount, t.keys))
    throw new Error(`undefined key for amount ${s.amount}`);
  const n = t.keys[s.amount];
  return Dn(
    new TextEncoder().encode(s.secret),
    e,
    X(s.C),
    X(n)
  );
}
function Hn(...s) {
  const t = s.reduce((r, i) => r + i.length, 0), e = new Uint8Array(t);
  let n = 0;
  for (let r = 0; r < s.length; r++)
    e.set(s[r], n), n = n + s[r].length;
  return e;
}
function Ns(s) {
  const t = new TextEncoder(), e = Ce(s), n = Rt(e), r = t.encode("craw"), i = t.encode("B");
  return Hn(r, i, n);
}
function Fs(s) {
  const t = new TextDecoder(), e = t.decode(s.slice(0, 4)), n = t.decode(new Uint8Array([s[4]]));
  if (e !== "craw" || n !== "B")
    throw new Error("not a valid binary token");
  const r = s.slice(5), i = Ft(r);
  return xe(i);
}
function ee(s) {
  return s.reduce((t, e) => t + e, 0);
}
function ne(s, t) {
  if (s === t)
    return true;
  if (s == null || t == null || typeof s != "object" || typeof t != "object")
    return false;
  if (Array.isArray(s) && Array.isArray(t))
    return s.length !== t.length ? false : s.every((r, i) => ne(r, t[i]));
  if (Array.isArray(s) || Array.isArray(t))
    return false;
  const e = Object.keys(s), n = Object.keys(t);
  return e.length !== n.length ? false : e.every((r) => n.includes(r) && ne(s[r], t[r]));
}
function qe(s) {
  return ["web+cashu://", "cashu://", "cashu:", "cashu"].forEach((e) => {
    s.startsWith(e) && (s = s.slice(e.length));
  }), s;
}
var it = class _it {
  constructor() {
    this.connectionMap = /* @__PURE__ */ new Map();
  }
  static getInstance() {
    return _it.instance || (_it.instance = new _it()), _it.instance;
  }
  getConnection(t, e) {
    if (this.connectionMap.has(t))
      return this.connectionMap.get(t);
    const n = new jn(t, e);
    return this.connectionMap.set(t, n), n;
  }
};
var jn = class {
  constructor(t, e) {
    this.subListeners = {}, this.rpcListeners = {}, this.rpcId = 0, this.onCloseCallbacks = [], this._WS = ze(), this.url = new URL(t), this.messageQueue = new $n(), this._logger = e ?? L;
  }
  connect() {
    return this.connectionPromise || (this.connectionPromise = new Promise((t, e) => {
      try {
        this.ws = new this._WS(this.url.toString()), this.onCloseCallbacks = [];
      } catch (n) {
        e(n instanceof Error ? n : new Error(String(n)));
        return;
      }
      this.ws.onopen = () => {
        t();
      }, this.ws.onerror = () => {
        e(new Error("Failed to open WebSocket"));
      }, this.ws.onmessage = (n) => {
        this.messageQueue.enqueue(n.data), this.handlingInterval || (this.handlingInterval = setInterval(
          this.handleNextMessage.bind(this),
          0
        ));
      }, this.ws.onclose = (n) => {
        this.connectionPromise = void 0, this.onCloseCallbacks.forEach((r) => r(n));
      };
    })), this.connectionPromise;
  }
  sendRequest(t, e) {
    var _a, _b;
    if (((_a = this.ws) == null ? void 0 : _a.readyState) !== 1) {
      if (t === "unsubscribe")
        return;
      throw this._logger.error("Attempted sendRequest, but socket was not open"), new Error("Socket not open");
    }
    const n = this.rpcId;
    this.rpcId++;
    const r = JSON.stringify({ jsonrpc: "2.0", method: t, params: e, id: n });
    (_b = this.ws) == null ? void 0 : _b.send(r);
  }
  /**
   * @deprecated Use cancelSubscription for JSONRPC compliance.
   */
  closeSubscription(t) {
    var _a;
    (_a = this.ws) == null ? void 0 : _a.send(JSON.stringify(["CLOSE", t]));
  }
  addSubListener(t, e) {
    (this.subListeners[t] = this.subListeners[t] || []).push(
      e
    );
  }
  addRpcListener(t, e, n) {
    this.rpcListeners[n] = { callback: t, errorCallback: e };
  }
  removeRpcListener(t) {
    delete this.rpcListeners[t];
  }
  removeListener(t, e) {
    if (this.subListeners[t]) {
      if (this.subListeners[t].length === 1) {
        delete this.subListeners[t];
        return;
      }
      this.subListeners[t] = this.subListeners[t].filter(
        (n) => n !== e
      );
    }
  }
  async ensureConnection() {
    var _a;
    ((_a = this.ws) == null ? void 0 : _a.readyState) !== 1 && await this.connect();
  }
  handleNextMessage() {
    var _a, _b;
    if (this.messageQueue.size === 0) {
      clearInterval(this.handlingInterval), this.handlingInterval = void 0;
      return;
    }
    const t = this.messageQueue.dequeue();
    let e;
    try {
      if (e = JSON.parse(t), "result" in e && e.id != null)
        this.rpcListeners[e.id] && (this.rpcListeners[e.id].callback(), this.removeRpcListener(e.id));
      else if ("error" in e && e.id != null)
        this.rpcListeners[e.id] && (this.rpcListeners[e.id].errorCallback(new Error(e.error.message)), this.removeRpcListener(e.id));
      else if ("method" in e && !("id" in e)) {
        const n = (_a = e.params) == null ? void 0 : _a.subId;
        if (!n)
          return;
        if (((_b = this.subListeners[n]) == null ? void 0 : _b.length) > 0) {
          const r = e;
          this.subListeners[n].forEach((i) => {
            var _a2;
            return i((_a2 = r.params) == null ? void 0 : _a2.payload);
          });
        }
      }
    } catch (n) {
      this._logger.error("Error doing handleNextMessage", { e: n });
      return;
    }
  }
  createSubscription(t, e, n) {
    var _a;
    if (((_a = this.ws) == null ? void 0 : _a.readyState) !== 1)
      throw this._logger.error("Attempted createSubscription, but socket was not open"), new Error("Socket is not open");
    const r = (Math.random() + 1).toString(36).substring(7);
    return this.addRpcListener(
      () => {
        this.addSubListener(r, e);
      },
      n,
      this.rpcId
    ), this.sendRequest("subscribe", { ...t, subId: r }), this.rpcId++, r;
  }
  /**
   * Cancels a subscription, sending an unsubscribe request and handling responses.
   *
   * @param subId The subscription ID to cancel.
   * @param callback The original payload callback to remove.
   * @param errorCallback Optional callback for unsubscribe errors (defaults to logging).
   */
  cancelSubscription(t, e, n) {
    this.removeListener(t, e), this.addRpcListener(
      () => {
        this._logger.info("Unsubscribed {subId}", { subId: t });
      },
      n || ((r) => this._logger.error("Unsubscribe failed", { e: r })),
      this.rpcId
    ), this.sendRequest("unsubscribe", { subId: t });
  }
  get activeSubscriptions() {
    return Object.keys(this.subListeners);
  }
  close() {
    var _a;
    this.ws && ((_a = this.ws) == null ? void 0 : _a.close());
  }
  onClose(t) {
    this.onCloseCallbacks.push(t);
  }
};
function At(s, t) {
  return s.state || (t.warn(
    "Field 'state' not found in MeltQuoteResponse. Update NUT-05 of mint: https://github.com/cashubtc/nuts/pull/136)"
  ), typeof s.paid == "boolean" && (s.state = s.paid ? ut.PAID : ut.UNPAID)), s;
}
function se(s, t) {
  return s.state || (t.warn(
    "Field 'state' not found in MintQuoteResponse. Update NUT-04 of mint: https://github.com/cashubtc/nuts/pull/141)"
  ), typeof s.paid == "boolean" && (s.state = s.paid ? Tt.PAID : Tt.UNPAID)), s;
}
function Qn(s, t) {
  return Array.isArray(s == null ? void 0 : s.contact) && (s == null ? void 0 : s.contact.length) > 0 && (s.contact = s.contact.map((e) => Array.isArray(e) && e.length === 2 && typeof e[0] == "string" && typeof e[1] == "string" ? (t.warn(
    "Mint returned deprecated 'contact' field: Update NUT-06: https://github.com/cashubtc/nuts/pull/117"
  ), { method: e[0], info: e[1] }) : e)), s;
}
var wt = class {
  constructor(t) {
    var _a, _b, _c, _d;
    this.REGEX_METACHAR = /[\\^$.*+?()[\]{}|]/, this._mintInfo = t;
    const e = this.toEndpoints((_b = (_a = t == null ? void 0 : t.nuts) == null ? void 0 : _a[22]) == null ? void 0 : _b.protected_endpoints);
    this._protected22 = this.buildIndex(e);
    const n = this.toEndpoints((_d = (_c = t == null ? void 0 : t.nuts) == null ? void 0 : _c[21]) == null ? void 0 : _d.protected_endpoints);
    this._protected21 = this.buildIndex(n);
  }
  isSupported(t) {
    switch (t) {
      case 4:
      case 5:
        return this.checkMintMelt(t);
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 14:
      case 20:
        return this.checkGenericNut(t);
      case 17:
        return this.checkNut17();
      case 15:
        return this.checkNut15();
      default:
        throw new Error("nut is not supported by cashu-ts");
    }
  }
  requiresBlindAuthToken(t, e) {
    return this.matchesProtected(this._protected22, t, e);
  }
  requiresClearAuthToken(t, e) {
    return this.matchesProtected(this._protected21, t, e);
  }
  matchesProtected(t, e, n) {
    if (!t)
      return false;
    const r = `${e} ${n}`, i = t.cache[r];
    if (typeof i == "boolean")
      return i;
    const o = t.exact.some((u) => u.method === e && u.path === n), a = o ? false : t.regex.some((u) => u.method === e && u.regex.test(n)), c = o || a;
    return t.cache[r] = c, c;
  }
  checkGenericNut(t) {
    var _a;
    return ((_a = this._mintInfo.nuts[t]) == null ? void 0 : _a.supported) ? { supported: true } : { supported: false };
  }
  checkMintMelt(t) {
    const e = this._mintInfo.nuts[t];
    return e && e.methods.length > 0 && !e.disabled ? { disabled: false, params: e.methods } : { disabled: true, params: (e == null ? void 0 : e.methods) ?? [] };
  }
  checkNut17() {
    return this._mintInfo.nuts[17] && this._mintInfo.nuts[17].supported.length > 0 ? { supported: true, params: this._mintInfo.nuts[17].supported } : { supported: false };
  }
  checkNut15() {
    return this._mintInfo.nuts[15] && this._mintInfo.nuts[15].methods.length > 0 ? { supported: true, params: this._mintInfo.nuts[15].methods } : { supported: false };
  }
  // ---------- private helpers ----------
  toEndpoints(t) {
    if (!Array.isArray(t))
      return [];
    const e = [];
    for (const n of t)
      if (n && typeof n == "object") {
        const r = n, i = r.method, o = r.path;
        if (typeof i == "string" && typeof o == "string") {
          const a = i.toUpperCase();
          (a === "GET" || a === "POST") && e.push({ method: a, path: o });
        }
      }
    return e;
  }
  buildIndex(t) {
    if (!t || t.length === 0)
      return;
    const e = [], n = [], r = this.REGEX_METACHAR;
    for (const o of t) {
      if (o.path.startsWith("^") || o.path.endsWith("$") || r.test(o.path))
        try {
          n.push({ method: o.method, regex: new RegExp(o.path) });
          continue;
        } catch {
        }
      e.push({ method: o.method, path: o.path });
    }
    return { cache: {}, exact: e, regex: n };
  }
  // ---------- getters ----------
  get contact() {
    return this._mintInfo.contact;
  }
  get description() {
    return this._mintInfo.description;
  }
  get description_long() {
    return this._mintInfo.description_long;
  }
  get name() {
    return this._mintInfo.name;
  }
  get pubkey() {
    return this._mintInfo.pubkey;
  }
  get nuts() {
    return this._mintInfo.nuts;
  }
  get version() {
    return this._mintInfo.version;
  }
  get motd() {
    return this._mintInfo.motd;
  }
  /**
   * @deprecated Use supportsNut04Description(method, unit)
   */
  get supportsBolt12Description() {
    return this.supportsNut04Description("bolt12");
  }
  /**
   * Checks if the mint supports creating invoices/offers with a description for the specified
   * payment method.
   *
   * @param method - The payment method to check ('bolt11' or 'bolt12')
   * @returns True if the mint supports description for the method, false otherwise.
   */
  supportsNut04Description(t, e) {
    var _a;
    return (_a = this._mintInfo.nuts[4]) == null ? void 0 : _a.methods.some(
      (n) => {
        var _a2;
        return n.method === t && (e ? n.unit === e : true) && (((_a2 = n.options) == null ? void 0 : _a2.description) === true || n.description === true);
      }
    );
  }
};
var zt = class _zt {
  constructor(t, e) {
    this.tokenListeners = [], this.discoveryUrl = t, this.logger = (e == null ? void 0 : e.logger) ?? L, this.clientId = (e == null ? void 0 : e.clientId) ?? "cashu-client", this.scope = (e == null ? void 0 : e.scope) ?? "openid", this.onTokens = e == null ? void 0 : e.onTokens;
  }
  static fromMintInfo(t, e) {
    var _a;
    const n = (_a = t == null ? void 0 : t.nuts) == null ? void 0 : _a["21"];
    if (!(n == null ? void 0 : n.openid_discovery))
      throw new Error("OIDCAuth: mint does not advertise NUT-21 openid_discovery");
    const r = (e == null ? void 0 : e.clientId) ?? n.client_id ?? "cashu-client";
    return new _zt(n.openid_discovery, { ...e, clientId: r });
  }
  setClient(t) {
    this.clientId = t;
  }
  setScope(t) {
    this.scope = t ?? "openid";
  }
  /**
   * Subscribe to token updates. Listeners are called after the primary onTokens callback.
   */
  addTokenListener(t) {
    this.tokenListeners.push(t);
  }
  // ---- Discovery ----
  async loadConfig() {
    if (this.config)
      return this.config;
    const t = await fetch(this.discoveryUrl, {
      method: "GET",
      headers: { Accept: "application/json" }
    }), e = await t.text();
    let n;
    try {
      n = e ? JSON.parse(e) : void 0;
    } catch (i) {
      this.logger.warn("OIDCAuth: bad discovery JSON", { err: i });
    }
    if (!t.ok || !n)
      throw new Error("OIDCAuth: invalid discovery document");
    const r = n;
    if (typeof r.token_endpoint != "string" || r.token_endpoint.length === 0)
      throw new Error("OIDCAuth: invalid discovery document, missing token_endpoint");
    return this.config = r, r;
  }
  // --- Authorization Code with PKCE ---
  /**
   * Generate a PKCE verifier and S256 challenge.
   *
   * - Verifier: base64url of random bytes, length >= 43, RFC 7636 compliant.
   * - Challenge: base64url(sha256(verifier))
   */
  generatePKCE() {
    const t = randomBytes(48), e = It(t), n = _.fromString(e), r = sha256(n), i = It(r);
    return { verifier: e, challenge: i };
  }
  /**
   * Build an Authorization Code + PKCE URL.
   */
  async buildAuthCodeUrl(t) {
    const e = await this.loadConfig(), n = t.scope ?? this.scope, r = new URLSearchParams({
      response_type: "code",
      client_id: this.clientId,
      redirect_uri: t.redirectUri,
      scope: n,
      code_challenge_method: t.codeChallengeMethod ?? "S256",
      code_challenge: t.codeChallenge
    });
    if (t.state && r.set("state", t.state), !e.authorization_endpoint)
      throw new Error("OIDCAuth: discovery lacks authorization_endpoint");
    return `${e.authorization_endpoint}?${r.toString()}`;
  }
  /**
   * Exchange an auth code for tokens, using the PKCE verifier.
   */
  async exchangeAuthCode(t) {
    const e = await this.loadConfig(), n = this.toForm({
      grant_type: "authorization_code",
      code: t.code,
      redirect_uri: t.redirectUri,
      client_id: this.clientId,
      code_verifier: t.codeVerifier
    }), r = await this.postFormStrict(e.token_endpoint, n);
    return this.handleTokens(r), r;
  }
  // ---- Device Code (recommended for CLIs) ----
  async deviceStart() {
    const e = (await this.loadConfig()).device_authorization_endpoint;
    if (!e)
      throw new Error("OIDCAuth: provider lacks device_authorization_endpoint");
    const n = this.toForm({ client_id: this.clientId, scope: this.scope });
    return this.postFormStrict(e, n);
  }
  async devicePoll(t, e = 5) {
    const n = await this.loadConfig();
    let r = Math.max(1, e);
    for (; ; ) {
      await this.sleep(r * 1e3);
      const i = this.toForm({
        grant_type: "urn:ietf:params:oauth:grant-type:device_code",
        device_code: t,
        client_id: this.clientId
      }), o = await this.postFormLoose(n.token_endpoint, i);
      if (o.access_token)
        return this.handleTokens(o), o;
      const a = (o.error ?? "").toString();
      if (a === "authorization_pending")
        continue;
      if (a === "slow_down") {
        r = Math.max(r + 5, r * 2);
        continue;
      }
      const c = o.error_description || a || "device authorization failed";
      throw new Error(`OIDCAuth: ${c}`);
    }
  }
  /**
   * One call convenience for Device Code flow.
   *
   * @remarks
   * Polling interval will be the MAX of intervalSec and Mint interval.
   * @param intervalSec Desired polling interval in seconds.
   * @returns The start fields and helpers to poll or cancel.
   */
  async startDeviceAuth(t = 5) {
    const e = await this.deviceStart(), n = Math.max(e.interval ?? 1, t);
    let r = false;
    return { ...e, poll: async () => {
      const a = await this.loadConfig();
      let c = Math.max(1, n);
      for (; ; ) {
        if (r)
          throw new Error("OIDCAuth: device polling cancelled");
        await this.sleep(c * 1e3);
        const u = this.toForm({
          grant_type: "urn:ietf:params:oauth:grant-type:device_code",
          device_code: e.device_code,
          client_id: this.clientId
        }), l = await this.postFormLoose(a.token_endpoint, u);
        if (l.access_token)
          return this.handleTokens(l), l;
        const h = (l.error ?? "").toString();
        if (h === "authorization_pending")
          continue;
        if (h === "slow_down") {
          c = Math.max(c + 5, c * 2);
          continue;
        }
        const d = l.error_description || h || "device authorization failed";
        throw new Error(`OIDCAuth: ${d}`);
      }
    }, cancel: () => {
      r = true;
    } };
  }
  // ---- Refresh ----
  async refresh(t) {
    const e = await this.loadConfig(), n = this.toForm({
      grant_type: "refresh_token",
      refresh_token: t,
      client_id: this.clientId
    }), r = await this.postFormStrict(e.token_endpoint, n);
    return this.handleTokens(r), r;
  }
  // ---- ROPC (discouraged, but some mints allow it) ----
  async passwordGrant(t, e) {
    const n = await this.loadConfig(), r = this.toForm({
      grant_type: "password",
      client_id: this.clientId,
      username: t,
      password: e,
      scope: this.scope
    }), i = await this.postFormStrict(n.token_endpoint, r);
    return this.handleTokens(i), i;
  }
  // ---- internals ----
  /**
   * Fire and forget token fan out. Any listener errors are logged inside safeCallback. Nothing
   * thrown here will come from listeners.
   */
  handleTokens(t) {
    if (!t.access_token) {
      const e = t.error_description || t.error || "token response missing access_token";
      throw new Error(`OIDCAuth: ${e}`);
    }
    queueMicrotask(
      () => lt(this.onTokens, t, this.logger, { where: "OIDCAuth.handleTokens" })
    );
    for (const e of this.tokenListeners)
      queueMicrotask(
        () => lt(e, t, this.logger, {
          where: "OIDCAuth.handleTokens.listener"
        })
      );
  }
  toForm(t) {
    const e = (n) => encodeURIComponent(n).replace(/%20/g, "+");
    return Object.entries(t).map(([n, r]) => `${e(n)}=${e(r)}`).join("&");
  }
  // Strict, throws on non 2xx
  async postFormStrict(t, e) {
    try {
      this.logger.debug("OIDCAuth Request", { formBody: e });
      const n = await fetch(t, {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          Accept: "application/json"
        },
        body: e
      }), r = await n.text();
      let i;
      try {
        i = r ? JSON.parse(r) : void 0;
      } catch (o) {
        this.logger.warn("OIDCAuth: bad JSON (strict)", { err: o });
      }
      if (!n.ok) {
        const o = i ?? {}, a = o.error_description || o.error || `HTTP ${n.status}`;
        throw new Error(`OIDCAuth: ${a}`);
      }
      return this.logger.debug("OIDCAuth Response", { json: i }), i ?? {};
    } catch (n) {
      throw this.logger.error("OIDCAuth: postFormStrict failed", { err: n }), n;
    }
  }
  // Loose, returns JSON payload even on non 2xx
  async postFormLoose(t, e) {
    try {
      this.logger.debug("OIDCAuth Request", { formBody: e });
      const r = await (await fetch(t, {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          Accept: "application/json"
        },
        body: e
      })).text();
      let i;
      try {
        i = r ? JSON.parse(r) : void 0;
      } catch (o) {
        this.logger.warn("OIDCAuth: bad JSON (loose)", { err: o });
      }
      return this.logger.debug("OIDCAuth Response", { json: i }), i ?? {};
    } catch (n) {
      return this.logger.error("OIDCAuth: postFormLoose network error", { err: n }), { error: "network_error", error_description: String(n) };
    }
  }
  sleep(t) {
    return new Promise((e) => setTimeout(e, t));
  }
};
var Vt = class {
  /**
   * @param mintUrl Requires mint URL to create this object.
   * @param customRequest Optional, for custom network communication with the mint.
   * @param authTokenGetter Optional. Function to obtain a NUT-22 BlindedAuthToken (e.g. from a
   *   database or localstorage)
   */
  constructor(t, e) {
    this._mintUrl = Oe(t), this._request = (e == null ? void 0 : e.customRequest) ?? pe, this._authProvider = e == null ? void 0 : e.authProvider, this._logger = (e == null ? void 0 : e.logger) ?? L, je(this._logger);
  }
  get mintUrl() {
    return this._mintUrl;
  }
  /**
   * Create an OIDC client using this mint‚Äôs NUT-21 metadata.
   *
   * @example
   *
   * ```ts
   * const oidc = await mint.oidcAuth({ onTokens: (t) => authMgr.setCAT(t.access_token!) });
   * const start = await oidc.deviceStart();
   * // show start.user_code / start.verification_uri to the user
   * const token = await oidc.devicePoll(start.device_code, start.interval ?? 5);
   * // token.access_token is your CAT
   * ```
   */
  async oidcAuth(t) {
    const e = (await this.getLazyMintInfo()).nuts[21];
    if (!(e == null ? void 0 : e.openid_discovery))
      throw new Error("Mint: no NUT-21 openid_discovery");
    return new zt(e.openid_discovery, {
      ...t,
      clientId: (t == null ? void 0 : t.clientId) ?? e.client_id ?? "cashu-client"
    });
  }
  /**
   * Fetches mint's info at the /info endpoint.
   *
   * @param customRequest Optional override for the request function.
   * @returns The mint's information response.
   */
  async getInfo(t) {
    const n = await (t ?? this._request)({
      endpoint: W(this._mintUrl, "/v1/info")
    });
    return Qn(n, this._logger);
  }
  /**
   * Lazily fetches and caches the mint's info if not already loaded.
   *
   * @returns The parsed MintInfo object.
   */
  async getLazyMintInfo() {
    if (this._mintInfo)
      return this._mintInfo;
    const t = await this.getInfo();
    return this._mintInfo = new wt(t), this._mintInfo;
  }
  /**
   * Performs a swap operation with ecash inputs and outputs.
   *
   * @param swapPayload Payload containing inputs and outputs.
   * @param customRequest Optional override for the request function.
   * @returns Signed outputs.
   */
  async swap(t, e) {
    const n = await this.requestWithAuth(
      "POST",
      "/v1/swap",
      { requestBody: t },
      e
    );
    if (!T(n) || !Array.isArray(n == null ? void 0 : n.signatures)) {
      const r = T(n) && "detail" in n ? n.detail : void 0;
      throw new Error(r ?? "bad response");
    }
    return n;
  }
  /**
   * Requests a new mint quote from the mint.
   *
   * @param mintQuotePayload Payload for creating a new mint quote.
   * @param customRequest Optional override for the request function.
   * @returns A new mint quote containing a payment request for the specified amount and unit.
   */
  async createMintQuoteBolt11(t, e) {
    const n = await this.requestWithAuth("POST", "/v1/mint/quote/bolt11", { requestBody: t }, e);
    return se(n, this._logger);
  }
  /**
   * Requests a new BOLT12 mint quote from the mint using Lightning Network offers.
   *
   * @param mintQuotePayload Payload containing amount, unit, optional description, and required
   *   pubkey.
   * @param customRequest Optional override for the request function.
   * @returns A mint quote containing a BOLT12 offer.
   */
  async createMintQuoteBolt12(t, e) {
    return await this.requestWithAuth(
      "POST",
      "/v1/mint/quote/bolt12",
      { requestBody: t },
      e
    );
  }
  /**
   * Gets an existing mint quote from the mint.
   *
   * @param quote Quote ID.
   * @param customRequest Optional override for the request function.
   * @returns The status of the mint quote, including payment details and state.
   */
  async checkMintQuoteBolt11(t, e) {
    const n = await this.requestWithAuth("GET", `/v1/mint/quote/bolt11/${t}`, {}, e);
    return se(n, this._logger);
  }
  /**
   * Gets an existing BOLT12 mint quote from the mint.
   *
   * @param quote Quote ID to check.
   * @param customRequest Optional override for the request function.
   * @returns Updated quote with current payment and issuance amounts.
   */
  async checkMintQuoteBolt12(t, e) {
    return await this.requestWithAuth(
      "GET",
      `/v1/mint/quote/bolt12/${t}`,
      {},
      e
    );
  }
  /**
   * Mints new tokens by requesting blind signatures on the provided outputs.
   *
   * @param mintPayload Payload containing the outputs to get blind signatures on.
   * @param customRequest Optional override for the request function.
   * @returns Serialized blinded signatures.
   */
  async mintBolt11(t, e) {
    const n = await this.requestWithAuth(
      "POST",
      "/v1/mint/bolt11",
      { requestBody: t },
      e
    );
    if (!T(n) || !Array.isArray(n == null ? void 0 : n.signatures)) {
      const r = T(n) && "detail" in n ? n.detail : void 0;
      throw new Error(r ?? "bad response");
    }
    return n;
  }
  /**
   * Mints new tokens using a BOLT12 quote by requesting blind signatures on the provided outputs.
   *
   * @param mintPayload Payload containing the quote ID and outputs to get blind signatures on.
   * @param customRequest Optional override for the request function.
   * @returns Serialized blinded signatures for the requested outputs.
   */
  async mintBolt12(t, e) {
    const n = await this.requestWithAuth(
      "POST",
      "/v1/mint/bolt12",
      { requestBody: t },
      e
    );
    if (!T(n) || !Array.isArray(n == null ? void 0 : n.signatures)) {
      const r = T(n) && "detail" in n ? n.detail : void 0;
      throw new Error(r ?? "bad response");
    }
    return n;
  }
  /**
   * Requests a new melt quote from the mint.
   *
   * @param meltQuotePayload Payload for creating a new melt quote.
   * @param customRequest Optional override for the request function.
   * @returns The melt quote response.
   */
  async createMeltQuoteBolt11(t, e) {
    const n = await this.requestWithAuth("POST", "/v1/melt/quote/bolt11", { requestBody: t }, e), r = At(n, this._logger);
    if (!T(r) || typeof (r == null ? void 0 : r.amount) != "number" || typeof (r == null ? void 0 : r.fee_reserve) != "number" || typeof (r == null ? void 0 : r.quote) != "string") {
      const i = T(r) && "detail" in r ? r.detail : void 0;
      throw new Error(i ?? "bad response");
    }
    return r;
  }
  /**
   * Requests a new BOLT12 melt quote from the mint for paying a Lightning Network offer. For
   * amount-less offers, specify the amount in options.amountless.amount_msat.
   *
   * @param meltQuotePayload Payload containing the BOLT12 offer to pay and unit.
   * @param customRequest Optional override for the request function.
   * @returns Melt quote with amount, fee reserve, and payment state.
   */
  async createMeltQuoteBolt12(t, e) {
    return await this.requestWithAuth(
      "POST",
      "/v1/melt/quote/bolt12",
      { requestBody: t },
      e
    );
  }
  /**
   * Gets an existing melt quote.
   *
   * @param quote Quote ID.
   * @param customRequest Optional override for the request function.
   * @returns The melt quote response.
   */
  async checkMeltQuoteBolt11(t, e) {
    const n = await this.requestWithAuth("GET", `/v1/melt/quote/bolt11/${t}`, {}, e), r = At(n, this._logger);
    if (!T(r) || typeof (r == null ? void 0 : r.amount) != "number" || typeof (r == null ? void 0 : r.fee_reserve) != "number" || typeof (r == null ? void 0 : r.quote) != "string" || typeof (r == null ? void 0 : r.state) != "string" || !Object.values(ut).includes(r.state)) {
      const i = T(r) && "detail" in r ? r.detail : void 0;
      throw new Error(i ?? "bad response");
    }
    return r;
  }
  /**
   * Gets an existing BOLT12 melt quote from the mint. Returns current payment state (UNPAID,
   * PENDING, or PAID) and payment preimage if paid.
   *
   * @param quote Quote ID to check.
   * @param customRequest Optional override for the request function.
   * @returns Updated quote with current payment state and preimage if available.
   */
  async checkMeltQuoteBolt12(t, e) {
    return await this.requestWithAuth(
      "GET",
      `/v1/melt/quote/bolt12/${t}`,
      {},
      e
    );
  }
  /**
   * Requests the mint to pay for a Bolt11 payment request by providing ecash as inputs to be spent.
   * The inputs contain the amount and the fee_reserves for a Lightning payment. The payload can
   * also contain blank outputs in order to receive back overpaid Lightning fees.
   *
   * @param meltPayload The melt payload containing inputs and optional outputs.
   * @param options.customRequest Optional override for the request function.
   * @param options.preferAsync Optional override to set 'respond-async' header.
   * @returns The melt response.
   */
  async meltBolt11(t, e) {
    const n = {
      ...(e == null ? void 0 : e.preferAsync) ? { Prefer: "respond-async" } : {}
    }, r = await this.requestWithAuth(
      "POST",
      "/v1/melt/bolt11",
      {
        requestBody: t,
        headers: n
      },
      e == null ? void 0 : e.customRequest
    ), i = At(r, this._logger);
    if (!T(i) || typeof (i == null ? void 0 : i.state) != "string" || !Object.values(ut).includes(i.state)) {
      const o = T(i) && "detail" in i ? i.detail : void 0;
      throw new Error(o ?? "bad response");
    }
    return i;
  }
  /**
   * Requests the mint to pay a BOLT12 offer by providing ecash inputs to be spent. The inputs must
   * cover the amount plus fee reserves. Optional outputs can be included to receive change for
   * overpaid Lightning fees.
   *
   * @param meltPayload Payload containing quote ID, inputs, and optional outputs for change.
   * @param options.customRequest Optional override for the request function.
   * @param options.preferAsync Optional override to set 'respond-async' header.
   * @returns Payment result with state and optional change signatures.
   */
  async meltBolt12(t, e) {
    const n = {
      ...(e == null ? void 0 : e.preferAsync) ? { Prefer: "respond-async" } : {}
    };
    return await this.requestWithAuth(
      "POST",
      "/v1/melt/bolt12",
      {
        requestBody: t,
        headers: n
      },
      e == null ? void 0 : e.customRequest
    );
  }
  /**
   * Checks if specific proofs have already been redeemed.
   *
   * @param checkPayload The payload containing proofs to check.
   * @param customRequest Optional override for the request function.
   * @returns Redeemed and unredeemed ordered list of booleans.
   */
  async check(t, e) {
    const n = await this.requestWithAuth(
      "POST",
      "/v1/checkstate",
      { requestBody: t },
      e
    );
    if (!T(n) || !Array.isArray(n == null ? void 0 : n.states)) {
      const r = T(n) && "detail" in n ? n.detail : void 0;
      throw new Error(r ?? "bad response");
    }
    return n;
  }
  /**
   * Get the mint's public keys.
   *
   * @param keysetId Optional param to get the keys for a specific keyset. If not specified, the
   *   keys from all active keysets are fetched.
   * @param mintUrl Optional alternative mint URL to use for this request.
   * @param customRequest Optional override for the request function.
   * @returns The mint's public keys.
   */
  async getKeys(t, e, n) {
    const r = e || this._mintUrl;
    t && (t = t.replace(/\//g, "_").replace(/\+/g, "-"));
    const o = await (n ?? this._request)({
      endpoint: t ? W(r, "/v1/keys", t) : W(r, "/v1/keys")
    });
    if (!T(o) || !Array.isArray(o.keysets)) {
      const a = T(o) && "detail" in o ? o.detail : void 0;
      throw new Error(a ?? "bad response");
    }
    return o;
  }
  /**
   * Get the mint's keysets in no specific order.
   *
   * @param customRequest Optional override for the request function.
   * @returns All the mint's past and current keysets.
   */
  async getKeySets(t) {
    return (t ?? this._request)({ endpoint: W(this._mintUrl, "/v1/keysets") });
  }
  /**
   * Restores proofs from the provided blinded messages.
   *
   * @param restorePayload The payload containing outputs to restore.
   * @param customRequest Optional override for the request function.
   * @returns The restore response with outputs and signatures.
   */
  async restore(t, e) {
    const r = await (e ?? this._request)({
      endpoint: W(this._mintUrl, "/v1/restore"),
      method: "POST",
      requestBody: t
    });
    if (!T(r) || !Array.isArray(r == null ? void 0 : r.outputs) || !Array.isArray(r == null ? void 0 : r.signatures)) {
      const i = T(r) && "detail" in r ? r.detail : void 0;
      throw new Error(i ?? "bad response");
    }
    return r;
  }
  /**
   * Tries to establish a websocket connection with the websocket mint url according to NUT-17.
   */
  async connectWebSocket() {
    if (this.ws)
      await this.ws.ensureConnection();
    else {
      const t = new URL(this._mintUrl), e = "v1/ws";
      t.pathname && (t.pathname.endsWith("/") ? t.pathname += e : t.pathname += "/" + e), this.ws = it.getInstance().getConnection(
        `${t.protocol === "https:" ? "wss" : "ws"}://${t.host}${t.pathname}`
      );
      try {
        await this.ws.connect();
      } catch (n) {
        throw this._logger.error("Failed to connect to WebSocket...", { e: n }), new Error("Failed to connect to WebSocket...");
      }
    }
  }
  /**
   * Closes a websocket connection.
   */
  disconnectWebSocket() {
    this.ws && this.ws.close();
  }
  get webSocketConnection() {
    return this.ws;
  }
  /**
   * Returns the Clear Authentication Token (CAT) to use in the 'Clear-auth' header, or undefined if
   * not required for the given path and method.
   *
   * @param method The method to call on the path.
   * @param path The API path to check for blind auth requirement.
   * @returns The blind auth token if required, otherwise undefined.
   */
  async handleClearAuth(t, e) {
    if (!(!this._authProvider || !(await this.getLazyMintInfo()).requiresClearAuthToken(t, e)))
      return this._logger.error("Clear Authentication Token...", { cat: this._authProvider.getCAT() }), this._authProvider.getCAT();
  }
  /**
   * Returns a serialized Blind Authentication Token (BAT) to use in the 'Blind-auth' header, or
   * undefined if not required for the given path and method.
   *
   * @param method The method to call on the path.
   * @param path The API path to check for blind auth requirement.
   * @returns The blind auth token if required, otherwise undefined.
   */
  async handleBlindAuth(t, e) {
    if (!this._authProvider || !(await this.getLazyMintInfo()).requiresBlindAuthToken(t, e))
      return;
    const r = await this._authProvider.getBlindAuthToken({ method: t, path: e });
    return this._logger.error("Blind Authentication Token...", { bat: r }), r;
  }
  async requestWithAuth(t, e, n = {}, r) {
    const i = r ?? this._request, o = await this.handleBlindAuth(t, e), a = await this.handleClearAuth(t, e), c = {
      ...n.headers ?? {},
      ...o ? { "Blind-auth": o } : {},
      ...a ? { "Clear-auth": a } : {}
    };
    return i({
      ...n,
      endpoint: W(this._mintUrl, e),
      method: t,
      headers: c
    });
  }
};
var zn = class {
  constructor(t, e, n, r, i) {
    this._keys = {}, this._id = t, this._unit = e, this._active = n, this._input_fee_ppk = r, this._final_expiry = i;
  }
  get id() {
    return this._id;
  }
  get unit() {
    return this._unit;
  }
  get isActive() {
    return this._active;
  }
  get fee() {
    return this._input_fee_ppk ?? 0;
  }
  get expiry() {
    return this._final_expiry;
  }
  get hasKeys() {
    return Object.keys(this._keys).length > 0;
  }
  get hasHexId() {
    return Ct(this._id);
  }
  get keys() {
    return this._keys;
  }
  set keys(t) {
    this._keys = t;
  }
  /**
   * For compat with v2 MintKeyset type.
   */
  get active() {
    return this._active;
  }
  /**
   * For compat with v2 MintKeyset type.
   */
  get input_fee_ppk() {
    return this._input_fee_ppk ?? 0;
  }
  /**
   * For compat with v2 MintKeyset type.
   */
  get final_expiry() {
    return this._final_expiry;
  }
  /**
   * To Mint API MintKeyset format.
   *
   * @returns MintKeyset object.
   */
  toMintKeyset() {
    return {
      id: this._id,
      unit: this._unit,
      active: this._active,
      input_fee_ppk: this._input_fee_ppk,
      final_expiry: this._final_expiry
    };
  }
  /**
   * To Mint API MintKeys format.
   *
   * @returns MintKeys object.
   */
  toMintKeys() {
    return this.hasKeys ? {
      id: this._id,
      unit: this._unit,
      keys: this._keys
    } : null;
  }
  /**
   * Verifies that the keyset's ID matches the derived ID from its keys, unit, and expiry.
   *
   * @returns True if verification succeeds, false otherwise (e.g., no keys or mismatch).
   */
  verify() {
    if (!this.hasKeys)
      return false;
    const t = hexToBytes(this._id)[0];
    return Qt(this._keys, this._unit, this._final_expiry, t) === this._id;
  }
};
var Ue = class {
  constructor(t, e, n, r) {
    if (this.keysets = {}, this.mint = typeof t == "string" ? new Vt(t) : t, this.unit = e, n && r) {
      const i = Array.isArray(r) ? r : [r];
      this.buildKeychain(n, i);
    }
  }
  /**
   * Single entry point to load or refresh keysets and keys for the unit.
   *
   * @remarks
   * Fetches in parallel, filters by unit, assigns keys.
   * @param forceRefresh If true, refetch even if loaded.
   */
  async init(t) {
    if (Object.keys(this.keysets).length > 0 && !t)
      return;
    const [e, n] = await Promise.all([this.mint.getKeySets(), this.mint.getKeys()]);
    this.buildKeychain(e.keysets, n.keysets), this.getCheapestKeyset();
  }
  /**
   * Builds keychain from Mint Keyset and Keys data.
   *
   * @param allKeysets Keyset data from mint.getKeySets() API.
   * @param allKeys Keys data from mint.getKeys() API.
   */
  buildKeychain(t, e) {
    this.keysets = {}, t.filter((i) => i.unit === this.unit).forEach((i) => {
      this.keysets[i.id] = new zn(i.id, i.unit, i.active, i.input_fee_ppk, i.final_expiry);
    });
    const r = new Map(
      e.filter((i) => i.unit === this.unit).map((i) => [i.id, i])
    );
    Object.values(this.keysets).forEach((i) => {
      if (!i.hasHexId || !i.isActive)
        return;
      const o = r.get(i.id);
      if (o && (i.keys = o.keys, !i.verify()))
        throw new Error(`Keyset verification failed for ID ${i.id}`);
    });
  }
  /**
   * Get a keyset by ID or the cheapest keyset if no ID is provided.
   *
   * @param id Optional keyset ID.
   * @returns Keyset with keys.
   * @throws If keyset not found or uninitialized.
   */
  getKeyset(t) {
    const e = t ? this.keysets[t] : this.getCheapestKeyset();
    if (!e)
      throw new Error(`Keyset '${t}' not found`);
    return e;
  }
  /**
   * Get the cheapest active keyset.
   *
   * @remarks
   * Selects active keyset with lowest fee and hex ID.
   * @returns Active Keyset.
   * @throws If none found or uninitialized.
   */
  getCheapestKeyset() {
    if (Object.keys(this.keysets).length === 0)
      throw new Error("KeyChain not initialized");
    const t = Object.values(this.keysets).filter(
      (e) => e.isActive && e.hasHexId && e.hasKeys
    );
    if (t.length === 0)
      throw new Error("No active keyset found");
    return t.sort((e, n) => e.fee - n.fee)[0];
  }
  /**
   * Get list of all keysets for the unit.
   *
   * @returns Array of Keysets.
   * @throws If uninitialized.
   */
  getKeysets() {
    if (Object.keys(this.keysets).length === 0)
      throw new Error("KeyChain not initialized");
    return Object.values(this.keysets);
  }
  /**
   * Extract the Mint API data from the keychain.
   *
   * @remarks
   * Useful for instantiating new wallets / keychains without repeatedly calling the mint API.
   */
  getCache() {
    const t = this.getKeysets(), e = t.filter((n) => n.hasKeys).map((n) => n.toMintKeys()).filter((n) => n !== null);
    return {
      keysets: t.map((n) => n.toMintKeyset()),
      keys: e,
      unit: this.unit,
      mintUrl: this.mint.mintUrl
    };
  }
};
var vt = class {
  constructor(t, e, n) {
    this.amount = t, this.B_ = e, this.id = n;
  }
  getSerializedBlindedMessage() {
    return { amount: this.amount, B_: this.B_.toHex(true), id: this.id };
  }
};
var Vn = /* @__PURE__ */ new Set([
  "locktime",
  "pubkeys",
  "n_sigs",
  "refund",
  "n_sigs_refund"
]);
function Re(s) {
  if (!s || typeof s != "string")
    throw new Error("tag key must be a non empty string");
  if (Vn.has(s))
    throw new Error(`additionalTags must not use reserved key "${s}"`);
}
var re = 1024;
var xt = /* @__PURE__ */ new WeakMap();
function Gn(s, t) {
  t && xt.set(s, t);
}
function Jn(s) {
  const t = xt.get(s);
  if (t)
    return xt.delete(s), t;
}
var N = class _N {
  constructor(t, e, n) {
    this.secret = n, this.blindingFactor = e, this.blindedMessage = t;
  }
  toProof(t, e) {
    let n;
    t.dleq && (n = {
      s: hexToBytes(t.dleq.s),
      e: hexToBytes(t.dleq.e),
      r: this.blindingFactor
    });
    const r = {
      id: t.id,
      amount: t.amount,
      C_: X(t.C_)
    }, i = X(e.keys[t.amount]), o = Sn(r, this.blindingFactor, this.secret, i), a = {
      ...Tn(o),
      ...n && {
        dleq: {
          s: bytesToHex(n.s),
          e: bytesToHex(n.e),
          r: Mt(n.r ?? BigInt(0))
        }
      }
    }, c = Jn(this);
    return c && (a.p2pk_e = c), a;
  }
  static createP2PKData(t, e, n, r) {
    return G(e, n.keys, r).map((o) => this.createSingleP2PKData(t, o, n.id));
  }
  static createSingleP2PKData(t, e, n) {
    var _a;
    const r = Array.isArray(t.pubkey) ? t.pubkey : [t.pubkey], i = t.refundKeys ?? [], o = Math.max(1, Math.min(t.requiredSignatures ?? 1, r.length)), a = Math.max(
      1,
      Math.min(t.requiredRefundSignatures ?? 1, i.length || 1)
    );
    let c = r[0], u = r.slice(1), l = i, h;
    if (t.blindKeys) {
      const x = [c, ...u, ...i], { blinded: S, Ehex: B } = gn(x, n);
      c = S[0], u = S.slice(1, r.length), l = S.slice(r.length), h = B;
    }
    const d = [], p = t.locktime ?? NaN;
    if (Number.isSafeInteger(p) && p >= 0 && d.push(["locktime", String(p)]), u.length > 0 && (d.push(["pubkeys", ...u]), o > 1 && d.push(["n_sigs", String(o)])), l.length > 0 && (d.push(["refund", ...l]), a > 1 && d.push(["n_sigs_refund", String(a)])), (_a = t.additionalTags) == null ? void 0 : _a.length) {
      const x = t.additionalTags.map(([S, ...B]) => (Re(S), [S, ...B.map(String)]));
      d.push(...x);
    }
    const m = [
      "P2PK",
      {
        nonce: bytesToHex(randomBytes(32)),
        data: c,
        tags: d
      }
    ], P = JSON.stringify(m), A = [...P].length;
    if (A > re)
      throw new Error(`Secret too long (${A} characters), maximum is ${re}`);
    const w = new TextEncoder().encode(P), { r: v, B_: I } = gt(w), U = new _N(
      new vt(e, I, n).getSerializedBlindedMessage(),
      v,
      w
    );
    return t.blindKeys && h && Gn(U, h), U;
  }
  static createRandomData(t, e, n) {
    return G(t, e.keys, n).map((i) => this.createSingleRandomData(i, e.id));
  }
  static createSingleRandomData(t, e) {
    const n = bytesToHex(randomBytes(32)), r = new TextEncoder().encode(n), { r: i, B_: o } = gt(r);
    return new _N(
      new vt(t, o, e).getSerializedBlindedMessage(),
      i,
      r
    );
  }
  static createDeterministicData(t, e, n, r, i) {
    return G(t, r.keys, i).map(
      (a, c) => this.createSingleDeterministicData(a, e, n + c, r.id)
    );
  }
  static createSingleDeterministicData(t, e, n, r) {
    const i = xn(e, r, n), o = bytesToHex(i), a = new TextEncoder().encode(o), c = $(Bn(e, r, n)), { r: u, B_: l } = gt(a, c);
    return new _N(
      new vt(t, l, r).getSerializedBlindedMessage(),
      u,
      a
    );
  }
  /**
   * Calculates the sum of amounts in an array of OutputDataLike objects.
   *
   * @param outputs Array of OutputDataLike objects.
   * @returns The total sum of amounts.
   */
  static sumOutputAmounts(t) {
    return t.reduce((e, n) => e + n.blindedMessage.amount, 0);
  }
};
function ie(s) {
  const t = s.toLowerCase();
  if (t.length === 66 && (t.startsWith("02") || t.startsWith("03")))
    return t;
  if (t.length === 64)
    return `02${t}`;
  throw new Error(
    `Invalid pubkey, expected 33 byte compressed or 32 byte x only, got length ${t.length}`
  );
}
function Xn(s) {
  return s instanceof Date ? Math.floor(s.getTime() / 1e3) : s < 1e12 ? Math.floor(s) : Math.floor(s / 1e3);
}
var Ne = class _Ne {
  constructor() {
    this.lockSet = /* @__PURE__ */ new Set(), this.refundSet = /* @__PURE__ */ new Set(), this.extraTags = [];
  }
  addLockPubkey(t) {
    const e = Array.isArray(t) ? t : [t];
    for (const n of e)
      this.lockSet.add(ie(n));
    return this;
  }
  addRefundPubkey(t) {
    const e = Array.isArray(t) ? t : [t];
    for (const n of e)
      this.refundSet.add(ie(n));
    return this;
  }
  lockUntil(t) {
    return this.locktime = Xn(t), this;
  }
  requireLockSignatures(t) {
    return this.nSigs = Math.max(1, Math.trunc(t)), this;
  }
  requireRefundSignatures(t) {
    return this.nSigsRefund = Math.max(1, Math.trunc(t)), this;
  }
  addTag(t, e) {
    Re(t);
    const n = e === void 0 ? [] : Array.isArray(e) ? e : [e];
    return this.extraTags.push([t, ...n.map(String)]), this;
  }
  addTags(t) {
    for (const [e, ...n] of t)
      this.addTag(e, n);
    return this;
  }
  /**
   * @alpha
   */
  blindKeys() {
    return this._blindKeys = true, this;
  }
  toOptions() {
    const t = Array.from(this.lockSet), e = Array.from(this.refundSet);
    if (t.length === 0)
      throw new Error("At least one lock pubkey is required");
    if (e.length > 0 && this.locktime === void 0)
      throw new Error(
        "Refund pubkeys require a locktime, add lockUntil(...) or remove refund keys"
      );
    const n = t.length + e.length;
    if (n > 10)
      throw new Error(`Too many pubkeys, ${n} provided, maximum allowed is 10 in total`);
    const r = this.nSigs ? Math.min(Math.max(1, this.nSigs), t.length) : void 0, i = this.nSigsRefund ? Math.min(Math.max(1, this.nSigsRefund), Math.max(1, e.length)) : void 0, a = {
      pubkey: t.length === 1 ? t[0] : t,
      ...this.locktime !== void 0 ? { locktime: this.locktime } : {},
      ...e.length ? { refundKeys: e } : {},
      ...r && r > 1 ? { requiredSignatures: r } : {},
      ...i && i > 1 ? { requiredRefundSignatures: i } : {},
      ...this.extraTags.length ? { additionalTags: this.extraTags.slice() } : {},
      ...this._blindKeys ? { blindKeys: true } : {}
    };
    return N.createSingleP2PKData(a, 1, "deedbeef"), a;
  }
  static fromOptions(t) {
    var _a, _b;
    const e = new _Ne(), n = Array.isArray(t.pubkey) ? t.pubkey : [t.pubkey];
    return e.addLockPubkey(n), t.locktime !== void 0 && e.lockUntil(t.locktime), ((_a = t.refundKeys) == null ? void 0 : _a.length) && e.addRefundPubkey(t.refundKeys), t.requiredSignatures !== void 0 && e.requireLockSignatures(t.requiredSignatures), t.requiredRefundSignatures !== void 0 && e.requireRefundSignatures(t.requiredRefundSignatures), ((_b = t.additionalTags) == null ? void 0 : _b.length) && e.addTags(t.additionalTags), t.blindKeys && e.blindKeys(), e;
  }
};
var Yn = (s, t, e, n = false, r = false, i = L) => {
  const h = He();
  let d = null, p = 1 / 0, m = 0, P = 0;
  const A = (f) => {
    try {
      return e.getKeyset(f.id).fee;
    } catch (g) {
      bt(`Could not get fee. No keyset found for keyset id: ${f.id}`, i, {
        error: g,
        keychain: e.getKeysets()
      });
    }
  }, w = (f, g) => f - (n ? Math.ceil(g / 1e3) : 0), v = (f) => {
    const g = [...f];
    for (let k = g.length - 1; k > 0; k--) {
      const y = Math.floor(Math.random() * (k + 1));
      [g[k], g[y]] = [g[y], g[k]];
    }
    return g;
  }, I = (f, g, k) => {
    let y = 0, F = f.length - 1, E = null;
    for (; y <= F; ) {
      const z = Math.floor((y + F) / 2), et = f[z].exFee;
      (k ? et <= g : et >= g) ? (E = z, k ? y = z + 1 : F = z - 1) : k ? F = z - 1 : y = z + 1;
    }
    return k ? E : y < f.length ? y : null;
  }, U = (f, g) => {
    const k = g.exFee;
    let y = 0, F = f.length;
    for (; y < F; ) {
      const E = Math.floor((y + F) / 2);
      f[E].exFee < k ? y = E + 1 : F = E;
    }
    f.splice(y, 0, g);
  }, x = (f, g) => w(f, g) < t ? 1 / 0 : f + g / 1e3 - t;
  let S = 0, B = 0;
  const at = s.map((f) => {
    const g = A(f), k = n ? f.amount - g / 1e3 : f.amount, y = { proof: f, exFee: k, ppkfee: g };
    return (!n || k > 0) && (S += f.amount, B += g), y;
  });
  let M = n ? at.filter((f) => f.exFee > 0) : at;
  if (M.sort((f, g) => f.exFee - g.exFee), M.length > 0) {
    let f;
    if (r) {
      const g = I(M, t, true);
      f = g !== null ? g + 1 : 0;
    } else {
      const g = I(M, t, false);
      if (g !== null) {
        const k = M[g].exFee, y = I(M, k, true);
        de(y, "Unexpected null rightIndex in binary search", i), f = y + 1;
      } else
        f = M.length;
    }
    for (let g = f; g < M.length; g++)
      S -= M[g].proof.amount, B -= M[g].ppkfee;
    M = M.slice(0, f);
  }
  const Z = w(S, B);
  if (t <= 0 || t > Z)
    return { keep: s, send: [] };
  const tt = Math.min(
    Math.ceil(t * (1 + 0 / 100)),
    t + 0,
    Z
  );
  for (let f = 0; f < 60; f++) {
    const g = [];
    let k = 0, y = 0;
    for (const C of v(M)) {
      const R = k + C.proof.amount, D = y + C.ppkfee, j = w(R, D);
      if (r && j > t || (g.push(C), k = R, y = D, j >= t))
        break;
    }
    const F = new Set(g), E = M.filter((C) => !F.has(C)), z = v(Array.from({ length: g.length }, (C, R) => R)).slice(
      0,
      5e3
    );
    for (const C of z) {
      const R = w(k, y);
      if (R === t || !r && R >= t && R <= tt)
        break;
      const D = g[C], j = k - D.proof.amount, nt = y - D.ppkfee, Fe = w(j, nt), Jt = t - Fe, _t = I(E, Jt, r);
      if (_t !== null) {
        const ct = E[_t];
        (!r || ct.exFee > D.exFee) && (Jt >= 0 || ct.exFee <= D.exFee) && (g[C] = ct, k = j + ct.proof.amount, y = nt + ct.ppkfee, E.splice(_t, 1), U(E, D));
      }
    }
    const et = x(k, y);
    if (et < p) {
      i.debug(
        `selectProofsToSend: best solution found in trial #${f} - amount: ${k}, delta: ${et}`
      ), d = [...g].sort((R, D) => D.exFee - R.exFee), p = et, m = k, P = y;
      const C = [...d];
      for (; C.length > 1 && p > 0; ) {
        const R = C.pop(), D = k - R.proof.amount, j = y - R.ppkfee, nt = x(D, j);
        if (nt == 1 / 0)
          break;
        nt < p && (d = [...C], p = nt, m = D, P = j, k = D, y = j);
      }
    }
    if (d && p < 1 / 0) {
      const C = w(m, P);
      if (C === t || !r && C >= t && C <= tt)
        break;
    }
    if (h.elapsed() > 1e3) {
      le(
        r,
        "Proof selection took too long. Try again with a smaller proof set.",
        i
      ), i.warn("Proof selection took too long. Returning best selection so far.");
      break;
    }
  }
  if (d && p < 1 / 0) {
    const f = d.map((y) => y.proof), g = new Set(f), k = s.filter((y) => !g.has(y));
    return i.info(`Proof selection took ${h.elapsed()}ms`), { keep: k, send: f };
  }
  return { keep: s, send: [] };
};
var Zn = class {
  constructor(t) {
    if (this.next = /* @__PURE__ */ new Map(), this.locks = /* @__PURE__ */ new Map(), t)
      for (const [e, n] of Object.entries(t))
        this.next.set(e, n);
  }
  async withLock(t, e) {
    const n = this.locks.get(t) ?? Promise.resolve();
    let r;
    const i = new Promise((a) => r = a), o = n.then(() => i);
    this.locks.set(t, o);
    try {
      return await n, await e();
    } finally {
      r(), this.locks.get(t) === o && this.locks.delete(t);
    }
  }
  async reserve(t, e) {
    if (e < 0)
      throw new Error("reserve called with negative count");
    return this.withLock(t, () => {
      const n = this.next.get(t) ?? 0;
      return e === 0 ? { start: n, count: 0 } : (this.next.set(t, n + e), { start: n, count: e });
    });
  }
  async advanceToAtLeast(t, e) {
    await this.withLock(t, () => {
      const n = this.next.get(t) ?? 0;
      e > n && this.next.set(t, e);
    });
  }
  async setNext(t, e) {
    await this.withLock(t, () => {
      if (e < 0)
        throw new Error("setNext: negative next not allowed");
      this.next.set(t, e);
    });
  }
  snapshot() {
    return Promise.resolve(Object.fromEntries(this.next.entries()));
  }
};
var ts = class {
  constructor(t) {
    this.wallet = t;
  }
  send(t, e) {
    return new es(this.wallet, t, e);
  }
  receive(t) {
    return new ns(this.wallet, t);
  }
  mintBolt11(t, e) {
    return new oe(this.wallet, "bolt11", t, e);
  }
  mintBolt12(t, e) {
    return new oe(this.wallet, "bolt12", t, e);
  }
  meltBolt11(t, e) {
    return new ae(this.wallet, "bolt11", t, e);
  }
  meltBolt12(t, e) {
    return new ae(this.wallet, "bolt12", t, e);
  }
};
var es = class {
  constructor(t, e, n) {
    this.wallet = t, this.amount = e, this.proofs = n, this.config = {};
  }
  /**
   * Use random blinding for the sent outputs.
   *
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asRandom(t) {
    return this.sendOT = { type: "random", denominations: t }, this;
  }
  /**
   * Use deterministic outputs for the sent proofs.
   *
   * @param counter Starting counter. Zero means auto reserve using the wallet‚Äôs CounterSource.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asDeterministic(t = 0, e) {
    return this.sendOT = { type: "deterministic", counter: t, denominations: e }, this;
  }
  /**
   * Use P2PK locked outputs for the sent proofs.
   *
   * @param options NUT 11 options like pubkey and locktime.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asP2PK(t, e) {
    return this.sendOT = { type: "p2pk", options: t, denominations: e }, this;
  }
  /**
   * Use a factory to generate OutputData for the sent proofs.
   *
   * @param factory OutputDataFactory used to produce blinded messages.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asFactory(t, e) {
    return this.sendOT = { type: "factory", factory: t, denominations: e }, this;
  }
  /**
   * Provide pre created OutputData for the sent proofs.
   *
   * @param data Fully formed OutputData. Their amounts must sum to the send amount, otherwise the
   *   wallet will throw.
   */
  asCustom(t) {
    return this.sendOT = { type: "custom", data: t }, this;
  }
  /**
   * Use random blinding for change outputs.
   *
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  keepAsRandom(t) {
    return this.keepOT = { type: "random", denominations: t }, this;
  }
  /**
   * Use deterministic outputs for change.
   *
   * @param counter Starting counter. Zero means auto reserve using the wallet‚Äôs CounterSource.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  keepAsDeterministic(t = 0, e) {
    return this.keepOT = { type: "deterministic", counter: t, denominations: e }, this;
  }
  /**
   * Use P2PK locked change (NUT 11).
   *
   * @param options Locking options applied to the kept proofs.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  keepAsP2PK(t, e) {
    return this.keepOT = { type: "p2pk", options: t, denominations: e }, this;
  }
  /**
   * Use a factory to generate OutputData for change.
   *
   * @param factory OutputDataFactory used to produce blinded messages.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  keepAsFactory(t, e) {
    return this.keepOT = { type: "factory", factory: t, denominations: e }, this;
  }
  /**
   * Provide pre created OutputData for change.
   *
   * @param data Fully formed OutputData for the keep (change) amount.
   */
  keepAsCustom(t) {
    return this.keepOT = { type: "custom", data: t }, this;
  }
  /**
   * Make the sender cover the receiver‚Äôs future spend fee.
   *
   * @param on When true, include fees in the sent amount. Default true if called.
   */
  includeFees(t = true) {
    return this.config.includeFees = t, this;
  }
  /**
   * Use a specific keyset for the operation.
   *
   * @param id Keyset id to use for mint keys and fee lookup.
   */
  keyset(t) {
    return this.config.keysetId = t, this;
  }
  /**
  * Provide existing proofs to help optimise denomination selection.
  *
  * @remarks
  * Has no effect if denominations (custom split) was specified.
  * @param p Proofs currently held by the wallet, used to hit denomination targets.
  */
  proofsWeHave(t) {
    return this.config.proofsWeHave = t, this;
  }
  /**
   * Receive a callback once counters are atomically reserved for deterministic outputs.
   *
   * @param cb Called with OperationCounters when counters are reserved.
   */
  onCountersReserved(t) {
    return this.config.onCountersReserved = t, this;
  }
  /**
   * Force a pure offline, exact match selection. No mint calls are made. If an exact match cannot
   * be found, this throws.
   *
   * @param requireDleq Only consider proofs with a DLEQ when true.
   */
  offlineExactOnly(t = false) {
    return this.offlineExact = { requireDleq: t }, this;
  }
  /**
   * Force a pure offline selection that allows a close match, overspend permitted per wallet RGLI.
   * No mint calls are made. Returns the best offline subset found, or throws if funds are
   * insufficient.
   *
   * @param requireDleq Only consider proofs with a DLEQ when true.
   */
  offlineCloseMatch(t = false) {
    return this.offlineClose = { requireDleq: t }, this;
  }
  /**
   * Execute the send or swap.
   *
   * @returns The split result with kept and sent proofs.
   */
  async run() {
    if ((this.offlineExact || this.offlineClose) && (this.sendOT || this.keepOT))
      throw new Error(
        "Offline selection cannot be combined with custom output types. Remove send/keep output configuration, or use an online swap."
      );
    if (this.offlineExact)
      return this.wallet.sendOffline(this.amount, this.proofs, {
        includeFees: this.config.includeFees,
        exactMatch: true,
        requireDleq: this.offlineExact.requireDleq
      });
    if (this.offlineClose)
      return this.wallet.sendOffline(this.amount, this.proofs, {
        includeFees: this.config.includeFees,
        exactMatch: false,
        requireDleq: this.offlineClose.requireDleq
      });
    const t = {
      send: this.sendOT ?? this.wallet.defaultOutputType(),
      ...this.keepOT ? { keep: this.keepOT } : {}
    };
    return this.wallet.send(this.amount, this.proofs, this.config, t);
  }
};
var ns = class {
  constructor(t, e) {
    this.wallet = t, this.token = e, this.config = {};
  }
  /**
   * Use random blinding for the received outputs.
   *
   * @remarks
   * If denoms specified, proofsWeHave() will have no effect.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asRandom(t) {
    return this.outputType = { type: "random", denominations: t }, this;
  }
  /**
   * Use deterministic outputs for the received proofs.
   *
   * @remarks
   * If denoms specified, proofsWeHave() will have no effect.
   * @param counter Starting counter. Zero means auto reserve using the wallet‚Äôs CounterSource.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asDeterministic(t = 0, e) {
    return this.outputType = { type: "deterministic", counter: t, denominations: e }, this;
  }
  /**
   * Use P2PK locked outputs for the received proofs.
   *
   * @remarks
   * If denoms specified, proofsWeHave() will have no effect.
   * @param options NUT 11 options like pubkey and locktime.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asP2PK(t, e) {
    return this.outputType = { type: "p2pk", options: t, denominations: e }, this;
  }
  /**
   * Use a factory to generate OutputData for received proofs.
   *
   * @remarks
   * If denoms specified, proofsWeHave() will have no effect.
   * @param factory OutputDataFactory used to produce blinded messages.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asFactory(t, e) {
    return this.outputType = { type: "factory", factory: t, denominations: e }, this;
  }
  /**
   * Provide pre created OutputData for received proofs.
   *
   * @param data Fully formed OutputData for the final amount.
   */
  asCustom(t) {
    return this.outputType = { type: "custom", data: t }, this;
  }
  /**
   * Use a specific keyset for the operation.
   *
   * @param id Keyset id to use for mint keys and fee lookup.
   */
  keyset(t) {
    return this.config.keysetId = t, this;
  }
  /**
   * Require all incoming proofs to have a valid DLEQ for the selected keyset.
   *
   * @param on When true, proofs without DLEQ are rejected.
   */
  requireDleq(t = true) {
    return this.config.requireDleq = t, this;
  }
  /**
   * Private key used to sign P2PK locked incoming proofs.
   *
   * @param k Single key or array of multisig keys.
   */
  privkey(t) {
    return this.config.privkey = t, this;
  }
  /**
   * Provide existing proofs to help optimise denomination selection.
   *
   * @remarks
   * Has no effect if denominations (custom split) was specified.
   * @param p Proofs currently held by the wallet, used to hit denomination targets.
   */
  proofsWeHave(t) {
    return this.config.proofsWeHave = t, this;
  }
  /**
   * Receive a callback once counters are atomically reserved for deterministic outputs.
   *
   * @param cb Called with OperationCounters when counters are reserved.
   */
  onCountersReserved(t) {
    return this.config.onCountersReserved = t, this;
  }
  async run() {
    return this.wallet.receive(this.token, this.config, this.outputType);
  }
};
var oe = class {
  constructor(t, e, n, r) {
    this.wallet = t, this.method = e, this.amount = n, this.quote = r, this.config = {}, this._hasPrivkey;
  }
  /**
   * Use random blinding for the minted proofs.
   *
   * @remarks
   * If denoms specified, proofsWeHave() will have no effect.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asRandom(t) {
    return this.outputType = { type: "random", denominations: t }, this;
  }
  /**
   * Use deterministic outputs for the minted proofs.
   *
   * @remarks
   * If denoms specified, proofsWeHave() will have no effect.
   * @param counter Starting counter. Zero means auto reserve using the wallet‚Äôs CounterSource.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asDeterministic(t = 0, e) {
    return this.outputType = { type: "deterministic", counter: t, denominations: e }, this;
  }
  /**
   * Use P2PK locked outputs for the minted proofs.
   *
   * @remarks
   * If denoms specified, proofsWeHave() will have no effect.
   * @param options NUT 11 options like pubkey and locktime.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asP2PK(t, e) {
    return this.outputType = { type: "p2pk", options: t, denominations: e }, this;
  }
  /**
   * Use a factory to generate OutputData for minted proofs.
   *
   * @remarks
   * If denoms specified, proofsWeHave() will have no effect.
   * @param factory OutputDataFactory used to produce blinded messages.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asFactory(t, e) {
    return this.outputType = { type: "factory", factory: t, denominations: e }, this;
  }
  /**
   * Provide pre created OutputData for minted proofs.
   *
   * @param data Fully formed OutputData for the final amount.
   */
  asCustom(t) {
    return this.outputType = { type: "custom", data: t }, this;
  }
  /**
   * Use a specific keyset for the operation.
   *
   * @param id Keyset id to use for mint keys and fee lookup.
   */
  keyset(t) {
    return this.config.keysetId = t, this;
  }
  /**
   * Private key to sign locked mint quotes.
   *
   * @param k Private key for locked quotes.
   */
  privkey(t) {
    return this.config.privkey = t, this;
  }
  /**
   * Provide existing proofs to help optimise denomination selection.
   *
   * @remarks
   * Has no effect if denominations (custom split) was specified.
   * @param p Proofs currently held by the wallet, used to hit denomination targets.
   */
  proofsWeHave(t) {
    return this.config.proofsWeHave = t, this;
  }
  /**
   * Receive a callback once counters are atomically reserved for deterministic outputs.
   *
   * @param cb Called with OperationCounters when counters are reserved.
   */
  onCountersReserved(t) {
    return this.config.onCountersReserved = t, this;
  }
  /**
   * Execute minting against the quote.
   *
   * @remarks
   * This method can only be called for bolt12 quotes when .privkey() is set.
   * @returns The newly minted proofs.
   */
  async run() {
    if (this.method === "bolt11") {
      const e = this.quote;
      if (e.pubkey && !this.config.privkey)
        throw new Error("privkey is required for locked BOLT11 mint quotes");
      return this.wallet.mintProofsBolt11(this.amount, e, this.config, this.outputType);
    }
    const t = this.quote;
    if (!this.config.privkey)
      throw new Error("privkey is required for BOLT12 mint quotes");
    return this.wallet.mintProofsBolt12(
      this.amount,
      t,
      this.config.privkey,
      this.config,
      this.outputType
    );
  }
};
var ae = class {
  constructor(t, e, n, r) {
    this.wallet = t, this.method = e, this.quote = n, this.proofs = r, this.config = {};
  }
  /**
   * Use random blinding for change outputs.
   *
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asRandom(t) {
    return this.outputType = { type: "random", denominations: t }, this;
  }
  /**
   * Use deterministic outputs for change.
   *
   * @param counter Starting counter. Zero means auto reserve using the wallet‚Äôs CounterSource.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asDeterministic(t = 0, e) {
    return this.outputType = { type: "deterministic", counter: t, denominations: e }, this;
  }
  /**
   * Use P2PK-locked change (NUT-11).
   *
   * @param options NUT-11 locking options (e.g., pubkey, locktime).
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asP2PK(t, e) {
    return this.outputType = { type: "p2pk", options: t, denominations: e }, this;
  }
  /**
   * Use a factory to generate OutputData for change.
   *
   * @param factory Factory used to produce blinded messages.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asFactory(t, e) {
    return this.outputType = { type: "factory", factory: t, denominations: e }, this;
  }
  /**
   * Provide pre-created OutputData for change.
   *
   * @param data Fully formed OutputData for the change amount.
   */
  asCustom(t) {
    return this.outputType = { type: "custom", data: t }, this;
  }
  /**
   * Use a specific keyset for the melt operation.
   *
   * @param id Keyset id to use for mint keys and fee lookup.
   */
  keyset(t) {
    return this.config.keysetId = t, this;
  }
  /**
   * Receive a callback once counters are atomically reserved for deterministic outputs.
   *
   * @param cb Called with OperationCounters when counters are reserved.
   */
  onCountersReserved(t) {
    return this.config.onCountersReserved = t, this;
  }
  /**
   * Receive a callback when NUT-08 blanks (0-sat change outputs) are created for async melts.
   *
   * @remarks
   * You can persist these blanks and later call `wallet.completeMelt(blanks)` to finalize and
   * recover change once the invoice/offer is paid.
   * @param cb Callback invoked with the created blanks payload.
   */
  onChangeOutputsCreated(t) {
    return this.config.onChangeOutputsCreated = t, this;
  }
  /**
   * Execute the melt against the quote.
   *
   * @returns The melt result: `{ quote, change }`.
   */
  async run() {
    return this.method === "bolt11" ? this.wallet.meltProofsBolt11(this.quote, this.proofs, this.config, this.outputType) : this.wallet.meltProofsBolt12(this.quote, this.proofs, this.config, this.outputType);
  }
};
function ss(s) {
  const t = /* @__PURE__ */ new WeakSet();
  try {
    return JSON.stringify(s, (e, n) => {
      if (typeof n == "object" && n !== null) {
        if (t.has(n))
          return "[Circular]";
        t.add(n);
      }
      return n;
    });
  } catch {
    return Object.prototype.toString.call(s);
  }
}
function ce(s) {
  if (s instanceof Error)
    return s;
  const t = typeof s == "string" ? s : ss(s), e = new Error(t);
  return e.cause = s, e;
}
function ue() {
  const s = new Error("Aborted");
  return Object.defineProperty(s, "name", { value: "AbortError" }), s;
}
function st(s) {
  s && Promise.resolve(s).then((t) => {
    try {
      t();
    } catch {
    }
  }).catch(() => {
  });
}
var rs = class {
  constructor(t) {
    this.wallet = t, this.countersReservedHandlers = /* @__PURE__ */ new Set(), this.meltBlanksHandlers = /* @__PURE__ */ new Set();
  }
  // Binds an abort signal to each subscription canceller
  withAbort(t, e) {
    if (!t)
      return e;
    if (t.aborted)
      return e(), () => {
      };
    const n = () => e();
    return t.addEventListener("abort", n, { once: true }), () => {
      t.removeEventListener("abort", n), e();
    };
  }
  // Subscribe to a quote-paid event and resolve when it fires.
  // Supports AbortSignal and timeout, and always cleans up.
  waitUntilPaid(t, e, n, r = "Timeout waiting for paid") {
    return new Promise((i, o) => {
      let a = null, c = null;
      const u = (h) => {
        st(a), c && (clearTimeout(c), c = null), (n == null ? void 0 : n.signal) && n.signal.removeEventListener("abort", l), h && o(ce(h));
      }, l = () => u(ue());
      if (n == null ? void 0 : n.signal) {
        if (n.signal.aborted)
          return l();
        n.signal.addEventListener("abort", l, { once: true });
      }
      (n == null ? void 0 : n.timeoutMs) && n.timeoutMs > 0 && (c = setTimeout(() => u(new Error(r)), n.timeoutMs)), a = t(
        e,
        (h) => {
          u(), i(h);
        },
        (h) => u(h),
        // reject if subscription itself errors
        { signal: n == null ? void 0 : n.signal }
        // delegate abort to subscription as well
      );
    });
  }
  /**
   * Register a callback that fires whenever deterministic counters are reserved.
   *
   * Timing: the callback is invoked synchronously _after_ a successful reservation and _before_ the
   * enclosing wallet method returns. The wallet does **not** await your callback, it is
   * fire-and-forget.
   *
   * Responsibility for async work is on the consumer. If your handler calls an async function (e.g.
   * persisting `start + count` to storage), make sure to handle errors inside it to avoid unhandled
   * rejections.
   *
   * Typical use: persist `start + count` for the `keysetId` so counters survive restarts.
   *
   * @example
   *
   * ```ts
   * wallet.on.countersReserved(({ keysetId, start, count, next }) => {
   * 	saveNextToDb(keysetId, start + count); // handle async errors inside saveNextToDb
   * });
   * ```
   *
   * @param cb Handler called with { keysetId, start, count }.
   * @returns A function that unsubscribes the handler.
   */
  countersReserved(t, e) {
    this.countersReservedHandlers.add(t);
    const n = () => this.countersReservedHandlers.delete(t);
    return this.withAbort(e == null ? void 0 : e.signal, n);
  }
  /**
   * @internal
   */
  _emitCountersReserved(t) {
    for (const e of this.countersReservedHandlers)
      lt(e, t, this.wallet.logger, { event: "countersReserved" });
  }
  /**
   * Register a callback fired whenever NUT-08 blanks are created during a melt.
   *
   * Called synchronously right after blanks are prepared (before the melt request), and the wallet
   * does not await your handler.
   *
   * Typical use: persist `payload` so you can later call `wallet.completeMelt(payload)`.
   */
  meltBlanksCreated(t, e) {
    this.meltBlanksHandlers.add(t);
    const n = () => this.meltBlanksHandlers.delete(t);
    return this.withAbort(e == null ? void 0 : e.signal, n);
  }
  /**
   * @internal
   */
  _emitMeltBlanksCreated(t) {
    for (const e of this.meltBlanksHandlers)
      lt(e, t, this.wallet.logger, { event: "meltBlanksCreated" });
  }
  /**
   * Register a callback to be called whenever a mint quote's state changes.
   *
   * @param quoteIds List of mint quote IDs that should be subscribed to.
   * @param callback Callback function that will be called whenever a mint quote state changes.
   * @param errorCallback
   * @returns
   */
  async mintQuoteUpdates(t, e, n, r) {
    await this.wallet.mint.connectWebSocket();
    const i = this.wallet.mint.webSocketConnection;
    if (!i)
      throw new Error("Failed to establish WebSocket connection.");
    const o = Array.from(new Set(t)), a = i.createSubscription({ kind: "bolt11_mint_quote", filters: o }, e, n), c = () => i.cancelSubscription(a, e);
    return this.withAbort(r == null ? void 0 : r.signal, c);
  }
  /**
   * Register a callback to be called when a single mint quote gets paid.
   *
   * @param quoteId Mint quote id that should be subscribed to.
   * @param callback Callback function that will be called when this mint quote gets paid.
   * @param errorCallback
   * @returns
   */
  async mintQuotePaid(t, e, n, r) {
    return this.mintQuoteUpdates(
      [t],
      (i) => {
        i.state === Tt.PAID && e(i);
      },
      n,
      r
    );
  }
  /**
   * Register a callback to be called whenever a melt quote‚Äôs state changes.
   *
   * @param quoteId Melt quote id that should be subscribed to.
   * @param callback Callback function that will be called when this melt quote gets paid.
   * @param errorCallback
   * @returns
   */
  async meltQuoteUpdates(t, e, n, r) {
    await this.wallet.mint.connectWebSocket();
    const i = this.wallet.mint.webSocketConnection;
    if (!i)
      throw new Error("Failed to establish WebSocket connection.");
    const o = Array.from(new Set(t)), a = i.createSubscription({ kind: "bolt11_melt_quote", filters: o }, e, n), c = () => i.cancelSubscription(a, e);
    return this.withAbort(r == null ? void 0 : r.signal, c);
  }
  /**
   * Register a callback to be called when a single melt quote gets paid.
   *
   * @param quoteIds List of melt quote IDs that should be subscribed to.
   * @param callback Callback function that will be called whenever a melt quote state changes.
   * @param errorCallback
   * @returns
   */
  async meltQuotePaid(t, e, n, r) {
    return this.meltQuoteUpdates(
      [t],
      (i) => {
        i.state === ut.PAID && e(i);
      },
      n,
      r
    );
  }
  /**
   * Register a callback to be called whenever a subscribed proof state changes.
   *
   * @param proofs List of proofs that should be subscribed to.
   * @param callback Callback function that will be called whenever a proof's state changes.
   * @param errorCallback
   * @returns
   */
  async proofStateUpdates(t, e, n, r) {
    await this.wallet.mint.connectWebSocket();
    const i = this.wallet.mint.webSocketConnection;
    if (!i)
      throw new Error("Failed to establish WebSocket connection.");
    const o = new TextEncoder(), a = {};
    for (const d of t) {
      const p = ft(o.encode(d.secret)).toHex(true);
      a[p] = d;
    }
    const c = Object.keys(a), u = (d) => {
      e({ ...d, proof: a[d.Y] });
    }, l = i.createSubscription({ kind: "proof_state", filters: c }, u, n), h = () => i.cancelSubscription(l, u);
    return this.withAbort(r == null ? void 0 : r.signal, h);
  }
  /**
   * Resolve once a mint quote transitions to PAID, with automatic unsubscription, optional abort
   * signal, and optional timeout.
   *
   * The underlying subscription is always cancelled after resolution or rejection, including on
   * timeout or abort.
   *
   * @example
   *
   * ```ts
   * const ac = new AbortController();
   * // Cancel if the user navigates away
   * window.addEventListener('beforeunload', () => ac.abort(), { once: true });
   *
   * try {
   * 	const paid = await wallet.on.onceMintPaid(quoteId, {
   * 		signal: ac.signal,
   * 		timeoutMs: 60_000,
   * 	});
   * 	console.log('Mint paid, amount', paid.amount);
   * } catch (e) {
   * 	if ((e as Error).name === 'AbortError') {
   * 		console.log('User aborted');
   * 	} else {
   * 		console.error('Mint not paid', e);
   * 	}
   * }
   * ```
   *
   * @param id Mint quote id to watch.
   * @param opts Optional controls.
   * @param opts.signal AbortSignal to cancel the wait early.
   * @param opts.timeoutMs Milliseconds to wait before rejecting with a timeout error.
   * @returns A promise that resolves with the latest `MintQuoteResponse` once PAID.
   */
  onceMintPaid(t, e) {
    return this.waitUntilPaid(
      this.mintQuotePaid.bind(this),
      t,
      e,
      "Timeout waiting for mint paid"
    );
  }
  /**
   * Resolve when ANY of several mint quotes is PAID, cancelling the rest.
   *
   * Subscribes to all distinct ids, resolves with `{ id, quote }` for the first PAID, and cancels
   * all remaining subscriptions.
   *
   * Errors from individual subscriptions are ignored by default so a single noisy stream does not
   * abort the whole race. Set `failOnError: true` to reject on the first error instead. If all
   * subscriptions error and none paid, the promise rejects with the last seen error.
   *
   * @example
   *
   * ```ts
   * // Race multiple quotes obtained from splitting a large top up
   * const { id, quote } = await wallet.on.onceAnyMintPaid(batchQuoteIds, {
   * 	timeoutMs: 120_000,
   * });
   * console.log('First top up paid', id, quote.preimage?.length);
   * ```
   *
   * @param ids Array of mint quote ids (duplicates are ignored).
   * @param opts Optional controls.
   * @param opts.signal AbortSignal to cancel the wait early.
   * @param opts.timeoutMs Milliseconds to wait before rejecting with a timeout error.
   * @param opts.failOnError When true, reject on first error. Default false.
   * @returns A promise resolving to the id that won and its `MintQuoteResponse`.
   */
  onceAnyMintPaid(t, e) {
    return new Promise((n, r) => {
      const i = Array.from(new Set(t)), o = /* @__PURE__ */ new Map();
      let a = null, c = null, u = false;
      const l = (d) => {
        for (const p of o.values())
          st(p);
        o.clear(), a && (clearTimeout(a), a = null), (e == null ? void 0 : e.signal) && e.signal.removeEventListener("abort", h), d && r(ce(d));
      }, h = () => l(ue());
      if (e == null ? void 0 : e.signal) {
        if (e.signal.aborted)
          return h();
        e.signal.addEventListener("abort", h, { once: true });
      }
      if ((e == null ? void 0 : e.timeoutMs) && e.timeoutMs > 0 && (a = setTimeout(
        () => l(new Error("Timeout waiting for any mint paid")),
        e.timeoutMs
      )), i.length === 0)
        return l(new Error("No quote ids provided"));
      for (const d of i) {
        const p = this.mintQuotePaid(
          d,
          (m) => {
            l(), n({ id: d, quote: m });
          },
          (m) => {
            if (e == null ? void 0 : e.failOnError) {
              l(m);
              return;
            }
            c = m;
            const P = o.get(d);
            P && (st(P), o.delete(d)), u && o.size === 0 && l(c ?? new Error("No subscriptions remaining"));
          }
        );
        o.set(d, p);
      }
      u = true;
    });
  }
  /**
   * Resolve once a melt quote transitions to PAID, with automatic unsubscription, optional abort
   * signal, and optional timeout.
   *
   * Mirrors onceMintPaid, but for melts.
   *
   * @example
   *
   * ```ts
   * try {
   * 	const paid = await wallet.on.onceMeltPaid(meltId, { timeoutMs: 45_000 });
   * 	console.log('Invoice paid by mint, paid msat', paid.paid ?? 0);
   * } catch (e) {
   * 	console.error('Payment did not complete in time', e);
   * }
   * ```
   *
   * @param id Melt quote id to watch.
   * @param opts Optional controls.
   * @param opts.signal AbortSignal to cancel the wait early.
   * @param opts.timeoutMs Milliseconds to wait before rejecting with a timeout error.
   * @returns A promise that resolves with the `MeltQuoteResponse` once PAID.
   */
  onceMeltPaid(t, e) {
    return this.waitUntilPaid(
      this.meltQuotePaid.bind(this),
      t,
      e,
      "Timeout waiting for melt paid"
    );
  }
  /**
   * Async iterable that yields proof state updates for the provided proofs.
   *
   * Adds a bounded buffer option:
   *
   * - If `maxBuffer` is set and the queue is full when a new payload arrives, either drop the oldest
   *   queued payload (`drop: 'oldest'`, default) or the incoming payload (`drop: 'newest'`). In
   *   both cases `onDrop` is invoked with the dropped payload.
   *
   * The stream ends and cleans up on abort or on the wallet error callback. Errors from the wallet
   * are treated as a graceful end for this iterator.
   *
   * @example
   *
   * ```ts
   * const ac = new AbortController();
   * try {
   * 	for await (const update of wallet.on.proofStatesStream(myProofs)) {
   * 		if (update.state === CheckStateEnum.SPENT) {
   * 			console.warn('Spent proof', update.proof.id);
   * 		}
   * 	}
   * } catch (e) {
   * 	if ((e as Error).name !== 'AbortError') {
   * 		console.error('Stream error', e);
   * 	}
   * }
   * ```
   *
   * @param proofs The proofs to subscribe to. Only `secret` is required.
   * @param opts Optional controls.
   * @param opts.signal AbortSignal that stops the stream when aborted.
   * @param opts.maxBuffer Maximum number of queued items before applying the drop strategy.
   * @param opts.drop Overflow strategy when `maxBuffer` is reached, 'oldest' | 'newest'. Default
   *   'oldest'.
   * @param opts.onDrop Callback invoked with the payload that was dropped.
   * @returns An async iterable of update payloads.
   */
  proofStatesStream(t, e) {
    return (async function* () {
      const n = [];
      let r = false, i = null;
      const o = (e == null ? void 0 : e.maxBuffer) && e.maxBuffer > 0 ? e.maxBuffer : 1 / 0, a = (e == null ? void 0 : e.drop) ?? "oldest", c = () => {
        const d = i;
        i = null, d && d();
      }, u = (d) => {
        var _a, _b;
        if (n.length >= o)
          if (a === "oldest") {
            const p = n.shift();
            if (p !== void 0)
              try {
                (_a = e == null ? void 0 : e.onDrop) == null ? void 0 : _a.call(e, p);
              } catch {
              }
            n.push(d);
          } else {
            try {
              (_b = e == null ? void 0 : e.onDrop) == null ? void 0 : _b.call(e, d);
            } catch {
            }
            return;
          }
        else
          n.push(d);
        c();
      }, l = this.proofStateUpdates(
        t,
        (d) => {
          u(d);
        },
        () => {
          r = true, c();
        },
        { signal: e == null ? void 0 : e.signal }
      ), h = () => {
        r = true, c();
      };
      try {
        for ((e == null ? void 0 : e.signal) && (e.signal.aborted ? h() : e.signal.addEventListener("abort", h, { once: true })); !r || n.length; ) {
          for (; n.length; )
            yield n.shift();
          if (r)
            break;
          await new Promise((d) => i = d);
        }
      } finally {
        st(l), (e == null ? void 0 : e.signal) && e.signal.removeEventListener("abort", h);
      }
    }).call(this);
  }
  /**
   * Create a composite canceller that can collect many subscriptions and dispose them all in one
   * call.
   *
   * Accepts both a `SubscriptionCanceller` and a `Promise<SubscriptionCanceller>`. When the
   * composite canceller is called, all collected cancellations are invoked. Errors from individual
   * cancellers are caught and ignored.
   *
   * The returned function also has an `.add()` method to register more cancellers, and a
   * `.cancelled` boolean property for debugging.
   *
   * @example
   *
   * ```ts
   * const cancelAll = wallet.on.group();
   * cancelAll.add(wallet.on.mintQuotes(ids, onUpdate, onErr));
   * cancelAll.add(asyncSubscribeElsewhere());
   *
   * // later
   * cancelAll(); // disposes everything
   * ```
   *
   * @returns Composite canceller function with `.add()` and `.cancelled` members.
   */
  group() {
    const t = [];
    let e = false;
    const n = () => {
      if (!e)
        for (e = true; t.length; )
          st(t.pop());
    };
    return n.add = (r) => e ? (st(r), r) : (t.push(r), r), Object.defineProperty(n, "cancelled", {
      get: () => e,
      enumerable: true
    }), n;
  }
};
var is = class {
  constructor(t) {
    this.src = t;
  }
  /**
   * Returns the "next" counter for a specified keyset.
   */
  async peekNext(t) {
    return (await this.src.reserve(t, 0)).start;
  }
  /**
   * Bumps the counter if it is behind `minNext` (no-op if ahead).
   */
  async advanceToAtLeast(t, e) {
    await this.src.advanceToAtLeast(t, e);
  }
  /**
   * Hard-sets the cursor (useful for tests or migrations).
   *
   * @throws If the CounterSource does not support setNext()
   */
  async setNext(t, e) {
    if (typeof this.src.setNext == "function") {
      await this.src.setNext(t, e);
      return;
    }
    throw new Error("CounterSource does not support setNext()");
  }
  /**
   * Returns the current "next" per keyset (what will be reserved next).
   *
   * @throws If the CounterSource does not support snapshot()
   */
  async snapshot() {
    if (typeof this.src.snapshot == "function")
      return await this.src.snapshot();
    throw new Error("CounterSource does not support snapshot()");
  }
};
var Et = {
  UNSPENT: "UNSPENT",
  PENDING: "PENDING",
  SPENT: "SPENT"
};
var St = "__PENDING__";
var Gt = class _Gt {
  /**
   * Create a wallet for a given mint and unit. Call `loadMint` before use.
   *
   * Binding, if `options.keysetId` is omitted, the wallet binds to the cheapest active keyset for
   * this unit during `loadMint`. The keychain only loads keysets for this unit.
   *
   * Caching, to preload, provide both `keysets` and `keys`, otherwise the cache is ignored.
   *
   * Deterministic secrets, pass `bip39seed` and optionally `secretsPolicy`. Deterministic outputs
   * reserve counters from `counterSource`, or an ephemeral in memory source if not supplied.
   * `initialCounter` applies only with a supplied `keysetId` and the ephemeral source.
   *
   * Splitting, `denominationTarget` guides proof splits, default is 3. Override coin selection with
   * `selectProofs` if needed. Logging defaults to a null logger.
   *
   * @param mint Mint instance or URL.
   * @param options Optional settings.
   * @param options.unit Wallet unit, default 'sat'.
   * @param options.keysetId Bind to this keyset id, else bind on `loadMint`.
   * @param options.bip39seed BIP39 seed for deterministic secrets.
   * @param options.secretsPolicy Secrets policy, default 'auto'.
   * @param options.counterSource Counter source for deterministic outputs. If provided, this takes
   *   precedence over counterInit. Use when you need persistence across processes or devices.
   * @param options.counterInit Seed values for the built-in EphemeralCounterSource. Ignored if
   *   counterSource is also provided.
   * @param options.keys Cached keys for this unit, only used when `keysets` is also provided.
   * @param options.keysets Cached keysets for this unit, only used when `keys` is also provided.
   * @param options.mintInfo Optional cached mint info.
   * @param options.denominationTarget Target proofs per denomination, default 3.
   * @param options.selectProofs Custom proof selection function.
   * @param options.logger Logger instance, default null logger.
   */
  constructor(t, e) {
    this._seed = void 0, this._unit = "sat", this._mintInfo = void 0, this._denominationTarget = 3, this._secretsPolicy = "auto", this._boundKeysetId = St, this.swap = this.send.bind(this), this.ops = new ts(this), this.on = new rs(this), this._logger = (e == null ? void 0 : e.logger) ?? L, this._selectProofs = (e == null ? void 0 : e.selectProofs) ?? Yn, this.mint = typeof t == "string" ? new Vt(t, { authProvider: e == null ? void 0 : e.authProvider, logger: this._logger }) : t, this._unit = (e == null ? void 0 : e.unit) ?? this._unit, this._boundKeysetId = (e == null ? void 0 : e.keysetId) ?? this._boundKeysetId, (e == null ? void 0 : e.bip39seed) && (this.failIf(
      !(e.bip39seed instanceof Uint8Array),
      "bip39seed must be a valid Uint8Array",
      {
        bip39seed: e.bip39seed
      }
    ), this._seed = e.bip39seed), this._secretsPolicy = (e == null ? void 0 : e.secretsPolicy) ?? this._secretsPolicy, (e == null ? void 0 : e.counterSource) ? this._counterSource = e.counterSource : this._counterSource = new Zn(e == null ? void 0 : e.counterInit), this.counters = new is(this._counterSource), this.keyChain = new Ue(this.mint, this._unit, e == null ? void 0 : e.keysets, e == null ? void 0 : e.keys), this._mintInfo = (e == null ? void 0 : e.mintInfo) ? new wt(e.mintInfo) : this._mintInfo, this._denominationTarget = (e == null ? void 0 : e.denominationTarget) ?? this._denominationTarget;
  }
  // Convenience wrappers for "log and throw"
  fail(t, e) {
    return bt(t, this._logger, e);
  }
  failIf(t, e, n) {
    return le(t, e, this._logger, n);
  }
  failIfNullish(t, e, n) {
    return de(t, e, this._logger, n);
  }
  safeCallback(t, e, n) {
    lt(t, e, this._logger, n);
  }
  /**
   * Load mint information, keysets, and keys. Must be called before using other methods.
   *
   * @param forceRefresh If true, re-fetches data even if cached.
   * @throws If fetching mint info, keysets, or keys fails.
   */
  async loadMint(t) {
    const e = [];
    if ((!this._mintInfo || t) && e.push(
      this.mint.getInfo().then((n) => (this._mintInfo = new wt(n), null))
    ), e.push(this.keyChain.init(t).then(() => null)), await Promise.all(e), this._logger.debug("KeyChain", { keychain: this.keyChain.getCache() }), this._boundKeysetId === St)
      this._boundKeysetId = this.keyChain.getCheapestKeyset().id;
    else {
      const n = this.keyChain.getKeyset(this._boundKeysetId);
      this.failIf(!n.hasKeys, "Wallet keyset has no keys after refresh", { keyset: n.id });
    }
  }
  // -----------------------------------------------------------------
  // Section: Getters
  // -----------------------------------------------------------------
  /**
   * Get the wallet's unit.
   *
   * @returns The unit (e.g., 'sat').
   */
  get unit() {
    return this._unit;
  }
  /**
   * Get information about the mint.
   *
   * @remarks
   * Returns cached mint info. Call `loadMint` first to initialize the wallet.
   * @returns Mint info.
   * @throws If mint info is not initialized.
   */
  getMintInfo() {
    return this.failIfNullish(this._mintInfo, "Mint info not initialized; call loadMint first"), this._mintInfo;
  }
  /**
   * The keyset ID bound to this wallet instance.
   */
  get keysetId() {
    return this.failIf(this._boundKeysetId === St, "Wallet not initialised, call loadMint"), this._boundKeysetId;
  }
  /**
   * Gets the requested keyset or the keyset bound to the wallet.
   *
   * @remarks
   * This method enforces wallet policies. If `id` is omitted, it returns the keyset bound to this
   * wallet, including validation that:
   *
   * - The keyset exists in the keychain,
   * - The unit matches the wallet's unit,
   * - Keys are loaded for that keyset.
   *
   * Contrast with `keyChain.getKeyset(id?)`, which, when called without an id, returns the cheapest
   * active keyset for the unit, ignoring the wallet binding.
   * @param id Optional keyset id to resolve. If omitted, the wallet's bound keyset is used.
   * @returns The resolved `Keyset`.
   * @throws If the keyset is not found, has no keys, or its unit differs from the wallet.
   */
  getKeyset(t) {
    const e = this.keyChain.getKeyset(t ?? this.keysetId);
    return this.failIf(e.unit !== this._unit, "Keyset unit does not match wallet unit", {
      keyset: e.id,
      unit: e.unit,
      walletUnit: this._unit
    }), this.failIf(!e.hasKeys, "Keyset has no keys loaded", { keyset: e.id }), e;
  }
  get logger() {
    return this._logger;
  }
  // -----------------------------------------------------------------
  // Section: Counters
  // -----------------------------------------------------------------
  async reserveFor(t, e) {
    return e <= 0 ? { start: 0, count: 0 } : this._counterSource.reserve(t, e);
  }
  countersNeeded(t) {
    return t.type !== "deterministic" || t.counter !== 0 ? 0 : (t.denominations ?? []).length;
  }
  async addCountersToOutputTypes(t, ...e) {
    const n = e.reduce((c, u) => c + this.countersNeeded(u), 0);
    if (n === 0)
      return { outputTypes: e };
    const r = await this.reserveFor(t, n);
    let i = r.start;
    const o = e.map((c) => {
      if (c.type === "deterministic" && c.counter === 0) {
        const u = (c.denominations ?? []).length;
        if (u > 0) {
          const l = { ...c, counter: i };
          return i += u, l;
        }
      }
      return c;
    }), a = {
      keysetId: t,
      start: r.start,
      count: r.count,
      next: r.start + r.count
    };
    return this.on._emitCountersReserved(a), { outputTypes: o, used: a };
  }
  /**
   * Bind this wallet to a specific keyset id.
   *
   * @remarks
   * This changes the default keyset used by all operations that do not explicitly pass a keysetId.
   * The method validates that the keyset exists in the keychain, matches the wallet unit, and has
   * keys loaded.
   *
   * Typical uses:
   *
   * 1. After loadMint, to pin the wallet to a particular active keyset.
   * 2. After a refresh, to rebind deliberately rather than falling back to cheapest.
   *
   * @param id The keyset identifier to bind to.
   * @throws If keyset not found, if it has no keys loaded, or if its unit is not the wallet unit.
   */
  bindKeyset(t) {
    const e = this.keyChain.getKeyset(t);
    this.failIf(e.unit !== this._unit, "Keyset unit does not match wallet unit", {
      keyset: e.id,
      unit: e.unit,
      walletUnit: this._unit
    }), this.failIf(!e.hasKeys, "Keyset has no keys loaded", { keyset: e.id }), this._boundKeysetId = e.id, this._logger.debug("Wallet bound to keyset", {
      keysetId: e.id,
      unit: e.unit,
      feePPK: e.fee
    });
  }
  /**
   * Creates a new Wallet bound to a different keyset, sharing the same CounterSource.
   *
   * Use this to operate on multiple keysets concurrently without mutating your original wallet.
   * Counters remain monotonic across instances because the same CounterSource is reused.
   *
   * Do NOT pass a fresh CounterSource for the same seed unless you know exactly why. Reusing
   * counters can recreate secrets that a mint will reject.
   *
   * @param id The keyset identifier to bind to.
   * @throws If keyset not found, if it has no keys loaded, or if its unit is not the wallet unit.
   */
  withKeyset(t, e) {
    return new _Gt(this.mint, {
      keysetId: t,
      bip39seed: this._seed,
      secretsPolicy: this._secretsPolicy,
      logger: this._logger,
      counterSource: (e == null ? void 0 : e.counterSource) ?? this._counterSource,
      ...this.keyChain.getCache()
    });
  }
  /**
   * Returns the default OutputType for this wallet, based on its configured secrets policy
   * (options?.secretsPolicy) and seed state.
   *
   * - If the secrets policy is 'random', returns { type: 'random' }.
   * - If the policy is 'deterministic', requires a seed and returns { type: 'deterministic', counter:
   *   0 }. Counter 0 is a flag meaning "auto-increment from current state".
   * - If no explicit policy is set, falls back to:
   *
   *   - Deterministic if a seed is present.
   *   - Random if no seed is present.
   *
   * @returns An OutputType object describing the default output strategy.
   * @throws Error if the policy is 'deterministic' but no seed has been set.
   */
  defaultOutputType() {
    return this._secretsPolicy === "random" ? { type: "random" } : this._secretsPolicy === "deterministic" ? (this.failIfNullish(this._seed, "Deterministic policy requires a seed"), { type: "deterministic", counter: 0 }) : this._seed ? { type: "deterministic", counter: 0 } : { type: "random" };
  }
  // -----------------------------------------------------------------
  // Section: Output Creation
  // -----------------------------------------------------------------
  /**
   * Configures output denominations with fee adjustments and optimization.
   *
   * @remarks
   * If 'custom' outputType, data outputs MUST sum to the amount. Other outputTypes may supply
   * denominations. If no denominations are passed in, they will be calculated based on proofsWeHave
   * or the default split. If partial denominations are passed in, the balance will be added using
   * default split. Additional denominations to cover fees will then be added if required.
   * @param amount The total amount for outputs.
   * @param keyset The mint keyset.
   * @param outputType The output configuration.
   * @param includeFees Whether to include swap fees in the output amount.
   * @param proofsWeHave Optional proofs for optimizing denomination splitting.
   * @returns OutputType with required denominations.
   */
  configureOutputs(t, e, n, r = false, i = []) {
    let o = t;
    if (n.type === "custom") {
      this.failIf(r, "The custom OutputType does not support automatic fee inclusion");
      const c = N.sumOutputAmounts(n.data);
      return this.failIf(
        c !== t,
        `Custom output data total (${c}) does not match amount (${t})`
      ), n;
    }
    let a = n.denominations ?? [];
    if (a.length === 0 && i.length > 0 && (a = Un(
      i,
      o,
      e.keys,
      this._denominationTarget
    )), a = G(o, e.keys, a), r) {
      let c = this.getFeesForKeyset(a.length, e.id), u = G(c, e.keys);
      for (; this.getFeesForKeyset(a.length + u.length, e.id) > c; )
        c++, u = G(c, e.keys);
      o += c, a = [...a, ...u];
    }
    return { ...n, denominations: a };
  }
  /**
   * Sum total implied by a prepared OutputType. Note: Empty denomination is valid (e.g: zero
   * change).
   */
  preparedTotal(t) {
    return t.type === "custom" ? N.sumOutputAmounts(t.data) : (t.denominations ?? []).reduce((n, r) => n + r, 0);
  }
  /**
   * Generates blinded messages based on the specified output type.
   *
   * @param amount The total amount for outputs.
   * @param keyset The mint keys.
   * @param outputType The output configuration.
   * @returns Prepared output data.
   */
  createOutputData(t, e, n) {
    if (this.failIf(t < 0, "Amount was negative", { amount: t }), // 'custom' OutputType has no denominations. Every other OutputType does.
    // so let's sanity check those were filled properly (eg: configureOutputs)
    n.type != "custom" && n.denominations && n.denominations.length > 0) {
      const i = n.denominations.reduce((o, a) => o + a, 0);
      this.failIf(i !== t, "Denominations do not sum to the expected amount", {
        splitSum: i,
        expected: t
      });
    }
    let r;
    switch (n.type) {
      case "random":
        r = N.createRandomData(t, e, n.denominations);
        break;
      case "deterministic":
        this.failIfNullish(
          this._seed,
          "Deterministic outputs require a seed configured in the wallet"
        ), r = N.createDeterministicData(
          t,
          this._seed,
          n.counter,
          e,
          n.denominations
        );
        break;
      case "p2pk":
        r = N.createP2PKData(
          n.options,
          t,
          e,
          n.denominations
        );
        break;
      case "factory": {
        r = G(t, e.keys, n.denominations).map((o) => n.factory(o, e));
        break;
      }
      case "custom": {
        r = n.data;
        const i = N.sumOutputAmounts(r);
        this.failIf(
          i !== t,
          `Custom output data total (${i}) does not match amount (${t})`
        );
        break;
      }
      default:
        this.fail("Invalid OutputType");
    }
    return r;
  }
  /**
   * Creates a swap transaction with sorted outputs for privacy. This prevents a mint working out
   * which proofs will be sent or kept.
   *
   * @param inputs Prepared input proofs.
   * @param keepOutputs Outputs to keep (change or receiver's proofs).
   * @param sendOutputs Outputs to send (optional, default empty for receive/mint).
   * @returns Swap transaction with payload and metadata for processing signatures.
   */
  createSwapTransaction(t, e, n = []) {
    t = this._prepareInputsForMint(t);
    const r = [...e, ...n], i = r.map((h, d) => d).sort(
      (h, d) => r[h].blindedMessage.amount - r[d].blindedMessage.amount
    ), o = [
      ...Array.from({ length: e.length }, () => true),
      ...Array.from({ length: n.length }, () => false)
    ], a = i.map((h) => r[h]), c = i.map((h) => o[h]), u = a.map((h) => h.blindedMessage);
    return this._logger.debug("createSwapTransaction:", {
      indices: i,
      sortedKeepVector: c
      // outputs, // <-- removed for security
    }), {
      payload: {
        inputs: t,
        outputs: u
      },
      outputData: a,
      keepVector: c,
      sortedIndices: i
    };
  }
  // -----------------------------------------------------------------
  // Section: Send and Receive
  // -----------------------------------------------------------------
  /**
   * Receive a token (swaps with mint for new proofs)
   *
   * @example
   *
   * ```typescript
   * const result = await wallet.receive(
   * 	token,
   * 	{ includeFees: true },
   * 	{ type: 'deterministic', counter: 0 },
   * );
   * ```
   *
   * @param token Token string or decoded token.
   * @param config Optional receive config.
   * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().
   * @returns Newly minted proofs.
   */
  async receive(t, e, n) {
    const { keysetId: r, privkey: i, requireDleq: o, proofsWeHave: a, onCountersReserved: c } = e || {};
    n = n ?? this.defaultOutputType();
    const u = typeof t == "string" ? this.decodeToken(t) : t, l = Oe(u.mint);
    this.failIf(l !== this.mint.mintUrl, "Token belongs to a different mint", {
      token: l,
      wallet: this.mint.mintUrl
    }), this.failIf(u.unit !== this._unit, "Token is not in wallet unit", {
      token: u.unit,
      wallet: this._unit
    });
    let h = [];
    ({ proofs: h } = u);
    const d = rt(h);
    if (d === 0)
      return [];
    i && (h = this.signP2PKProofs(h, i));
    const p = this.getKeyset(r);
    if (o)
      for (const S of h) {
        const B = this.keyChain.getKeyset(S.id);
        De(S, B) || this.fail("Token contains proofs with invalid or missing DLEQ");
      }
    const m = d - this.getFeesForProofs(h);
    let P = this.configureOutputs(
      m,
      p,
      n,
      false,
      // includeFees is not applicable for receive
      a
    );
    const A = await this.addCountersToOutputTypes(p.id, P);
    [P] = A.outputTypes, A.used && this.safeCallback(c, A.used, { op: "receive" }), this._logger.debug("receive counter", { counter: A.used, receiveOT: P });
    const w = this.createOutputData(this.preparedTotal(P), p, P), v = this.createSwapTransaction(h, w, []), { signatures: I } = await this.mint.swap(v.payload), U = v.outputData.map(
      (S, B) => S.toProof(I[B], p)
    ), x = [];
    return v.sortedIndices.forEach((S, B) => {
      x[S] = U[B];
    }), this._logger.debug("RECEIVE COMPLETED", { amounts: x.map((S) => S.amount) }), x;
  }
  /**
   * Sends proofs of a given amount from provided proofs.
   *
   * @remarks
   * If proofs are P2PK-locked to your public key, call signP2PKProofs first to sign them. The
   * default config uses exact match selection, and does not includeFees or requireDleq. Because the
   * send is offline, the user will unlock the signed proofs when they receive them online.
   * @param amount Amount to send.
   * @param proofs Array of proofs (must sum >= amount; pre-sign if P2PK-locked).
   * @param config Optional parameters for the send.
   * @returns SendResponse with keep/send proofs.
   * @throws Throws if the send cannot be completed offline.
   */
  sendOffline(t, e, n) {
    const { requireDleq: r = false, includeFees: i = false, exactMatch: o = true } = n || {};
    r && (e = e.filter((l) => l.dleq != null)), this.failIf(rt(e) < t, "Not enough funds available to send");
    const { keep: a, send: c } = this.selectProofsToSend(e, t, i, o), u = this._prepareInputsForMint(c, r);
    return { keep: a, send: u };
  }
  /**
   * Send proofs with online swap if necessary.
   *
   * @remarks
   * If proofs are P2PK-locked to your public key, call signP2PKProofs first to sign them.
   * @example
   *
   * ```typescript
   * // Simple send
   * const result = await wallet.send(5, proofs);
   *
   * // With a SendConfig
   * const result = await wallet.send(5, proofs, { includeFees: true });
   *
   * // With Custom output configuration
   * const customConfig: OutputConfig = {
   * 	send: { type: 'p2pk', options: { pubkey: '...' } },
   * 	keep: { type: 'deterministic', counter: 0 },
   * };
   * const customResult = await wallet.send(5, proofs, { includeFees: true }, customConfig);
   * ```
   *
   * @param amount Amount to send (receiver gets this net amount).
   * @param proofs Array of proofs to split.
   * @param config Optional parameters for the swap.
   * @returns SendResponse with keep/send proofs.
   * @throws Throws if the send cannot be completed offline or if funds are insufficient.
   */
  async send(t, e, n, r) {
    const { keysetId: i, includeFees: o = false, onCountersReserved: a } = n || {};
    r = r ?? {
      send: this.defaultOutputType(),
      keep: this.defaultOutputType()
    };
    try {
      const f = this.defaultOutputType().type === "deterministic", g = (E) => !E || E.type === "random" && (!E.denominations || E.denominations.length === 0);
      if (i || f || !g(r.send) || r.keep && !g(r.keep)) {
        const E = [];
        throw i && E.push("keysetId override"), f && E.push("wallet default is deterministic"), g(r.send) || E.push("non-default send output type"), r.keep && !g(r.keep) && E.push("non-default keep output type"), new Error(`Options require a swap: ${E.join(", ")}`);
      }
      const { keep: k, send: y } = this.sendOffline(t, e, {
        includeFees: o,
        exactMatch: true,
        requireDleq: false
        // safety
      }), F = o ? this.getFeesForProofs(y) : 0;
      if (rt(y) === t + F)
        return this._logger.info("Successful exactMatch offline selection!"), { keep: k, send: y };
    } catch (f) {
      const g = f instanceof Error ? f.message : "Unknown error";
      this._logger.debug("ExactMatch offline selection failed.", { e: g });
    }
    const c = this.getKeyset(i);
    let u = this.configureOutputs(
      t,
      c,
      r.send ?? this.defaultOutputType(),
      o
    );
    const l = this.preparedTotal(u), { keep: h, send: d } = this.selectProofsToSend(
      e,
      l,
      true
      // Include fees to cover swap fee
    );
    if (d.length === 0)
      throw new Error("Not enough funds available to send");
    const p = rt(d), m = this.getFeesForProofs(d), P = p - m - l;
    this.failIf(P < 0, "Not enough funds available for swap", {
      selectedSum: p,
      swapFee: m,
      sendAmount: l,
      changeAmount: P
    });
    let A = this.configureOutputs(
      P,
      c,
      r.keep ?? this.defaultOutputType(),
      false,
      n == null ? void 0 : n.proofsWeHave
    );
    const w = this.preparedTotal(A), v = await this.addCountersToOutputTypes(c.id, u, A);
    [u, A] = v.outputTypes, v.used && this.safeCallback(a, v.used, { op: "send" }), this._logger.debug("send counters", { counter: v.used, sendOT: u, keepOT: A });
    const I = this.createOutputData(l, c, u), U = this.createOutputData(w, c, A), x = this.createSwapTransaction(d, U, I), { signatures: S } = await this.mint.swap(x.payload), B = x.outputData.map((f, g) => f.toProof(S[g], c)), at = Array(B.length), M = Array(x.keepVector.length);
    x.sortedIndices.forEach((f, g) => {
      M[f] = x.keepVector[g], at[f] = B[g];
    });
    const Z = [], tt = [];
    return at.forEach((f, g) => {
      M[g] ? Z.push(f) : tt.push(f);
    }), this._logger.debug("SEND COMPLETED", {
      unselectedProofs: h.map((f) => f.amount),
      keepProofs: Z.map((f) => f.amount),
      sendProofs: tt.map((f) => f.amount)
    }), {
      keep: [...Z, ...h],
      send: tt
    };
  }
  // -----------------------------------------------------------------
  // Section: Transaction Helpers
  // -----------------------------------------------------------------
  /**
   * Selects proofs to send based on amount and fee inclusion.
   *
   * @remarks
   * Uses an adapted Randomized Greedy with Local Improvement (RGLI) algorithm, which has a time
   * complexity O(n log n) and space complexity O(n).
   * @param proofs Array of Proof objects available to select from.
   * @param amountToSend The target amount to send.
   * @param includeFees Optional boolean to include fees; Default: false.
   * @param exactMatch Optional boolean to require exact match; Default: false.
   * @returns SendResponse containing proofs to keep and proofs to send.
   * @throws Throws an error if an exact match cannot be found within MAX_TIMEMS.
   * @see https://crypto.ethz.ch/publications/files/Przyda02.pdf
   */
  selectProofsToSend(t, e, n = false, r = false) {
    const { keep: i, send: o } = this._selectProofs(
      t,
      e,
      this.keyChain,
      n,
      r
    );
    return { keep: i, send: o };
  }
  /**
   * Prepares proofs for sending by signing P2PK-locked proofs.
   *
   * @remarks
   * Call this method before operations like send if the proofs are P2PK-locked and need unlocking.
   * This is a public wrapper for signing.
   * @param proofs The proofs to sign.
   * @param privkey The private key for signing.
   * @returns Signed proofs.
   */
  signP2PKProofs(t, e) {
    return bn(t, e);
  }
  /**
   * Calculates the fees based on inputs (proofs)
   *
   * @param proofs Input proofs to calculate fees for.
   * @returns Fee amount.
   * @throws Throws an error if the proofs keyset is unknown.
   */
  getFeesForProofs(t) {
    const e = t.reduce((n, r) => n + this.getProofFeePPK(r), 0);
    return Math.ceil(e / 1e3);
  }
  /**
   * Returns the current fee PPK for a proof according to the cached keyset.
   *
   * @param proof {Proof} A single proof.
   * @returns FeePPK {number} The feePPK for the selected proof.
   * @throws Throws an error if the proofs keyset is unknown.
   */
  getProofFeePPK(t) {
    try {
      return this.keyChain.getKeyset(t.id).fee;
    } catch (e) {
      this.fail(`Could not get fee. No keyset found for keyset id: ${t.id}`, {
        e,
        keychain: this.keyChain.getKeysets()
      });
    }
  }
  /**
   * Calculates the fees based on inputs for a given keyset.
   *
   * @param nInputs Number of inputs.
   * @param keysetId KeysetId used to lookup `input_fee_ppk`
   * @returns Fee amount.
   */
  getFeesForKeyset(t, e) {
    try {
      const n = this.keyChain.getKeyset(e).fee;
      return Math.floor(Math.max((t * n + 999) / 1e3, 0));
    } catch (n) {
      this.fail(`No keyset found with ID ${e}`, { e: n });
    }
  }
  /**
   * Prepares inputs for a mint operation.
   *
   * @remarks
   * Internal method; strips DLEQ (NUT-12) and p2pk_e (NUT-26) for privacy and serializes witnesses.
   * Returns an array of new proof objects - does not mutate the originals.
   * @param proofs The proofs to prepare.
   * @param keepDleq Optional boolean to keep DLEQ (default: false, strips for privacy).
   * @returns Prepared proofs for mint payload.
   */
  _prepareInputsForMint(t, e = false) {
    return t.map((n) => {
      const r = n.witness && typeof n.witness != "string" ? JSON.stringify(n.witness) : n.witness, { dleq: i, p2pk_e: o, ...a } = n;
      return e && i ? { ...a, dleq: i, witness: r } : { ...a, witness: r };
    });
  }
  /**
   * Decodes a string token.
   *
   * @remarks
   * Rehydrates a token from the space-saving CBOR format, including mapping short keyset ids to
   * their full representation.
   * @param token The token in string format (cashuB...)
   * @returns Token object.
   */
  decodeToken(t) {
    const e = this.keyChain.getKeysets();
    return Fn(t, e);
  }
  // -----------------------------------------------------------------
  // Section: Restore
  // -----------------------------------------------------------------
  /**
   * Restores batches of deterministic proofs until no more signatures are returned from the mint.
   *
   * @param [gapLimit=300] The amount of empty counters that should be returned before restoring
   *   ends (defaults to 300). Default is `300`
   * @param [batchSize=100] The amount of proofs that should be restored at a time (defaults to
   *   100). Default is `100`
   * @param [counter=0] The counter that should be used as a starting point (defaults to 0). Default
   *   is `0`
   * @param [keysetId] Which keysetId to use for the restoration. If none is passed the instance's
   *   default one will be used.
   */
  async batchRestore(t = 300, e = 100, n = 0, r) {
    const i = Math.ceil(t / e), o = [];
    let a, c = 0;
    for (; c < i; ) {
      const u = await this.restore(n, e, { keysetId: r });
      u.proofs.length > 0 ? (c = 0, o.push(...u.proofs), a = u.lastCounterWithSignature) : c++, n += e;
    }
    return { proofs: o, lastCounterWithSignature: a };
  }
  /**
   * Regenerates.
   *
   * @param start Set starting point for count (first cycle for each keyset should usually be 0)
   * @param count Set number of blinded messages that should be generated.
   * @param options.keysetId Set a custom keysetId to restore from. @see `keyChain)`
   */
  async restore(t, e, n) {
    const { keysetId: r } = n || {}, i = this.getKeyset(r);
    this.failIfNullish(this._seed, "Cashu Wallet must be initialized with a seed to use restore");
    const o = Array(e).fill(0), a = N.createDeterministicData(0, this._seed, t, i, o), { outputs: c, signatures: u } = await this.mint.restore({
      outputs: a.map((p) => p.blindedMessage)
    }), l = {};
    c.forEach((p, m) => l[p.B_] = u[m]);
    const h = [];
    let d;
    for (let p = 0; p < a.length; p++) {
      const m = l[a[p].blindedMessage.B_];
      m && (d = t + p, a[p].blindedMessage.amount = m.amount, h.push(a[p].toProof(m, i)));
    }
    return {
      proofs: h,
      lastCounterWithSignature: d
    };
  }
  // -----------------------------------------------------------------
  // Section: Create Mint Quote
  // -----------------------------------------------------------------
  /**
   * @deprecated Use createMintQuoteBolt11()
   */
  async createMintQuote(t, e) {
    return this.createMintQuoteBolt11(t, e);
  }
  /**
   * Requests a mint quote from the mint. Response returns a Lightning payment request for the
   * requested given amount and unit.
   *
   * @param amount Amount requesting for mint.
   * @param description Optional description for the mint quote.
   * @param pubkey Optional public key to lock the quote to.
   * @returns The mint will return a mint quote with a Lightning invoice for minting tokens of the
   *   specified amount and unit.
   */
  async createMintQuoteBolt11(t, e) {
    e && (this.getMintInfo().supportsNut04Description("bolt11", this._unit) || this.fail("Mint does not support description for bolt11"));
    const n = {
      unit: this._unit,
      amount: t,
      description: e
    }, r = await this.mint.createMintQuoteBolt11(n);
    return { ...r, amount: r.amount || t, unit: r.unit || this._unit };
  }
  /**
   * Requests a mint quote from the mint that is locked to a public key.
   *
   * @param amount Amount requesting for mint.
   * @param pubkey Public key to lock the quote to.
   * @param description Optional description for the mint quote.
   * @returns The mint will return a mint quote with a Lightning invoice for minting tokens of the
   *   specified amount and unit. The quote will be locked to the specified `pubkey`.
   */
  async createLockedMintQuote(t, e, n) {
    const { supported: r } = this.getMintInfo().isSupported(20);
    this.failIf(!r, "Mint does not support NUT-20");
    const i = {
      unit: this._unit,
      amount: t,
      description: n,
      pubkey: e
    }, o = await this.mint.createMintQuoteBolt11(i);
    this.failIf(typeof o.pubkey != "string", "Mint returned unlocked mint quote");
    const a = o.pubkey;
    return {
      ...o,
      pubkey: a,
      amount: o.amount || t,
      unit: o.unit || this._unit
    };
  }
  /**
   * Requests a mint quote from the mint. Response returns a Lightning BOLT12 offer for the
   * requested given amount and unit.
   *
   * @param pubkey Public key to lock the quote to.
   * @param options.amount BOLT12 offer amount requesting for mint. If not specified, the offer will
   *   be amountless.
   * @param options.description Description for the mint quote.
   * @returns The mint will return a mint quote with a BOLT12 offer for minting tokens of the
   *   specified amount and unit.
   */
  async createMintQuoteBolt12(t, e) {
    const n = this.getMintInfo();
    (e == null ? void 0 : e.description) && !n.supportsNut04Description("bolt12", this._unit) && this.fail("Mint does not support description for bolt12");
    const r = {
      pubkey: t,
      unit: this._unit,
      amount: e == null ? void 0 : e.amount,
      description: e == null ? void 0 : e.description
    };
    return this.mint.createMintQuoteBolt12(r);
  }
  // -----------------------------------------------------------------
  // Section: Check Mint Quote
  // -----------------------------------------------------------------
  /**
   * @deprecated Use checkMintQuoteBolt11()
   */
  async checkMintQuote(t) {
    return this.checkMintQuoteBolt11(t);
  }
  /**
   * Gets an existing mint quote from the mint.
   *
   * @param quote Quote ID.
   * @returns The mint will create and return a Lightning invoice for the specified amount.
   */
  async checkMintQuoteBolt11(t) {
    const e = typeof t == "string" ? t : t.quote, n = await this.mint.checkMintQuoteBolt11(e);
    return typeof t == "string" ? n : { ...n, amount: n.amount || t.amount, unit: n.unit || t.unit };
  }
  /**
   * Gets an existing BOLT12 mint quote from the mint.
   *
   * @param quote Quote ID.
   * @returns The latest mint quote for the given quote ID.
   */
  async checkMintQuoteBolt12(t) {
    return this.mint.checkMintQuoteBolt12(t);
  }
  // -----------------------------------------------------------------
  // Section: Mint Proofs
  // -----------------------------------------------------------------
  /**
   * @deprecated Use mintProofsBolt11()
   */
  async mintProofs(t, e, n, r) {
    return this._mintProofs("bolt11", t, e, n, r);
  }
  /**
   * Mint proofs for a bolt11 quote.
   *
   * @param amount Amount to mint.
   * @param quote Mint quote ID or object (bolt11).
   * @param config Optional parameters (e.g. privkey for locked quotes).
   * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().
   * @returns Minted proofs.
   */
  async mintProofsBolt11(t, e, n, r) {
    return this._mintProofs("bolt11", t, e, n, r);
  }
  /**
   * Mints proofs for a bolt12 quote.
   *
   * @param amount Amount to mint.
   * @param quote Bolt12 mint quote.
   * @param privkey Private key to unlock the quote.
   * @param config Optional parameters (e.g. keysetId).
   * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().
   * @returns Minted proofs.
   */
  async mintProofsBolt12(t, e, n, r, i) {
    return this._mintProofs("bolt12", t, e, { ...r, privkey: n }, i);
  }
  /**
   * Internal helper for minting proofs with bolt11 or bolt12.
   *
   * @remarks
   * Handles blinded messages, signatures, and proof construction. Use public methods like
   * mintProofs or helpers for API access.
   * @param method 'bolt11' or 'bolt12'.
   * @param amount Amount to mint (must be positive).
   * @param quote Quote ID or object.
   * @param config Optional (privkey, keysetId).
   * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().
   * @returns Minted proofs.
   * @throws If params are invalid or mint returns errors.
   */
  async _mintProofs(t, e, n, r, i) {
    i = i ?? this.defaultOutputType();
    const { privkey: o, keysetId: a, proofsWeHave: c, onCountersReserved: u } = r ?? {};
    this.failIf(e <= 0, "Invalid mint amount: must be positive", { amount: e });
    const l = this.getKeyset(a);
    let h = this.configureOutputs(
      e,
      l,
      i,
      false,
      // no fees
      c
    );
    const d = this.preparedTotal(h), p = await this.addCountersToOutputTypes(l.id, h);
    [h] = p.outputTypes, p.used && this.safeCallback(u, p.used, { op: "mintProofs" }), this._logger.debug("mint counter", { counter: p.used, mintOT: h });
    const m = this.createOutputData(d, l, h), P = m.map((v) => v.blindedMessage), A = {
      outputs: P,
      quote: typeof n == "string" ? n : n.quote
    };
    if (typeof n != "string" && n.pubkey) {
      this.failIf(!o, "Can not sign locked quote without private key");
      const v = qn(o, n.quote, P);
      A.signature = v;
    }
    let w;
    return t === "bolt12" ? { signatures: w } = await this.mint.mintBolt12(A) : { signatures: w } = await this.mint.mintBolt11(A), this.failIf(
      w.length !== m.length,
      `Mint returned ${w.length} signatures, expected ${m.length}`
    ), this._logger.debug("MINT COMPLETED", { amounts: m.map((v) => v.blindedMessage.amount) }), m.map((v, I) => v.toProof(w[I], l));
  }
  // -----------------------------------------------------------------
  // Section: Create Melt Quote
  // -----------------------------------------------------------------
  /**
   * @deprecated Use createMeltQuoteBolt11.
   */
  async createMeltQuote(t) {
    return this.createMeltQuoteBolt11(t);
  }
  /**
   * Requests a melt quote from the mint. Response returns amount and fees for a given unit in order
   * to pay a Lightning invoice.
   *
   * @param invoice LN invoice that needs to get a fee estimate.
   * @returns The mint will create and return a melt quote for the invoice with an amount and fee
   *   reserve.
   */
  async createMeltQuoteBolt11(t) {
    const e = {
      unit: this._unit,
      request: t
    }, n = await this.mint.createMeltQuoteBolt11(e);
    return {
      ...n,
      unit: n.unit || this._unit,
      request: n.request || t
    };
  }
  /**
   * Requests a melt quote from the mint. Response returns amount and fees for a given unit in order
   * to pay a BOLT12 offer.
   *
   * @param offer BOLT12 offer that needs to get a fee estimate.
   * @param amountMsat Amount in millisatoshis for amount-less offers. If this is defined and the
   *   offer has an amount, they **MUST** be equal.
   * @returns The mint will create and return a melt quote for the offer with an amount and fee
   *   reserve.
   */
  async createMeltQuoteBolt12(t, e) {
    return this.mint.createMeltQuoteBolt12({
      unit: this._unit,
      request: t,
      options: e ? {
        amountless: {
          amount_msat: e
        }
      } : void 0
    });
  }
  /**
   * Requests a multi path melt quote from the mint.
   *
   * @remarks
   * Uses NUT-15 Partial multi-path payments for BOLT11.
   * @param invoice LN invoice that needs to get a fee estimate.
   * @param partialAmount The partial amount of the invoice's total to be paid by this instance.
   * @returns The mint will create and return a melt quote for the invoice with an amount and fee
   *   reserve.
   * @see https://github.com/cashubtc/nuts/blob/main/15.md
   */
  async createMultiPathMeltQuote(t, e) {
    const { supported: n, params: r } = this.getMintInfo().isSupported(15);
    this.failIf(!n, "Mint does not support NUT-15"), this.failIf(
      !(r == null ? void 0 : r.some((u) => u.method === "bolt11" && u.unit === this._unit)),
      `Mint does not support MPP for bolt11 and ${this._unit}`
    );
    const o = {
      mpp: {
        amount: e
      }
    }, a = {
      unit: this._unit,
      request: t,
      options: o
    };
    return { ...await this.mint.createMeltQuoteBolt11(a), request: t, unit: this._unit };
  }
  // -----------------------------------------------------------------
  // Section: Check Melt Quote
  // -----------------------------------------------------------------
  /**
   * @deprecated Use checkMeltQuoteBolt11()
   */
  async checkMeltQuote(t) {
    return this.checkMeltQuoteBolt11(t);
  }
  /**
   * Returns an existing bolt11 melt quote from the mint.
   *
   * @param quote ID of the melt quote.
   * @returns The mint will return an existing melt quote.
   */
  async checkMeltQuoteBolt11(t) {
    const e = typeof t == "string" ? t : t.quote, n = await this.mint.checkMeltQuoteBolt11(e);
    return typeof t == "string" ? n : { ...n, request: t.request, unit: t.unit };
  }
  /**
   * Returns an existing bolt12 melt quote from the mint.
   *
   * @param quote ID of the melt quote.
   * @returns The mint will return an existing melt quote.
   */
  async checkMeltQuoteBolt12(t) {
    return this.mint.checkMeltQuoteBolt12(t);
  }
  // -----------------------------------------------------------------
  // Section: Melt Proofs
  // -----------------------------------------------------------------
  /**
   * @deprecated Use meltProofsBolt11()
   */
  async meltProofs(t, e, n, r) {
    return this._meltProofs("bolt11", t, e, n, r);
  }
  /**
   * Melt proofs for a bolt11 melt quote.
   *
   * @remarks
   * ProofsToSend must be at least amount+fee_reserve from the melt quote. This function does not
   * perform coin selection!.
   * @param meltQuote ID of the melt quote.
   * @param proofsToSend Proofs to melt.
   * @param config Optional parameters.
   * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().
   * @returns MeltProofsResponse with quote and change proofs.
   */
  async meltProofsBolt11(t, e, n, r) {
    return this._meltProofs("bolt11", t, e, n, r);
  }
  /**
   * Melt proofs for a bolt12 melt quote, returns change proofs using specified outputType.
   *
   * @remarks
   * ProofsToSend must be at least amount+fee_reserve from the melt quote. This function does not
   * perform coin selection!.
   * @param meltQuote ID of the melt quote.
   * @param proofsToSend Proofs to melt.
   * @param config Optional parameters.
   * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().
   * @returns MeltProofsResponse with quote and change proofs.
   */
  async meltProofsBolt12(t, e, n, r) {
    return this._meltProofs("bolt12", t, e, n, r);
  }
  /**
   * Melt proofs for a given melt quote created with the bolt11 or bolt12 method.
   *
   * @remarks
   * Creates NUT-08 blanks (1-sat) for Lightning fee return. Get these by setting a
   * config.onChangeOutputsCreated callback for async melting. @see completeMelt.
   * @param method Payment method of the quote.
   * @param meltQuote The bolt11 or bolt12 melt quote.
   * @param proofsToSend Proofs to melt.
   * @param config Optional (keysetId, onChangeOutputsCreated).
   * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().
   * @returns MeltProofsResponse.
   * @throws If params are invalid or mint returns errors.
   * @see https://github.com/cashubtc/nuts/blob/main/08.md.
   */
  async _meltProofs(t, e, n, r, i) {
    var _a, _b, _c;
    i = i ?? this.defaultOutputType();
    const { keysetId: o, onChangeOutputsCreated: a, onCountersReserved: c } = r || {}, u = this.getKeyset(o), l = rt(n), h = l - e.amount;
    let d = [];
    if (this.failIf(h < 0, "Not enough proofs to cover amount + fee reserve", {
      sendAmount: l,
      quoteAmount: e.amount
    }), h > 0) {
      let w = Math.ceil(Math.log2(h)) || 1;
      w < 0 && (w = 0);
      const v = w ? new Array(w).fill(0) : [];
      this._logger.debug("Creating NUT-08 blanks for fee reserve", {
        feeReserve: h,
        denominations: v
      }), i.type === "custom" && this.fail("Custom OutputType not supported for melt change (must be 0-sat blanks)");
      let I = { ...i, denominations: v };
      const U = await this.addCountersToOutputTypes(u.id, I);
      [I] = U.outputTypes, U.used && this.safeCallback(c, U.used, { op: "meltProofs" }), this._logger.debug("melt counter", { counter: U.used, meltOT: I }), d = this.createOutputData(0, u, I);
    }
    n = this._prepareInputsForMint(n);
    const p = {
      quote: e.quote,
      inputs: n,
      outputs: d.map((w) => w.blindedMessage)
    };
    if (d.length > 0) {
      const w = {
        method: t,
        payload: p,
        outputData: d,
        keyset: u,
        quote: e
      };
      this.safeCallback(a, w, { op: "meltProofs" }), this.on._emitMeltBlanksCreated(w);
    }
    let m;
    const P = typeof a == "function";
    t === "bolt12" ? m = await this.mint.meltBolt12(p, { preferAsync: P }) : m = await this.mint.meltBolt11(p, { preferAsync: P }), this.failIf(
      (((_a = m.change) == null ? void 0 : _a.length) ?? 0) > d.length,
      `Mint returned ${((_b = m.change) == null ? void 0 : _b.length) ?? 0} signatures, but only ${d.length} blanks were provided`
    );
    const A = ((_c = m.change) == null ? void 0 : _c.map((w, v) => d[v].toProof(w, u))) ?? [];
    return this._logger.debug("MELT COMPLETED", { changeAmounts: A.map((w) => w.amount) }), { quote: { ...m, unit: e.unit, request: e.request }, change: A };
  }
  /**
   * Completes a pending melt by re-calling the melt endpoint and constructing change proofs.
   *
   * @remarks
   * Use with blanks from onChangeOutputsCreated to retry pending melts. Works for Bolt11/Bolt12.
   * Returns change proofs if paid, else empty change.
   * @param blanks The blanks from onChangeOutputsCreated.
   * @returns Updated MeltProofsResponse.
   * @throws If melt fails or signatures don't match output count.
   */
  async completeMelt(t) {
    var _a, _b, _c;
    const e = t.method === "bolt12" ? await this.mint.meltBolt12(t.payload) : await this.mint.meltBolt11(t.payload);
    this.failIf(
      (((_a = e.change) == null ? void 0 : _a.length) ?? 0) > t.outputData.length,
      `Mint returned ${((_b = e.change) == null ? void 0 : _b.length) ?? 0} signatures, but only ${t.outputData.length} blanks were provided`
    );
    const n = ((_c = e.change) == null ? void 0 : _c.map((r, i) => t.outputData[i].toProof(r, t.keyset))) ?? [];
    return this._logger.debug("COMPLETE MELT", { changeAmounts: n.map((r) => r.amount) }), {
      quote: { ...e, unit: t.quote.unit, request: t.quote.request },
      change: n
    };
  }
  // -----------------------------------------------------------------
  // Section: Proof States
  // -----------------------------------------------------------------
  /**
   * Get an array of the states of proofs from the mint (as an array of CheckStateEnum's)
   *
   * @param proofs (only the `secret` field is required)
   * @returns NUT-07 state for each proof, in same order.
   */
  async checkProofsStates(t) {
    const e = new TextEncoder(), n = t.map(
      (o) => ft(e.encode(o.secret)).toHex(true)
    ), r = 100, i = [];
    for (let o = 0; o < n.length; o += r) {
      const a = n.slice(o, o + r), { states: c } = await this.mint.check({
        Ys: a
      }), u = {};
      c.forEach((l) => {
        u[l.Y] = l;
      });
      for (let l = 0; l < a.length; l++) {
        const h = u[a[l]];
        this.failIfNullish(h, "Could not find state for proof with Y: " + a[l]), i.push(h);
      }
    }
    return i;
  }
  /**
   * Groups proofs by their corresponding state, preserving order within each group.
   *
   * @param proofs (only the `secret` field is required)
   * @returns An object with arrays of proofs grouped by CheckStateEnum state.
   */
  async groupProofsByState(t) {
    const e = await this.checkProofsStates(t), n = {
      unspent: [],
      pending: [],
      spent: []
    };
    for (let r = 0; r < e.length; r++) {
      const i = t[r];
      switch (e[r].state) {
        case Et.UNSPENT:
          n.unspent.push(i);
          break;
        case Et.PENDING:
          n.pending.push(i);
          break;
        case Et.SPENT:
          n.spent.push(i);
          break;
      }
    }
    return n;
  }
};
var os = ((s) => (s.POST = "post", s.NOSTR = "nostr", s))(os || {});
var kt = class kt2 {
  constructor(t, e) {
    this.tokens = {}, this.pool = [], this.desiredPoolSize = 10, this.maxPerMint = 10, this.mintUrl = t, this.req = (e == null ? void 0 : e.request) ?? pe, this.logger = (e == null ? void 0 : e.logger) ?? L, this.desiredPoolSize = Math.max(1, (e == null ? void 0 : e.desiredPoolSize) ?? this.desiredPoolSize), this.maxPerMint = Math.max(1, (e == null ? void 0 : e.maxPerMint) ?? this.maxPerMint);
  }
  // ------------------------------
  // Public API
  // ------------------------------
  /**
   * Attach an OIDCAuth instance so this manager can refresh CATs. Registers a listener to update
   * internal CAT/refresh state on new tokens.
   */
  attachOIDC(t) {
    return this.oidc = t, this.oidc.addTokenListener((e) => this.updateFromOIDC(e)), this;
  }
  get poolSize() {
    return this.pool.length;
  }
  get poolTarget() {
    return this.desiredPoolSize;
  }
  get activeAuthKeysetId() {
    var _a;
    try {
      return (_a = this.keychain) == null ? void 0 : _a.getCheapestKeyset().id;
    } catch {
      return;
    }
  }
  get hasCAT() {
    return !!this.tokens.accessToken;
  }
  // ------------------------------
  // AuthProvider (NUT-21, Clear-auth)
  // ------------------------------
  getCAT() {
    return this.tokens.accessToken;
  }
  setCAT(t) {
    this.tokens.accessToken = t, t || (this.tokens.refreshToken = void 0, this.tokens.expiresAt = void 0);
  }
  /**
   * Ensure a valid CAT is available (refresh if expiring soon). Returns a token safe to send right
   * now, or undefined if unobtainable.
   */
  async ensureCAT(t) {
    return this.validForAtLeast(t) ? this.tokens.accessToken : !this.oidc || !this.tokens.refreshToken ? this.tokens.accessToken : (this.inflightRefresh || (this.inflightRefresh = (async () => {
      try {
        const e = await this.oidc.refresh(this.tokens.refreshToken);
        this.updateFromOIDC(e);
      } catch (e) {
        this.logger.warn("AuthManager: CAT refresh failed", { err: e });
      } finally {
        this.inflightRefresh = void 0;
      }
    })()), await this.inflightRefresh, this.validForAtLeast(0) ? this.tokens.accessToken : void 0);
  }
  // Returns true if expiry date is >minValidSecs away
  validForAtLeast(t = kt2.MIN_VALID_SECS) {
    const { accessToken: e, expiresAt: n } = this.tokens;
    return e ? n ? Date.now() + t * 1e3 < n : true : false;
  }
  // Updates access and refresh tokens in our store, using either the explicit expires_in key or falling back to the JWT expiry.
  updateFromOIDC(t) {
    if (!t.access_token)
      return;
    const e = Date.now();
    if (this.tokens.accessToken = t.access_token, t.refresh_token && (this.tokens.refreshToken = t.refresh_token), typeof t.expires_in == "number" && t.expires_in > 0)
      this.tokens.expiresAt = e + t.expires_in * 1e3;
    else {
      const n = this.parseJwtExpSec(t.access_token);
      this.tokens.expiresAt = n ? n * 1e3 : void 0;
    }
    this.logger.debug("AuthManager: OIDC tokens updated", { expiresAt: this.tokens.expiresAt });
  }
  // ------------------------------
  // AuthProvider (NUT-22, Blind-auth)
  // ------------------------------
  /**
   * Ensure there are enough BAT tokens (topping up if needed)
   *
   * @param minTokens Minimum tokens needed.
   */
  async ensure(t) {
    if (await this.init(), this.pool.length >= t)
      return;
    const e = Math.max(this.desiredPoolSize, t), n = this.getBatMaxMint(), r = Math.min(e - this.pool.length, n);
    r <= 0 || await this.topUp(r);
  }
  /**
   * Gets a Blind Authentication Token (BAT)
   *
   * @param {method, path} to Call (not used in our implementation)
   * @returns The serialized BAT ready to insert into request header.
   */
  async getBlindAuthToken({
    method: t,
    path: e
  }) {
    return this.info && !this.info.requiresBlindAuthToken(t, e) && this.logger.warn("Endpoint is not marked as protected by NUT-22; still issuing BAT", {
      method: t,
      path: e
    }), this.withLock(async () => {
      if (await this.ensure(1), this.pool.length === 0)
        throw new Error("AuthManager: no BATs available and minting failed");
      const n = this.pool.pop();
      return this.logger.debug("AuthManager: BAT requested", {
        method: t,
        path: e,
        remaining: this.pool.length
      }), as(n);
    });
  }
  /**
   * Replace or merge the current BAT pool with previously persisted BATs.
   */
  importPool(t, e = "replace") {
    e === "replace" && (this.pool = []);
    const n = new Map(this.pool.map((r) => [r.secret, r]));
    for (const r of t)
      !r || !r.secret || !r.C || !r.id || n.has(r.secret) || (this.pool.push(r), n.set(r.secret, r));
  }
  /**
   * Return a deep-copied snapshot of the current BAT pool (full Proofs, including dleq).
   */
  exportPool() {
    return this.pool.map((t) => ({ ...t, dleq: t.dleq ? { ...t.dleq } : void 0 }));
  }
  // ------------------------------
  // Internals
  // ------------------------------
  /**
   * Extract exp, seconds since epoch, from a JWT access token.
   */
  parseJwtExpSec(t) {
    if (!t)
      return;
    const e = t.split(".");
    if (e.length === 3)
      try {
        const n = _.toString(_.fromBase64(e[1])), r = JSON.parse(n), i = typeof r.exp == "number" ? r.exp : Number(r.exp);
        if (Number.isFinite(i) && i > 0)
          return i;
      } catch {
        this.logger.warn("JWT access token was malformed.", {
          token: t
        });
      }
  }
  /**
   * Simple mutex lock - chains promises in order.
   */
  async withLock(t) {
    const e = this.lockChain ?? Promise.resolve();
    let n;
    const r = new Promise((o) => {
      n = o;
    }), i = e.then(() => r);
    this.lockChain = i;
    try {
      return await e, await t();
    } finally {
      n(), this.lockChain === i && (this.lockChain = void 0);
    }
  }
  /**
   * Initialise mint info and auth keysets/keys as needed.
   */
  async init() {
    if (!this.info) {
      const t = await this.req({
        endpoint: W(this.mintUrl, "/v1/info"),
        method: "GET"
      });
      this.info = new wt(t);
    }
    if (!this.keychain) {
      const [t, e] = await Promise.all([
        this.req({
          endpoint: W(this.mintUrl, "/v1/auth/blind/keysets"),
          method: "GET"
        }),
        this.req({
          endpoint: W(this.mintUrl, "/v1/auth/blind/keys"),
          method: "GET"
        })
      ]);
      this.keychain = new Ue(this.mintUrl, "auth", t.keysets, e.keysets), this.keychain.getCheapestKeyset();
    }
  }
  /**
   * Gets the BAT minting limit: lower of manager limit and Mint‚Äôs NUT-22 limit.
   */
  getBatMaxMint() {
    var _a;
    if (!this.info)
      throw new Error("AuthManager: mint info not loaded");
    const e = ((_a = this.info.nuts[22]) == null ? void 0 : _a.bat_max_mint) ?? this.maxPerMint;
    return Math.max(1, Math.min(this.maxPerMint, e));
  }
  getActiveKeys() {
    if (!this.keychain)
      throw new Error("AuthManager: keyset not loaded for active keyset");
    return this.keychain.getCheapestKeyset();
  }
  /**
   * Mint a batch of BATs using the current CAT if the endpoint is protected by NUT-21.
   */
  async topUp(t) {
    if (!this.info)
      throw new Error("AuthManager: mint info not loaded");
    const e = this.info.requiresClearAuthToken("POST", "/v1/auth/blind/mint");
    let n;
    if (e && (n = await this.ensureCAT(), !n))
      throw new Error(
        "AuthManager: Clear-auth token required for /v1/auth/blind/mint but not available. Authenticate with the mint to obtain a CAT first."
      );
    const r = this.getActiveKeys(), i = N.createRandomData(t, r), o = { outputs: i.map((l) => l.blindedMessage) }, a = {};
    n && (a["Clear-auth"] = n);
    const c = await this.req({
      endpoint: W(this.mintUrl, "/v1/auth/blind/mint"),
      method: "POST",
      headers: a,
      requestBody: o
    });
    if (!Array.isArray(c == null ? void 0 : c.signatures) || c.signatures.length !== i.length)
      throw new Error("AuthManager: bad BAT mint response");
    const u = i.map((l, h) => l.toProof(c.signatures[h], r));
    for (const l of u)
      if (!De(l, r))
        throw new Error("AuthManager: mint returned BAT with invalid DLEQ");
    this.pool.push(...u), this.logger.debug("AuthManager: performed topUp", {
      minted: u.length,
      pool: this.pool.length
    });
  }
};
kt.MIN_VALID_SECS = 30;
var Bt = kt;
function as(s) {
  const t = { id: s.id, secret: s.secret, C: s.C };
  return `authA${me(t)}`;
}
async function Ls(s, t) {
  const e = new Bt(s, {
    desiredPoolSize: (t == null ? void 0 : t.authPool) ?? 10,
    logger: t == null ? void 0 : t.logger
  }), n = new Vt(s, { authProvider: e, logger: t == null ? void 0 : t.logger }), r = await n.oidcAuth({
    ...t == null ? void 0 : t.oidc,
    logger: t == null ? void 0 : t.logger,
    onTokens: (o) => e.setCAT(o.access_token)
    // set CAT automatically
  });
  e.attachOIDC(r);
  const i = new Gt(n, { authProvider: e, logger: t == null ? void 0 : t.logger });
  return await i.loadMint(), { mint: n, auth: e, oidc: r, wallet: i };
}
export {
  Bt as AuthManager,
  Et as CheckStateEnum,
  gs as ConsoleLogger,
  ht as HttpResponseError,
  Ue as KeyChain,
  zn as Keyset,
  ae as MeltBuilder,
  ut as MeltQuoteState,
  Ln as MessageNode,
  $n as MessageQueue,
  Vt as Mint,
  oe as MintBuilder,
  wt as MintInfo,
  Dt as MintOperationError,
  Tt as MintQuoteState,
  Kt as NetworkError,
  zt as OIDCAuth,
  N as OutputData,
  Zt as P2BK_DST,
  Ne as P2PKBuilder,
  Ht as PaymentRequest,
  os as PaymentRequestTransportType,
  ns as ReceiveBuilder,
  es as SendBuilder,
  jn as WSConnection,
  Gt as Wallet,
  is as WalletCounters,
  rs as WalletEvents,
  ts as WalletOps,
  Bs as bigIntStringify,
  gt as blindMessage,
  $ as bytesToNumber,
  qs as checkResponse,
  Sn as constructProofFromPromise,
  Ls as createAuthWallet,
  vs as createBlindSignature,
  Cs as createDLEQProof,
  Is as createNewMintKeys,
  ys as createP2PKsecret,
  Es as createRandomBlindedMessage,
  ve as createRandomSecretKey,
  Us as decodePaymentRequest,
  ne as deepEqual,
  Bn as deriveBlindingFactor,
  Qt as deriveKeysetId,
  gn as deriveP2BKBlindedPubkeys,
  mn as deriveP2BKSecretKey,
  pn as deriveP2BKSecretKeys,
  xn as deriveSecret,
  Ts as deserializeMintKeys,
  Ss as deserializeProof,
  Fn as getDecodedToken,
  Fs as getDecodedTokenBinary,
  Os as getEncodedToken,
  Ns as getEncodedTokenBinary,
  Rn as getEncodedTokenV3,
  Nn as getEncodedTokenV4,
  Un as getKeepAmounts,
  Te as getKeysetAmounts,
  vn as getKeysetIdInt,
  $t as getP2PKExpectedKWitnessPubkeys,
  _e as getP2PKLocktime,
  kn as getP2PKNSigs,
  ks as getP2PKSigFlag,
  ke as getP2PKWitnessPubkeys,
  be as getP2PKWitnessRefundkeys,
  Wt as getP2PKWitnessSignatures,
  Mn as getPubKeyFromPrivKey,
  Pe as getSignedOutput,
  Ps as getSignedOutputs,
  Ks as getTokenMetadata,
  Be as handleTokens,
  Ie as hasCorrespondingKey,
  jt as hasNonHexId,
  ws as hasP2PKSignedProof,
  De as hasValidDleq,
  ft as hashToCurve,
  Ae as hash_e,
  dt as hexToNumber,
  ms as injectWebSocketImpl,
  T as isObj,
  Ct as isValidHex,
  W as joinUrls,
  Pn as maybeDeriveP2BKPrivateKeys,
  Pt as mergeUInt8Arrays,
  Mt as numberToHexPadded64,
  Q as parseP2PKSecret,
  As as pointFromBytes,
  X as pointFromHex,
  Oe as sanitizeUrl,
  Yn as selectProofsRGLI,
  In as serializeMintKeys,
  Tn as serializeProof,
  ps as setGlobalRequestOptions,
  wn as signBlindedMessage,
  qn as signMintQuote,
  _n as signP2PKProof,
  bn as signP2PKProofs,
  yn as signP2PKSecret,
  Ds as sortProofsById,
  G as splitAmount,
  Ke as stripDleq,
  rt as sumProofs,
  En as unblindSignature,
  Kn as verifyDLEQProof,
  Dn as verifyDLEQProof_reblind,
  Rs as verifyKeysetId,
  xs as verifyMintQuoteSignature,
  Lt as verifyP2PKSecretSignature,
  bs as verifyP2PKSig,
  _s as verifyP2PKSigOutput,
  Ms as verifyProof
};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip32/lib/esm/index.js:
  (*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=@cashu_cashu-ts.js.map
