{"version":3,"file":"cashu-ts.es.js","sources":["../src/mint/types/responses.ts","../src/model/Errors.ts","../src/logger/NullLogger.ts","../src/logger/helpers.ts","../src/logger/ConsoleLogger.ts","../src/transport/request.ts","../src/transport/ws.ts","../src/utils/Bytes.ts","../src/utils/base64.ts","../src/utils/cbor.ts","../src/crypto/NUT26.ts","../src/crypto/NUT11.ts","../src/crypto/core.ts","../src/crypto/NUT01.ts","../src/crypto/NUT13.ts","../src/crypto/NUT12.ts","../src/crypto/NUT20.ts","../src/model/PaymentRequest.ts","../src/utils/core.ts","../src/transport/WSConnection.ts","../src/legacy/nut-05.ts","../src/legacy/nut-04.ts","../src/legacy/nut-06.ts","../src/model/MintInfo.ts","../src/auth/OIDCAuth.ts","../src/mint/Mint.ts","../src/wallet/Keyset.ts","../src/wallet/KeyChain.ts","../src/model/BlindedMessage.ts","../src/model/OutputData.ts","../src/wallet/P2PKBuilder.ts","../src/wallet/SelectProofs.ts","../src/wallet/CounterSource.ts","../src/wallet/WalletOps.ts","../src/wallet/WalletEvents.ts","../src/wallet/WalletCounters.ts","../src/model/types/proof-state.ts","../src/wallet/Wallet.ts","../src/wallet/types/payment-requests.ts","../src/auth/AuthManager.ts","../src/auth/createAuthWallet.ts"],"sourcesContent":["import type {\n\tSerializedBlindedMessage,\n\tSerializedBlindedSignature,\n} from '../../model/types/blinded';\nimport type { ProofState } from '../../model/types/proof-state';\n\n/**\n * Cashu api error.\n */\nexport type ApiError = {\n\t/**\n\t * Error message.\n\t */\n\terror?: string;\n\t/**\n\t * HTTP error code.\n\t */\n\tcode?: number;\n\t/**\n\t * Detailed error message.\n\t */\n\tdetail?: string;\n};\n\n/**\n * Response when checking proofs if they are spendable. Should not rely on this for receiving, since\n * it can be easily cheated.\n */\nexport type CheckStateResponse = {\n\tstates: ProofState[];\n} & ApiError;\n\n/**\n * Response from mint at /info endpoint.\n */\nexport type GetInfoResponse = {\n\tname: string;\n\tpubkey: string;\n\tversion: string;\n\tdescription?: string;\n\tdescription_long?: string;\n\ticon_url?: string;\n\tcontact: MintContactInfo[];\n\tnuts: {\n\t\t'4': {\n\t\t\t// Minting\n\t\t\tmethods: SwapMethod[];\n\t\t\tdisabled: boolean;\n\t\t};\n\t\t'5': {\n\t\t\t// Melting\n\t\t\tmethods: SwapMethod[];\n\t\t\tdisabled: boolean;\n\t\t};\n\t\t'7'?: {\n\t\t\t// Token state check\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'8'?: {\n\t\t\t// Overpaid melt fees\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'9'?: {\n\t\t\t// Restore\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'10'?: {\n\t\t\t// Spending conditions\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'11'?: {\n\t\t\t// P2PK\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'12'?: {\n\t\t\t// DLEQ\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'14'?: {\n\t\t\t// HTLCs\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'15'?: {\n\t\t\t// MPP\n\t\t\tmethods: MPPMethod[];\n\t\t};\n\t\t'17'?: {\n\t\t\t// WebSockets\n\t\t\tsupported: WebSocketSupport[];\n\t\t};\n\t\t'20'?: {\n\t\t\t// Locked Mint Quote\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'21'?: {\n\t\t\t// Clear Authentication\n\t\t\topenid_discovery: string;\n\t\t\tclient_id: string;\n\t\t\tprotected_endpoints?: Array<{ method: 'GET' | 'POST'; path: string }>;\n\t\t};\n\t\t'22'?: {\n\t\t\t// Blind Authentication\n\t\t\tbat_max_mint: number;\n\t\t\tprotected_endpoints: Array<{ method: 'GET' | 'POST'; path: string }>;\n\t\t};\n\t};\n\tmotd?: string;\n};\n\n/**\n * Response from the mint after requesting a melt quote.\n */\nexport type PartialMeltQuoteResponse = {\n\t/**\n\t * Quote ID.\n\t */\n\tquote: string;\n\t/**\n\t * Amount to be melted.\n\t */\n\tamount: number;\n\t/**\n\t * Fee reserve to be added to the amount.\n\t */\n\tfee_reserve: number;\n\t/**\n\t * State of the melt quote.\n\t */\n\tstate: MeltQuoteState;\n\t/**\n\t * Timestamp of when the quote expires.\n\t */\n\texpiry: number;\n\t/**\n\t * Preimage of the paid invoice. is null if it the invoice has not been paid yet. can be null,\n\t * depending on which LN-backend the mint uses.\n\t */\n\tpayment_preimage: string | null;\n\t/**\n\t * Return/Change from overpaid fees. This happens due to Lighting fee estimation being inaccurate.\n\t */\n\tchange?: SerializedBlindedSignature[];\n\t/**\n\t * Payment request for the melt quote.\n\t */\n\trequest?: string;\n\t/**\n\t * Unit of the melt quote.\n\t */\n\tunit?: string;\n} & ApiError;\n\nexport type MeltQuoteResponse = PartialMeltQuoteResponse & { request: string; unit: string };\n\n/**\n * Response from the mint after requesting a BOLT12 melt quote. Contains payment details and state\n * for paying Lightning Network offers.\n */\nexport type Bolt12MeltQuoteResponse = MeltQuoteResponse;\n\nexport const MeltQuoteState = {\n\tUNPAID: 'UNPAID',\n\tPENDING: 'PENDING',\n\tPAID: 'PAID',\n} as const;\nexport type MeltQuoteState = (typeof MeltQuoteState)[keyof typeof MeltQuoteState];\n\nexport type MintContactInfo = {\n\tmethod: string;\n\tinfo: string;\n};\n\nexport const MintQuoteState = {\n\tUNPAID: 'UNPAID',\n\tPAID: 'PAID',\n\tISSUED: 'ISSUED',\n} as const;\nexport type MintQuoteState = (typeof MintQuoteState)[keyof typeof MintQuoteState];\n\n/**\n * Response from the mint after requesting a mint.\n */\nexport type PartialMintQuoteResponse = {\n\t/**\n\t * Payment request.\n\t */\n\trequest: string;\n\t/**\n\t * Quote ID.\n\t */\n\tquote: string;\n\t/**\n\t * State of the mint quote.\n\t */\n\tstate: MintQuoteState;\n\t/**\n\t * Timestamp of when the quote expires.\n\t */\n\texpiry: number;\n\t/**\n\t * Public key the quote is locked to.\n\t */\n\tpubkey?: string;\n\t/**\n\t * Unit of the quote.\n\t */\n\tunit?: string;\n\t/**\n\t * Amount requested for mint quote.\n\t */\n\tamount?: number;\n} & ApiError;\n\nexport type MintQuoteResponse = PartialMintQuoteResponse & { amount: number; unit: string };\n\nexport type LockedMintQuoteResponse = MintQuoteResponse & { pubkey: string };\n\n/**\n * Response from the mint after requesting a BOLT12 mint quote. Contains a Lightning Network offer\n * and tracks payment/issuance amounts.\n */\nexport type Bolt12MintQuoteResponse = {\n\t/**\n\t * Quote identifier.\n\t */\n\tquote: string;\n\t/**\n\t * BOLT12 offer that can be paid to mint tokens.\n\t */\n\trequest: string;\n\t/**\n\t * Requested amount. This is null for amount-less offers.\n\t */\n\tamount: number | null;\n\t/**\n\t * Unit of the amount.\n\t */\n\tunit: string;\n\t/**\n\t * Unix timestamp when quote expires.\n\t */\n\texpiry: number | null;\n\t/**\n\t * Public key that locked this quote.\n\t */\n\tpubkey: string;\n\t/**\n\t * The amount that has been paid to the mint via the bolt12 offer. The difference between this and\n\t * `amount_issued` can be minted.\n\t */\n\tamount_paid: number;\n\t/**\n\t * The amount of ecash that has been issued for the given mint quote.\n\t */\n\tamount_issued: number;\n};\n\n/**\n * Response from the mint after requesting a mint.\n */\nexport type MintResponse = {\n\tsignatures: SerializedBlindedSignature[];\n} & ApiError;\n\n/**\n * Response from mint at /v1/restore endpoint.\n */\nexport type PostRestoreResponse = {\n\toutputs: SerializedBlindedMessage[];\n\tsignatures: SerializedBlindedSignature[];\n};\n\n/**\n * Ecash to other MoE swap method, displayed in @type {GetInfoResponse}\n */\nexport type SwapMethod = {\n\tmethod: string;\n\tunit: string;\n\tmin_amount: number;\n\tmax_amount: number;\n\tdescription?: boolean; //added this for Nutshell =>0.16.4 compatibility, see https://github.com/cashubtc/nutshell/pull/783\n\toptions?: {\n\t\tdescription?: boolean;\n\t};\n};\n\n/**\n * Response from the mint after performing a split action.\n */\nexport type SwapResponse = {\n\t/**\n\t * Represents the outputs after the split.\n\t */\n\tsignatures: SerializedBlindedSignature[];\n} & ApiError;\n\n/**\n * MPP supported methods.\n */\nexport type MPPMethod = {\n\tmethod: string;\n\tunit: string;\n};\n\n/**\n * WebSocket supported methods.\n */\nexport type WebSocketSupport = {\n\tmethod: string;\n\tunit: string;\n\tcommands: string[];\n};\n\n/**\n * Response from the mint after blind auth minting.\n */\nexport type BlindAuthMintResponse = {\n\tsignatures: SerializedBlindedSignature[];\n} & ApiError;\n","/**\n * This error is thrown when a HTTP response is not 2XX nor a protocol error.\n */\nexport class HttpResponseError extends Error {\n\tstatus: number;\n\tconstructor(message: string, status: number) {\n\t\tsuper(message);\n\t\tthis.status = status;\n\t\tthis.name = 'HttpResponseError';\n\t\tObject.setPrototypeOf(this, HttpResponseError.prototype);\n\t}\n}\n\n/**\n * This error is thrown when a network request fails.\n */\nexport class NetworkError extends Error {\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = 'NetworkError';\n\t\tObject.setPrototypeOf(this, NetworkError.prototype);\n\t}\n}\n\n/**\n * This error is thrown when a [protocol\n * error](https://github.com/cashubtc/nuts/blob/main/00.md#errors) occurs. See error codes\n * [here](https://github.com/cashubtc/nuts/blob/main/error_codes.md).\n */\nexport class MintOperationError extends HttpResponseError {\n\tcode: number;\n\tconstructor(code: number, detail: string) {\n\t\tsuper(detail || 'Unknown mint operation error', 400);\n\t\tthis.code = code;\n\t\tthis.name = 'MintOperationError';\n\t\tObject.setPrototypeOf(this, MintOperationError.prototype);\n\t}\n}\n","import type { Logger } from './Logger';\n\n// The default logger implementation - does nothing\n/* eslint-disable @typescript-eslint/no-empty-function */\nexport const NULL_LOGGER: Logger = {\n\terror() {},\n\twarn() {},\n\tinfo() {},\n\tdebug() {},\n\ttrace() {},\n\tlog() {},\n};\n/* eslint-enable @typescript-eslint/no-empty-function */\n","import { type Logger } from './Logger';\nimport { NULL_LOGGER } from './NullLogger';\n\n/**\n * Log at ERROR and throw. Always throws.\n *\n * @param message - Error message to log and throw.\n * @param logger - Logger to use, defaults to NULL_LOGGER.\n * @param context - Optional structured context for the log.\n * @throws {Error} Always throws with the given message.\n */\nexport function fail(\n\tmessage: string,\n\tlogger: Logger = NULL_LOGGER,\n\tcontext?: Record<string, unknown>,\n): never {\n\tlogger.error(message, context);\n\tthrow new Error(message);\n}\n\n/**\n * Throw if a Boolean condition is true. On return, the compiler knows the condition is false.\n *\n * @param condition - Condition that must be false to continue.\n * @param message - Error message if condition is true.\n * @param logger - Logger to use, defaults to NULL_LOGGER.\n * @param context - Optional structured context for the log.\n * @throws {Error} If condition is true, throws with the given message.\n */\nexport function failIf(\n\tcondition: boolean,\n\tmessage: string,\n\tlogger: Logger = NULL_LOGGER,\n\tcontext?: Record<string, unknown>,\n): asserts condition is false {\n\tif (condition) fail(message, logger, context);\n}\n\n/**\n * Throw if a value is null or undefined. Value is narrowed thereafter.\n *\n * @typeParam T - The value type to check.\n * @param value - The value to validate.\n * @param message - Error message if value is nullish.\n * @param logger - Logger to use, defaults to NULL_LOGGER.\n * @param context - Optional structured context for the log.\n * @throws {Error} If value is null or undefined.\n */\nexport function failIfNullish<T>(\n\tvalue: T,\n\tmessage: string,\n\tlogger: Logger = NULL_LOGGER,\n\tcontext?: Record<string, unknown>,\n): asserts value is Exclude<T, null | undefined> {\n\tif (value == null) fail(message, logger, context);\n}\n\n/**\n * Invoke a user-supplied callback safely in a fire-and-forget manner.\n *\n * Used for per-operation hooks (e.g. `onCountersReserved`, `onChangeOutputsCreated`) where user\n * code must never break the wallet’s control flow. The callback is invoked synchronously,\n * exceptions are caught and logged (as a warning), and then swallowed.\n *\n * The wallet never `await`s the callback.\n *\n * @example\n *\n * ```ts\n * if (autoCounters.used) {\n * \tsafeCallback(onCountersReserved, autoCounters.used, _logger, { keysetId });\n * }\n * ```\n *\n * @typeParam T Type of the payload passed to the callback.\n * @param cb The callback to invoke, or `undefined`.\n * @param payload The payload to pass to the callback.\n * @param logger Logger to use (defaults to NULL_LOGGER).\n * @param context Optional structured context for the log.\n */\nexport function safeCallback<T>(\n\tcb: ((p: T) => void | Promise<void>) | undefined,\n\tpayload: T,\n\tlogger: Logger = NULL_LOGGER,\n\tcontext?: Record<string, unknown>,\n): void {\n\tif (!cb) return;\n\n\ttry {\n\t\tconst maybePromise = cb(payload);\n\t\tif (maybePromise && typeof maybePromise.then === 'function') {\n\t\t\tmaybePromise.catch((error) => {\n\t\t\t\ttry {\n\t\t\t\t\tlogger.warn('callback failed', {\n\t\t\t\t\t\t...(context ?? {}),\n\t\t\t\t\t\terror,\n\t\t\t\t\t\tcb: cb.name ?? '',\n\t\t\t\t\t});\n\t\t\t\t} catch {\n\t\t\t\t\t/* ignore logger errors */\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t} catch (error) {\n\t\ttry {\n\t\t\tlogger.warn('callback failed', {\n\t\t\t\t...(context ?? {}),\n\t\t\t\terror,\n\t\t\t\tcb: cb.name ?? '',\n\t\t\t});\n\t\t} catch {\n\t\t\t/* ignore logger errors */\n\t\t}\n\t}\n}\n","import { type Logger, type LogLevel } from './Logger';\n\nconst LEVEL_ORDER: Record<LogLevel, number> = {\n\terror: 0,\n\twarn: 1,\n\tinfo: 2,\n\tdebug: 3,\n\ttrace: 4,\n};\n\n/**\n * Outputs messages to the console based on the specified log level.\n *\n * Supports placeholder substitution in messages (e.g., `{key}`) using values from the optional\n * `context` object. Context keys not used in substitution are appended to the output as additional\n * data. Each log message is prefixed with the log level in square brackets (e.g., `[INFO]`).\n *\n * @example Const logger = new ConsoleLogger(LogLevel.DEBUG); logger.info('User {username} logged\n * in', { username: 'alice', ip: '127.0.0.1' }); // Output: [INFO] User alice logged in { ip:\n * \"127.0.0.1\" }\n */\nexport class ConsoleLogger implements Logger {\n\tprivate minLevel: LogLevel;\n\n\tconstructor(minLevel: LogLevel = 'info') {\n\t\tthis.minLevel = minLevel;\n\t}\n\n\tprivate should(level: LogLevel): boolean {\n\t\treturn LEVEL_ORDER[level] <= LEVEL_ORDER[this.minLevel];\n\t}\n\tprivate method(level: LogLevel): (msg: string, ...rest: unknown[]) => void {\n\t\tswitch (level) {\n\t\t\tcase 'error':\n\t\t\t\treturn console.error;\n\t\t\tcase 'warn':\n\t\t\t\treturn console.warn;\n\t\t\tcase 'info':\n\t\t\t\treturn console.info;\n\t\t\tcase 'debug':\n\t\t\t\treturn console.debug;\n\t\t\tcase 'trace':\n\t\t\t\treturn console.trace;\n\t\t\tdefault:\n\t\t\t\treturn console.log;\n\t\t}\n\t}\n\tprivate header(level: LogLevel, message: string): string {\n\t\treturn `[${level.toUpperCase()}] ${message}`;\n\t}\n\tprivate flattenContext(ctx?: Record<string, unknown>): Record<string, unknown> | undefined {\n\t\tif (!ctx) return undefined;\n\t\tconst out: Record<string, unknown> = {};\n\t\tfor (const [k, v] of Object.entries(ctx)) {\n\t\t\tout[k] = v instanceof Error ? { message: v.message, stack: v.stack } : v;\n\t\t}\n\t\treturn out;\n\t}\n\tprivate emit(level: LogLevel, message: string, context?: Record<string, unknown>) {\n\t\tif (!this.should(level)) return;\n\t\tconst line = this.header(level, message);\n\t\tconst ctx = this.flattenContext(context);\n\t\tconst fn = this.method(level);\n\t\tif (ctx && Object.keys(ctx).length) fn(line, ctx);\n\t\telse fn(line);\n\t}\n\n\terror(msg: string, ctx?: Record<string, unknown>) {\n\t\tthis.emit('error', msg, ctx);\n\t}\n\twarn(msg: string, ctx?: Record<string, unknown>) {\n\t\tthis.emit('warn', msg, ctx);\n\t}\n\tinfo(msg: string, ctx?: Record<string, unknown>) {\n\t\tthis.emit('info', msg, ctx);\n\t}\n\tdebug(msg: string, ctx?: Record<string, unknown>) {\n\t\tthis.emit('debug', msg, ctx);\n\t}\n\ttrace(msg: string, ctx?: Record<string, unknown>) {\n\t\tthis.emit('trace', msg, ctx);\n\t}\n\n\tlog(level: LogLevel, message: string, context?: Record<string, unknown>) {\n\t\tthis.emit(level, message, context);\n\t}\n}\n\n/**\n * Creates a timer to measure elapsed time in milliseconds.\n *\n * @example Const timer = measureTime(); // ... some code ... const duration = timer.elapsed();\n *\n * @returns An object with an `elapsed` method to retrieve the duration since the timer started.\n */\nexport function measureTime() {\n\tconst start = Date.now();\n\treturn {\n\t\telapsed: () => {\n\t\t\treturn Date.now() - start;\n\t\t},\n\t};\n}\n","import { HttpResponseError, NetworkError, MintOperationError } from '../model/Errors';\nimport { type Logger, NULL_LOGGER } from '../logger';\nimport { type ApiError } from '../mint/types/responses';\n\n// Generic request function type so callers can do requestInstance<T>(...)\nexport type RequestFn = <T = unknown>(args: RequestOptions) => Promise<T>;\n\nexport type RequestArgs = {\n\tendpoint: string;\n\trequestBody?: Record<string, unknown>;\n\theaders?: Record<string, string>;\n\tlogger?: Logger;\n};\n\nexport type RequestOptions = RequestArgs & Omit<RequestInit, 'body' | 'headers'>;\n\nlet globalRequestOptions: Partial<RequestOptions> = {};\nlet requestLogger = NULL_LOGGER;\n\n/**\n * An object containing any custom settings that you want to apply to the global fetch method.\n *\n * @param options See possible options here:\n *   https://developer.mozilla.org/en-US/docs/Web/API/fetch#options.\n */\nexport function setGlobalRequestOptions(options: Partial<RequestOptions>): void {\n\tglobalRequestOptions = options;\n}\n\n/**\n * Allows a logger to be set.\n *\n * @param {Logger} logger The logger instance to use.\n */\nexport function setRequestLogger(logger: Logger): void {\n\trequestLogger = logger;\n}\n\nasync function _request({\n\tendpoint,\n\trequestBody,\n\theaders: requestHeaders,\n\t...options\n}: RequestOptions): Promise<unknown> {\n\tconst body = requestBody ? JSON.stringify(requestBody) : undefined;\n\tconst headers = {\n\t\t...{ Accept: 'application/json, text/plain, */*' },\n\t\t...(body ? { 'Content-Type': 'application/json' } : undefined),\n\t\t...requestHeaders,\n\t};\n\n\tlet response: Response;\n\ttry {\n\t\tresponse = await fetch(endpoint, { body, headers, ...options });\n\t} catch (err) {\n\t\t// A fetch() promise only rejects when the request fails,\n\t\t// for example, because of a badly-formed request URL or a network error.\n\t\tthrow new NetworkError(err instanceof Error ? err.message : 'Network request failed');\n\t}\n\n\tif (!response.ok) {\n\t\tlet errorData: ApiError;\n\t\ttry {\n\t\t\terrorData = (await response.json()) as ApiError;\n\t\t} catch {\n\t\t\terrorData = { error: 'bad response' };\n\t\t}\n\n\t\tif (\n\t\t\tresponse.status === 400 &&\n\t\t\t'code' in errorData &&\n\t\t\ttypeof errorData.code === 'number' &&\n\t\t\t'detail' in errorData &&\n\t\t\ttypeof errorData.detail === 'string'\n\t\t) {\n\t\t\tthrow new MintOperationError(errorData.code, errorData.detail);\n\t\t}\n\n\t\tlet errorMessage = 'HTTP request failed';\n\t\tif ('error' in errorData && typeof errorData.error === 'string') {\n\t\t\terrorMessage = errorData.error;\n\t\t} else if ('detail' in errorData && typeof errorData.detail === 'string') {\n\t\t\terrorMessage = errorData.detail;\n\t\t}\n\n\t\tthrow new HttpResponseError(errorMessage, response.status);\n\t}\n\n\ttry {\n\t\treturn await response.json();\n\t} catch (err) {\n\t\trequestLogger.error('Failed to parse HTTP response', { err });\n\t\tthrow new HttpResponseError('bad response', response.status);\n\t}\n}\n\nexport default async function request<T>(options: RequestOptions): Promise<T> {\n\tconst data = await _request({ ...options, ...globalRequestOptions });\n\treturn data as T;\n}\n","let _WS: typeof WebSocket | undefined;\n\nif (typeof WebSocket !== 'undefined') {\n\t_WS = WebSocket;\n}\n\nexport function injectWebSocketImpl(ws: typeof WebSocket) {\n\t_WS = ws;\n}\n\nexport function getWebSocketImpl() {\n\tif (_WS === undefined) {\n\t\tthrow new Error('WebSocket implementation not initialized');\n\t}\n\treturn _WS;\n}\n","export class Bytes {\n\tstatic fromHex(hex: string): Uint8Array {\n\t\thex = hex.trim();\n\t\tif (hex.length === 0) {\n\t\t\treturn new Uint8Array(0);\n\t\t}\n\t\tif (hex.length < 2 || hex.length & 1) {\n\t\t\tthrow new Error('Invalid hex string: odd length.');\n\t\t}\n\t\tif (hex.startsWith('0x') || hex.startsWith('0X')) {\n\t\t\thex = hex.slice(2);\n\t\t}\n\t\tconst match = hex.match(/^[0-9a-fA-F]*$/);\n\t\tif (!match) {\n\t\t\tthrow new Error('Invalid hex string: contains non-hex characters');\n\t\t}\n\t\tconst matches = hex.match(/.{1,2}/g);\n\t\tif (!matches) {\n\t\t\tthrow new Error('Invalid hex string');\n\t\t}\n\t\treturn new Uint8Array(matches.map((byte) => parseInt(byte, 16)));\n\t}\n\n\tstatic toHex(bytes: Uint8Array): string {\n\t\treturn Array.from(bytes, (byte) => byte.toString(16).padStart(2, '0')).join('');\n\t}\n\n\tstatic fromString(str: string): Uint8Array {\n\t\tstr = str.trim();\n\t\treturn new TextEncoder().encode(str);\n\t}\n\n\tstatic toString(bytes: Uint8Array): string {\n\t\treturn new TextDecoder('utf-8').decode(bytes);\n\t}\n\n\tstatic concat(...arrays: Uint8Array[]): Uint8Array {\n\t\tconst totalLength = arrays.reduce((sum, arr) => sum + arr.length, 0);\n\t\tconst result = new Uint8Array(totalLength);\n\t\tlet offset = 0;\n\t\tfor (const arr of arrays) {\n\t\t\tresult.set(arr, offset);\n\t\t\toffset += arr.length;\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic alloc(size: number): Uint8Array {\n\t\treturn new Uint8Array(size);\n\t}\n\n\tstatic writeBigUint64BE(value: bigint): Uint8Array {\n\t\tconst buffer = new ArrayBuffer(8);\n\t\tnew DataView(buffer).setBigUint64(0, value, false);\n\t\treturn new Uint8Array(buffer);\n\t}\n\n\tstatic toBase64(bytes: Uint8Array): string {\n\t\tif (typeof Buffer !== 'undefined') {\n\t\t\treturn Buffer.from(bytes).toString('base64');\n\t\t}\n\t\t// preventing stack overflow by chunking\n\t\tif (bytes.length > 32768) {\n\t\t\tlet result = '';\n\t\t\tfor (let i = 0; i < bytes.length; i += 32768) {\n\t\t\t\tconst chunk = bytes.slice(i, i + 32768);\n\t\t\t\tresult += btoa(String.fromCharCode(...chunk));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\treturn btoa(String.fromCharCode(...bytes));\n\t}\n\n\tstatic fromBase64(base64: string): Uint8Array {\n\t\tbase64 = base64.trim();\n\t\t// normalise base64url to base64 and pad\n\t\tlet normalizedBase64 = base64.replace(/-/g, '+').replace(/_/g, '/');\n\t\twhile (normalizedBase64.length % 4) {\n\t\t\tnormalizedBase64 += '=';\n\t\t}\n\t\tif (typeof Buffer !== 'undefined') {\n\t\t\treturn new Uint8Array(Buffer.from(normalizedBase64, 'base64'));\n\t\t}\n\t\treturn new Uint8Array([...atob(normalizedBase64)].map((c) => c.charCodeAt(0)));\n\t}\n\t// NOTE: MUST remain a constant-time implementation (full byte check)\n\t// because callers rely on it (e.g. deriveP2BKSecretKey).\n\tstatic equals(a: Uint8Array, b: Uint8Array): boolean {\n\t\tif (a.length !== b.length) return false;\n\t\tlet result = 0;\n\t\tfor (let i = 0; i < a.length; i++) {\n\t\t\tresult |= a[i] ^ b[i];\n\t\t}\n\t\treturn result === 0;\n\t}\n\n\tstatic compare(a: Uint8Array, b: Uint8Array): number {\n\t\tconst minLength = Math.min(a.length, b.length);\n\t\tfor (let i = 0; i < minLength; i++) {\n\t\t\tif (a[i] < b[i]) return -1;\n\t\t\tif (a[i] > b[i]) return 1;\n\t\t}\n\t\treturn a.length - b.length;\n\t}\n}\n","import { Bytes } from './Bytes';\n\nfunction encodeUint8toBase64(uint8array: Uint8Array): string {\n\treturn Bytes.toBase64(uint8array);\n}\n\nfunction encodeUint8toBase64Url(bytes: Uint8Array): string {\n\treturn Bytes.toBase64(bytes)\n\t\t.replace(/\\+/g, '-') // Replace + with -\n\t\t.replace(/\\//g, '_') // Replace / with _\n\t\t.replace(/=+$/, ''); // Remove padding characters\n}\n\nfunction encodeBase64toUint8(base64String: string): Uint8Array {\n\treturn Bytes.fromBase64(base64String);\n}\n\nfunction encodeJsonToBase64(jsonObj: unknown): string {\n\tconst jsonString = JSON.stringify(jsonObj);\n\treturn base64urlFromBase64(Bytes.toBase64(Bytes.fromString(jsonString)));\n}\n\nfunction encodeBase64ToJson<T extends object>(base64String: string): T {\n\tconst jsonString = Bytes.toString(Bytes.fromBase64(base64urlToBase64(base64String)));\n\tconst jsonObj = JSON.parse(jsonString) as T;\n\treturn jsonObj;\n}\n\nfunction base64urlToBase64(str: string) {\n\treturn str.replace(/-/g, '+').replace(/_/g, '/').split('=')[0];\n\t// .replace(/./g, '=');\n}\n\nfunction base64urlFromBase64(str: string) {\n\treturn str.replace(/\\+/g, '-').replace(/\\//g, '_').split('=')[0];\n\t// .replace(/=/g, '.');\n}\n\nfunction isBase64String(s: string): boolean {\n\tif (typeof s !== 'string' || s.length === 0) return false;\n\n\t// Accept both base64 and base64url char sets\n\tconst base64url = /^[A-Za-z0-9\\-_]+={0,2}$/;\n\tconst base64 = /^[A-Za-z0-9+/]+={0,2}$/;\n\n\t// Quick character-set check\n\tif (!base64url.test(s) && !base64.test(s)) return false;\n\n\t// Normalize base64url to standard base64 for decoding\n\tconst normalized = s.replace(/-/g, '+').replace(/_/g, '/');\n\n\t// Padding: length must be multiple of 4. Add '=' padding if needed (but no more than 2)\n\tconst padLength = (4 - (normalized.length % 4)) % 4;\n\tif (padLength > 2) return false; // should never happen but keep safe\n\tconst padded = normalized + '='.repeat(padLength);\n\n\ttry {\n\t\tconst decoded = Bytes.fromBase64(padded);\n\n\t\t// Re-encode and compare to the original (allowing either standard or url-safe representation)\n\t\tconst reStandard = Bytes.toBase64(decoded);\n\t\tconst reUrl = reStandard.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n\n\t\t// Also compare against original normalized-without-padding variant\n\t\tconst originalNoPad = normalized.replace(/=+$/, '');\n\n\t\tif (reStandard.replace(/=+$/, '') === originalNoPad) return true;\n\t\tif (reUrl === originalNoPad) return true;\n\n\t\treturn false;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\nexport {\n\tencodeUint8toBase64,\n\tencodeUint8toBase64Url,\n\tencodeBase64toUint8,\n\tencodeJsonToBase64,\n\tencodeBase64ToJson,\n\tisBase64String,\n};\n","/*\n * Lightweight CBOR encoder/decoder (purpose and limitations)\n *\n * Supported\n * - Major types: 0 (unsigned), 1 (negative), 2 (byte string), 3 (text string),\n *   4 (array), 5 (map), 7 (simple values & floats).\n * - Additional-info lengths: short (0..23), 1-, 2- and 4-byte length forms are\n *   encoded by the encoder. The decoder understands 8-byte length fields\n *   (additional-info 27) and will decode them into a JavaScript Number\n *   (hi * 2**32 + lo) but the encoder intentionally does not emit 8-byte\n *   integer forms (see 'Not implemented' below).\n * - Floating point: decoder supports float16/float32/float64. Encoder emits\n *   float64 for non-integers.\n * - Guardrails: explicit throws for unsupported types and sizes (e.g. huge\n *   strings/byte arrays/arrays/maps > 2**32-1, integers larger than 32-bit for\n *   encoding). DataView out-of-bounds reads are normalized to\n *   \"Unexpected end of data\" for clearer errors.\n *\n * Not implemented / intentionally out of scope\n * - Indefinite-length (streaming) containers (indefinite-length arrays,\n *   maps, byte/text strings) are not supported. Test vectors with streaming\n *   markers are skipped in the test harness.\n * - Semantic tags (major type 6) are not interpreted; tagged values are\n *   skipped in encode-roundtrip tests. Implementing tags should return a\n *   wrapper object or otherwise surface the tag + value.\n * - Big integers / bignum handling: this implementation does not return\n *   BigInt for values outside Number.isSafeInteger nor emit CBOR bignum tags\n *   (tag 2/3). Decode may parse 8-byte unsigned/negative integers into a\n *   Number which can overflow JS precision; callers who need accurate bignum\n *   support should add BigInt decoding and encoder support.\n * - Encoder does not emit float16/float32 or 8-byte integer (additional-info\n *   27) forms. It intentionally limits integer encoding to <= 32-bit and\n *   uses float64 for non-integers to keep the implementation small.\n *\n * Guidance for contributors\n * - To add streaming support, implement indefinite-length decoders that\n *   concatenate chunks until the break byte (0xff) and update decodeItem\n *   accordingly.\n * - To add BigInt/bignum support, change decode paths to return BigInt when\n *   required, add fixture representation for BigInt in tests, and emit proper\n *   tag-2/3 bignum encodings or 8-byte integer forms in the encoder.\n */\n\n/* Reference: CBOR specification (RFC 8949) https://www.rfc-editor.org/rfc/rfc8949.html */\n\ntype SimpleValue = boolean | null | undefined;\n\nexport type ResultObject = { [key: string]: ResultValue };\nexport type ResultValue = SimpleValue | number | string | Uint8Array | ResultValue[] | ResultObject;\n\ntype ResultKeyType = Extract<ResultValue, number | string>;\nexport type ValidDecodedType = Extract<ResultValue, ResultObject>;\n\nfunction isResultKeyType(value: ResultValue): value is ResultKeyType {\n\treturn typeof value === 'number' || typeof value === 'string';\n}\n\ntype DecodeResult<T extends ResultValue> = {\n\tvalue: T;\n\toffset: number;\n};\n\nexport function encodeCBOR(value: unknown): Uint8Array {\n\tconst buffer: number[] = [];\n\tencodeItem(value, buffer);\n\treturn new Uint8Array(buffer);\n}\n\nfunction encodeItem(value: unknown, buffer: number[]) {\n\tif (value === null) {\n\t\tbuffer.push(0xf6);\n\t} else if (value === undefined) {\n\t\tbuffer.push(0xf7);\n\t} else if (typeof value === 'boolean') {\n\t\tbuffer.push(value ? 0xf5 : 0xf4);\n\t} else if (typeof value === 'number') {\n\t\tencodeNumber(value, buffer);\n\t} else if (typeof value === 'string') {\n\t\tencodeString(value, buffer);\n\t} else if (Array.isArray(value)) {\n\t\tencodeArray(value, buffer);\n\t} else if (value instanceof Uint8Array) {\n\t\tencodeByteString(value, buffer);\n\t} else if (\n\t\t// Defensive: POJO only (null/array handled above)\n\t\ttypeof value === 'object' &&\n\t\tvalue !== null &&\n\t\t!Array.isArray(value)\n\t) {\n\t\tencodeObject(value as Record<string, unknown>, buffer);\n\t} else {\n\t\tthrow new Error('Unsupported type');\n\t}\n}\n\nfunction encodeUnsigned(value: number, buffer: number[]) {\n\tif (value < 24) {\n\t\tbuffer.push(value);\n\t} else if (value < 256) {\n\t\tbuffer.push(0x18, value);\n\t} else if (value < 65536) {\n\t\tbuffer.push(0x19, (value >>> 8) & 0xff, value & 0xff);\n\t} else if (value < 4294967296) {\n\t\tbuffer.push(\n\t\t\t0x1a,\n\t\t\t(value >>> 24) & 0xff,\n\t\t\t(value >>> 16) & 0xff,\n\t\t\t(value >>> 8) & 0xff,\n\t\t\tvalue & 0xff,\n\t\t);\n\t} else {\n\t\tthrow new Error('Unsupported integer size');\n\t}\n}\n\nfunction encodeSigned(value: number, buffer: number[]) {\n\t// CBOR negative integer encoding: store -1 - value as unsigned under major type 1\n\tconst unsigned = -1 - value;\n\tif (unsigned < 24) {\n\t\tbuffer.push(0x20 | unsigned);\n\t} else if (unsigned < 256) {\n\t\tbuffer.push(0x38, unsigned & 0xff);\n\t} else if (unsigned < 65536) {\n\t\tbuffer.push(0x39, (unsigned >>> 8) & 0xff, unsigned & 0xff);\n\t} else if (unsigned < 4294967296) {\n\t\tbuffer.push(\n\t\t\t0x3a,\n\t\t\t(unsigned >>> 24) & 0xff,\n\t\t\t(unsigned >>> 16) & 0xff,\n\t\t\t(unsigned >>> 8) & 0xff,\n\t\t\tunsigned & 0xff,\n\t\t);\n\t} else {\n\t\tthrow new Error('Unsupported integer size');\n\t}\n}\n\nfunction encodeFloat64(value: number, buffer: number[]) {\n\t// major type 7, additional info 27 (0xfb) followed by 8 bytes IEEE 754 big-endian\n\tconst ab = new ArrayBuffer(8);\n\tconst dv = new DataView(ab);\n\tdv.setFloat64(0, value, false);\n\tbuffer.push(0xfb);\n\tfor (let i = 0; i < 8; i++) buffer.push(dv.getUint8(i));\n}\n\nfunction encodeNumber(value: number, buffer: number[]) {\n\tif (Number.isInteger(value)) {\n\t\tif (value >= 0) {\n\t\t\t// unsigned\n\t\t\tencodeUnsigned(value, buffer);\n\t\t} else {\n\t\t\t// negative integer\n\t\t\tencodeSigned(value, buffer);\n\t\t}\n\t} else {\n\t\t// encode non-integer numbers as float64 for simplicity\n\t\tencodeFloat64(value, buffer);\n\t}\n}\n\nfunction encodeByteString(value: Uint8Array, buffer: number[]) {\n\tconst length = value.length;\n\n\tif (length < 24) {\n\t\tbuffer.push(0x40 + length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0x58, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0x59, (length >> 8) & 0xff, length & 0xff);\n\t} else if (length < 4294967296) {\n\t\tbuffer.push(\n\t\t\t0x5a,\n\t\t\t(length >>> 24) & 0xff,\n\t\t\t(length >>> 16) & 0xff,\n\t\t\t(length >>> 8) & 0xff,\n\t\t\tlength & 0xff,\n\t\t);\n\t} else {\n\t\tthrow new Error('Byte string too long to encode');\n\t}\n\n\tfor (let i = 0; i < value.length; i++) {\n\t\tbuffer.push(value[i]);\n\t}\n}\n\nfunction encodeString(value: string, buffer: number[]) {\n\tconst utf8 = new TextEncoder().encode(value);\n\tconst length = utf8.length;\n\n\tif (length < 24) {\n\t\tbuffer.push(0x60 + length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0x78, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0x79, (length >>> 8) & 0xff, length & 0xff);\n\t} else if (length < 4294967296) {\n\t\tbuffer.push(\n\t\t\t0x7a,\n\t\t\t(length >>> 24) & 0xff,\n\t\t\t(length >>> 16) & 0xff,\n\t\t\t(length >>> 8) & 0xff,\n\t\t\tlength & 0xff,\n\t\t);\n\t} else {\n\t\tthrow new Error('String too long to encode');\n\t}\n\n\tfor (let i = 0; i < utf8.length; i++) {\n\t\tbuffer.push(utf8[i]);\n\t}\n}\n\nfunction encodeArray(value: unknown[], buffer: number[]) {\n\tconst length = value.length;\n\tif (length < 24) {\n\t\tbuffer.push(0x80 | length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0x98, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0x99, (length >>> 8) & 0xff, length & 0xff);\n\t} else {\n\t\tthrow new Error('Unsupported array length');\n\t}\n\n\tfor (const item of value) {\n\t\tencodeItem(item, buffer);\n\t}\n}\n\nfunction encodeObject(value: Record<string, unknown>, buffer: number[]) {\n\tconst keys = Object.keys(value);\n\tconst length = keys.length;\n\n\t// Guardrail: we only support map lengths up to 2^32-1 (same as encodeUnsigned max)\n\tif (length >= 4294967296) {\n\t\tthrow new Error('Object has too many keys to encode');\n\t}\n\n\t// Write initial byte for major type 5 (map) and additional info based on length\n\tif (length < 24) {\n\t\tbuffer.push(0xa0 | length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0xb8, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0xb9, (length >> 8) & 0xff, length & 0xff);\n\t} else {\n\t\tbuffer.push(\n\t\t\t0xba,\n\t\t\t(length >> 24) & 0xff,\n\t\t\t(length >> 16) & 0xff,\n\t\t\t(length >> 8) & 0xff,\n\t\t\tlength & 0xff,\n\t\t);\n\t}\n\tfor (const key of keys) {\n\t\tencodeString(key, buffer);\n\t\tencodeItem(value[key], buffer);\n\t}\n}\n\nexport function decodeCBOR(data: Uint8Array): ResultValue {\n\tconst view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n\tconst result = decodeItem(view, 0);\n\treturn result.value;\n}\n\nfunction decodeItem(view: DataView, offset: number): DecodeResult<ResultValue> {\n\tif (offset >= view.byteLength) {\n\t\tthrow new Error('Unexpected end of data');\n\t}\n\tconst initialByte = view.getUint8(offset++);\n\tconst majorType = initialByte >> 5;\n\tconst additionalInfo = initialByte & 0x1f;\n\n\tswitch (majorType) {\n\t\tcase 0:\n\t\t\treturn decodeUnsigned(view, offset, additionalInfo);\n\t\tcase 1:\n\t\t\treturn decodeSigned(view, offset, additionalInfo);\n\t\tcase 2:\n\t\t\treturn decodeByteString(view, offset, additionalInfo);\n\t\tcase 3:\n\t\t\treturn decodeString(view, offset, additionalInfo);\n\t\tcase 4:\n\t\t\treturn decodeArray(view, offset, additionalInfo);\n\t\tcase 5:\n\t\t\treturn decodeMap(view, offset, additionalInfo);\n\t\tcase 7:\n\t\t\treturn decodeSimpleAndFloat(view, offset, additionalInfo);\n\t\tdefault:\n\t\t\tthrow new Error(`Unsupported major type: ${majorType}`);\n\t}\n}\n\nfunction ensureAvailable(view: DataView, offset: number, needed: number) {\n\tif (offset + needed > view.byteLength) {\n\t\tthrow new Error('Unexpected end of data');\n\t}\n}\n\nfunction decodeLength(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<number> {\n\tif (additionalInfo < 24) return { value: additionalInfo, offset };\n\tif (additionalInfo === 24) {\n\t\tensureAvailable(view, offset, 1);\n\t\treturn { value: view.getUint8(offset++), offset };\n\t}\n\tif (additionalInfo === 25) {\n\t\tensureAvailable(view, offset, 2);\n\t\tconst value = view.getUint16(offset, false);\n\t\toffset += 2;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 26) {\n\t\tensureAvailable(view, offset, 4);\n\t\tconst value = view.getUint32(offset, false);\n\t\toffset += 4;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 27) {\n\t\tensureAvailable(view, offset, 8);\n\t\tconst hi = view.getUint32(offset, false);\n\t\tconst lo = view.getUint32(offset + 4, false);\n\t\toffset += 8;\n\t\treturn { value: hi * 2 ** 32 + lo, offset };\n\t}\n\tthrow new Error(`Unsupported length: ${additionalInfo}`);\n}\n\nfunction decodeUnsigned(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<number> {\n\tconst { value, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\treturn { value, offset: newOffset };\n}\n\nfunction decodeSigned(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<number> {\n\tconst { value, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\treturn { value: -1 - value, offset: newOffset };\n}\n\nfunction decodeByteString(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<Uint8Array> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tif (newOffset + length > view.byteLength) {\n\t\tthrow new Error('Byte string length exceeds data length');\n\t}\n\tconst value = new Uint8Array(view.buffer, view.byteOffset + newOffset, length);\n\treturn { value, offset: newOffset + length };\n}\n\nfunction decodeString(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<string> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tif (newOffset + length > view.byteLength) {\n\t\tthrow new Error('String length exceeds data length');\n\t}\n\tconst bytes = new Uint8Array(view.buffer, view.byteOffset + newOffset, length);\n\tconst value = new TextDecoder().decode(bytes);\n\treturn { value, offset: newOffset + length };\n}\n\nfunction decodeArray(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<ResultValue[]> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tconst array = [];\n\tlet currentOffset = newOffset;\n\tfor (let i = 0; i < length; i++) {\n\t\tconst result = decodeItem(view, currentOffset);\n\t\tarray.push(result.value);\n\t\tcurrentOffset = result.offset;\n\t}\n\treturn { value: array, offset: currentOffset };\n}\n\nfunction decodeMap(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<Record<string, ResultValue>> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tconst map: { [key: string]: ResultValue } = {};\n\tlet currentOffset = newOffset;\n\tfor (let i = 0; i < length; i++) {\n\t\tconst keyResult = decodeItem(view, currentOffset);\n\t\tif (!isResultKeyType(keyResult.value)) {\n\t\t\tthrow new Error('Invalid key type');\n\t\t}\n\t\tconst valueResult = decodeItem(view, keyResult.offset);\n\t\tmap[keyResult.value] = valueResult.value;\n\t\tcurrentOffset = valueResult.offset;\n\t}\n\treturn { value: map, offset: currentOffset };\n}\n\nfunction decodeFloat16(uint16: number): number {\n\tconst exponent = (uint16 & 0x7c00) >> 10;\n\tconst fraction = uint16 & 0x03ff;\n\tconst sign = uint16 & 0x8000 ? -1 : 1;\n\n\tif (exponent === 0) {\n\t\treturn sign * 2 ** -14 * (fraction / 1024);\n\t} else if (exponent === 0x1f) {\n\t\treturn fraction ? NaN : sign * Infinity;\n\t}\n\treturn sign * 2 ** (exponent - 15) * (1 + fraction / 1024);\n}\n\nfunction decodeSimpleAndFloat(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<SimpleValue | number> {\n\tif (additionalInfo < 24) {\n\t\tswitch (additionalInfo) {\n\t\t\tcase 20:\n\t\t\t\treturn { value: false, offset };\n\t\t\tcase 21:\n\t\t\t\treturn { value: true, offset };\n\t\t\tcase 22:\n\t\t\t\treturn { value: null, offset };\n\t\t\tcase 23:\n\t\t\t\treturn { value: undefined, offset };\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown simple value: ${additionalInfo}`);\n\t\t}\n\t}\n\tif (additionalInfo === 24) {\n\t\tensureAvailable(view, offset, 1);\n\t\treturn { value: view.getUint8(offset++), offset };\n\t}\n\tif (additionalInfo === 25) {\n\t\tensureAvailable(view, offset, 2);\n\t\tconst value = decodeFloat16(view.getUint16(offset, false));\n\t\toffset += 2;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 26) {\n\t\tensureAvailable(view, offset, 4);\n\t\tconst value = view.getFloat32(offset, false);\n\t\toffset += 4;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 27) {\n\t\tensureAvailable(view, offset, 8);\n\t\tconst value = view.getFloat64(offset, false);\n\t\toffset += 8;\n\t\treturn { value, offset };\n\t}\n\tthrow new Error(`Unknown simple or float value: ${additionalInfo}`);\n}\n","import { secp256k1 } from '@noble/curves/secp256k1';\nimport { Bytes, bytesToNumber, hexToNumber, numberToHexPadded64 } from '../utils';\nimport { pointFromHex } from './core';\nimport { bytesToHex, hexToBytes, utf8ToBytes } from '@noble/hashes/utils';\nimport { sha256 } from '@noble/hashes/sha2';\nimport { type WeierstrassPoint } from '@noble/curves/abstract/weierstrass';\n\n/**\n * BIP340-style domain separation tag (DST) for P2BK.\n *\n * @alpha\n */\nexport const P2BK_DST = utf8ToBytes('Cashu_P2BK_v1');\n\n/**\n * Blind a sequence of public keys using ECDH derived tweaks, one tweak per slot.\n *\n * @remarks\n * Security note: \"Ehex\" must never be reused. Doing so would create linkability and leak privacy.\n * The only exception is for SIG_ALL proofs, as all secret tags must match.\n *\n * This is the Sender side API.\n * @param pubkeys Ordered SEC1 compressed pubkeys, [data, ...pubkeys, ...refund]\n * @param keysetId Hex keyset identifier, bound into the tweak.\n * @param eBytes Optional. Fixed ephemeral secret key to use (eg for SIG_ALL / testing)\n * @returns Blinded pubkeys in the same order, and Ehex as SEC1 compressed hex, 33 bytes.\n * @throws If a blinded key is at infinity.\n * @alpha\n */\nexport function deriveP2BKBlindedPubkeys(\n\tpubkeys: string[],\n\tkeysetId: string,\n\teBytes?: Uint8Array,\n): { blinded: string[]; Ehex: string } {\n\tif (!pubkeys.length) return { blinded: [], Ehex: '' };\n\t// Create fresh ephemeral secret (e) if not supplied, and calculate pubkey (E)\n\teBytes = eBytes ?? secp256k1.utils.randomSecretKey(); // 32 bytes\n\tconst e = secp256k1.Point.Fn.fromBytes(eBytes); // bigint in [1..n-1]\n\tconst E = secp256k1.getPublicKey(eBytes, true); // SEC1 compressed (bytes)\n\tconst kid = hexToBytes(keysetId);\n\t// Blind each pubkey in turn\n\tconst blinded = pubkeys.map((pubkey, i) => {\n\t\tconst P = pointFromHex(pubkey);\n\t\tconst r = deriveP2BKBlindingTweakFromECDH(P, e, kid, i);\n\t\tconst P_ = P.add(secp256k1.Point.BASE.multiply(r));\n\t\tif (P_.equals(secp256k1.Point.ZERO)) throw new Error('Blinded key at infinity');\n\t\treturn P_.toHex(true);\n\t});\n\treturn { blinded, Ehex: bytesToHex(E) };\n}\n\n/**\n * Derive blinded secret keys that correspond to given P2BK blinded pubkeys.\n *\n * Pubkeys are processed in order, for a proof that is [data, ...pubkeys, ...refund]. Private key\n * order does not matter.\n *\n * @remarks\n * Security note, this operates on long lived secrets. JavaScript BigInt arithmetic in a JIT is not\n * guaranteed constant time. Do not expose this function on a server that holds private keys.\n *\n * This is the Receiver side API.\n * @param Ehex Ephemeral public key (E) as SEC1 hex.\n * @param privateKey Secret key or array of secret keys, hex.\n * @param blindPubKey Blinded public key or array of blinded public keys, hex.\n * @param keysetIdHex Keyset identifier as hex.\n * @returns Array of derived secret keys as 64 char hex.\n * @alpha\n */\nexport function deriveP2BKSecretKeys(\n\tEhex: string,\n\tprivateKey: string | string[],\n\tblindPubKey: string | string[],\n\tkeysetIdHex: string,\n): string[] {\n\tconst privs = Array.isArray(privateKey) ? privateKey : [privateKey];\n\tconst pubs = Array.isArray(blindPubKey) ? blindPubKey : [blindPubKey];\n\tconst out = new Set<string>();\n\tconst E = secp256k1.Point.fromHex(Ehex);\n\tconst kid = hexToBytes(keysetIdHex);\n\tfor (const privHex of privs) {\n\t\tconst p = secp256k1.Point.Fn.fromBytes(hexToBytes(privHex));\n\t\tconst P = secp256k1.getPublicKey(hexToBytes(privHex), true); // 33 bytes, validates on curve\n\t\tpubs.forEach((hexP_, i) => {\n\t\t\tconst r = deriveP2BKBlindingTweakFromECDH(E, p, kid, i);\n\t\t\tconst P_ = hexToBytes(hexP_);\n\t\t\tconst kHex = deriveP2BKSecretKey(privHex, r, P_, P);\n\t\t\tif (kHex) out.add(kHex); // add only when this priv matches this P′\n\t\t});\n\t}\n\treturn Array.from(out);\n}\n\n/**\n * Derive a blinded secret key per NUT-26.\n *\n * Unblinds the pubkey (P = P_ - r·G), verifies x-coord against the naturalPub x(P) == x(p·G), then\n * choose skStd = (p + rᵢ) mod n if parity(P) == parity(p·G), otherwise skNeg = (-p + rᵢ) mod n.\n * Returns skStd if no blindPubkey is provided.\n *\n * @remarks\n * Security note, this operates on long lived secrets. JavaScript BigInt arithmetic in a JIT is not\n * guaranteed constant time. Do not expose this function on a server that holds private keys.\n * @param privkey Unblinded private key (p), hex or bigint.\n * @param rBlind Blinding scalar (r), hex or bigint.\n * @param blindPubkey Optional. Blinded pubkey (P_) to match, 33 byte hex.\n * @param naturalPub Optional. Pubkey calculated from private key (P = p·G), 33 byte hex.\n * @returns Derived blinded secret key as 64 char hex.\n * @throws If inputs are out of range, or the derived key would be zero.\n * @alpha\n */\nexport function deriveP2BKSecretKey(\n\tprivkey: string | bigint,\n\trBlind: string | bigint,\n\tblindPubkey?: Uint8Array,\n\tnaturalPub?: Uint8Array,\n): string | null {\n\t// Implementation note: must keep algorithmic constant time!\n\tconst n = secp256k1.Point.CURVE().n;\n\tconst p = typeof privkey === 'string' ? hexToNumber(privkey) : privkey;\n\tconst r = typeof rBlind === 'string' ? hexToNumber(rBlind) : rBlind;\n\tif (p <= 0n || p >= n) throw new Error('Invalid private key');\n\tif (r <= 0n || r >= n) throw new Error('Invalid scalar r');\n\t// If caller didn't provide P = p·G, compute it in compressed form (33 bytes)\n\tnaturalPub = naturalPub ?? secp256k1.Point.BASE.multiply(p).toBytes(true);\n\tif (naturalPub.length !== 33) throw new Error('naturalPub must be 33 bytes');\n\t// Calculate both sk candidates for constant time (add/subtract is cheap)\n\tconst skStd: bigint = (p + r) % n;\n\tconst skNeg: bigint = (n - p + r) % n;\n\t// Return skStd if no blinded pubkey was provided to verify against\n\tif (!blindPubkey) {\n\t\tif (skStd === 0n) throw new Error('Derived secret key is zero');\n\t\treturn numberToHexPadded64(skStd);\n\t}\n\tif (blindPubkey.length !== 33) throw new Error('blindPubkey must be 33 bytes');\n\t// Decode P′, compute R and unblind\n\tconst P_ = secp256k1.Point.fromHex(blindPubkey); // valid point\n\tconst R = secp256k1.Point.BASE.multiply(r); // R = r·G\n\tconst P = P_.subtract(R); // P = P_ - R\n\tif (P.equals(secp256k1.Point.ZERO)) return null;\n\t// Check x only equality, using constant time compare\n\tconst xP = P.toBytes(true).slice(1);\n\tconst xNaturalPub = naturalPub.slice(1);\n\tif (!Bytes.equals(xP, xNaturalPub)) {\n\t\treturn null; // this P' is not for this privkey\n\t}\n\t// Select by parity, comparing the low bit only\n\tconst yP = P.toBytes(true)[0] & 1;\n\tconst yNaturalPub = naturalPub[0] & 1;\n\tconst out = yP === yNaturalPub ? skStd : skNeg;\n\tif (out === 0n) throw new Error('Derived secret key is zero');\n\treturn numberToHexPadded64(out);\n}\n\n/**\n * Internal helper, derive P2BK blinding tweak using ECDH.\n *\n * @remarks\n * Computes the shared point Z = scalar·point, takes its 32 byte x coordinate Zx, then derives:\n *\n *     rᵢ = SHA - 256(P2BK_DST || Zx || keysetId || i); // all inputs as raw bytes\n *\n * If the result reduces to zero, or is >= curve order (n), retries once with an extra 0xff byte\n * appended to the message. Throws if the retry also reduces to zero.\n *\n * This function is symmetric. It can be called with either.\n *\n * - The receiver's private key (p) and the sender's ephemeral public key (E)\n * - The sender's ephemeral secret (e) and the receiver's public key (P)\n *\n * Both yield the same Z and therefore the same r thanks to the magic of ECDH!\n * @param point Ephemeral public key (E) or recipient public key (P)\n * @param scalar Private scalar (p) or ephemeral scalar (e) in [1, n − 1]\n * @param keysetId Keyset identifier as raw bytes.\n * @param slotIndex Zero based slot index, only lowest 8 bits (0–255) are used.\n * @returns Tweak (r) in [1, n − 1]\n * @throws If r reduces to zero after the retry.\n * @alpha\n */\nfunction deriveP2BKBlindingTweakFromECDH(\n\tpoint: WeierstrassPoint<bigint>, // E or P\n\tscalar: bigint, // p or e\n\tkeysetId: Uint8Array, // kid\n\tslotIndex: number, // i\n): bigint {\n\t// Calculate x-only ECDH shared point (Zx)\n\tconst Zx = point.multiply(scalar).toBytes(true).slice(1);\n\tconst iByte = new Uint8Array([slotIndex & 0xff]);\n\t// Derive deterministic blinding factor (r):\n\tlet r = bytesToNumber(sha256(Bytes.concat(P2BK_DST, Zx, keysetId, iByte)));\n\tif (r === 0n || r >= secp256k1.Point.CURVE().n) {\n\t\t// Very unlikely to get here!\n\t\tr = bytesToNumber(sha256(Bytes.concat(P2BK_DST, Zx, keysetId, iByte, new Uint8Array([0xff]))));\n\t\tif (r === 0n || r >= secp256k1.Point.CURVE().n) {\n\t\t\tthrow new Error('P2BK: tweak derivation failed');\n\t\t}\n\t}\n\treturn r;\n}\n","import { type PrivKey, bytesToHex, hexToBytes, randomBytes } from '@noble/curves/utils';\nimport { sha256 } from '@noble/hashes/sha2';\nimport { schnorr } from '@noble/curves/secp256k1';\nimport { type P2PKWitness, type Proof } from '../model/types';\nimport { type BlindedMessage } from './core';\nimport { deriveP2BKSecretKeys } from './NUT26';\nimport { type Logger, NULL_LOGGER } from '../logger';\n\nexport type SigFlag = 'SIG_INPUTS' | 'SIG_ALL';\n\nexport type Secret = [WellKnownSecret, SecretData];\n\nexport type WellKnownSecret = 'P2PK';\n\nexport type SecretData = {\n\tnonce: string;\n\tdata: string;\n\ttags?: string[][];\n};\n\nexport const createP2PKsecret = (pubkey: string): string => {\n\tconst newSecret: Secret = [\n\t\t'P2PK',\n\t\t{\n\t\t\tnonce: bytesToHex(randomBytes(32)),\n\t\t\tdata: pubkey,\n\t\t},\n\t];\n\treturn JSON.stringify(newSecret);\n};\n\nexport const parseP2PKSecret = (secret: string | Uint8Array): Secret => {\n\ttry {\n\t\tif (secret instanceof Uint8Array) {\n\t\t\tsecret = new TextDecoder().decode(secret);\n\t\t}\n\t\treturn JSON.parse(secret) as Secret;\n\t} catch {\n\t\tthrow new Error(\"can't parse secret\");\n\t}\n};\n\n/**\n * Signs a P2PK secret using Schnorr.\n *\n * @remarks\n * Signatures are non-deterministic because schnorr.sign() generates a new random auxiliary value\n * (auxRand) each time it is called.\n */\nexport const signP2PKSecret = (secret: string, privateKey: PrivKey): string => {\n\tconst msghash = sha256(secret);\n\tconst sig = schnorr.sign(msghash, privateKey); // auxRand is random by default\n\treturn bytesToHex(sig);\n};\n\nexport const signBlindedMessage = (B_: string, privateKey: PrivKey): string => {\n\tconst msgHash = sha256(B_);\n\tconst sig = schnorr.sign(msgHash, privateKey);\n\treturn bytesToHex(sig);\n};\n\n/**\n * Verifies a Schnorr signature on a P2PK secret.\n *\n * @param signature - The Schnorr signature (hex-encoded).\n * @param secret - The Secret to verify.\n * @param pubkey - The Cashu P2PK public key (hex-encoded, X-only or with 02/03 prefix).\n * @returns {boolean} True if the signature is valid, false otherwise.\n */\nexport const verifyP2PKSecretSignature = (\n\tsignature: string,\n\tsecret: string,\n\tpubkey: string,\n): boolean => {\n\ttry {\n\t\tconst msghash = sha256(secret);\n\t\t// Use X-only pubkey: strip 02/03 prefix if pubkey is 66 hex chars (33 bytes)\n\t\tconst pubkeyX = pubkey.length === 66 ? pubkey.slice(2) : pubkey;\n\t\tif (schnorr.verify(signature, msghash, hexToBytes(pubkeyX))) {\n\t\t\treturn true;\n\t\t}\n\t} catch (e) {\n\t\tconsole.error('verifyP2PKsecret error:', e);\n\t}\n\treturn false; // no bueno\n};\n\n/**\n * Verifies a pubkey has signed a P2PK Proof.\n *\n * @param pubkey - The Cashu P2PK public key (hex-encoded, X-only or with 02/03 prefix).\n * @param proof - A Cashu proof.\n * @returns {boolean} True if one of the signatures is theirs, false otherwise.\n */\nexport const hasP2PKSignedProof = (pubkey: string, proof: Proof): boolean => {\n\tif (!proof.witness) {\n\t\treturn false;\n\t}\n\tconst signatures = getP2PKWitnessSignatures(proof.witness);\n\t// See if any of the signatures belong to this pubkey. We need to do this\n\t// as Schnorr signatures are non-deterministic (see: signP2PKSecret)\n\treturn signatures.some((sig) => {\n\t\ttry {\n\t\t\treturn verifyP2PKSecretSignature(sig, proof.secret, pubkey);\n\t\t} catch {\n\t\t\treturn false; // Invalid signature, treat as not signed\n\t\t}\n\t});\n};\n\n/**\n * Returns the expected witness public keys from a NUT-11 P2PK secret.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {array} With the public keys or empty array.\n */\nexport function getP2PKExpectedKWitnessPubkeys(secretStr: string | Secret): string[] {\n\ttry {\n\t\t// Validate secret\n\t\tconst secret: Secret = typeof secretStr === 'string' ? parseP2PKSecret(secretStr) : secretStr;\n\t\tif (secret[0] !== 'P2PK') {\n\t\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t\t}\n\t\tconst now = Math.floor(Date.now() / 1000);\n\t\tconst locktime = getP2PKLocktime(secret);\n\t\tif (locktime > now) {\n\t\t\t// Am interpretting NUT-11 as intending pubkeys to be usable for a\n\t\t\t// 1-of-m multisig if provided, even if n_sigs is not set\n\t\t\treturn getP2PKWitnessPubkeys(secret);\n\t\t}\n\t\treturn getP2PKWitnessRefundkeys(secret);\n\t} catch {\n\t\t// do nothing\n\t}\n\treturn []; // Unlocked, malformed or expired with no refund keys\n}\n\n/**\n * Returns ALL locktime witnesses from a NUT-11 P2PK secret NB: Does not specify if they are\n * expected to sign - see: getP2PKExpectedKWitnessPubkeys()\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {array} With the public key(s or empty array.\n */\nexport function getP2PKWitnessPubkeys(secretStr: string | Secret): string[] {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseP2PKSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\tconst { data, tags } = secret[1];\n\tconst pubkeysTag = tags && tags.find((tag) => tag[0] === 'pubkeys');\n\tconst pubkeys = pubkeysTag && pubkeysTag.length > 1 ? pubkeysTag.slice(1) : [];\n\treturn [data, ...pubkeys].filter(Boolean);\n}\n\n/**\n * Returns ALL refund witnesses from a NUT-11 P2PK secret NB: Does not specify if they are expected\n * to sign - see: getP2PKExpectedKWitnessPubkeys()\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {array} With the public keys or empty array.\n */\nexport function getP2PKWitnessRefundkeys(secretStr: string | Secret): string[] {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseP2PKSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\tconst { tags } = secret[1];\n\tconst refundTag = tags && tags.find((tag) => tag[0] === 'refund');\n\treturn refundTag && refundTag.length > 1 ? refundTag.slice(1).filter(Boolean) : [];\n}\n\n/**\n * Returns the locktime from a NUT-11 P2PK secret or Infinity if no locktime.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {number} The locktime unix timestamp or Infinity (permanent lock)\n */\nexport function getP2PKLocktime(secretStr: string | Secret): number {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseP2PKSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\tconst { tags } = secret[1];\n\tconst locktimeTag = tags && tags.find((tag) => tag[0] === 'locktime');\n\treturn locktimeTag && locktimeTag.length > 1 ? parseInt(locktimeTag[1], 10) : Infinity; // Permanent lock if not set\n}\n\n/**\n * Returns the number of signatures required from a NUT-11 P2PK secret.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {number} The number of signatories (n_sigs / n_sigs_refund) or 0 if secret is unlocked.\n */\nexport function getP2PKNSigs(secretStr: string | Secret): number {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseP2PKSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\t// Check for witnesses\n\tconst witness = getP2PKExpectedKWitnessPubkeys(secret);\n\tif (!witness.length) {\n\t\treturn 0; // unlocked if no witnesses needed\n\t}\n\t// Check for Lock multisig\n\tconst { tags } = secret[1];\n\tconst now = Math.floor(Date.now() / 1000);\n\tconst locktime = getP2PKLocktime(secret);\n\tif (locktime > now) {\n\t\tconst n_sigsTag = tags && tags.find((tag) => tag[0] === 'n_sigs');\n\t\treturn n_sigsTag && n_sigsTag.length > 1 ? parseInt(n_sigsTag[1], 10) : 1; // Default: 1\n\t}\n\t// Refund multisig\n\tconst n_sigs_refundTag = tags && tags.find((tag) => tag[0] === 'n_sigs_refund');\n\treturn n_sigs_refundTag && n_sigs_refundTag.length > 1 ? parseInt(n_sigs_refundTag[1], 10) : 1; // Default: 1\n}\n\n/**\n * Returns the sigflag from a NUT-11 P2PK secret.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {string} The sigflag or 'SIG_INPUTS' (default)\n */\nexport function getP2PKSigFlag(secretStr: string | Secret): string {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseP2PKSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\tconst { tags } = secret[1];\n\tconst sigFlagTag = tags && tags.find((tag) => tag[0] === 'sigflag');\n\treturn sigFlagTag && sigFlagTag.length > 1 ? (sigFlagTag[1] as SigFlag) : 'SIG_INPUTS';\n}\n\n/**\n * Gets witness signatures as an array.\n *\n * @param witness From Proof.\n * @returns Array of witness signatures.\n */\nexport const getP2PKWitnessSignatures = (witness: string | P2PKWitness | undefined): string[] => {\n\tif (!witness) return [];\n\tif (typeof witness === 'string') {\n\t\ttry {\n\t\t\tconst parsed = JSON.parse(witness) as P2PKWitness;\n\t\t\treturn parsed.signatures || [];\n\t\t} catch (e) {\n\t\t\tconsole.error('Failed to parse witness string:', e);\n\t\t\treturn [];\n\t\t}\n\t}\n\treturn witness.signatures || [];\n};\n\n/**\n * Signs proofs with provided private key(s) if required NB: Will only sign if the proof requires a\n * signature from the key.\n *\n * @param proofs - An array of proofs to sign.\n * @param privateKey - A single private key or array of private keys.\n * @param logger - Optional logger (default: NULL_LOGGER)\n */\nexport const signP2PKProofs = (\n\tproofs: Proof[],\n\tprivateKey: string | string[],\n\tlogger: Logger = NULL_LOGGER,\n): Proof[] => {\n\treturn proofs.map((proof, index) => {\n\t\ttry {\n\t\t\tconst privateKeys: string[] = maybeDeriveP2BKPrivateKeys(privateKey, proof);\n\t\t\tlet signedProof = proof;\n\t\t\tfor (const priv of privateKeys) {\n\t\t\t\ttry {\n\t\t\t\t\tsignedProof = signP2PKProof(signedProof, priv);\n\t\t\t\t} catch (error: unknown) {\n\t\t\t\t\t// Log signature failures only - these are not fatal, just informational\n\t\t\t\t\t// as not all keys will be needed for some proofs (eg P2BK, NIP60 etc)\n\t\t\t\t\tconst message = error instanceof Error ? error.message : 'Unknown error';\n\t\t\t\t\tlogger.warn(`Proof #${index + 1}: ${message}`);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn signedProof;\n\t\t} catch (error: unknown) {\n\t\t\t// General errors (eg from deriveP2BKSecretKey)\n\t\t\tconst message = error instanceof Error ? error.message : 'Unknown error';\n\t\t\tlogger.error(`Proof #${index + 1}: ${message}`);\n\t\t\tthrow new Error(`Failed signing proof #${index + 1}: ${message}`);\n\t\t}\n\t});\n};\n\n/**\n * Signs a single proof with the provided private key if required NB: Will only sign if the proof\n * requires a signature from the key.\n *\n * @param proof - A proof to sign.\n * @param privateKey - A single private key.\n * @throws Error if signature is not required or proof is already signed.\n */\nexport const signP2PKProof = (proof: Proof, privateKey: string): Proof => {\n\t// Check secret is P2PK\n\tconst parsed: Secret = parseP2PKSecret(proof.secret);\n\tif (parsed[0] !== 'P2PK') {\n\t\tthrow new Error('not a P2PK secret');\n\t}\n\t// Check if the private key is required to sign by checking its\n\t// X-only pubkey (no 02/03 prefix) against the expected witness pubkeys\n\t// NB: Nostr pubkeys prepend 02 by convention, ignoring actual Y-parity\n\tconst pubkey = bytesToHex(schnorr.getPublicKey(privateKey)); // x-only\n\tconst witnesses = getP2PKExpectedKWitnessPubkeys(parsed);\n\tif (!witnesses.length || !witnesses.some((w) => w.includes(pubkey))) {\n\t\tthrow new Error(`Signature not required from [02|03]${pubkey}`);\n\t}\n\t// Check if the public key has already signed\n\tconst signatures = getP2PKWitnessSignatures(proof.witness);\n\tconst alreadySigned = signatures.some((sig) => {\n\t\ttry {\n\t\t\treturn verifyP2PKSecretSignature(sig, proof.secret, pubkey);\n\t\t} catch {\n\t\t\treturn false; // Invalid signature, treat as not signed\n\t\t}\n\t});\n\tif (alreadySigned) {\n\t\tthrow new Error(`Proof already signed by [02|03]${pubkey}`);\n\t}\n\t// Add new signature\n\tconst signature = signP2PKSecret(proof.secret, privateKey);\n\treturn { ...proof, witness: { signatures: [...signatures, signature] } };\n};\n\nexport const verifyP2PKSig = (proof: Proof): boolean => {\n\tif (!proof.witness) {\n\t\tthrow new Error('could not verify signature, no witness provided');\n\t}\n\n\tconst parsedSecret: Secret = parseP2PKSecret(proof.secret);\n\tconst witnesses = getP2PKExpectedKWitnessPubkeys(parsedSecret);\n\tif (!witnesses.length) {\n\t\tthrow new Error('no signatures required, proof is unlocked');\n\t}\n\tlet signatories = 0;\n\tconst requiredSigs = getP2PKNSigs(parsedSecret);\n\tconst signatures = getP2PKWitnessSignatures(proof.witness);\n\t// Loop through witnesses to see if any of the signatures belong to them.\n\t// We need to do this as Schnorr signatures are non-deterministic\n\t// (see: signP2PKSecret), so we count the number of valid witnesses,\n\t// not the number of valid signatures\n\tfor (const pubkey of witnesses) {\n\t\tconst hasSigned = signatures.some((sig) => {\n\t\t\ttry {\n\t\t\t\treturn verifyP2PKSecretSignature(sig, proof.secret, pubkey);\n\t\t\t} catch {\n\t\t\t\treturn false; // Invalid signature, treat as not signed\n\t\t\t}\n\t\t});\n\t\tif (hasSigned) {\n\t\t\tsignatories++;\n\t\t}\n\t}\n\treturn signatories >= requiredSigs;\n};\n\nexport const verifyP2PKSigOutput = (output: BlindedMessage, publicKey: string): boolean => {\n\tif (!output.witness?.signatures || output.witness.signatures.length === 0) {\n\t\tthrow new Error('could not verify signature, no witness signatures provided');\n\t}\n\treturn schnorr.verify(\n\t\toutput.witness.signatures[0],\n\t\tsha256(output.B_.toHex(true)),\n\t\tpublicKey.slice(2),\n\t);\n};\n\nexport const getSignedOutput = (output: BlindedMessage, privateKey: PrivKey): BlindedMessage => {\n\tconst B_ = output.B_.toHex(true);\n\tconst signature = signBlindedMessage(B_, privateKey);\n\toutput.witness = { signatures: [signature] };\n\treturn output;\n};\n\nexport const getSignedOutputs = (\n\toutputs: BlindedMessage[],\n\tprivateKey: string,\n): BlindedMessage[] => {\n\treturn outputs.map((o) => getSignedOutput(o, privateKey));\n};\n\n/**\n * Derives blinded secret keys for a P2BK proof.\n *\n * @remarks\n * Calculates the deterministic blinding factor for each P2PK pubkey (data, pubkeys, refund) and\n * calling our parity-aware derivation.\n * @param privateKey Secret key (or array of secret keys)\n * @param proof The proof.\n * @returns Deduplicated list of derived secret keys (hex, 64 chars)\n * @alpha\n */\nexport function maybeDeriveP2BKPrivateKeys(privateKey: string | string[], proof: Proof): string[] {\n\tconst privs = Array.isArray(privateKey) ? privateKey : [privateKey];\n\tconst Ehex: string | undefined = proof?.p2pk_e;\n\tif (!Ehex) {\n\t\treturn Array.from(new Set(privs));\n\t}\n\t// Extract pubkeys and keyset ID from proof\n\tconst secret = parseP2PKSecret(proof.secret);\n\tconst pubs = [...getP2PKWitnessPubkeys(secret), ...getP2PKWitnessRefundkeys(secret)];\n\tconst kid = proof.id; // keyset id is hex\n\treturn deriveP2BKSecretKeys(Ehex, privs, pubs, kid);\n}\n","import { type WeierstrassPoint } from '@noble/curves/abstract/weierstrass';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { sha256 } from '@noble/hashes/sha2';\nimport { type PrivKey, randomBytes, bytesToHex, hexToBytes } from '@noble/curves/utils';\nimport { Bytes, bytesToNumber, hexToNumber, encodeBase64toUint8 } from '../utils';\nimport { type P2PKWitness } from '../model/types';\nimport { getSignedOutput } from './NUT11';\n\nexport type BlindSignature = {\n\tC_: WeierstrassPoint<bigint>;\n\tamount: number;\n\tid: string;\n};\n\nexport type BlindedMessage = {\n\tB_: WeierstrassPoint<bigint>;\n\tr: bigint;\n\tsecret: Uint8Array;\n\twitness?: P2PKWitness;\n};\n\nexport type DLEQ = {\n\ts: Uint8Array; // signature\n\te: Uint8Array; // challenge\n\tr?: bigint; // optional: blinding factor\n};\n\nexport type RawProof = {\n\tC: WeierstrassPoint<bigint>;\n\tsecret: Uint8Array;\n\tamount: number;\n\tid: string;\n\twitness?: P2PKWitness;\n};\n\nexport type SerializedProof = {\n\tC: string;\n\tsecret: string;\n\tamount: number;\n\tid: string;\n\twitness?: string;\n};\n\nconst DOMAIN_SEPARATOR = hexToBytes('536563703235366b315f48617368546f43757276655f43617368755f');\n\nexport function hashToCurve(secret: Uint8Array): WeierstrassPoint<bigint> {\n\tconst msgToHash = sha256(Bytes.concat(DOMAIN_SEPARATOR, secret));\n\tconst counter = new Uint32Array(1);\n\tconst maxIterations = 2 ** 16;\n\tfor (let i = 0; i < maxIterations; i++) {\n\t\tconst counterBytes = new Uint8Array(counter.buffer);\n\t\tconst hash = sha256(Bytes.concat(msgToHash, counterBytes));\n\t\ttry {\n\t\t\treturn pointFromHex(bytesToHex(Bytes.concat(new Uint8Array([0x02]), hash)));\n\t\t} catch {\n\t\t\tcounter[0]++;\n\t\t}\n\t}\n\tthrow new Error('No valid point found');\n}\n\nexport function hash_e(pubkeys: Array<WeierstrassPoint<bigint>>): Uint8Array {\n\tconst hexStrings = pubkeys.map((p) => p.toHex(false));\n\tconst e_ = hexStrings.join('');\n\treturn sha256(new TextEncoder().encode(e_));\n}\n\nexport function pointFromBytes(bytes: Uint8Array) {\n\treturn secp256k1.Point.fromHex(bytesToHex(bytes));\n}\n\nexport function pointFromHex(hex: string) {\n\treturn secp256k1.Point.fromHex(hex);\n}\n\nexport const getKeysetIdInt = (keysetId: string): bigint => {\n\tlet keysetIdInt: bigint;\n\tif (/^[a-fA-F0-9]+$/.test(keysetId)) {\n\t\tkeysetIdInt = hexToNumber(keysetId) % BigInt(2 ** 31 - 1);\n\t} else {\n\t\t//legacy keyset compatibility\n\t\tkeysetIdInt = bytesToNumber(encodeBase64toUint8(keysetId)) % BigInt(2 ** 31 - 1);\n\t}\n\treturn keysetIdInt;\n};\n\nexport function createRandomSecretKey() {\n\treturn secp256k1.utils.randomSecretKey();\n}\n\nexport function createBlindSignature(\n\tB_: WeierstrassPoint<bigint>,\n\tprivateKey: Uint8Array,\n\tamount: number,\n\tid: string,\n): BlindSignature {\n\tconst C_: WeierstrassPoint<bigint> = B_.multiply(bytesToNumber(privateKey));\n\treturn { C_, amount, id };\n}\n\nexport function createRandomBlindedMessage(privateKey?: PrivKey): BlindedMessage {\n\treturn blindMessage(\n\t\trandomBytes(32),\n\t\tbytesToNumber(secp256k1.utils.randomSecretKey()),\n\t\tprivateKey,\n\t);\n}\n\nexport function blindMessage(secret: Uint8Array, r?: bigint, privateKey?: PrivKey): BlindedMessage {\n\tconst Y = hashToCurve(secret);\n\tif (!r) {\n\t\tr = bytesToNumber(secp256k1.utils.randomSecretKey());\n\t}\n\tconst rG = secp256k1.Point.BASE.multiply(r);\n\tconst B_ = Y.add(rG);\n\tif (privateKey !== undefined) {\n\t\treturn getSignedOutput({ B_, r, secret }, privateKey);\n\t}\n\treturn { B_, r, secret };\n}\n\nexport function unblindSignature(\n\tC_: WeierstrassPoint<bigint>,\n\tr: bigint,\n\tA: WeierstrassPoint<bigint>,\n): WeierstrassPoint<bigint> {\n\tconst C = C_.subtract(A.multiply(r));\n\treturn C;\n}\n\nexport function constructProofFromPromise(\n\tpromise: BlindSignature,\n\tr: bigint,\n\tsecret: Uint8Array,\n\tkey: WeierstrassPoint<bigint>,\n): RawProof {\n\tconst A = key;\n\tconst C = unblindSignature(promise.C_, r, A);\n\tconst proof = {\n\t\tid: promise.id,\n\t\tamount: promise.amount,\n\t\tsecret,\n\t\tC,\n\t};\n\treturn proof;\n}\n\nexport const serializeProof = (proof: RawProof): SerializedProof => {\n\treturn {\n\t\tamount: proof.amount,\n\t\tC: proof.C.toHex(true),\n\t\tid: proof.id,\n\t\tsecret: new TextDecoder().decode(proof.secret),\n\t\twitness: JSON.stringify(proof.witness),\n\t};\n};\n\nexport const deserializeProof = (proof: SerializedProof): RawProof => {\n\treturn {\n\t\tamount: proof.amount,\n\t\tC: pointFromHex(proof.C),\n\t\tid: proof.id,\n\t\tsecret: new TextEncoder().encode(proof.secret),\n\t\twitness: proof.witness ? (JSON.parse(proof.witness) as P2PKWitness) : undefined,\n\t};\n};\n","import { type WeierstrassPoint } from '@noble/curves/abstract/weierstrass';\nimport { bytesToHex, hexToBytes } from '@noble/curves/utils';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { type RawProof, createRandomSecretKey, hashToCurve } from './core';\nimport { HDKey } from '@scure/bip32';\nimport { deriveKeysetId, bytesToNumber } from '../utils';\n\nconst DERIVATION_PATH = \"m/0'/0'/0'\";\n\nexport type RawMintKeys = { [k: string]: Uint8Array };\n\nexport type SerializedMintKeys = {\n\t[k: string]: string;\n};\n\nexport type Enumerate<N extends number, Acc extends number[] = []> = Acc['length'] extends N\n\t? Acc[number]\n\t: Enumerate<N, [...Acc, Acc['length']]>;\n\nexport type IntRange<F extends number, T extends number> = Exclude<Enumerate<T>, Enumerate<F>>;\n\nexport type KeysetPair = {\n\tkeysetId: string;\n\tpubKeys: RawMintKeys;\n\tprivKeys: RawMintKeys;\n};\n\nexport function serializeMintKeys(mintKeys: RawMintKeys): SerializedMintKeys {\n\tconst serializedMintKeys: SerializedMintKeys = {};\n\tObject.keys(mintKeys).forEach((p) => {\n\t\tserializedMintKeys[p] = bytesToHex(mintKeys[p]);\n\t});\n\treturn serializedMintKeys;\n}\n\nexport function deserializeMintKeys(serializedMintKeys: SerializedMintKeys): RawMintKeys {\n\tconst mintKeys: RawMintKeys = {};\n\tObject.keys(serializedMintKeys).forEach((p) => {\n\t\tmintKeys[p] = hexToBytes(serializedMintKeys[p]);\n\t});\n\treturn mintKeys;\n}\n\nexport function getPubKeyFromPrivKey(privKey: Uint8Array) {\n\treturn secp256k1.getPublicKey(privKey, true);\n}\n\nexport function createNewMintKeys(pow2height: IntRange<0, 65>, seed?: Uint8Array): KeysetPair {\n\tlet counter = 0n;\n\tconst pubKeys: RawMintKeys = {};\n\tconst privKeys: RawMintKeys = {};\n\tlet masterKey;\n\tif (seed) {\n\t\tmasterKey = HDKey.fromMasterSeed(seed);\n\t}\n\twhile (counter < pow2height) {\n\t\tconst index: string = (2n ** counter).toString();\n\t\tif (masterKey) {\n\t\t\tconst k = masterKey.derive(`${DERIVATION_PATH}/${counter}`).privateKey;\n\t\t\tif (k) {\n\t\t\t\tprivKeys[index] = k;\n\t\t\t} else {\n\t\t\t\tthrow new Error(`Could not derive Private key from: ${DERIVATION_PATH}/${counter}`);\n\t\t\t}\n\t\t} else {\n\t\t\tprivKeys[index] = createRandomSecretKey();\n\t\t}\n\n\t\tpubKeys[index] = getPubKeyFromPrivKey(privKeys[index]);\n\t\tcounter++;\n\t}\n\tconst keysetId = deriveKeysetId(serializeMintKeys(pubKeys));\n\treturn { pubKeys, privKeys, keysetId };\n}\n\nexport function verifyProof(proof: RawProof, privKey: Uint8Array): boolean {\n\tconst Y: WeierstrassPoint<bigint> = hashToCurve(proof.secret);\n\tconst aY: WeierstrassPoint<bigint> = Y.multiply(bytesToNumber(privKey));\n\treturn aY.equals(proof.C);\n}\n","import { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha2';\nimport { getKeysetIdInt } from './core';\nimport { HDKey } from '@scure/bip32';\nimport { Bytes, isBase64String } from '../utils';\n\nconst STANDARD_DERIVATION_PATH = `m/129372'/0'`;\n\nenum DerivationType {\n\tSECRET = 0,\n\tBLINDING_FACTOR = 1,\n}\n\nexport const deriveSecret = (seed: Uint8Array, keysetId: string, counter: number): Uint8Array => {\n\tconst isValidHex = /^[a-fA-F0-9]+$/.test(keysetId);\n\tif (!isValidHex && isBase64String(keysetId)) {\n\t\treturn derive_deprecated(seed, keysetId, counter, DerivationType.SECRET);\n\t}\n\n\tif (isValidHex && keysetId.startsWith('00')) {\n\t\treturn derive_deprecated(seed, keysetId, counter, DerivationType.SECRET);\n\t} else if (isValidHex && keysetId.startsWith('01')) {\n\t\treturn derive(seed, keysetId, counter, DerivationType.SECRET);\n\t}\n\tthrow new Error(`Unrecognized keyset ID version ${keysetId.slice(0, 2)}`);\n};\n\nexport const deriveBlindingFactor = (\n\tseed: Uint8Array,\n\tkeysetId: string,\n\tcounter: number,\n): Uint8Array => {\n\tconst isValidHex = /^[a-fA-F0-9]+$/.test(keysetId);\n\tif (!isValidHex && isBase64String(keysetId)) {\n\t\treturn derive_deprecated(seed, keysetId, counter, DerivationType.BLINDING_FACTOR);\n\t}\n\n\tif (isValidHex && keysetId.startsWith('00')) {\n\t\treturn derive_deprecated(seed, keysetId, counter, DerivationType.BLINDING_FACTOR);\n\t} else if (isValidHex && keysetId.startsWith('01')) {\n\t\treturn derive(seed, keysetId, counter, DerivationType.BLINDING_FACTOR);\n\t}\n\tthrow new Error(`Unrecognized keyset ID version ${keysetId.slice(0, 2)}`);\n};\n\nconst derive = (\n\tseed: Uint8Array,\n\tkeysetId: string,\n\tcounter: number,\n\tsecretOrBlinding: DerivationType,\n): Uint8Array => {\n\tlet message = Bytes.concat(\n\t\tBytes.fromString('Cashu_KDF_HMAC_SHA256'),\n\t\tBytes.fromHex(keysetId),\n\t\tBytes.writeBigUint64BE(BigInt(counter)),\n\t);\n\n\tswitch (secretOrBlinding) {\n\t\tcase DerivationType.SECRET:\n\t\t\tmessage = Bytes.concat(message, Bytes.fromHex('00'));\n\t\t\tbreak;\n\t\tcase DerivationType.BLINDING_FACTOR:\n\t\t\tmessage = Bytes.concat(message, Bytes.fromHex('01'));\n\t}\n\n\t// Step 2: Compute HMAC-SHA256\n\treturn hmac(sha256, seed, message);\n};\n\nconst derive_deprecated = (\n\tseed: Uint8Array,\n\tkeysetId: string,\n\tcounter: number,\n\tsecretOrBlinding: DerivationType,\n): Uint8Array => {\n\tconst hdkey = HDKey.fromMasterSeed(seed);\n\tconst keysetIdInt = getKeysetIdInt(keysetId);\n\tconst derivationPath = `${STANDARD_DERIVATION_PATH}/${keysetIdInt}'/${counter}'/${secretOrBlinding}`;\n\tconst derived = hdkey.derive(derivationPath);\n\tif (derived.privateKey === null) {\n\t\tthrow new Error('Could not derive private key');\n\t}\n\treturn derived.privateKey;\n};\n","import { type DLEQ, hash_e, hashToCurve, createRandomSecretKey } from './core';\nimport { bytesToNumber } from '../utils';\nimport { type WeierstrassPoint } from '@noble/curves/abstract/weierstrass';\nimport { numberToBytesBE } from '@noble/curves/utils';\nimport { secp256k1 } from '@noble/curves/secp256k1';\n\nfunction arraysEqual(arr1: Uint8Array, arr2: Uint8Array) {\n\tif (arr1.length !== arr2.length) return false;\n\tfor (let i = 0; i < arr1.length; i++) {\n\t\tif (arr1[i] !== arr2[i]) return false;\n\t}\n\treturn true;\n}\n\nexport const verifyDLEQProof = (\n\tdleq: DLEQ,\n\tB_: WeierstrassPoint<bigint>,\n\tC_: WeierstrassPoint<bigint>,\n\tA: WeierstrassPoint<bigint>,\n) => {\n\tconst sG = secp256k1.Point.BASE.multiply(secp256k1.Point.Fn.fromBytes(dleq.s));\n\tconst eA = A.multiply(bytesToNumber(dleq.e));\n\tconst sB_ = B_.multiply(bytesToNumber(dleq.s));\n\tconst eC_ = C_.multiply(bytesToNumber(dleq.e));\n\tconst R_1 = sG.subtract(eA); // R1 = sG - eA\n\tconst R_2 = sB_.subtract(eC_); // R2 = sB' - eC'\n\tconst hash = hash_e([R_1, R_2, A, C_]); // e == hash(R1, R2, A, C')\n\treturn arraysEqual(hash, dleq.e);\n};\n\nexport const verifyDLEQProof_reblind = (\n\tsecret: Uint8Array, // secret\n\tdleq: DLEQ,\n\tC: WeierstrassPoint<bigint>, // unblinded e-cash signature point\n\tA: WeierstrassPoint<bigint>, // mint public key point\n) => {\n\tif (dleq.r === undefined) throw new Error('verifyDLEQProof_reblind: Undefined blinding factor');\n\tconst Y = hashToCurve(secret);\n\tconst C_ = C.add(A.multiply(dleq.r)); // Re-blind the e-cash signature\n\tconst bG = secp256k1.Point.BASE.multiply(dleq.r);\n\tconst B_ = Y.add(bG); // Re-blind the message\n\treturn verifyDLEQProof(dleq, B_, C_, A);\n};\n\n/**\n * !!! WARNING !!! Not recommended for production use, due to non-constant time operations See:\n * https://github.com/cashubtc/cashu-crypto-ts/pull/2 for more details See:\n * https://en.wikipedia.org/wiki/Timing_attack for information about timing attacks.\n */\nexport const createDLEQProof = (B_: WeierstrassPoint<bigint>, a: Uint8Array): DLEQ => {\n\tconst r = secp256k1.Point.Fn.fromBytes(createRandomSecretKey()); // r <- random (Uint8Array)\n\tconst R_1 = secp256k1.Point.BASE.multiply(r); // R1 = rG\n\tconst R_2 = B_.multiply(r); // R2 = rB_\n\tconst scalar_a = secp256k1.Point.Fn.fromBytes(a);\n\tconst C_ = B_.multiply(scalar_a); // C_ = aB_\n\tconst A = secp256k1.Point.BASE.multiply(scalar_a); // A = aG\n\tconst e = hash_e([R_1, R_2, A, C_]); // e = hash(R1, R2, A, C_)\n\tconst scalar_e = secp256k1.Point.Fn.fromBytes(e);\n\t// Use field operations for constant-time addition and multiplication\n\tconst s_scalar = secp256k1.Point.Fn.add(r, secp256k1.Point.Fn.mul(scalar_e, scalar_a));\n\tconst s = numberToBytesBE(s_scalar, 32); // s = (r + e * a) mod n\n\treturn { s, e };\n};\n","import { schnorr } from '@noble/curves/secp256k1';\nimport { type SerializedBlindedMessage } from '../model/types';\nimport { bytesToHex, hexToBytes } from '@noble/hashes/utils';\nimport { sha256 } from '@noble/hashes/sha2';\n\nfunction constructMessage(quote: string, blindedMessages: SerializedBlindedMessage[]): Uint8Array {\n\tlet message = quote;\n\tfor (const blindedMessage of blindedMessages) {\n\t\tmessage += blindedMessage.B_;\n\t}\n\tconst msgbytes = new TextEncoder().encode(message);\n\treturn sha256(msgbytes);\n}\n\nexport function signMintQuote(\n\tprivkey: string,\n\tquote: string,\n\tblindedMessages: SerializedBlindedMessage[],\n): string {\n\tconst message = constructMessage(quote, blindedMessages);\n\tconst privkeyBytes = hexToBytes(privkey);\n\tconst signature = schnorr.sign(message, privkeyBytes);\n\treturn bytesToHex(signature);\n}\n\nexport function verifyMintQuoteSignature(\n\tpubkey: string,\n\tquote: string,\n\tblindedMessages: SerializedBlindedMessage[],\n\tsignature: string,\n): boolean {\n\tconst sigbytes = hexToBytes(signature);\n\tlet pubkeyBytes = hexToBytes(pubkey);\n\tif (pubkeyBytes.length !== 33) return false;\n\tpubkeyBytes = pubkeyBytes.slice(1);\n\tconst message = constructMessage(quote, blindedMessages);\n\treturn schnorr.verify(sigbytes, message, pubkeyBytes);\n}\n","import { encodeBase64toUint8, decodeCBOR, encodeCBOR, Bytes } from '../utils';\nimport type {\n\tRawPaymentRequest,\n\tRawTransport,\n\tNUT10Option,\n\tPaymentRequestTransport,\n\tPaymentRequestTransportType,\n} from '../wallet/types';\n\nexport class PaymentRequest {\n\tconstructor(\n\t\tpublic transport?: PaymentRequestTransport[],\n\t\tpublic id?: string,\n\t\tpublic amount?: number,\n\t\tpublic unit?: string,\n\t\tpublic mints?: string[],\n\t\tpublic description?: string,\n\t\tpublic singleUse: boolean = false,\n\t\tpublic nut10?: NUT10Option,\n\t\tpublic nut26: boolean = false,\n\t) {}\n\n\ttoRawRequest() {\n\t\tconst rawRequest: RawPaymentRequest = {};\n\t\tif (this.transport) {\n\t\t\trawRequest.t = this.transport.map((t: PaymentRequestTransport) => ({\n\t\t\t\tt: t.type,\n\t\t\t\ta: t.target,\n\t\t\t\tg: t.tags,\n\t\t\t}));\n\t\t}\n\t\tif (this.id) {\n\t\t\trawRequest.i = this.id;\n\t\t}\n\t\tif (this.amount) {\n\t\t\trawRequest.a = this.amount;\n\t\t}\n\t\tif (this.unit) {\n\t\t\trawRequest.u = this.unit;\n\t\t}\n\t\tif (this.mints) {\n\t\t\trawRequest.m = this.mints;\n\t\t}\n\t\tif (this.description) {\n\t\t\trawRequest.d = this.description;\n\t\t}\n\t\tif (this.singleUse) {\n\t\t\trawRequest.s = this.singleUse;\n\t\t}\n\t\tif (this.nut10) {\n\t\t\trawRequest.nut10 = {\n\t\t\t\tk: this.nut10.kind,\n\t\t\t\td: this.nut10.data,\n\t\t\t\tt: this.nut10.tags,\n\t\t\t};\n\t\t}\n\t\tif (this.nut26) {\n\t\t\trawRequest.nut26 = this.nut26;\n\t\t}\n\t\treturn rawRequest;\n\t}\n\n\ttoEncodedRequest() {\n\t\tconst rawRequest: RawPaymentRequest = this.toRawRequest();\n\t\tconst data = encodeCBOR(rawRequest);\n\t\tconst encodedData = Bytes.toBase64(data);\n\t\treturn 'creq' + 'A' + encodedData;\n\t}\n\n\tgetTransport(type: PaymentRequestTransportType) {\n\t\treturn this.transport?.find((t: PaymentRequestTransport) => t.type === type);\n\t}\n\n\tstatic fromRawRequest(rawPaymentRequest: RawPaymentRequest): PaymentRequest {\n\t\tconst transports = rawPaymentRequest.t\n\t\t\t? rawPaymentRequest.t.map((t: RawTransport) => ({\n\t\t\t\t\ttype: t.t,\n\t\t\t\t\ttarget: t.a,\n\t\t\t\t\ttags: t.g,\n\t\t\t\t}))\n\t\t\t: undefined;\n\t\tconst nut10 = rawPaymentRequest.nut10\n\t\t\t? {\n\t\t\t\t\tkind: rawPaymentRequest.nut10.k,\n\t\t\t\t\tdata: rawPaymentRequest.nut10.d,\n\t\t\t\t\ttags: rawPaymentRequest.nut10.t,\n\t\t\t\t}\n\t\t\t: undefined;\n\t\treturn new PaymentRequest(\n\t\t\ttransports,\n\t\t\trawPaymentRequest.i,\n\t\t\trawPaymentRequest.a,\n\t\t\trawPaymentRequest.u,\n\t\t\trawPaymentRequest.m,\n\t\t\trawPaymentRequest.d,\n\t\t\trawPaymentRequest.s,\n\t\t\tnut10,\n\t\t\trawPaymentRequest.nut26,\n\t\t);\n\t}\n\n\tstatic fromEncodedRequest(encodedRequest: string): PaymentRequest {\n\t\tif (!encodedRequest.startsWith('creq')) {\n\t\t\tthrow new Error('unsupported pr: invalid prefix');\n\t\t}\n\t\tconst version = encodedRequest[4];\n\t\tif (version !== 'A') {\n\t\t\tthrow new Error('unsupported pr version');\n\t\t}\n\t\tconst encodedData = encodedRequest.slice(5);\n\t\tconst data = encodeBase64toUint8(encodedData);\n\t\tconst decoded = decodeCBOR(data) as RawPaymentRequest;\n\t\treturn this.fromRawRequest(decoded);\n\t}\n}\n","import { type DLEQ, pointFromHex, verifyDLEQProof_reblind } from '../crypto';\nimport { bytesToHex, hexToBytes } from '@noble/curves/utils';\nimport { sha256 } from '@noble/hashes/sha2';\nimport {\n\tencodeBase64ToJson,\n\tencodeBase64toUint8,\n\tencodeJsonToBase64,\n\tencodeUint8toBase64Url,\n\tisBase64String,\n} from './base64';\nimport { decodeCBOR, encodeCBOR } from './cbor';\nimport { PaymentRequest } from '../model/PaymentRequest';\nimport type {\n\tTokenMetadata,\n\tDeprecatedToken,\n\tKeys,\n\tMintKeys,\n\tMintKeyset,\n\tProof,\n\tSerializedDLEQ,\n\tToken,\n\tTokenV4Template,\n\tV4DLEQTemplate,\n\tV4InnerToken,\n\tV4ProofTemplate,\n} from '../model/types';\nimport { Bytes } from './Bytes';\nimport { type Keyset } from '../wallet';\n\n/**\n * Splits the amount into denominations of the provided keyset.\n *\n * @remarks\n * Partial splits will be filled up to value using minimum splits required. Sorting is only applied\n * if a fill was made - exact custom splits are always returned in the same order.\n * @param value Amount to split.\n * @param keyset Keys to look up split amounts.\n * @param split? Optional custom split amounts.\n * @param order? Optional order for split amounts (if fill was required)\n * @returns Array of split amounts.\n * @throws Error if split sum is greater than value or mint does not have keys for requested split.\n */\nexport function splitAmount(\n\tvalue: number,\n\tkeyset: Keys,\n\tsplit?: number[],\n\torder?: 'desc' | 'asc',\n): number[] {\n\tif (split) {\n\t\tconst totalSplitAmount = sumArray(split);\n\n\t\t// Special case: explicit \"zero-total\" outputs (restore or NUT-08 blanks)\n\t\tif (value === 0 && totalSplitAmount === 0) {\n\t\t\treturn split;\n\t\t}\n\n\t\t// Normal positive-value paths: ignore zeros for validation and totals\n\t\tconst positive = split.filter((amt) => amt > 0);\n\t\tconst totalPositive = sumArray(positive);\n\t\tif (totalPositive > value) {\n\t\t\tthrow new Error(`Split is greater than total amount: ${totalPositive} > ${value}`);\n\t\t}\n\t\tif (positive.some((amt) => !hasCorrespondingKey(amt, keyset))) {\n\t\t\tthrow new Error('Provided amount preferences do not match the amounts of the mint keyset.');\n\t\t}\n\n\t\t// if caller supplied an exact custom split, preserve their order\n\t\tif (totalPositive === value) {\n\t\t\treturn positive;\n\t\t}\n\n\t\t// Work only with validated positive amounts from here on\n\t\tsplit = positive;\n\t\tvalue -= totalPositive;\n\t} else {\n\t\tsplit = [];\n\t}\n\n\t// Denomination fill for the remaining value\n\tconst sortedKeyAmounts = getKeysetAmounts(keyset, 'desc');\n\tif (!sortedKeyAmounts || sortedKeyAmounts.length === 0) {\n\t\tthrow new Error('Cannot split amount, keyset is inactive or contains no keys');\n\t}\n\tfor (const amt of sortedKeyAmounts) {\n\t\tif (amt <= 0) continue;\n\t\t// Calculate how many of amt fit into remaining value\n\t\tconst requireCount = Math.floor(value / amt);\n\t\t// Add them to the split and reduce the target value by added amounts\n\t\tsplit.push(...Array<number>(requireCount).fill(amt));\n\t\tvalue -= amt * requireCount;\n\t\t// Break early once target is satisfied\n\t\tif (value === 0) break;\n\t}\n\tif (value !== 0) {\n\t\tthrow new Error(`Unable to split remaining amount: ${value}`);\n\t}\n\n\t// Only sort when we performed a fill and it was requested\n\t// Exact custom splits were returned unsorted earlier\n\tif (order) {\n\t\treturn split.sort((a, b) => (order === 'desc' ? b - a : a - b));\n\t}\n\treturn split;\n}\n\n/**\n * Creates a list of amounts to keep based on the proofs we have and the proofs we want to reach.\n *\n * @param proofsWeHave Complete set of proofs stored (from current mint)\n * @param amountToKeep Amount to keep.\n * @param keys Keys of current keyset.\n * @param targetCount The target number of proofs to reach.\n * @returns An array of amounts to keep.\n */\nexport function getKeepAmounts(\n\tproofsWeHave: Proof[],\n\tamountToKeep: number,\n\tkeys: Keys,\n\ttargetCount: number,\n): number[] {\n\t// determines amounts we need to reach the targetCount for each amount based on the amounts of the proofs we have\n\t// it tries to select amounts so that the proofs we have and the proofs we want reach the targetCount\n\tconst amountsWeWant: number[] = [];\n\tconst amountsWeHave = proofsWeHave.map((p: Proof) => p.amount);\n\tconst sortedKeyAmounts = getKeysetAmounts(keys, 'asc');\n\tsortedKeyAmounts.forEach((amt) => {\n\t\tconst countWeHave = amountsWeHave.filter((a) => a === amt).length;\n\t\tconst countWeWant = Math.max(targetCount - countWeHave, 0);\n\t\tfor (let i = 0; i < countWeWant; ++i) {\n\t\t\tif (amountsWeWant.reduce((a, b) => a + b, 0) + amt > amountToKeep) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tamountsWeWant.push(amt);\n\t\t}\n\t});\n\t// use splitAmount to fill the rest between the sum of amountsWeHave and amountToKeep\n\tconst amountDiff = amountToKeep - amountsWeWant.reduce((a, b) => a + b, 0);\n\tif (amountDiff) {\n\t\tconst remainingAmounts = splitAmount(amountDiff, keys);\n\t\tremainingAmounts.forEach((amt: number) => {\n\t\t\tamountsWeWant.push(amt);\n\t\t});\n\t}\n\treturn amountsWeWant.sort((a, b) => a - b);\n}\n/**\n * Returns the amounts in the keyset sorted by the order specified.\n *\n * @param keyset To search in.\n * @param order Order to sort the amounts in.\n * @returns The amounts in the keyset sorted by the order specified.\n */\nexport function getKeysetAmounts(keyset: Keys, order: 'asc' | 'desc' = 'desc'): number[] {\n\tif (order == 'desc') {\n\t\treturn Object.keys(keyset)\n\t\t\t.map((k: string) => parseInt(k))\n\t\t\t.sort((a: number, b: number) => b - a);\n\t}\n\treturn Object.keys(keyset)\n\t\t.map((k: string) => parseInt(k))\n\t\t.sort((a: number, b: number) => a - b);\n}\n\n/**\n * Checks if the provided amount is in the keyset.\n *\n * @param amount Amount to check.\n * @param keyset To search in.\n * @returns True if the amount is in the keyset, false otherwise.\n */\nexport function hasCorrespondingKey(amount: number, keyset: Keys): boolean {\n\treturn amount in keyset;\n}\n\n/**\n * Converts a bytes array to a number.\n *\n * @param bytes To convert to number.\n * @returns Number.\n */\nexport function bytesToNumber(bytes: Uint8Array): bigint {\n\treturn hexToNumber(bytesToHex(bytes));\n}\n\n/**\n * Converts a hex string to a number.\n *\n * @param hex To convert to number.\n * @returns Number.\n */\nexport function hexToNumber(hex: string): bigint {\n\treturn BigInt(`0x${hex}`);\n}\n\n/**\n * Converts a number to a hex string of 64 characters.\n *\n * @param number (bigint) to conver to hex.\n * @returns Hex string start-padded to 64 characters.\n */\nexport function numberToHexPadded64(number: bigint): string {\n\treturn number.toString(16).padStart(64, '0');\n}\n\nexport function isValidHex(str: string) {\n\treturn /^[a-f0-9]*$/i.test(str);\n}\n\n/**\n * Checks wether a proof or a list of proofs contains a non-hex id.\n *\n * @param p Proof or list of proofs.\n * @returns Boolean.\n */\nexport function hasNonHexId(p: Proof | Proof[]) {\n\tif (Array.isArray(p)) {\n\t\treturn p.some((proof) => !isValidHex(proof.id));\n\t}\n\treturn !isValidHex(p.id);\n}\n\n//used for json serialization\nexport function bigIntStringify<T>(_key: unknown, value: T) {\n\treturn typeof value === 'bigint' ? value.toString() : value;\n}\n\n/**\n * Helper function to encode a v3 cashu token.\n *\n * @param token To encode.\n * @returns Encoded token.\n */\nexport function getEncodedTokenV3(token: Token, removeDleq?: boolean): string {\n\tif (!hasNonHexId(token.proofs)) {\n\t\ttoken.proofs = convertToShortKeysetId(token.proofs);\n\t}\n\tif (removeDleq) {\n\t\ttoken.proofs = stripDleq(token.proofs);\n\t}\n\tconst v3TokenObj: DeprecatedToken = { token: [{ mint: token.mint, proofs: token.proofs }] };\n\tif (token.unit) {\n\t\tv3TokenObj.unit = token.unit;\n\t}\n\tif (token.memo) {\n\t\tv3TokenObj.memo = token.memo;\n\t}\n\tconst prefix = 'cashu';\n\tconst version = 'A';\n\treturn prefix + version + encodeJsonToBase64(v3TokenObj);\n}\n\n/*\n * Convert a keyset ID into short form\n */\nfunction convertToShortKeysetId(proofs: Proof[]) {\n\treturn proofs.map((p) => {\n\t\tconst newP = { ...p };\n\t\tnewP.id = newP.id.slice(0, 16);\n\t\treturn newP;\n\t});\n}\n\n/**\n * Helper function to encode a cashu token (defaults to v4 if keyset id allows it)\n *\n * @param token\n * @param [opts]\n */\nexport function getEncodedToken(\n\ttoken: Token,\n\topts?: { version?: 3 | 4; removeDleq?: boolean },\n): string {\n\t// Find out if it's a base64 keyset\n\tconst nonHex = hasNonHexId(token.proofs);\n\tif (nonHex || opts?.version === 3) {\n\t\tif (opts?.version === 4) {\n\t\t\tthrow new Error('can not encode to v4 token if proofs contain non-hex keyset id');\n\t\t}\n\t\treturn getEncodedTokenV3(token, opts?.removeDleq);\n\t}\n\treturn getEncodedTokenV4(token, opts?.removeDleq);\n}\n\nexport function getEncodedTokenV4(token: Token, removeDleq?: boolean): string {\n\tif (removeDleq) {\n\t\ttoken.proofs = stripDleq(token.proofs);\n\t}\n\t// Make sure each DLEQ has its blinding factor\n\ttoken.proofs.forEach((p) => {\n\t\tif (p.dleq && p.dleq.r == undefined) {\n\t\t\tthrow new Error('Missing blinding factor in included DLEQ proof');\n\t\t}\n\t});\n\tconst nonHex = hasNonHexId(token.proofs);\n\tif (nonHex) {\n\t\tthrow new Error('can not encode to v4 token if proofs contain non-hex keyset id');\n\t}\n\t// Map keyset IDs to short IDs\n\ttoken.proofs = convertToShortKeysetId(token.proofs);\n\n\tconst tokenTemplate = templateFromToken(token);\n\n\tconst encodedData = encodeCBOR(tokenTemplate);\n\tconst prefix = 'cashu';\n\tconst version = 'B';\n\tconst base64Data = encodeUint8toBase64Url(encodedData);\n\treturn prefix + version + base64Data;\n}\n\nfunction templateFromToken(token: Token): TokenV4Template {\n\tconst idMap: { [id: string]: Proof[] } = {};\n\tconst mint = token.mint;\n\tfor (let i = 0; i < token.proofs.length; i++) {\n\t\tconst proof = token.proofs[i];\n\t\tif (idMap[proof.id]) {\n\t\t\tidMap[proof.id].push(proof);\n\t\t} else {\n\t\t\tidMap[proof.id] = [proof];\n\t\t}\n\t}\n\tconst tokenTemplate: TokenV4Template = {\n\t\tm: mint,\n\t\tu: token.unit || 'sat',\n\t\tt: Object.keys(idMap).map(\n\t\t\t(id: string): V4InnerToken => ({\n\t\t\t\ti: hexToBytes(id),\n\t\t\t\tp: idMap[id].map(\n\t\t\t\t\t(p: Proof): V4ProofTemplate => ({\n\t\t\t\t\t\ta: p.amount,\n\t\t\t\t\t\ts: p.secret,\n\t\t\t\t\t\tc: hexToBytes(p.C),\n\t\t\t\t\t\t...(p.dleq && {\n\t\t\t\t\t\t\td: {\n\t\t\t\t\t\t\t\te: hexToBytes(p.dleq.e),\n\t\t\t\t\t\t\t\ts: hexToBytes(p.dleq.s),\n\t\t\t\t\t\t\t\tr: hexToBytes(p.dleq.r ?? '00'),\n\t\t\t\t\t\t\t} as V4DLEQTemplate,\n\t\t\t\t\t\t}),\n\t\t\t\t\t\t...(p.p2pk_e && {\n\t\t\t\t\t\t\tpe: hexToBytes(p.p2pk_e),\n\t\t\t\t\t\t}),\n\t\t\t\t\t\t...(p.witness && {\n\t\t\t\t\t\t\tw: JSON.stringify(p.witness),\n\t\t\t\t\t\t}),\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t}),\n\t\t),\n\t} as TokenV4Template;\n\tif (token.memo) {\n\t\ttokenTemplate.d = token.memo;\n\t}\n\treturn tokenTemplate;\n}\n\nfunction tokenFromTemplate(template: TokenV4Template): Token {\n\tconst proofs: Proof[] = [];\n\ttemplate.t.forEach((t) =>\n\t\tt.p.forEach((p) => {\n\t\t\tproofs.push({\n\t\t\t\tsecret: p.s,\n\t\t\t\tC: bytesToHex(p.c),\n\t\t\t\tamount: p.a,\n\t\t\t\tid: bytesToHex(t.i),\n\t\t\t\t...(p.d && {\n\t\t\t\t\tdleq: {\n\t\t\t\t\t\tr: bytesToHex(p.d.r),\n\t\t\t\t\t\ts: bytesToHex(p.d.s),\n\t\t\t\t\t\te: bytesToHex(p.d.e),\n\t\t\t\t\t} as SerializedDLEQ,\n\t\t\t\t}),\n\t\t\t\t...(p.pe && {\n\t\t\t\t\tp2pk_e: bytesToHex(p.pe),\n\t\t\t\t}),\n\t\t\t\t...(p.w && {\n\t\t\t\t\twitness: p.w,\n\t\t\t\t}),\n\t\t\t});\n\t\t}),\n\t);\n\tconst decodedToken: Token = { mint: template.m, proofs, unit: template.u || 'sat' };\n\tif (template.d) {\n\t\tdecodedToken.memo = template.d;\n\t}\n\treturn decodedToken;\n}\n\n/**\n * Helper function to decode cashu tokens into object.\n *\n * @param token An encoded cashu token (cashuAey...)\n * @returns Cashu token object.\n */\nexport function getDecodedToken(tokenString: string, keysets?: MintKeyset[] | Keyset[]) {\n\t// remove prefixes\n\tconst token = removePrefix(tokenString);\n\tconst tokenObj = handleTokens(token);\n\ttokenObj.proofs = mapShortKeysetIds(tokenObj.proofs, keysets);\n\treturn tokenObj;\n}\n\n/**\n * Returns the metadata of a cashu token.\n *\n * @param token An encoded cashu token (cashuAey...)\n * @returns Token metadata.\n */\nexport function getTokenMetadata(token: string): TokenMetadata {\n\ttoken = removePrefix(token);\n\tconst tokenObj = handleTokens(token);\n\treturn {\n\t\tunit: tokenObj.unit || 'sat',\n\t\tmint: tokenObj.mint,\n\t\tamount: sumProofs(tokenObj.proofs),\n\t\t...(tokenObj.memo && { memo: tokenObj.memo }),\n\t\tincompleteProofs: tokenObj.proofs.map((p) => ({\n\t\t\tsecret: p.secret,\n\t\t\tC: p.C,\n\t\t\tamount: p.amount,\n\t\t\t...(p.dleq && {\n\t\t\t\tdleq: p.dleq,\n\t\t\t}),\n\t\t\t...(p.witness && {\n\t\t\t\twitness: p.witness,\n\t\t\t}),\n\t\t})),\n\t};\n}\n\n/**\n * Helper function to decode different versions of cashu tokens into an object.\n *\n * @param token An encoded cashu token (cashuAey...)\n * @returns Cashu Token object.\n */\nexport function handleTokens(token: string): Token {\n\tconst version = token.slice(0, 1);\n\tconst encodedToken = token.slice(1);\n\tif (version === 'A') {\n\t\tconst parsedV3Token = encodeBase64ToJson<DeprecatedToken>(encodedToken);\n\t\tif (parsedV3Token.token.length > 1) {\n\t\t\tthrow new Error('Multi entry token are not supported');\n\t\t}\n\t\tconst entry = parsedV3Token.token[0];\n\t\tconst tokenObj: Token = {\n\t\t\tmint: entry.mint,\n\t\t\tproofs: entry.proofs,\n\t\t\tunit: parsedV3Token.unit || 'sat',\n\t\t};\n\t\tif (parsedV3Token.memo) {\n\t\t\ttokenObj.memo = parsedV3Token.memo;\n\t\t}\n\t\treturn tokenObj;\n\t} else if (version === 'B') {\n\t\tconst uInt8Token = encodeBase64toUint8(encodedToken);\n\t\tconst tokenData = decodeCBOR(uInt8Token) as TokenV4Template;\n\t\treturn tokenFromTemplate(tokenData);\n\t}\n\tthrow new Error('Token version is not supported');\n}\n\n/**\n * Returns the keyset id of a set of keys.\n *\n * @param keys Keys object to derive keyset id from.\n * @param unit (optional) the unit of the keyset.\n * @param expiry (optional) expiry of the keyset.\n * @param versionByte (optional) version of the keyset ID. Default is 0.\n * @param isDeprecatedBase64 (optional) true if the keyset ID should be derived as a deprecated v0\n *   base64 keyset ID.\n * @returns Keyset id of the keys.\n * @throws If keyset versionByte is not valid.\n */\nexport function deriveKeysetId(\n\tkeys: Keys,\n\tunit?: string,\n\texpiry?: number,\n\tversionByte: number = 0,\n\tisDeprecatedBase64: boolean = false,\n) {\n\tif (isDeprecatedBase64) {\n\t\tconst pubkeysConcat = Object.entries(keys)\n\t\t\t.sort((a: [string, string], b: [string, string]) => +a[0] - +b[0])\n\t\t\t.map(([, pubKey]: [unknown, string]) => pubKey)\n\t\t\t.reduce((prev: string, curr: string) => prev + curr, '');\n\t\tconst hash = sha256(pubkeysConcat);\n\t\tconst b64 = Bytes.toBase64(hash);\n\t\treturn b64.slice(0, 12);\n\t}\n\n\tlet pubkeysConcat = Object.entries(keys)\n\t\t.sort((a: [string, string], b: [string, string]) => +a[0] - +b[0])\n\t\t.map(([, pubKey]: [unknown, string]) => hexToBytes(pubKey))\n\t\t.reduce((prev: Uint8Array, curr: Uint8Array) => mergeUInt8Arrays(prev, curr), new Uint8Array());\n\n\tlet hash;\n\tlet hashHex;\n\tswitch (versionByte) {\n\t\tcase 0:\n\t\t\thash = sha256(pubkeysConcat);\n\t\t\thashHex = Bytes.toHex(hash).slice(0, 14);\n\t\t\treturn '00' + hashHex;\n\t\tcase 1:\n\t\t\tif (!unit) {\n\t\t\t\tthrow new Error('Cannot compute keyset ID version 01: unit is required.');\n\t\t\t}\n\t\t\tpubkeysConcat = mergeUInt8Arrays(pubkeysConcat, Bytes.fromString('unit:' + unit));\n\t\t\tif (expiry) {\n\t\t\t\tpubkeysConcat = mergeUInt8Arrays(\n\t\t\t\t\tpubkeysConcat,\n\t\t\t\t\tBytes.fromString('final_expiry:' + expiry.toString()),\n\t\t\t\t);\n\t\t\t}\n\t\t\thash = sha256(pubkeysConcat);\n\t\t\thashHex = Bytes.toHex(hash);\n\t\t\treturn '01' + hashHex;\n\t\tdefault:\n\t\t\tthrow new Error(`Unrecognized keyset ID version: ${versionByte}`);\n\t}\n}\n\nexport function mergeUInt8Arrays(a1: Uint8Array, a2: Uint8Array): Uint8Array {\n\t// sum of individual array lengths\n\tconst mergedArray = new Uint8Array(a1.length + a2.length);\n\tmergedArray.set(a1);\n\tmergedArray.set(a2, a1.length);\n\treturn mergedArray;\n}\n\nexport function sortProofsById(proofs: Proof[]) {\n\treturn proofs.sort((a: Proof, b: Proof) => a.id.localeCompare(b.id));\n}\n\nexport function isObj(v: unknown): v is object {\n\treturn typeof v === 'object';\n}\n\nexport function checkResponse(data: { error?: string; detail?: string }) {\n\tif (!isObj(data)) return;\n\tif ('error' in data && data.error) {\n\t\tthrow new Error(data.error);\n\t}\n\tif ('detail' in data && data.detail) {\n\t\tthrow new Error(data.detail);\n\t}\n}\n\nexport function joinUrls(...parts: string[]): string {\n\treturn parts.map((part: string) => part.replace(/(^\\/+|\\/+$)/g, '')).join('/');\n}\n\nexport function sanitizeUrl(url: string): string {\n\treturn url.replace(/\\/$/, '');\n}\n\nexport function sumProofs(proofs: Proof[]) {\n\treturn proofs.reduce((acc: number, proof: Proof) => acc + proof.amount, 0);\n}\n\nexport function decodePaymentRequest(paymentRequest: string) {\n\treturn PaymentRequest.fromEncodedRequest(paymentRequest);\n}\n\nexport class MessageNode {\n\tprivate _value: string;\n\tprivate _next: MessageNode | null;\n\n\tpublic get value(): string {\n\t\treturn this._value;\n\t}\n\tpublic set value(message: string) {\n\t\tthis._value = message;\n\t}\n\tpublic get next(): MessageNode | null {\n\t\treturn this._next;\n\t}\n\tpublic set next(node: MessageNode | null) {\n\t\tthis._next = node;\n\t}\n\n\tconstructor(message: string) {\n\t\tthis._value = message;\n\t\tthis._next = null;\n\t}\n}\n\nexport class MessageQueue {\n\tprivate _first: MessageNode | null;\n\tprivate _last: MessageNode | null;\n\n\tpublic get first(): MessageNode | null {\n\t\treturn this._first;\n\t}\n\tpublic set first(messageNode: MessageNode | null) {\n\t\tthis._first = messageNode;\n\t}\n\tpublic get last(): MessageNode | null {\n\t\treturn this._last;\n\t}\n\tpublic set last(messageNode: MessageNode | null) {\n\t\tthis._last = messageNode;\n\t}\n\tprivate _size: number;\n\tpublic get size(): number {\n\t\treturn this._size;\n\t}\n\tpublic set size(v: number) {\n\t\tthis._size = v;\n\t}\n\n\tconstructor() {\n\t\tthis._first = null;\n\t\tthis._last = null;\n\t\tthis._size = 0;\n\t}\n\tenqueue(message: string): boolean {\n\t\tconst newNode = new MessageNode(message);\n\t\tif (this._size === 0 || !this._last) {\n\t\t\tthis._first = newNode;\n\t\t\tthis._last = newNode;\n\t\t} else {\n\t\t\tthis._last.next = newNode;\n\t\t\tthis._last = newNode;\n\t\t}\n\t\tthis._size++;\n\t\treturn true;\n\t}\n\tdequeue(): string | null {\n\t\tif (this._size === 0 || !this._first) return null;\n\n\t\tconst prev = this._first;\n\t\tthis._first = prev.next;\n\t\tprev.next = null;\n\n\t\tthis._size--;\n\t\treturn prev.value;\n\t}\n}\n/**\n * Removes all traces of DLEQs from a list of proofs.\n *\n * @param proofs The list of proofs that dleq should be stripped from.\n */\nexport function stripDleq(proofs: Proof[]): Array<Omit<Proof, 'dleq'>> {\n\treturn proofs.map((p) => {\n\t\tconst newP = { ...p };\n\t\tdelete newP['dleq'];\n\t\treturn newP;\n\t});\n}\n\n/**\n * Check that the keyset hashes to the specified ID.\n *\n * @deprecated Now part of Keyset class.\n * @param keys The keyset to be verified.\n * @returns True if the verification was successful, false otherwise.\n * @throws Error if the keyset ID version is unrecognized.\n */\nexport function verifyKeysetId(keys: MintKeys): boolean {\n\tconst isBase64 = isBase64String(keys.id);\n\tconst isValidHex = /^[a-fA-F0-9]+$/.test(keys.id);\n\tconst versionByte = isValidHex ? hexToBytes(keys.id)[0] : 0;\n\treturn (\n\t\tderiveKeysetId(\n\t\t\tkeys.keys,\n\t\t\tkeys.unit,\n\t\t\tkeys.final_expiry,\n\t\t\tversionByte,\n\t\t\tisBase64 && !isValidHex,\n\t\t) === keys.id\n\t);\n}\n\n/**\n * Maps the short keyset IDs stored in the token to actual keyset IDs that were fetched from the\n * Mint.\n */\nfunction mapShortKeysetIds(proofs: Proof[], keysets?: MintKeyset[] | Keyset[]): Proof[] {\n\tconst newProofs = [];\n\tfor (const proof of proofs) {\n\t\tlet idBytes;\n\t\ttry {\n\t\t\tidBytes = hexToBytes(proof.id);\n\t\t} catch {\n\t\t\t// Base64 keysets don't need conversion\n\t\t\tnewProofs.push(proof);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (idBytes[0] === 0x00) {\n\t\t\tnewProofs.push(proof);\n\t\t} else if (idBytes[0] === 0x01) {\n\t\t\tif (!keysets) {\n\t\t\t\tthrow new Error('A short keyset ID v2 was encountered, but got no keysets to map it to.');\n\t\t\t}\n\t\t\t// Look for a match: prefix(keyset ID) == short ID\n\t\t\tlet found = false;\n\t\t\tfor (const keyset of keysets) {\n\t\t\t\tif (proof.id === keyset.id.slice(0, proof.id.length)) {\n\t\t\t\t\tproof.id = keyset.id;\n\t\t\t\t\tnewProofs.push(proof);\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Couldn't map short keyset ID ${proof.id} to any known keysets of the current Mint`,\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(`Unknown keyset ID version: ${idBytes[0]}`);\n\t\t}\n\t}\n\n\treturn newProofs;\n}\n\n/**\n * Checks that the proof has a valid DLEQ proof according to keyset `keys`\n *\n * @param proof The proof subject to verification.\n * @param keyset The Mint's keyset to be used for verification.\n * @returns True if verification succeeded, false otherwise.\n * @throws Error if @param proof does not match any key in @param keyset.\n */\nexport function hasValidDleq(proof: Proof, keyset: MintKeys | Keyset): boolean {\n\tif (proof.dleq == undefined) {\n\t\treturn false;\n\t}\n\tconst dleq = {\n\t\te: hexToBytes(proof.dleq.e),\n\t\ts: hexToBytes(proof.dleq.s),\n\t\tr: hexToNumber(proof.dleq.r ?? '00'),\n\t} as DLEQ;\n\tif (!hasCorrespondingKey(proof.amount, keyset.keys)) {\n\t\tthrow new Error(`undefined key for amount ${proof.amount}`);\n\t}\n\tconst key = keyset.keys[proof.amount];\n\treturn verifyDLEQProof_reblind(\n\t\tnew TextEncoder().encode(proof.secret),\n\t\tdleq,\n\t\tpointFromHex(proof.C),\n\t\tpointFromHex(key),\n\t);\n}\n\nfunction concatByteArrays(...arrays: Uint8Array[]): Uint8Array {\n\tconst totalLength = arrays.reduce((a, c) => a + c.length, 0);\n\tconst byteArray = new Uint8Array(totalLength);\n\tlet pointer = 0;\n\tfor (let i = 0; i < arrays.length; i++) {\n\t\tbyteArray.set(arrays[i], pointer);\n\t\tpointer = pointer + arrays[i].length;\n\t}\n\treturn byteArray;\n}\n\nexport function getEncodedTokenBinary(token: Token): Uint8Array {\n\tconst utf8Encoder = new TextEncoder();\n\tconst template = templateFromToken(token);\n\tconst binaryTemplate = encodeCBOR(template);\n\tconst prefix = utf8Encoder.encode('craw');\n\tconst version = utf8Encoder.encode('B');\n\treturn concatByteArrays(prefix, version, binaryTemplate);\n}\n\nexport function getDecodedTokenBinary(bytes: Uint8Array): Token {\n\tconst utfDecoder = new TextDecoder();\n\tconst prefix = utfDecoder.decode(bytes.slice(0, 4));\n\tconst version = utfDecoder.decode(new Uint8Array([bytes[4]]));\n\tif (prefix !== 'craw' || version !== 'B') {\n\t\tthrow new Error('not a valid binary token');\n\t}\n\tconst binaryToken = bytes.slice(5);\n\tconst decoded = decodeCBOR(binaryToken) as TokenV4Template;\n\treturn tokenFromTemplate(decoded);\n}\n\nfunction sumArray(arr: number[]) {\n\treturn arr.reduce((a, c) => a + c, 0);\n}\n\n/**\n * Utility function for deep equality comparison of objects.\n */\nexport function deepEqual<T>(a: T, b: T): boolean {\n\tif (a === b) return true;\n\tif (a == null || b == null) return false;\n\tif (typeof a !== 'object' || typeof b !== 'object') return false;\n\n\tif (Array.isArray(a) && Array.isArray(b)) {\n\t\tif (a.length !== b.length) return false;\n\t\treturn a.every((item, index) => deepEqual(item, b[index]));\n\t}\n\n\tif (Array.isArray(a) || Array.isArray(b)) return false;\n\n\tconst keysA = Object.keys(a) as Array<keyof T>;\n\tconst keysB = Object.keys(b) as Array<keyof T>;\n\tif (keysA.length !== keysB.length) return false;\n\n\treturn keysA.every((key) => keysB.includes(key) && deepEqual(a[key], b[key]));\n}\n\nfunction removePrefix(token: string): string {\n\tconst uriPrefixes = ['web+cashu://', 'cashu://', 'cashu:', 'cashu'];\n\turiPrefixes.forEach((prefix: string) => {\n\t\tif (!token.startsWith(prefix)) {\n\t\t\treturn;\n\t\t}\n\t\ttoken = token.slice(prefix.length);\n\t});\n\treturn token;\n}\n","import { MessageQueue } from '../utils';\nimport { type JsonRpcMessage, type JsonRpcReqParams, type RpcSubId } from '../model/types';\nimport { type OnOpenError, type OnOpenSuccess } from '../wallet/types/websocket';\nimport { getWebSocketImpl } from './ws';\nimport { type Logger, NULL_LOGGER } from '../logger';\n\n// Internal interface for RPC listeners\ninterface RpcListener {\n\tcallback: () => void;\n\terrorCallback: (e: Error) => void;\n}\n\nexport class ConnectionManager {\n\tprivate static instance: ConnectionManager;\n\tprivate connectionMap: Map<string, WSConnection> = new Map();\n\n\tstatic getInstance() {\n\t\tif (!ConnectionManager.instance) {\n\t\t\tConnectionManager.instance = new ConnectionManager();\n\t\t}\n\t\treturn ConnectionManager.instance;\n\t}\n\n\tgetConnection(url: string, logger?: Logger): WSConnection {\n\t\tif (this.connectionMap.has(url)) {\n\t\t\treturn this.connectionMap.get(url) as WSConnection;\n\t\t}\n\t\tconst newConn = new WSConnection(url, logger);\n\t\tthis.connectionMap.set(url, newConn);\n\t\treturn newConn;\n\t}\n}\n\nexport class WSConnection {\n\tpublic readonly url: URL;\n\tprivate readonly _WS: typeof WebSocket;\n\tprivate ws: WebSocket | undefined;\n\tprivate connectionPromise: Promise<void> | undefined;\n\tprivate subListeners: { [subId: string]: Array<(payload: unknown) => void> } = {};\n\tprivate rpcListeners: { [rpcSubId: string]: RpcListener } = {};\n\tprivate messageQueue: MessageQueue;\n\tprivate handlingInterval?: number;\n\tprivate rpcId = 0;\n\tprivate _logger: Logger;\n\tprivate onCloseCallbacks: Array<(e: CloseEvent) => void> = [];\n\n\tconstructor(url: string, logger?: Logger) {\n\t\tthis._WS = getWebSocketImpl();\n\t\tthis.url = new URL(url);\n\t\tthis.messageQueue = new MessageQueue();\n\t\tthis._logger = logger ?? NULL_LOGGER;\n\t}\n\n\tconnect() {\n\t\tif (!this.connectionPromise) {\n\t\t\tthis.connectionPromise = new Promise((resolve: OnOpenSuccess, reject: OnOpenError) => {\n\t\t\t\ttry {\n\t\t\t\t\tthis.ws = new this._WS(this.url.toString());\n\t\t\t\t\tthis.onCloseCallbacks = [];\n\t\t\t\t} catch (err: unknown) {\n\t\t\t\t\treject(err instanceof Error ? err : new Error(String(err)));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.ws.onopen = () => {\n\t\t\t\t\tresolve();\n\t\t\t\t};\n\t\t\t\tthis.ws.onerror = () => {\n\t\t\t\t\treject(new Error('Failed to open WebSocket'));\n\t\t\t\t};\n\t\t\t\tthis.ws.onmessage = (e: MessageEvent) => {\n\t\t\t\t\tthis.messageQueue.enqueue(e.data as string);\n\t\t\t\t\tif (!this.handlingInterval) {\n\t\t\t\t\t\tthis.handlingInterval = setInterval(\n\t\t\t\t\t\t\tthis.handleNextMessage.bind(this),\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t) as unknown as number;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tthis.ws.onclose = (e: CloseEvent) => {\n\t\t\t\t\tthis.connectionPromise = undefined;\n\t\t\t\t\tthis.onCloseCallbacks.forEach((cb) => cb(e));\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\t\treturn this.connectionPromise;\n\t}\n\n\tsendRequest(method: 'subscribe', params: JsonRpcReqParams): void;\n\tsendRequest(method: 'unsubscribe', params: { subId: string }): void;\n\tsendRequest(method: 'subscribe' | 'unsubscribe', params: Partial<JsonRpcReqParams>) {\n\t\tif (this.ws?.readyState !== 1) {\n\t\t\tif (method === 'unsubscribe') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._logger.error('Attempted sendRequest, but socket was not open');\n\t\t\tthrow new Error('Socket not open');\n\t\t}\n\t\tconst id = this.rpcId;\n\t\tthis.rpcId++;\n\t\tconst message = JSON.stringify({ jsonrpc: '2.0', method, params, id });\n\t\tthis.ws?.send(message);\n\t}\n\n\t/**\n\t * @deprecated Use cancelSubscription for JSONRPC compliance.\n\t */\n\tcloseSubscription(subId: string) {\n\t\tthis.ws?.send(JSON.stringify(['CLOSE', subId]));\n\t}\n\n\taddSubListener<TPayload = unknown>(subId: string, callback: (payload: TPayload) => void) {\n\t\t(this.subListeners[subId] = this.subListeners[subId] || []).push(\n\t\t\tcallback as (payload: unknown) => void,\n\t\t);\n\t}\n\n\tprivate addRpcListener(\n\t\tcallback: () => void,\n\t\terrorCallback: (e: Error) => void,\n\t\tid: Exclude<RpcSubId, null>,\n\t) {\n\t\tthis.rpcListeners[id] = { callback, errorCallback };\n\t}\n\n\tprivate removeRpcListener(id: Exclude<RpcSubId, null>) {\n\t\tdelete this.rpcListeners[id];\n\t}\n\n\tprivate removeListener<TPayload = unknown>(subId: string, callback: (payload: TPayload) => void) {\n\t\tif (!this.subListeners[subId]) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.subListeners[subId].length === 1) {\n\t\t\tdelete this.subListeners[subId];\n\t\t\treturn;\n\t\t}\n\t\tthis.subListeners[subId] = this.subListeners[subId].filter(\n\t\t\t(fn) => fn !== (callback as (payload: unknown) => void),\n\t\t);\n\t}\n\n\tasync ensureConnection() {\n\t\tif (this.ws?.readyState !== 1) {\n\t\t\tawait this.connect();\n\t\t}\n\t}\n\n\tprivate handleNextMessage() {\n\t\tif (this.messageQueue.size === 0) {\n\t\t\tclearInterval(this.handlingInterval);\n\t\t\tthis.handlingInterval = undefined;\n\t\t\treturn;\n\t\t}\n\t\tconst message = this.messageQueue.dequeue() as string;\n\t\tlet parsed;\n\t\ttry {\n\t\t\tparsed = JSON.parse(message) as JsonRpcMessage;\n\t\t\tif ('result' in parsed && parsed.id != undefined) {\n\t\t\t\tif (this.rpcListeners[parsed.id]) {\n\t\t\t\t\tthis.rpcListeners[parsed.id].callback();\n\t\t\t\t\tthis.removeRpcListener(parsed.id);\n\t\t\t\t}\n\t\t\t} else if ('error' in parsed && parsed.id != undefined) {\n\t\t\t\tif (this.rpcListeners[parsed.id]) {\n\t\t\t\t\tthis.rpcListeners[parsed.id].errorCallback(new Error(parsed.error.message));\n\t\t\t\t\tthis.removeRpcListener(parsed.id);\n\t\t\t\t}\n\t\t\t} else if ('method' in parsed) {\n\t\t\t\tif ('id' in parsed) {\n\t\t\t\t\t// Do nothing as mints should not send requests\n\t\t\t\t} else {\n\t\t\t\t\tconst subId = parsed.params?.subId;\n\t\t\t\t\tif (!subId) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (this.subListeners[subId]?.length > 0) {\n\t\t\t\t\t\tconst notification = parsed;\n\t\t\t\t\t\tthis.subListeners[subId].forEach((cb) => cb(notification.params?.payload));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tthis._logger.error('Error doing handleNextMessage', { e });\n\t\t\treturn;\n\t\t}\n\t}\n\n\tcreateSubscription<TPayload = unknown>(\n\t\tparams: Omit<JsonRpcReqParams, 'subId'>,\n\t\tcallback: (payload: TPayload) => void,\n\t\terrorCallback: (e: Error) => void,\n\t): string {\n\t\tif (this.ws?.readyState !== 1) {\n\t\t\tthis._logger.error('Attempted createSubscription, but socket was not open');\n\t\t\tthrow new Error('Socket is not open');\n\t\t}\n\t\tconst subId = (Math.random() + 1).toString(36).substring(7);\n\t\tthis.addRpcListener(\n\t\t\t() => {\n\t\t\t\tthis.addSubListener(subId, callback);\n\t\t\t},\n\t\t\terrorCallback,\n\t\t\tthis.rpcId,\n\t\t);\n\t\tthis.sendRequest('subscribe', { ...params, subId });\n\t\tthis.rpcId++;\n\t\treturn subId;\n\t}\n\n\t/**\n\t * Cancels a subscription, sending an unsubscribe request and handling responses.\n\t *\n\t * @param subId The subscription ID to cancel.\n\t * @param callback The original payload callback to remove.\n\t * @param errorCallback Optional callback for unsubscribe errors (defaults to logging).\n\t */\n\tcancelSubscription<TPayload = unknown>(\n\t\tsubId: string,\n\t\tcallback: (payload: TPayload) => void,\n\t\terrorCallback?: (e: Error) => void,\n\t) {\n\t\tthis.removeListener(subId, callback);\n\t\tthis.addRpcListener(\n\t\t\t() => {\n\t\t\t\tthis._logger.info('Unsubscribed {subId}', { subId });\n\t\t\t},\n\t\t\terrorCallback || ((e: Error) => this._logger.error('Unsubscribe failed', { e })),\n\t\t\tthis.rpcId,\n\t\t);\n\t\tthis.sendRequest('unsubscribe', { subId });\n\t}\n\n\tget activeSubscriptions() {\n\t\treturn Object.keys(this.subListeners);\n\t}\n\n\tclose() {\n\t\tif (this.ws) {\n\t\t\tthis.ws?.close();\n\t\t}\n\t}\n\n\tonClose(callback: (e: CloseEvent) => void) {\n\t\tthis.onCloseCallbacks.push(callback);\n\t}\n}\n","import type { PartialMeltQuoteResponse } from '../mint/types';\nimport { MeltQuoteState } from '../mint/types';\nimport type { Logger } from '../logger';\n\nexport type MeltQuoteResponsePaidDeprecated = {\n\tpaid?: boolean;\n};\n\nexport function handleMeltQuoteResponseDeprecated(\n\tresponse: PartialMeltQuoteResponse & MeltQuoteResponsePaidDeprecated,\n\tlogger: Logger,\n): PartialMeltQuoteResponse {\n\t// if the response MeltQuoteResponse has a \"paid\" flag, we monkey patch it to the state enum\n\tif (!response.state) {\n\t\tlogger.warn(\n\t\t\t\"Field 'state' not found in MeltQuoteResponse. Update NUT-05 of mint: https://github.com/cashubtc/nuts/pull/136)\",\n\t\t);\n\t\tif (typeof response.paid === 'boolean') {\n\t\t\tresponse.state = response.paid ? MeltQuoteState.PAID : MeltQuoteState.UNPAID;\n\t\t}\n\t}\n\treturn response;\n}\n","import type { PartialMintQuoteResponse } from '../mint/types';\nimport { MintQuoteState } from '../mint/types';\nimport type { Logger } from '../logger';\n\nexport type MintQuoteResponsePaidDeprecated = {\n\tpaid?: boolean;\n};\n\nexport function handleMintQuoteResponseDeprecated(\n\tresponse: PartialMintQuoteResponse & MintQuoteResponsePaidDeprecated,\n\tlogger: Logger,\n): PartialMintQuoteResponse {\n\t// if the response MeltQuoteResponse has a \"paid\" flag, we monkey patch it to the state enum\n\tif (!response.state) {\n\t\tlogger.warn(\n\t\t\t\"Field 'state' not found in MintQuoteResponse. Update NUT-04 of mint: https://github.com/cashubtc/nuts/pull/141)\",\n\t\t);\n\t\tif (typeof response.paid === 'boolean') {\n\t\t\tresponse.state = response.paid ? MintQuoteState.PAID : MintQuoteState.UNPAID;\n\t\t}\n\t}\n\treturn response;\n}\n","import type { MintContactInfo, GetInfoResponse } from '../mint/types';\nimport type { Logger } from '../logger';\n\nexport function handleMintInfoContactFieldDeprecated(data: GetInfoResponse, logger: Logger) {\n\t// Monkey patch old contact field [\"email\", \"me@mail.com\"] Array<[string, string]>; to new contact field [{method: \"email\", info: \"me@mail.com\"}] Array<MintContactInfo>\n\t// This is to maintain backwards compatibility with older versions of the mint\n\tif (Array.isArray(data?.contact) && data?.contact.length > 0) {\n\t\tdata.contact = data.contact.map((contact: MintContactInfo) => {\n\t\t\tif (\n\t\t\t\tArray.isArray(contact) &&\n\t\t\t\tcontact.length === 2 &&\n\t\t\t\ttypeof contact[0] === 'string' &&\n\t\t\t\ttypeof contact[1] === 'string'\n\t\t\t) {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t`Mint returned deprecated 'contact' field: Update NUT-06: https://github.com/cashubtc/nuts/pull/117`,\n\t\t\t\t);\n\t\t\t\treturn { method: contact[0], info: contact[1] } as MintContactInfo;\n\t\t\t}\n\t\t\treturn contact;\n\t\t});\n\t}\n\treturn data;\n}\n","import {\n\ttype GetInfoResponse,\n\ttype MPPMethod,\n\ttype SwapMethod,\n\ttype WebSocketSupport,\n} from '../mint/types';\n\ntype Method = 'GET' | 'POST';\ntype Endpoint = { method: Method; path: string };\n\ntype ProtectedIndex = {\n\tcache: Record<string, boolean>; // \"METHOD /v1/foo\"\n\texact: Array<{ method: Method; path: string }>;\n\tregex: Array<{ method: Method; regex: RegExp }>;\n};\n\nexport class MintInfo {\n\t// Full mint info response\n\tprivate readonly _mintInfo: GetInfoResponse;\n\t// NUT-22, Blind-auth protected endpoints\n\tprivate readonly _protected22?: ProtectedIndex;\n\t// NUT-21, Clear-auth protected endpoints\n\tprivate readonly _protected21?: ProtectedIndex;\n\t// detects regex intent\n\tprivate readonly REGEX_METACHAR = /[\\\\^$.*+?()[\\]{}|]/;\n\n\tconstructor(info: GetInfoResponse) {\n\t\tthis._mintInfo = info;\n\n\t\tconst pe22 = this.toEndpoints(info?.nuts?.[22]?.protected_endpoints);\n\t\tthis._protected22 = this.buildIndex(pe22);\n\n\t\tconst pe21 = this.toEndpoints(info?.nuts?.[21]?.protected_endpoints);\n\t\tthis._protected21 = this.buildIndex(pe21);\n\t}\n\n\tisSupported(num: 4 | 5): { disabled: boolean; params: SwapMethod[] };\n\tisSupported(num: 7 | 8 | 9 | 10 | 11 | 12 | 14 | 20): { supported: boolean };\n\tisSupported(num: 17): { supported: boolean; params?: WebSocketSupport[] };\n\tisSupported(num: 15): { supported: boolean; params?: MPPMethod[] };\n\tisSupported(num: number) {\n\t\tswitch (num) {\n\t\t\tcase 4:\n\t\t\tcase 5: {\n\t\t\t\treturn this.checkMintMelt(num);\n\t\t\t}\n\t\t\tcase 7:\n\t\t\tcase 8:\n\t\t\tcase 9:\n\t\t\tcase 10:\n\t\t\tcase 11:\n\t\t\tcase 12:\n\t\t\tcase 14:\n\t\t\tcase 20: {\n\t\t\t\treturn this.checkGenericNut(num);\n\t\t\t}\n\t\t\tcase 17: {\n\t\t\t\treturn this.checkNut17();\n\t\t\t}\n\t\t\tcase 15: {\n\t\t\t\treturn this.checkNut15();\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error('nut is not supported by cashu-ts');\n\t\t\t}\n\t\t}\n\t}\n\n\trequiresBlindAuthToken(method: 'GET' | 'POST', path: string): boolean {\n\t\treturn this.matchesProtected(this._protected22, method, path);\n\t}\n\n\trequiresClearAuthToken(method: 'GET' | 'POST', path: string): boolean {\n\t\treturn this.matchesProtected(this._protected21, method, path);\n\t}\n\n\tprivate matchesProtected(idx: ProtectedIndex | undefined, method: Method, path: string): boolean {\n\t\tif (!idx) return false;\n\n\t\tconst cacheKey = `${method} ${path}`;\n\t\tconst cached = idx.cache[cacheKey];\n\t\tif (typeof cached === 'boolean') return cached;\n\n\t\tconst exactHit = idx.exact.some((e) => e.method === method && e.path === path);\n\t\tconst regexHit = exactHit\n\t\t\t? false\n\t\t\t: idx.regex.some((e) => e.method === method && e.regex.test(path));\n\n\t\tconst res = exactHit || regexHit;\n\t\tidx.cache[cacheKey] = res;\n\t\treturn res;\n\t}\n\n\tprivate checkGenericNut(num: 7 | 8 | 9 | 10 | 11 | 12 | 14 | 20) {\n\t\treturn this._mintInfo.nuts[num]?.supported ? { supported: true } : { supported: false };\n\t}\n\n\tprivate checkMintMelt(num: 4 | 5) {\n\t\tconst mintMeltInfo = this._mintInfo.nuts[num];\n\t\tif (mintMeltInfo && mintMeltInfo.methods.length > 0 && !mintMeltInfo.disabled) {\n\t\t\treturn { disabled: false, params: mintMeltInfo.methods };\n\t\t}\n\t\treturn { disabled: true, params: mintMeltInfo?.methods ?? [] };\n\t}\n\n\tprivate checkNut17() {\n\t\tif (this._mintInfo.nuts[17] && this._mintInfo.nuts[17].supported.length > 0) {\n\t\t\treturn { supported: true, params: this._mintInfo.nuts[17].supported };\n\t\t}\n\t\treturn { supported: false };\n\t}\n\n\tprivate checkNut15() {\n\t\tif (this._mintInfo.nuts[15] && this._mintInfo.nuts[15].methods.length > 0) {\n\t\t\treturn { supported: true, params: this._mintInfo.nuts[15].methods };\n\t\t}\n\t\treturn { supported: false };\n\t}\n\n\t// ---------- private helpers ----------\n\n\tprivate toEndpoints(maybe: unknown): Endpoint[] {\n\t\tif (!Array.isArray(maybe)) return [];\n\t\tconst out: Endpoint[] = [];\n\t\tfor (const e of maybe) {\n\t\t\tif (e && typeof e === 'object') {\n\t\t\t\tconst rec = e as Record<string, unknown>;\n\t\t\t\tconst mm = rec.method;\n\t\t\t\tconst pp = rec.path;\n\t\t\t\tif (typeof mm === 'string' && typeof pp === 'string') {\n\t\t\t\t\tconst method = mm.toUpperCase();\n\t\t\t\t\tif (method === 'GET' || method === 'POST') {\n\t\t\t\t\t\tout.push({ method, path: pp });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn out;\n\t}\n\n\tprivate buildIndex(endpoints?: Endpoint[]): ProtectedIndex | undefined {\n\t\tif (!endpoints || endpoints.length === 0) return undefined;\n\n\t\tconst exact: ProtectedIndex['exact'] = [];\n\t\tconst regex: ProtectedIndex['regex'] = [];\n\t\tconst metachar = this.REGEX_METACHAR;\n\n\t\tfor (const e of endpoints) {\n\t\t\tconst looksRegex = e.path.startsWith('^') || e.path.endsWith('$') || metachar.test(e.path);\n\t\t\tif (looksRegex) {\n\t\t\t\ttry {\n\t\t\t\t\tregex.push({ method: e.method, regex: new RegExp(e.path) });\n\t\t\t\t\tcontinue;\n\t\t\t\t} catch {\n\t\t\t\t\t// fall back to exact on malformed patterns\n\t\t\t\t}\n\t\t\t}\n\t\t\texact.push({ method: e.method, path: e.path });\n\t\t}\n\n\t\t// plain object avoids the unsafe any from Object.create(null)\n\t\tconst cache: Record<string, boolean> = {};\n\t\treturn { cache, exact, regex };\n\t}\n\n\t// ---------- getters ----------\n\n\tget contact() {\n\t\treturn this._mintInfo.contact;\n\t}\n\tget description() {\n\t\treturn this._mintInfo.description;\n\t}\n\tget description_long() {\n\t\treturn this._mintInfo.description_long;\n\t}\n\tget name() {\n\t\treturn this._mintInfo.name;\n\t}\n\tget pubkey() {\n\t\treturn this._mintInfo.pubkey;\n\t}\n\tget nuts() {\n\t\treturn this._mintInfo.nuts;\n\t}\n\tget version() {\n\t\treturn this._mintInfo.version;\n\t}\n\tget motd() {\n\t\treturn this._mintInfo.motd;\n\t}\n\n\t/**\n\t * @deprecated Use supportsNut04Description(method, unit)\n\t */\n\tget supportsBolt12Description(): boolean {\n\t\treturn this.supportsNut04Description('bolt12');\n\t}\n\n\t/**\n\t * Checks if the mint supports creating invoices/offers with a description for the specified\n\t * payment method.\n\t *\n\t * @param method - The payment method to check ('bolt11' or 'bolt12')\n\t * @returns True if the mint supports description for the method, false otherwise.\n\t */\n\tsupportsNut04Description(method: 'bolt11' | 'bolt12', unit?: string): boolean {\n\t\treturn this._mintInfo.nuts[4]?.methods.some(\n\t\t\t(met) =>\n\t\t\t\tmet.method === method &&\n\t\t\t\t(unit ? met.unit === unit : true) &&\n\t\t\t\t(met.options?.description === true || met.description === true),\n\t\t);\n\t}\n}\n","import { randomBytes } from '@noble/curves/utils';\nimport { type Logger, NULL_LOGGER, safeCallback } from '../logger';\nimport type { GetInfoResponse } from '../mint/types';\nimport { Bytes, encodeUint8toBase64Url } from '../utils';\nimport { sha256 } from '@noble/hashes/sha2';\n\nexport type OIDCConfig = {\n\tissuer: string;\n\tauthorization_endpoint?: string;\n\ttoken_endpoint: string;\n\tdevice_authorization_endpoint?: string;\n};\n\nexport type TokenResponse = {\n\taccess_token?: string;\n\ttoken_type?: string;\n\texpires_in?: number;\n\trefresh_token?: string;\n\tid_token?: string;\n\tscope?: string;\n\terror?: string;\n\terror_description?: string;\n};\n\nexport type DeviceStartResponse = {\n\tdevice_code: string;\n\tuser_code: string;\n\tverification_uri: string;\n\tverification_uri_complete?: string;\n\tinterval?: number;\n\texpires_in?: number;\n};\n\nexport type OIDCAuthOptions = {\n\tclientId?: string;\n\tscope?: string;\n\tlogger?: Logger;\n\tonTokens?: (t: TokenResponse) => void | Promise<void>;\n};\n\nexport class OIDCAuth {\n\tprivate readonly discoveryUrl: string;\n\tprivate readonly logger: Logger;\n\n\tprivate clientId: string;\n\tprivate scope: string;\n\tprivate config?: OIDCConfig;\n\tprivate onTokens?: (t: TokenResponse) => void | Promise<void>;\n\n\t// External listeners, notified after onTokens fires\n\tprivate tokenListeners: Array<(t: TokenResponse) => void | Promise<void>> = [];\n\n\tstatic fromMintInfo(info: { nuts: GetInfoResponse['nuts'] }, opts?: OIDCAuthOptions): OIDCAuth {\n\t\tconst n21 = info?.nuts?.['21'];\n\t\tif (!n21?.openid_discovery) {\n\t\t\tthrow new Error('OIDCAuth: mint does not advertise NUT-21 openid_discovery');\n\t\t}\n\t\tconst clientId = opts?.clientId ?? n21.client_id ?? 'cashu-client';\n\t\treturn new OIDCAuth(n21.openid_discovery, { ...opts, clientId });\n\t}\n\n\tconstructor(discoveryUrl: string, opts?: OIDCAuthOptions) {\n\t\tthis.discoveryUrl = discoveryUrl;\n\t\tthis.logger = opts?.logger ?? NULL_LOGGER;\n\t\tthis.clientId = opts?.clientId ?? 'cashu-client';\n\t\tthis.scope = opts?.scope ?? 'openid';\n\t\tthis.onTokens = opts?.onTokens;\n\t}\n\n\tsetClient(id: string): void {\n\t\tthis.clientId = id;\n\t}\n\n\tsetScope(scope?: string): void {\n\t\tthis.scope = scope ?? 'openid';\n\t}\n\n\t/**\n\t * Subscribe to token updates. Listeners are called after the primary onTokens callback.\n\t */\n\taddTokenListener(fn: (t: TokenResponse) => void | Promise<void>): void {\n\t\tthis.tokenListeners.push(fn);\n\t}\n\n\t// ---- Discovery ----\n\n\tasync loadConfig(): Promise<OIDCConfig> {\n\t\tif (this.config) return this.config;\n\t\tconst res = await fetch(this.discoveryUrl, {\n\t\t\tmethod: 'GET',\n\t\t\theaders: { Accept: 'application/json' },\n\t\t});\n\t\tconst text = await res.text();\n\t\tlet json: unknown;\n\t\ttry {\n\t\t\tjson = text ? JSON.parse(text) : undefined;\n\t\t} catch (err) {\n\t\t\tthis.logger.warn('OIDCAuth: bad discovery JSON', { err });\n\t\t}\n\t\tif (!res.ok || !json) {\n\t\t\tthrow new Error('OIDCAuth: invalid discovery document');\n\t\t}\n\t\tconst cfg = json as OIDCConfig;\n\t\tif (typeof cfg.token_endpoint !== 'string' || cfg.token_endpoint.length === 0) {\n\t\t\tthrow new Error('OIDCAuth: invalid discovery document, missing token_endpoint');\n\t\t}\n\t\tthis.config = cfg;\n\t\treturn cfg;\n\t}\n\n\t// --- Authorization Code with PKCE ---\n\n\t/**\n\t * Generate a PKCE verifier and S256 challenge.\n\t *\n\t * - Verifier: base64url of random bytes, length >= 43, RFC 7636 compliant.\n\t * - Challenge: base64url(sha256(verifier))\n\t */\n\tgeneratePKCE(): { verifier: string; challenge: string } {\n\t\t// 48 bytes->base64url is typically 64 chars without padding, comfortably >= 43\n\t\tconst rnd = randomBytes(48);\n\t\tconst verifier = encodeUint8toBase64Url(rnd);\n\n\t\t// RFC 7636, challenge = BASE64URL-ENCODE( SHA256( ASCII(verifier) ) )\n\t\tconst vBytes = Bytes.fromString(verifier);\n\t\tconst chBytes = sha256(vBytes);\n\t\tconst challenge = encodeUint8toBase64Url(chBytes);\n\n\t\treturn { verifier, challenge };\n\t}\n\n\t/**\n\t * Build an Authorization Code + PKCE URL.\n\t */\n\tasync buildAuthCodeUrl(input: {\n\t\tredirectUri: string;\n\t\tcodeChallenge: string;\n\t\tcodeChallengeMethod?: 'S256' | 'plain'; // default S256\n\t\tstate?: string; // optional state to pass back to redirectUrl\n\t\tscope?: string; // default this.scope\n\t}): Promise<string> {\n\t\tconst cfg = await this.loadConfig();\n\t\tconst scope = input.scope ?? this.scope;\n\t\tconst params = new URLSearchParams({\n\t\t\tresponse_type: 'code',\n\t\t\tclient_id: this.clientId,\n\t\t\tredirect_uri: input.redirectUri,\n\t\t\tscope,\n\t\t\tcode_challenge_method: input.codeChallengeMethod ?? 'S256',\n\t\t\tcode_challenge: input.codeChallenge,\n\t\t});\n\t\tif (input.state) params.set('state', input.state);\n\n\t\tif (!cfg.authorization_endpoint) {\n\t\t\tthrow new Error('OIDCAuth: discovery lacks authorization_endpoint');\n\t\t}\n\t\treturn `${cfg.authorization_endpoint}?${params.toString()}`;\n\t}\n\n\t/**\n\t * Exchange an auth code for tokens, using the PKCE verifier.\n\t */\n\tasync exchangeAuthCode(input: { code: string; redirectUri: string; codeVerifier: string }) {\n\t\tconst cfg = await this.loadConfig();\n\t\tconst form = this.toForm({\n\t\t\tgrant_type: 'authorization_code',\n\t\t\tcode: input.code,\n\t\t\tredirect_uri: input.redirectUri,\n\t\t\tclient_id: this.clientId,\n\t\t\tcode_verifier: input.codeVerifier,\n\t\t});\n\t\tconst tok = await this.postFormStrict<TokenResponse>(cfg.token_endpoint, form);\n\t\tthis.handleTokens(tok);\n\t\treturn tok;\n\t}\n\n\t// ---- Device Code (recommended for CLIs) ----\n\n\tasync deviceStart(): Promise<DeviceStartResponse> {\n\t\tconst cfg = await this.loadConfig();\n\t\tconst ep = cfg.device_authorization_endpoint;\n\t\tif (!ep) throw new Error('OIDCAuth: provider lacks device_authorization_endpoint');\n\n\t\tconst form = this.toForm({ client_id: this.clientId, scope: this.scope });\n\t\treturn this.postFormStrict<DeviceStartResponse>(ep, form);\n\t}\n\n\tasync devicePoll(device_code: string, intervalSec = 5): Promise<TokenResponse> {\n\t\tconst cfg = await this.loadConfig();\n\t\t// Clamp to a sensible minimum to avoid hot loops\n\t\tlet delay = Math.max(1, intervalSec);\n\t\twhile (true) {\n\t\t\tawait this.sleep(delay * 1000);\n\t\t\tconst form = this.toForm({\n\t\t\t\tgrant_type: 'urn:ietf:params:oauth:grant-type:device_code',\n\t\t\t\tdevice_code,\n\t\t\t\tclient_id: this.clientId,\n\t\t\t});\n\t\t\tconst res = await this.postFormLoose<TokenResponse>(cfg.token_endpoint, form);\n\t\t\tif (res.access_token) {\n\t\t\t\tthis.handleTokens(res);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\tconst err = (res.error ?? '').toString();\n\t\t\tif (err === 'authorization_pending') continue;\n\t\t\tif (err === 'slow_down') {\n\t\t\t\tdelay = Math.max(delay + 5, delay * 2);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst msg = res.error_description || err || 'device authorization failed';\n\t\t\tthrow new Error(`OIDCAuth: ${msg}`);\n\t\t}\n\t}\n\n\t/**\n\t * One call convenience for Device Code flow.\n\t *\n\t * @remarks\n\t * Polling interval will be the MAX of intervalSec and Mint interval.\n\t * @param intervalSec Desired polling interval in seconds.\n\t * @returns The start fields and helpers to poll or cancel.\n\t */\n\tasync startDeviceAuth(intervalSec: number = 5): Promise<\n\t\tDeviceStartResponse & {\n\t\t\tpoll: () => Promise<TokenResponse>;\n\t\t\tcancel: () => void;\n\t\t}\n\t> {\n\t\tconst start = await this.deviceStart();\n\t\tconst interval = Math.max(start.interval ?? 1, intervalSec);\n\t\tlet aborted = false;\n\n\t\tconst poll = async (): Promise<TokenResponse> => {\n\t\t\tconst cfg = await this.loadConfig();\n\t\t\tlet delay = Math.max(1, interval);\n\t\t\twhile (true) {\n\t\t\t\tif (aborted) throw new Error('OIDCAuth: device polling cancelled');\n\t\t\t\tawait this.sleep(delay * 1000);\n\t\t\t\tconst form = this.toForm({\n\t\t\t\t\tgrant_type: 'urn:ietf:params:oauth:grant-type:device_code',\n\t\t\t\t\tdevice_code: start.device_code,\n\t\t\t\t\tclient_id: this.clientId,\n\t\t\t\t});\n\t\t\t\tconst res = await this.postFormLoose<TokenResponse>(cfg.token_endpoint, form);\n\t\t\t\tif (res.access_token) {\n\t\t\t\t\tthis.handleTokens(res);\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tconst err = (res.error ?? '').toString();\n\t\t\t\tif (err === 'authorization_pending') continue;\n\t\t\t\tif (err === 'slow_down') {\n\t\t\t\t\tdelay = Math.max(delay + 5, delay * 2);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst msg = res.error_description || err || 'device authorization failed';\n\t\t\t\tthrow new Error(`OIDCAuth: ${msg}`);\n\t\t\t}\n\t\t};\n\n\t\tconst cancel = (): void => {\n\t\t\taborted = true;\n\t\t};\n\n\t\treturn { ...start, poll, cancel };\n\t}\n\n\t// ---- Refresh ----\n\n\tasync refresh(refresh_token: string): Promise<TokenResponse> {\n\t\tconst cfg = await this.loadConfig();\n\t\tconst form = this.toForm({\n\t\t\tgrant_type: 'refresh_token',\n\t\t\trefresh_token,\n\t\t\tclient_id: this.clientId,\n\t\t});\n\t\tconst tok = await this.postFormStrict<TokenResponse>(cfg.token_endpoint, form);\n\t\tthis.handleTokens(tok);\n\t\treturn tok;\n\t}\n\n\t// ---- ROPC (discouraged, but some mints allow it) ----\n\n\tasync passwordGrant(username: string, password: string): Promise<TokenResponse> {\n\t\tconst cfg = await this.loadConfig();\n\t\tconst form = this.toForm({\n\t\t\tgrant_type: 'password',\n\t\t\tclient_id: this.clientId,\n\t\t\tusername,\n\t\t\tpassword,\n\t\t\tscope: this.scope,\n\t\t});\n\t\tconst tok = await this.postFormStrict<TokenResponse>(cfg.token_endpoint, form);\n\t\tthis.handleTokens(tok);\n\t\treturn tok;\n\t}\n\n\t// ---- internals ----\n\n\t/**\n\t * Fire and forget token fan out. Any listener errors are logged inside safeCallback. Nothing\n\t * thrown here will come from listeners.\n\t */\n\tprivate handleTokens(t: TokenResponse): void {\n\t\tif (!t.access_token) {\n\t\t\tconst msg = t.error_description || t.error || 'token response missing access_token';\n\t\t\tthrow new Error(`OIDCAuth: ${msg}`);\n\t\t}\n\t\t// Schedule on microtask queue so we never block the caller and we avoid sync throws leaking.\n\t\tqueueMicrotask(() =>\n\t\t\tsafeCallback(this.onTokens, t, this.logger, { where: 'OIDCAuth.handleTokens' }),\n\t\t);\n\n\t\tfor (const listener of this.tokenListeners) {\n\t\t\tqueueMicrotask(() =>\n\t\t\t\tsafeCallback(listener, t, this.logger, {\n\t\t\t\t\twhere: 'OIDCAuth.handleTokens.listener',\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate toForm(params: Record<string, string>): string {\n\t\tconst enc = (v: string) => encodeURIComponent(v).replace(/%20/g, '+');\n\t\treturn Object.entries(params)\n\t\t\t.map(([k, v]) => `${enc(k)}=${enc(v)}`)\n\t\t\t.join('&');\n\t}\n\n\t// Strict, throws on non 2xx\n\tprivate async postFormStrict<TSuccess extends object>(\n\t\tendpoint: string,\n\t\tformBody: string,\n\t): Promise<TSuccess> {\n\t\ttry {\n\t\t\tthis.logger.debug('OIDCAuth Request', { formBody });\n\t\t\tconst res = await fetch(endpoint, {\n\t\t\t\tmethod: 'POST',\n\t\t\t\theaders: {\n\t\t\t\t\t'Content-Type': 'application/x-www-form-urlencoded',\n\t\t\t\t\tAccept: 'application/json',\n\t\t\t\t},\n\t\t\t\tbody: formBody,\n\t\t\t});\n\t\t\tconst text = await res.text();\n\t\t\tlet json: unknown;\n\t\t\ttry {\n\t\t\t\tjson = text ? JSON.parse(text) : undefined;\n\t\t\t} catch (err) {\n\t\t\t\tthis.logger.warn('OIDCAuth: bad JSON (strict)', { err });\n\t\t\t}\n\t\t\tif (!res.ok) {\n\t\t\t\tconst err = (json ?? {}) as TokenResponse;\n\t\t\t\tconst msg = err.error_description || err.error || `HTTP ${res.status}`;\n\t\t\t\tthrow new Error(`OIDCAuth: ${msg}`);\n\t\t\t}\n\t\t\tthis.logger.debug('OIDCAuth Response', { json });\n\t\t\treturn (json ?? {}) as TSuccess;\n\t\t} catch (err) {\n\t\t\tthis.logger.error('OIDCAuth: postFormStrict failed', { err });\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\t// Loose, returns JSON payload even on non 2xx\n\tprivate async postFormLoose<T extends object>(\n\t\tendpoint: string,\n\t\tformBody: string,\n\t): Promise<T | TokenResponse> {\n\t\ttry {\n\t\t\tthis.logger.debug('OIDCAuth Request', { formBody });\n\t\t\tconst res = await fetch(endpoint, {\n\t\t\t\tmethod: 'POST',\n\t\t\t\theaders: {\n\t\t\t\t\t'Content-Type': 'application/x-www-form-urlencoded',\n\t\t\t\t\tAccept: 'application/json',\n\t\t\t\t},\n\t\t\t\tbody: formBody,\n\t\t\t});\n\t\t\tconst text = await res.text();\n\t\t\tlet json: unknown;\n\t\t\ttry {\n\t\t\t\tjson = text ? JSON.parse(text) : undefined;\n\t\t\t} catch (err) {\n\t\t\t\tthis.logger.warn('OIDCAuth: bad JSON (loose)', { err });\n\t\t\t}\n\t\t\tthis.logger.debug('OIDCAuth Response', { json });\n\t\t\treturn (json ?? {}) as T | TokenResponse;\n\t\t} catch (err) {\n\t\t\tthis.logger.error('OIDCAuth: postFormLoose network error', { err });\n\t\t\treturn { error: 'network_error', error_description: String(err) };\n\t\t}\n\t}\n\n\tprivate sleep(ms: number): Promise<void> {\n\t\treturn new Promise<void>((resolve) => setTimeout(resolve, ms));\n\t}\n}\n","/**\n * Cashu Mint Class.\n *\n * @remarks\n * You should ordinarily not need to instantiate a Mint, as it will be auto-instantiated by the\n * Wallet class when you pass in the mint url.\n */\nimport type {\n\tGetInfoResponse,\n\tPartialMintQuoteResponse,\n\tMeltQuoteResponse,\n\tPartialMeltQuoteResponse,\n\tBolt12MintQuoteResponse,\n\tBolt12MeltQuoteResponse,\n\tCheckStateResponse,\n\tPostRestoreResponse,\n\tSwapResponse,\n\tCheckStatePayload,\n\tPostRestorePayload,\n\tMintResponse,\n\tApiError,\n} from './types';\nimport type { MintActiveKeys, MintAllKeysets } from '../model/types/keyset';\nimport type {\n\tMintQuotePayload,\n\tMintPayload,\n\tMeltQuotePayload,\n\tMeltPayload,\n\tSwapPayload,\n\tBolt12MintQuotePayload,\n} from '../wallet/types';\nimport { MeltQuoteState } from './types';\nimport request, {\n\tConnectionManager,\n\ttype WSConnection,\n\tsetRequestLogger,\n\ttype RequestFn,\n\ttype RequestOptions,\n} from '../transport';\nimport { isObj, joinUrls, sanitizeUrl } from '../utils';\nimport {\n\ttype MeltQuoteResponsePaidDeprecated,\n\thandleMeltQuoteResponseDeprecated,\n} from '../legacy/nut-05';\nimport {\n\ttype MintQuoteResponsePaidDeprecated,\n\thandleMintQuoteResponseDeprecated,\n} from '../legacy/nut-04';\nimport { handleMintInfoContactFieldDeprecated } from '../legacy/nut-06';\nimport { MintInfo } from '../model/MintInfo';\nimport { type Logger, NULL_LOGGER } from '../logger';\nimport type { AuthProvider } from '../auth/AuthProvider';\nimport { OIDCAuth, type OIDCAuthOptions } from '../auth/OIDCAuth';\n\n/**\n * Class represents Cashu Mint API.\n *\n * @remarks\n * This class contains lower-level functions that are implemented by Wallet.\n */\nclass Mint {\n\tprivate ws?: WSConnection;\n\tprivate _mintUrl: string;\n\tprivate _request: RequestFn;\n\tprivate _logger: Logger;\n\tprivate _mintInfo?: MintInfo;\n\tprivate _authProvider?: AuthProvider;\n\n\t/**\n\t * @param mintUrl Requires mint URL to create this object.\n\t * @param customRequest Optional, for custom network communication with the mint.\n\t * @param authTokenGetter Optional. Function to obtain a NUT-22 BlindedAuthToken (e.g. from a\n\t *   database or localstorage)\n\t */\n\tconstructor(\n\t\tmintUrl: string,\n\t\toptions?: {\n\t\t\tcustomRequest?: RequestFn;\n\t\t\tauthProvider?: AuthProvider;\n\t\t\tlogger?: Logger;\n\t\t},\n\t) {\n\t\tthis._mintUrl = sanitizeUrl(mintUrl);\n\t\tthis._request = options?.customRequest ?? request;\n\t\tthis._authProvider = options?.authProvider;\n\t\tthis._logger = options?.logger ?? NULL_LOGGER;\n\t\tsetRequestLogger(this._logger);\n\t}\n\n\tget mintUrl() {\n\t\treturn this._mintUrl;\n\t}\n\n\t/**\n\t * Create an OIDC client using this mint’s NUT-21 metadata.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const oidc = await mint.oidcAuth({ onTokens: (t) => authMgr.setCAT(t.access_token!) });\n\t * const start = await oidc.deviceStart();\n\t * // show start.user_code / start.verification_uri to the user\n\t * const token = await oidc.devicePoll(start.device_code, start.interval ?? 5);\n\t * // token.access_token is your CAT\n\t * ```\n\t */\n\tasync oidcAuth(opts?: OIDCAuthOptions): Promise<OIDCAuth> {\n\t\tconst n21 = (await this.getLazyMintInfo()).nuts['21'];\n\t\tif (!n21?.openid_discovery) {\n\t\t\tthrow new Error('Mint: no NUT-21 openid_discovery');\n\t\t}\n\t\treturn new OIDCAuth(n21.openid_discovery, {\n\t\t\t...opts,\n\t\t\tclientId: opts?.clientId ?? n21.client_id ?? 'cashu-client',\n\t\t});\n\t}\n\n\t/**\n\t * Fetches mint's info at the /info endpoint.\n\t *\n\t * @param customRequest Optional override for the request function.\n\t * @returns The mint's information response.\n\t */\n\tasync getInfo(customRequest?: RequestFn): Promise<GetInfoResponse> {\n\t\tconst requestInstance = customRequest ?? this._request;\n\t\tconst response = await requestInstance<GetInfoResponse>({\n\t\t\tendpoint: joinUrls(this._mintUrl, '/v1/info'),\n\t\t});\n\t\tconst data = handleMintInfoContactFieldDeprecated(response, this._logger);\n\t\treturn data;\n\t}\n\n\t/**\n\t * Lazily fetches and caches the mint's info if not already loaded.\n\t *\n\t * @returns The parsed MintInfo object.\n\t */\n\tasync getLazyMintInfo(): Promise<MintInfo> {\n\t\tif (this._mintInfo) {\n\t\t\treturn this._mintInfo;\n\t\t}\n\t\tconst data = await this.getInfo();\n\t\tthis._mintInfo = new MintInfo(data);\n\t\treturn this._mintInfo;\n\t}\n\n\t/**\n\t * Performs a swap operation with ecash inputs and outputs.\n\t *\n\t * @param swapPayload Payload containing inputs and outputs.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Signed outputs.\n\t */\n\tasync swap(swapPayload: SwapPayload, customRequest?: RequestFn): Promise<SwapResponse> {\n\t\tconst data = await this.requestWithAuth<SwapResponse>(\n\t\t\t'POST',\n\t\t\t'/v1/swap',\n\t\t\t{ requestBody: swapPayload },\n\t\t\tcustomRequest,\n\t\t);\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tconst errDetail = isObj(data) && 'detail' in data ? (data as ApiError).detail : undefined;\n\t\t\tthrow new Error(errDetail ?? 'bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Requests a new mint quote from the mint.\n\t *\n\t * @param mintQuotePayload Payload for creating a new mint quote.\n\t * @param customRequest Optional override for the request function.\n\t * @returns A new mint quote containing a payment request for the specified amount and unit.\n\t */\n\tasync createMintQuoteBolt11(\n\t\tmintQuotePayload: MintQuotePayload,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<PartialMintQuoteResponse> {\n\t\tconst response = await this.requestWithAuth<\n\t\t\tPartialMintQuoteResponse & MintQuoteResponsePaidDeprecated\n\t\t>('POST', '/v1/mint/quote/bolt11', { requestBody: mintQuotePayload }, customRequest);\n\t\tconst data = handleMintQuoteResponseDeprecated(response, this._logger);\n\t\treturn data;\n\t}\n\n\t/**\n\t * Requests a new BOLT12 mint quote from the mint using Lightning Network offers.\n\t *\n\t * @param mintQuotePayload Payload containing amount, unit, optional description, and required\n\t *   pubkey.\n\t * @param customRequest Optional override for the request function.\n\t * @returns A mint quote containing a BOLT12 offer.\n\t */\n\tasync createMintQuoteBolt12(\n\t\tmintQuotePayload: Bolt12MintQuotePayload,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<Bolt12MintQuoteResponse> {\n\t\tconst response = await this.requestWithAuth<Bolt12MintQuoteResponse>(\n\t\t\t'POST',\n\t\t\t'/v1/mint/quote/bolt12',\n\t\t\t{ requestBody: mintQuotePayload },\n\t\t\tcustomRequest,\n\t\t);\n\t\treturn response;\n\t}\n\n\t/**\n\t * Gets an existing mint quote from the mint.\n\t *\n\t * @param quote Quote ID.\n\t * @param customRequest Optional override for the request function.\n\t * @returns The status of the mint quote, including payment details and state.\n\t */\n\tasync checkMintQuoteBolt11(\n\t\tquote: string,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<PartialMintQuoteResponse> {\n\t\tconst response = await this.requestWithAuth<\n\t\t\tPartialMintQuoteResponse & MintQuoteResponsePaidDeprecated\n\t\t>('GET', `/v1/mint/quote/bolt11/${quote}`, {}, customRequest);\n\n\t\tconst data = handleMintQuoteResponseDeprecated(response, this._logger);\n\t\treturn data;\n\t}\n\n\t/**\n\t * Gets an existing BOLT12 mint quote from the mint.\n\t *\n\t * @param quote Quote ID to check.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Updated quote with current payment and issuance amounts.\n\t */\n\tasync checkMintQuoteBolt12(\n\t\tquote: string,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<Bolt12MintQuoteResponse> {\n\t\tconst response = await this.requestWithAuth<Bolt12MintQuoteResponse>(\n\t\t\t'GET',\n\t\t\t`/v1/mint/quote/bolt12/${quote}`,\n\t\t\t{},\n\t\t\tcustomRequest,\n\t\t);\n\t\treturn response;\n\t}\n\n\t/**\n\t * Mints new tokens by requesting blind signatures on the provided outputs.\n\t *\n\t * @param mintPayload Payload containing the outputs to get blind signatures on.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Serialized blinded signatures.\n\t */\n\tasync mintBolt11(mintPayload: MintPayload, customRequest?: RequestFn): Promise<MintResponse> {\n\t\tconst data = await this.requestWithAuth<MintResponse>(\n\t\t\t'POST',\n\t\t\t'/v1/mint/bolt11',\n\t\t\t{ requestBody: mintPayload },\n\t\t\tcustomRequest,\n\t\t);\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tconst errDetail = isObj(data) && 'detail' in data ? (data as ApiError).detail : undefined;\n\t\t\tthrow new Error(errDetail ?? 'bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Mints new tokens using a BOLT12 quote by requesting blind signatures on the provided outputs.\n\t *\n\t * @param mintPayload Payload containing the quote ID and outputs to get blind signatures on.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Serialized blinded signatures for the requested outputs.\n\t */\n\tasync mintBolt12(mintPayload: MintPayload, customRequest?: RequestFn): Promise<MintResponse> {\n\t\tconst data = await this.requestWithAuth<MintResponse>(\n\t\t\t'POST',\n\t\t\t'/v1/mint/bolt12',\n\t\t\t{ requestBody: mintPayload },\n\t\t\tcustomRequest,\n\t\t);\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tconst errDetail = isObj(data) && 'detail' in data ? (data as ApiError).detail : undefined;\n\t\t\tthrow new Error(errDetail ?? 'bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Requests a new melt quote from the mint.\n\t *\n\t * @param meltQuotePayload Payload for creating a new melt quote.\n\t * @param customRequest Optional override for the request function.\n\t * @returns The melt quote response.\n\t */\n\tasync createMeltQuoteBolt11(\n\t\tmeltQuotePayload: MeltQuotePayload,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<PartialMeltQuoteResponse> {\n\t\tconst response = await this.requestWithAuth<\n\t\t\tPartialMeltQuoteResponse & MeltQuoteResponsePaidDeprecated\n\t\t>('POST', '/v1/melt/quote/bolt11', { requestBody: meltQuotePayload }, customRequest);\n\n\t\tconst data = handleMeltQuoteResponseDeprecated(response, this._logger);\n\n\t\tif (\n\t\t\t!isObj(data) ||\n\t\t\ttypeof data?.amount !== 'number' ||\n\t\t\ttypeof data?.fee_reserve !== 'number' ||\n\t\t\ttypeof data?.quote !== 'string'\n\t\t) {\n\t\t\tconst errDetail = isObj(data) && 'detail' in data ? (data as ApiError).detail : undefined;\n\t\t\tthrow new Error(errDetail ?? 'bad response');\n\t\t}\n\t\treturn data;\n\t}\n\n\t/**\n\t * Requests a new BOLT12 melt quote from the mint for paying a Lightning Network offer. For\n\t * amount-less offers, specify the amount in options.amountless.amount_msat.\n\t *\n\t * @param meltQuotePayload Payload containing the BOLT12 offer to pay and unit.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Melt quote with amount, fee reserve, and payment state.\n\t */\n\tasync createMeltQuoteBolt12(\n\t\tmeltQuotePayload: MeltQuotePayload,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<Bolt12MeltQuoteResponse> {\n\t\tconst response = await this.requestWithAuth<Bolt12MeltQuoteResponse>(\n\t\t\t'POST',\n\t\t\t'/v1/melt/quote/bolt12',\n\t\t\t{ requestBody: meltQuotePayload },\n\t\t\tcustomRequest,\n\t\t);\n\t\treturn response;\n\t}\n\n\t/**\n\t * Gets an existing melt quote.\n\t *\n\t * @param quote Quote ID.\n\t * @param customRequest Optional override for the request function.\n\t * @returns The melt quote response.\n\t */\n\tasync checkMeltQuoteBolt11(\n\t\tquote: string,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<PartialMeltQuoteResponse> {\n\t\tconst response = await this.requestWithAuth<\n\t\t\tMeltQuoteResponse & MeltQuoteResponsePaidDeprecated\n\t\t>('GET', `/v1/melt/quote/bolt11/${quote}`, {}, customRequest);\n\n\t\tconst data = handleMeltQuoteResponseDeprecated(response, this._logger);\n\n\t\tif (\n\t\t\t!isObj(data) ||\n\t\t\ttypeof data?.amount !== 'number' ||\n\t\t\ttypeof data?.fee_reserve !== 'number' ||\n\t\t\ttypeof data?.quote !== 'string' ||\n\t\t\ttypeof data?.state !== 'string' ||\n\t\t\t!Object.values(MeltQuoteState).includes(data.state)\n\t\t) {\n\t\t\tconst errDetail = isObj(data) && 'detail' in data ? (data as ApiError).detail : undefined;\n\t\t\tthrow new Error(errDetail ?? 'bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Gets an existing BOLT12 melt quote from the mint. Returns current payment state (UNPAID,\n\t * PENDING, or PAID) and payment preimage if paid.\n\t *\n\t * @param quote Quote ID to check.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Updated quote with current payment state and preimage if available.\n\t */\n\tasync checkMeltQuoteBolt12(\n\t\tquote: string,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<Bolt12MeltQuoteResponse> {\n\t\tconst response = await this.requestWithAuth<Bolt12MeltQuoteResponse>(\n\t\t\t'GET',\n\t\t\t`/v1/melt/quote/bolt12/${quote}`,\n\t\t\t{},\n\t\t\tcustomRequest,\n\t\t);\n\t\treturn response;\n\t}\n\n\t/**\n\t * Requests the mint to pay for a Bolt11 payment request by providing ecash as inputs to be spent.\n\t * The inputs contain the amount and the fee_reserves for a Lightning payment. The payload can\n\t * also contain blank outputs in order to receive back overpaid Lightning fees.\n\t *\n\t * @param meltPayload The melt payload containing inputs and optional outputs.\n\t * @param options.customRequest Optional override for the request function.\n\t * @param options.preferAsync Optional override to set 'respond-async' header.\n\t * @returns The melt response.\n\t */\n\tasync meltBolt11(\n\t\tmeltPayload: MeltPayload,\n\t\toptions?: {\n\t\t\tcustomRequest?: RequestFn;\n\t\t\tpreferAsync?: boolean;\n\t\t},\n\t): Promise<PartialMeltQuoteResponse> {\n\t\tconst headers: Record<string, string> = {\n\t\t\t...(options?.preferAsync ? { Prefer: 'respond-async' } : {}),\n\t\t};\n\t\tconst response = await this.requestWithAuth<\n\t\t\tMeltQuoteResponse & MeltQuoteResponsePaidDeprecated\n\t\t>(\n\t\t\t'POST',\n\t\t\t'/v1/melt/bolt11',\n\t\t\t{\n\t\t\t\trequestBody: meltPayload,\n\t\t\t\theaders,\n\t\t\t},\n\t\t\toptions?.customRequest,\n\t\t);\n\n\t\tconst data = handleMeltQuoteResponseDeprecated(response, this._logger);\n\n\t\tif (\n\t\t\t!isObj(data) ||\n\t\t\ttypeof data?.state !== 'string' ||\n\t\t\t!Object.values(MeltQuoteState).includes(data.state)\n\t\t) {\n\t\t\tconst errDetail = isObj(data) && 'detail' in data ? (data as ApiError).detail : undefined;\n\t\t\tthrow new Error(errDetail ?? 'bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Requests the mint to pay a BOLT12 offer by providing ecash inputs to be spent. The inputs must\n\t * cover the amount plus fee reserves. Optional outputs can be included to receive change for\n\t * overpaid Lightning fees.\n\t *\n\t * @param meltPayload Payload containing quote ID, inputs, and optional outputs for change.\n\t * @param options.customRequest Optional override for the request function.\n\t * @param options.preferAsync Optional override to set 'respond-async' header.\n\t * @returns Payment result with state and optional change signatures.\n\t */\n\tasync meltBolt12(\n\t\tmeltPayload: MeltPayload,\n\t\toptions?: {\n\t\t\tcustomRequest?: RequestFn;\n\t\t\tpreferAsync?: boolean;\n\t\t},\n\t): Promise<Bolt12MeltQuoteResponse> {\n\t\tconst headers: Record<string, string> = {\n\t\t\t...(options?.preferAsync ? { Prefer: 'respond-async' } : {}),\n\t\t};\n\t\tconst data = await this.requestWithAuth<Bolt12MeltQuoteResponse>(\n\t\t\t'POST',\n\t\t\t'/v1/melt/bolt12',\n\t\t\t{\n\t\t\t\trequestBody: meltPayload,\n\t\t\t\theaders,\n\t\t\t},\n\t\t\toptions?.customRequest,\n\t\t);\n\t\treturn data;\n\t}\n\n\t/**\n\t * Checks if specific proofs have already been redeemed.\n\t *\n\t * @param checkPayload The payload containing proofs to check.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Redeemed and unredeemed ordered list of booleans.\n\t */\n\tasync check(\n\t\tcheckPayload: CheckStatePayload,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<CheckStateResponse> {\n\t\tconst data = await this.requestWithAuth<CheckStateResponse>(\n\t\t\t'POST',\n\t\t\t'/v1/checkstate',\n\t\t\t{ requestBody: checkPayload },\n\t\t\tcustomRequest,\n\t\t);\n\n\t\tif (!isObj(data) || !Array.isArray(data?.states)) {\n\t\t\tconst errDetail = isObj(data) && 'detail' in data ? (data as ApiError).detail : undefined;\n\t\t\tthrow new Error(errDetail ?? 'bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Get the mint's public keys.\n\t *\n\t * @param keysetId Optional param to get the keys for a specific keyset. If not specified, the\n\t *   keys from all active keysets are fetched.\n\t * @param mintUrl Optional alternative mint URL to use for this request.\n\t * @param customRequest Optional override for the request function.\n\t * @returns The mint's public keys.\n\t */\n\tasync getKeys(\n\t\tkeysetId?: string,\n\t\tmintUrl?: string,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<MintActiveKeys> {\n\t\tconst targetUrl = mintUrl || this._mintUrl;\n\t\t// backwards compatibility for base64 encoded keyset ids\n\t\tif (keysetId) {\n\t\t\t// make the keysetId url safe\n\t\t\tkeysetId = keysetId.replace(/\\//g, '_').replace(/\\+/g, '-');\n\t\t}\n\t\tconst requestInstance = customRequest ?? this._request;\n\t\tconst data = await requestInstance<MintActiveKeys>({\n\t\t\tendpoint: keysetId\n\t\t\t\t? joinUrls(targetUrl, '/v1/keys', keysetId)\n\t\t\t\t: joinUrls(targetUrl, '/v1/keys'),\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data.keysets)) {\n\t\t\tconst errDetail = isObj(data) && 'detail' in data ? (data as ApiError).detail : undefined;\n\t\t\tthrow new Error(errDetail ?? 'bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Get the mint's keysets in no specific order.\n\t *\n\t * @param customRequest Optional override for the request function.\n\t * @returns All the mint's past and current keysets.\n\t */\n\tasync getKeySets(customRequest?: RequestFn): Promise<MintAllKeysets> {\n\t\tconst requestInstance = customRequest ?? this._request;\n\t\treturn requestInstance<MintAllKeysets>({ endpoint: joinUrls(this._mintUrl, '/v1/keysets') });\n\t}\n\n\t/**\n\t * Restores proofs from the provided blinded messages.\n\t *\n\t * @param restorePayload The payload containing outputs to restore.\n\t * @param customRequest Optional override for the request function.\n\t * @returns The restore response with outputs and signatures.\n\t */\n\tasync restore(\n\t\trestorePayload: PostRestorePayload,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<PostRestoreResponse> {\n\t\tconst requestInstance = customRequest ?? this._request;\n\t\tconst data = await requestInstance<PostRestoreResponse>({\n\t\t\tendpoint: joinUrls(this._mintUrl, '/v1/restore'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: restorePayload,\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.outputs) || !Array.isArray(data?.signatures)) {\n\t\t\tconst errDetail = isObj(data) && 'detail' in data ? (data as ApiError).detail : undefined;\n\t\t\tthrow new Error(errDetail ?? 'bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Tries to establish a websocket connection with the websocket mint url according to NUT-17.\n\t */\n\tasync connectWebSocket() {\n\t\tif (this.ws) {\n\t\t\tawait this.ws.ensureConnection();\n\t\t} else {\n\t\t\tconst mintUrl = new URL(this._mintUrl);\n\t\t\tconst wsSegment = 'v1/ws';\n\t\t\tif (mintUrl.pathname) {\n\t\t\t\tif (mintUrl.pathname.endsWith('/')) {\n\t\t\t\t\tmintUrl.pathname += wsSegment;\n\t\t\t\t} else {\n\t\t\t\t\tmintUrl.pathname += '/' + wsSegment;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.ws = ConnectionManager.getInstance().getConnection(\n\t\t\t\t`${mintUrl.protocol === 'https:' ? 'wss' : 'ws'}://${mintUrl.host}${mintUrl.pathname}`,\n\t\t\t);\n\t\t\ttry {\n\t\t\t\tawait this.ws.connect();\n\t\t\t} catch (e) {\n\t\t\t\tthis._logger.error('Failed to connect to WebSocket...', { e });\n\t\t\t\tthrow new Error('Failed to connect to WebSocket...');\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Closes a websocket connection.\n\t */\n\tdisconnectWebSocket() {\n\t\tif (this.ws) {\n\t\t\tthis.ws.close();\n\t\t}\n\t}\n\n\tget webSocketConnection() {\n\t\treturn this.ws;\n\t}\n\n\t/**\n\t * Returns the Clear Authentication Token (CAT) to use in the 'Clear-auth' header, or undefined if\n\t * not required for the given path and method.\n\t *\n\t * @param method The method to call on the path.\n\t * @param path The API path to check for blind auth requirement.\n\t * @returns The blind auth token if required, otherwise undefined.\n\t */\n\tprivate async handleClearAuth(method: 'GET' | 'POST', path: string): Promise<string | undefined> {\n\t\tif (!this._authProvider) return undefined;\n\t\tconst info = await this.getLazyMintInfo();\n\t\tif (!info.requiresClearAuthToken(method, path)) return undefined;\n\t\tthis._logger.error('Clear Authentication Token...', { cat: this._authProvider.getCAT() });\n\t\treturn this._authProvider.getCAT();\n\t}\n\n\t/**\n\t * Returns a serialized Blind Authentication Token (BAT) to use in the 'Blind-auth' header, or\n\t * undefined if not required for the given path and method.\n\t *\n\t * @param method The method to call on the path.\n\t * @param path The API path to check for blind auth requirement.\n\t * @returns The blind auth token if required, otherwise undefined.\n\t */\n\tprivate async handleBlindAuth(method: 'GET' | 'POST', path: string): Promise<string | undefined> {\n\t\tif (!this._authProvider) return undefined;\n\t\tconst info = await this.getLazyMintInfo();\n\t\tif (!info.requiresBlindAuthToken(method, path)) return undefined;\n\t\tconst bat = await this._authProvider.getBlindAuthToken({ method, path });\n\t\tthis._logger.error('Blind Authentication Token...', { bat });\n\t\treturn bat;\n\t}\n\n\tprivate async requestWithAuth<T>(\n\t\tmethod: 'GET' | 'POST',\n\t\tpath: string,\n\t\tinit: Omit<RequestOptions, 'endpoint' | 'method' | 'headers' | 'requestBody'> & {\n\t\t\trequestBody?: Record<string, unknown>;\n\t\t\theaders?: Record<string, string>;\n\t\t} = {},\n\t\tcustomRequest?: RequestFn,\n\t): Promise<T> {\n\t\tconst requestInstance = customRequest ?? this._request;\n\t\t// Get BAT/CAT token if this endpoint is protected\n\t\tconst bat = await this.handleBlindAuth(method, path);\n\t\tconst cat = await this.handleClearAuth(method, path);\n\t\tconst headers: Record<string, string> = {\n\t\t\t...(init.headers ?? {}),\n\t\t\t...(bat ? { 'Blind-auth': bat } : {}),\n\t\t\t...(cat ? { 'Clear-auth': cat } : {}),\n\t\t};\n\t\treturn requestInstance<T>({\n\t\t\t...init,\n\t\t\tendpoint: joinUrls(this._mintUrl, path),\n\t\t\tmethod,\n\t\t\theaders,\n\t\t});\n\t}\n}\n\nexport { Mint };\n","import { isValidHex, deriveKeysetId } from '../utils';\nimport { type MintKeyset, type MintKeys } from '../model/types';\nimport { hexToBytes } from '@noble/curves/utils';\n\nexport class Keyset {\n\tprivate _id: string;\n\tprivate _unit: string;\n\tprivate _active: boolean;\n\tprivate _keys: Record<number, string> = {};\n\tprivate _input_fee_ppk?: number;\n\tprivate _final_expiry?: number;\n\n\tconstructor(\n\t\tid: string,\n\t\tunit: string,\n\t\tactive: boolean,\n\t\tinput_fee_ppk?: number,\n\t\tfinal_expiry?: number,\n\t) {\n\t\tthis._id = id;\n\t\tthis._unit = unit;\n\t\tthis._active = active;\n\t\tthis._input_fee_ppk = input_fee_ppk;\n\t\tthis._final_expiry = final_expiry;\n\t}\n\n\tget id(): string {\n\t\treturn this._id;\n\t}\n\n\tget unit(): string {\n\t\treturn this._unit;\n\t}\n\n\tget isActive(): boolean {\n\t\treturn this._active;\n\t}\n\n\tget fee(): number {\n\t\treturn this._input_fee_ppk ?? 0;\n\t}\n\n\tget expiry(): number | undefined {\n\t\treturn this._final_expiry;\n\t}\n\n\tget hasKeys(): boolean {\n\t\treturn Object.keys(this._keys).length > 0;\n\t}\n\n\tget hasHexId(): boolean {\n\t\treturn isValidHex(this._id);\n\t}\n\n\tget keys(): Record<number, string> {\n\t\treturn this._keys;\n\t}\n\n\tset keys(keys: Record<number, string>) {\n\t\tthis._keys = keys;\n\t}\n\n\t/**\n\t * For compat with v2 MintKeyset type.\n\t */\n\tget active(): boolean {\n\t\treturn this._active;\n\t}\n\n\t/**\n\t * For compat with v2 MintKeyset type.\n\t */\n\tget input_fee_ppk(): number {\n\t\treturn this._input_fee_ppk ?? 0;\n\t}\n\n\t/**\n\t * For compat with v2 MintKeyset type.\n\t */\n\tget final_expiry(): number | undefined {\n\t\treturn this._final_expiry;\n\t}\n\n\t/**\n\t * To Mint API MintKeyset format.\n\t *\n\t * @returns MintKeyset object.\n\t */\n\ttoMintKeyset(): MintKeyset {\n\t\treturn {\n\t\t\tid: this._id,\n\t\t\tunit: this._unit,\n\t\t\tactive: this._active,\n\t\t\tinput_fee_ppk: this._input_fee_ppk,\n\t\t\tfinal_expiry: this._final_expiry,\n\t\t};\n\t}\n\n\t/**\n\t * To Mint API MintKeys format.\n\t *\n\t * @returns MintKeys object.\n\t */\n\ttoMintKeys(): MintKeys | null {\n\t\tif (!this.hasKeys) {\n\t\t\treturn null;\n\t\t}\n\t\treturn {\n\t\t\tid: this._id,\n\t\t\tunit: this._unit,\n\t\t\tkeys: this._keys,\n\t\t};\n\t}\n\n\t/**\n\t * Verifies that the keyset's ID matches the derived ID from its keys, unit, and expiry.\n\t *\n\t * @returns True if verification succeeds, false otherwise (e.g., no keys or mismatch).\n\t */\n\tverify(): boolean {\n\t\tif (!this.hasKeys) {\n\t\t\treturn false;\n\t\t}\n\t\tconst versionByte = hexToBytes(this._id)[0];\n\t\tconst derivedId = deriveKeysetId(this._keys, this._unit, this._final_expiry, versionByte);\n\t\treturn derivedId === this._id;\n\t}\n}\n","import { Keyset } from './Keyset';\nimport { Mint } from '../mint';\nimport type { MintKeyset, MintKeys, MintAllKeysets, MintActiveKeys } from '../model/types/keyset';\n\n/**\n * Manages the unit-specific keysets for a Mint.\n *\n * @remarks\n * Will ONLY load keysets in the Keychain unit.\n */\nexport class KeyChain {\n\tprivate mint: Mint;\n\tprivate unit: string;\n\tprivate keysets: { [id: string]: Keyset } = {};\n\n\tconstructor(\n\t\tmint: string | Mint,\n\t\tunit: string,\n\t\tcachedKeysets?: MintKeyset[],\n\t\tcachedKeys?: MintKeys[] | MintKeys,\n\t) {\n\t\tthis.mint = typeof mint === 'string' ? new Mint(mint) : mint;\n\t\tthis.unit = unit;\n\t\tif (cachedKeysets && cachedKeys) {\n\t\t\t// Normalize and preload if both are provided\n\t\t\tconst arrayOfKeys = Array.isArray(cachedKeys) ? cachedKeys : [cachedKeys];\n\t\t\tthis.buildKeychain(cachedKeysets, arrayOfKeys);\n\t\t}\n\t}\n\n\t/**\n\t * Single entry point to load or refresh keysets and keys for the unit.\n\t *\n\t * @remarks\n\t * Fetches in parallel, filters by unit, assigns keys.\n\t * @param forceRefresh If true, refetch even if loaded.\n\t */\n\tasync init(forceRefresh?: boolean): Promise<void> {\n\t\t// Skip if already loaded, unless force\n\t\tif (Object.keys(this.keysets).length > 0 && !forceRefresh) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fetch keys and keysets in parallel\n\t\tconst [allKeysetsResponse, allKeysResponse]: [MintAllKeysets, MintActiveKeys] =\n\t\t\tawait Promise.all([this.mint.getKeySets(), this.mint.getKeys()]);\n\n\t\tthis.buildKeychain(allKeysetsResponse.keysets, allKeysResponse.keysets);\n\n\t\t// Smoke test (will throw if init was unsuccessful)\n\t\tthis.getCheapestKeyset();\n\t}\n\n\t/**\n\t * Builds keychain from Mint Keyset and Keys data.\n\t *\n\t * @param allKeysets Keyset data from mint.getKeySets() API.\n\t * @param allKeys Keys data from mint.getKeys() API.\n\t */\n\tprivate buildKeychain(allKeysets: MintKeyset[], allKeys: MintKeys[]): void {\n\t\t// Clear existing keysets to avoid stale data\n\t\tthis.keysets = {};\n\n\t\t// Filter and create Keysets for unit\n\t\tconst unitKeysets = allKeysets.filter((k: MintKeyset) => k.unit === this.unit);\n\t\tunitKeysets.forEach((k: MintKeyset) => {\n\t\t\tthis.keysets[k.id] = new Keyset(k.id, k.unit, k.active, k.input_fee_ppk, k.final_expiry);\n\t\t});\n\n\t\t// Create map of keys filtered by unit for fast lookup\n\t\tconst keysMap = new Map<string, MintKeys>(\n\t\t\tallKeys.filter((k) => k.unit === this.unit).map((k) => [k.id, k]),\n\t\t);\n\n\t\t// Assign keys and validate active hex keysets\n\t\t// Note: Non-hex and inactive keysets should not have keys\n\t\tObject.values(this.keysets).forEach((keyset) => {\n\t\t\tif (!keyset.hasHexId || !keyset.isActive) return;\n\t\t\tconst mk = keysMap.get(keyset.id);\n\t\t\tif (mk) {\n\t\t\t\tkeyset.keys = mk.keys;\n\t\t\t\tif (!keyset.verify()) {\n\t\t\t\t\tthrow new Error(`Keyset verification failed for ID ${keyset.id}`);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Get a keyset by ID or the cheapest keyset if no ID is provided.\n\t *\n\t * @param id Optional keyset ID.\n\t * @returns Keyset with keys.\n\t * @throws If keyset not found or uninitialized.\n\t */\n\tgetKeyset(id?: string): Keyset {\n\t\tconst keyset = id ? this.keysets[id] : this.getCheapestKeyset();\n\t\tif (!keyset) {\n\t\t\tthrow new Error(`Keyset '${id}' not found`);\n\t\t}\n\t\treturn keyset;\n\t}\n\n\t/**\n\t * Get the cheapest active keyset.\n\t *\n\t * @remarks\n\t * Selects active keyset with lowest fee and hex ID.\n\t * @returns Active Keyset.\n\t * @throws If none found or uninitialized.\n\t */\n\tgetCheapestKeyset(): Keyset {\n\t\tif (Object.keys(this.keysets).length === 0) {\n\t\t\tthrow new Error('KeyChain not initialized');\n\t\t}\n\t\tconst activeKeysets = Object.values(this.keysets).filter(\n\t\t\t(k) => k.isActive && k.hasHexId && k.hasKeys,\n\t\t);\n\t\tif (activeKeysets.length === 0) {\n\t\t\tthrow new Error('No active keyset found');\n\t\t}\n\t\treturn activeKeysets.sort((a, b) => a.fee - b.fee)[0];\n\t}\n\n\t/**\n\t * Get list of all keysets for the unit.\n\t *\n\t * @returns Array of Keysets.\n\t * @throws If uninitialized.\n\t */\n\tgetKeysets(): Keyset[] {\n\t\tif (Object.keys(this.keysets).length === 0) {\n\t\t\tthrow new Error('KeyChain not initialized');\n\t\t}\n\t\treturn Object.values(this.keysets);\n\t}\n\n\t/**\n\t * Extract the Mint API data from the keychain.\n\t *\n\t * @remarks\n\t * Useful for instantiating new wallets / keychains without repeatedly calling the mint API.\n\t */\n\tgetCache(): {\n\t\tkeysets: MintKeyset[];\n\t\tkeys: MintKeys[];\n\t\tunit: string;\n\t\tmintUrl: string;\n\t} {\n\t\tconst allKeysets = this.getKeysets();\n\t\tconst allKeys = allKeysets\n\t\t\t.filter((k) => k.hasKeys)\n\t\t\t.map((k) => k.toMintKeys())\n\t\t\t.filter((mk): mk is MintKeys => mk !== null);\n\t\treturn {\n\t\t\tkeysets: allKeysets.map((k) => k.toMintKeyset()),\n\t\t\tkeys: allKeys,\n\t\t\tunit: this.unit,\n\t\t\tmintUrl: this.mint.mintUrl,\n\t\t};\n\t}\n}\n","import { type SerializedBlindedMessage } from './types/index';\nimport { type WeierstrassPoint } from '@noble/curves/abstract/weierstrass';\n\nclass BlindedMessage {\n\tamount: number;\n\tB_: WeierstrassPoint<bigint>;\n\tid: string;\n\tconstructor(amount: number, B_: WeierstrassPoint<bigint>, id: string) {\n\t\tthis.amount = amount;\n\t\tthis.B_ = B_;\n\t\tthis.id = id;\n\t}\n\tgetSerializedBlindedMessage(): SerializedBlindedMessage {\n\t\treturn { amount: this.amount, B_: this.B_.toHex(true), id: this.id };\n\t}\n}\nexport { BlindedMessage };\n","import {\n\ttype MintKeys,\n\ttype Proof,\n\ttype SerializedBlindedMessage,\n\ttype SerializedBlindedSignature,\n\ttype SerializedDLEQ,\n} from './types';\nimport { type P2PKOptions, type Keyset } from '../wallet';\nimport {\n\tblindMessage,\n\tconstructProofFromPromise,\n\tderiveP2BKBlindedPubkeys,\n\tderiveBlindingFactor,\n\tderiveSecret,\n\tpointFromHex,\n\tserializeProof,\n\ttype DLEQ,\n} from '../crypto';\nimport { BlindedMessage } from './BlindedMessage';\nimport { bytesToHex, hexToBytes, randomBytes } from '@noble/hashes/utils';\nimport { bytesToNumber, numberToHexPadded64, splitAmount } from '../utils';\n\nexport interface OutputDataLike {\n\tblindedMessage: SerializedBlindedMessage;\n\tblindingFactor: bigint;\n\tsecret: Uint8Array;\n\n\ttoProof: (signature: SerializedBlindedSignature, keyset: MintKeys | Keyset) => Proof;\n}\n\nexport type OutputDataFactory = (amount: number, keys: MintKeys | Keyset) => OutputDataLike;\n\n/**\n * Core P2PK tags that must not be settable in additional tags.\n *\n * @internal\n */\nexport const RESERVED_P2PK_TAGS = new Set([\n\t'locktime',\n\t'pubkeys',\n\t'n_sigs',\n\t'refund',\n\t'n_sigs_refund',\n]);\n\n/**\n * Asserts P2PK Tag key is valid.\n *\n * @param key Tag Key.\n * @throws If not a string, or is a reserved string.\n */\nexport function assertValidTagKey(key: string) {\n\tif (!key || typeof key !== 'string') throw new Error('tag key must be a non empty string');\n\tif (RESERVED_P2PK_TAGS.has(key)) {\n\t\tthrow new Error(`additionalTags must not use reserved key \"${key}\"`);\n\t}\n}\n\n/**\n * Maximum secret length.\n *\n * @remarks\n * Based on the Nutshell default mint_max_secret_length.\n * @internal\n */\nexport const MAX_SECRET_LENGTH = 1024;\n\nexport function isOutputDataFactory(\n\tvalue: OutputData[] | OutputDataFactory,\n): value is OutputDataFactory {\n\treturn typeof value === 'function';\n}\n\n// Holds the map of Pubkey blinding factors for a given OutputData\n// This avoids changing the shape of the OutputDataLike interface\nconst EPHEMERAL_E = new WeakMap<OutputData, string>(); // one-shot\nfunction setEphemeralE(target: OutputData, Ehex?: string) {\n\tif (Ehex) EPHEMERAL_E.set(target, Ehex);\n}\nfunction takeEphemeralE(target: OutputData): string | undefined {\n\tconst e = EPHEMERAL_E.get(target);\n\tif (!e) return;\n\tEPHEMERAL_E.delete(target); // one-shot to avoid leakage\n\treturn e;\n}\n\nexport class OutputData implements OutputDataLike {\n\tblindedMessage: SerializedBlindedMessage;\n\tblindingFactor: bigint;\n\tsecret: Uint8Array;\n\n\tconstructor(\n\t\tblindedMessage: SerializedBlindedMessage,\n\t\tblindingFactor: bigint,\n\t\tsecret: Uint8Array,\n\t) {\n\t\tthis.secret = secret;\n\t\tthis.blindingFactor = blindingFactor;\n\t\tthis.blindedMessage = blindedMessage;\n\t}\n\n\ttoProof(sig: SerializedBlindedSignature, keyset: MintKeys | Keyset) {\n\t\tlet dleq: DLEQ | undefined;\n\t\tif (sig.dleq) {\n\t\t\tdleq = {\n\t\t\t\ts: hexToBytes(sig.dleq.s),\n\t\t\t\te: hexToBytes(sig.dleq.e),\n\t\t\t\tr: this.blindingFactor,\n\t\t\t};\n\t\t}\n\t\tconst blindSignature = {\n\t\t\tid: sig.id,\n\t\t\tamount: sig.amount,\n\t\t\tC_: pointFromHex(sig.C_),\n\t\t\tdleq: dleq,\n\t\t};\n\t\tconst A = pointFromHex(keyset.keys[sig.amount]);\n\t\tconst proof = constructProofFromPromise(blindSignature, this.blindingFactor, this.secret, A);\n\t\tconst serializedProof = {\n\t\t\t...serializeProof(proof),\n\t\t\t...(dleq && {\n\t\t\t\tdleq: {\n\t\t\t\t\ts: bytesToHex(dleq.s),\n\t\t\t\t\te: bytesToHex(dleq.e),\n\t\t\t\t\tr: numberToHexPadded64(dleq.r ?? BigInt(0)),\n\t\t\t\t} as SerializedDLEQ,\n\t\t\t}),\n\t\t} as Proof;\n\n\t\t// Add P2BK (Pay to Blinded Key) blinding factors if needed\n\t\tconst Ehex = takeEphemeralE(this);\n\t\tif (Ehex) serializedProof.p2pk_e = Ehex;\n\n\t\treturn serializedProof;\n\t}\n\n\tstatic createP2PKData(\n\t\tp2pk: P2PKOptions,\n\t\tamount: number,\n\t\tkeyset: MintKeys | Keyset,\n\t\tcustomSplit?: number[],\n\t) {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a) => this.createSingleP2PKData(p2pk, a, keyset.id));\n\t}\n\n\tstatic createSingleP2PKData(p2pk: P2PKOptions, amount: number, keysetId: string) {\n\t\t// normalise keys and clamp required signature counts to available keys\n\t\tconst lockKeys: string[] = Array.isArray(p2pk.pubkey) ? p2pk.pubkey : [p2pk.pubkey];\n\t\tconst refundKeys: string[] = p2pk.refundKeys ?? [];\n\t\tconst reqLock = Math.max(1, Math.min(p2pk.requiredSignatures ?? 1, lockKeys.length));\n\t\tconst reqRefund = Math.max(\n\t\t\t1,\n\t\t\tMath.min(p2pk.requiredRefundSignatures ?? 1, refundKeys.length || 1),\n\t\t);\n\n\t\t// Init vars\n\t\tlet data = lockKeys[0];\n\t\tlet pubkeys = lockKeys.slice(1);\n\t\tlet refund = refundKeys;\n\n\t\t// Optional key blinding (P2BK)\n\t\tlet Ehex: string | undefined;\n\t\tif (p2pk.blindKeys) {\n\t\t\tconst ordered = [data, ...pubkeys, ...refundKeys];\n\t\t\tconst { blinded, Ehex: _E } = deriveP2BKBlindedPubkeys(ordered, keysetId);\n\t\t\tdata = blinded[0];\n\t\t\tpubkeys = blinded.slice(1, lockKeys.length);\n\t\t\trefund = blinded.slice(lockKeys.length);\n\t\t\tEhex = _E;\n\t\t}\n\n\t\t// build P2PK Tags (NUT-11)\n\t\tconst tags: string[][] = [];\n\n\t\tconst ts = p2pk.locktime ?? NaN;\n\t\tif (Number.isSafeInteger(ts) && ts >= 0) {\n\t\t\ttags.push(['locktime', String(ts)]);\n\t\t}\n\n\t\tif (pubkeys.length > 0) {\n\t\t\ttags.push(['pubkeys', ...pubkeys]);\n\t\t\tif (reqLock > 1) {\n\t\t\t\ttags.push(['n_sigs', String(reqLock)]);\n\t\t\t}\n\t\t}\n\n\t\tif (refund.length > 0) {\n\t\t\ttags.push(['refund', ...refund]);\n\t\t\tif (reqRefund > 1) {\n\t\t\t\ttags.push(['n_sigs_refund', String(reqRefund)]);\n\t\t\t}\n\t\t}\n\n\t\t// Append additional tags if any\n\t\tif (p2pk.additionalTags?.length) {\n\t\t\tconst normalized = p2pk.additionalTags.map(([k, ...vals]) => {\n\t\t\t\tassertValidTagKey(k); // Validate key\n\t\t\t\treturn [k, ...vals.map(String)]; // all to strings\n\t\t\t});\n\t\t\ttags.push(...normalized);\n\t\t}\n\n\t\t// Construct secret\n\t\tconst newSecret: [string, { nonce: string; data: string; tags: string[][] }] = [\n\t\t\t'P2PK',\n\t\t\t{\n\t\t\t\tnonce: bytesToHex(randomBytes(32)),\n\t\t\t\tdata: data,\n\t\t\t\ttags,\n\t\t\t},\n\t\t];\n\n\t\t// blind the message\n\t\tconst parsed = JSON.stringify(newSecret);\n\n\t\t// Check secret length, counting Unicode code points\n\t\t// Same semantics as Nutshell python: len(str)\n\t\tconst charCount = [...parsed].length;\n\t\tif (charCount > MAX_SECRET_LENGTH) {\n\t\t\tthrow new Error(`Secret too long (${charCount} characters), maximum is ${MAX_SECRET_LENGTH}`);\n\t\t}\n\t\t// blind the message\n\t\tconst secretBytes = new TextEncoder().encode(parsed);\n\t\tconst { r, B_ } = blindMessage(secretBytes);\n\n\t\t// create OutputData\n\t\tconst od = new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tsecretBytes,\n\t\t);\n\n\t\t// stash Ehex - we add it to Proof later @see: toProof()\n\t\tif (p2pk.blindKeys && Ehex) setEphemeralE(od, Ehex);\n\n\t\treturn od;\n\t}\n\n\tstatic createRandomData(amount: number, keyset: MintKeys | Keyset, customSplit?: number[]) {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a) => this.createSingleRandomData(a, keyset.id));\n\t}\n\n\tstatic createSingleRandomData(amount: number, keysetId: string) {\n\t\tconst randomHex = bytesToHex(randomBytes(32));\n\t\tconst secretBytes = new TextEncoder().encode(randomHex);\n\t\tconst { r, B_ } = blindMessage(secretBytes);\n\t\treturn new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tsecretBytes,\n\t\t);\n\t}\n\n\tstatic createDeterministicData(\n\t\tamount: number,\n\t\tseed: Uint8Array,\n\t\tcounter: number,\n\t\tkeyset: MintKeys | Keyset,\n\t\tcustomSplit?: number[],\n\t): OutputData[] {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a, i) =>\n\t\t\tthis.createSingleDeterministicData(a, seed, counter + i, keyset.id),\n\t\t);\n\t}\n\n\tstatic createSingleDeterministicData(\n\t\tamount: number,\n\t\tseed: Uint8Array,\n\t\tcounter: number,\n\t\tkeysetId: string,\n\t) {\n\t\tconst secretBytes = deriveSecret(seed, keysetId, counter);\n\t\tconst secretBytesAsHex = bytesToHex(secretBytes);\n\t\tconst utf8SecretBytes = new TextEncoder().encode(secretBytesAsHex);\n\t\tconst deterministicR = bytesToNumber(deriveBlindingFactor(seed, keysetId, counter));\n\t\tconst { r, B_ } = blindMessage(utf8SecretBytes, deterministicR);\n\t\treturn new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tutf8SecretBytes,\n\t\t);\n\t}\n\n\t/**\n\t * Calculates the sum of amounts in an array of OutputDataLike objects.\n\t *\n\t * @param outputs Array of OutputDataLike objects.\n\t * @returns The total sum of amounts.\n\t */\n\tstatic sumOutputAmounts(outputs: OutputDataLike[]): number {\n\t\treturn outputs.reduce((sum, output) => sum + output.blindedMessage.amount, 0);\n\t}\n}\n","import { assertValidTagKey, OutputData } from '../model/OutputData';\nimport { type P2PKOptions, type P2PKTag } from './types/config';\n\n// Accept 33 byte compressed (02|03...), or 32 byte x-only,\n// normalised to lowercase 33 byte with 02 prefix for x only\nfunction normalisePubkey(pk: string): string {\n\tconst hex = pk.toLowerCase();\n\tif (hex.length === 66 && (hex.startsWith('02') || hex.startsWith('03'))) return hex;\n\tif (hex.length === 64) return `02${hex}`;\n\tthrow new Error(\n\t\t`Invalid pubkey, expected 33 byte compressed or 32 byte x only, got length ${hex.length}`,\n\t);\n}\n\nfunction toUnixSeconds(input: Date | number): number {\n\tif (input instanceof Date) return Math.floor(input.getTime() / 1000);\n\treturn input < 1e12 ? Math.floor(input) : Math.floor(input / 1000); // > 1e12 = ms\n}\n\nexport class P2PKBuilder {\n\t// A Set enforces uniqueness and preserves insertion order, which means\n\t// the first added lock key also becomes primary (data) pubkey\n\tprivate lockSet = new Set<string>();\n\tprivate refundSet = new Set<string>();\n\tprivate locktime?: number;\n\tprivate nSigs?: number;\n\tprivate nSigsRefund?: number;\n\tprivate extraTags: P2PKTag[] = [];\n\tprivate _blindKeys?: boolean;\n\n\taddLockPubkey(pk: string | string[]) {\n\t\tconst arr = Array.isArray(pk) ? pk : [pk];\n\t\tfor (const k of arr) this.lockSet.add(normalisePubkey(k));\n\t\treturn this;\n\t}\n\n\taddRefundPubkey(pk: string | string[]) {\n\t\tconst arr = Array.isArray(pk) ? pk : [pk];\n\t\tfor (const k of arr) this.refundSet.add(normalisePubkey(k));\n\t\treturn this;\n\t}\n\n\tlockUntil(when: Date | number) {\n\t\tthis.locktime = toUnixSeconds(when);\n\t\treturn this;\n\t}\n\n\trequireLockSignatures(n: number) {\n\t\tthis.nSigs = Math.max(1, Math.trunc(n));\n\t\treturn this;\n\t}\n\n\trequireRefundSignatures(n: number) {\n\t\tthis.nSigsRefund = Math.max(1, Math.trunc(n));\n\t\treturn this;\n\t}\n\n\taddTag(key: string, values?: string[] | string) {\n\t\tassertValidTagKey(key); //  Validate key\n\t\tconst vals = values === undefined ? [] : Array.isArray(values) ? values : [values];\n\t\tthis.extraTags.push([key, ...vals.map(String)]); // all to strings\n\t\treturn this;\n\t}\n\n\taddTags(tags: P2PKTag[]) {\n\t\tfor (const [k, ...vals] of tags) this.addTag(k, vals);\n\t\treturn this;\n\t}\n\t/**\n\t * @alpha\n\t */\n\tblindKeys() {\n\t\tthis._blindKeys = true;\n\t\treturn this;\n\t}\n\n\ttoOptions(): P2PKOptions {\n\t\tconst locks = Array.from(this.lockSet);\n\t\tconst refunds = Array.from(this.refundSet);\n\n\t\tif (locks.length === 0) throw new Error('At least one lock pubkey is required');\n\t\tif (refunds.length > 0 && this.locktime === undefined) {\n\t\t\tthrow new Error(\n\t\t\t\t'Refund pubkeys require a locktime, add lockUntil(...) or remove refund keys',\n\t\t\t);\n\t\t}\n\n\t\tconst total = locks.length + refunds.length;\n\t\tif (total > 10)\n\t\t\tthrow new Error(`Too many pubkeys, ${total} provided, maximum allowed is 10 in total`);\n\n\t\t// Clamp required signatures to available keys\n\t\tconst reqLock = this.nSigs ? Math.min(Math.max(1, this.nSigs), locks.length) : undefined;\n\t\tconst reqRefund = this.nSigsRefund\n\t\t\t? Math.min(Math.max(1, this.nSigsRefund), Math.max(1, refunds.length))\n\t\t\t: undefined;\n\n\t\tconst pubkey: string | string[] = locks.length === 1 ? locks[0] : locks;\n\n\t\tconst p2pk: P2PKOptions = {\n\t\t\tpubkey,\n\t\t\t...(this.locktime !== undefined ? { locktime: this.locktime } : {}),\n\t\t\t...(refunds.length ? { refundKeys: refunds } : {}),\n\t\t\t...(reqLock && reqLock > 1 ? { requiredSignatures: reqLock } : {}),\n\t\t\t...(reqRefund && reqRefund > 1 ? { requiredRefundSignatures: reqRefund } : {}),\n\t\t\t...(this.extraTags.length ? { additionalTags: this.extraTags.slice() } : {}),\n\t\t\t...(this._blindKeys ? { blindKeys: true } : {}),\n\t\t};\n\n\t\t// Ensure the secret is valid (not too long etc)\n\t\tconst smokeTest = OutputData.createSingleP2PKData(p2pk, 1, 'deedbeef');\n\t\tvoid smokeTest; // intentionally unused\n\n\t\treturn p2pk;\n\t}\n\n\tstatic fromOptions(opts: P2PKOptions): P2PKBuilder {\n\t\tconst b = new P2PKBuilder();\n\t\tconst locks = Array.isArray(opts.pubkey) ? opts.pubkey : [opts.pubkey];\n\t\tb.addLockPubkey(locks);\n\t\tif (opts.locktime !== undefined) b.lockUntil(opts.locktime);\n\t\tif (opts.refundKeys?.length) b.addRefundPubkey(opts.refundKeys);\n\t\tif (opts.requiredSignatures !== undefined) b.requireLockSignatures(opts.requiredSignatures);\n\t\tif (opts.requiredRefundSignatures !== undefined)\n\t\t\tb.requireRefundSignatures(opts.requiredRefundSignatures);\n\t\tif (opts.additionalTags?.length) b.addTags(opts.additionalTags);\n\t\tif (opts.blindKeys) b.blindKeys();\n\t\treturn b;\n\t}\n}\n","// Minimal types to avoid importing the whole wallet, keeps this module independent\nimport type { Proof } from '../model/types/proof';\nimport { fail, failIf, failIfNullish, type Logger, NULL_LOGGER, measureTime } from '../logger';\nimport { type SendResponse } from './types';\nimport { type KeyChain } from './KeyChain';\n\nexport type SelectProofs = (\n\tproofs: Proof[],\n\tamountToSend: number,\n\tkeyChain: KeyChain,\n\tincludeFees?: boolean,\n\texactMatch?: boolean,\n\tlogger?: Logger,\n) => SendResponse;\n\nexport const selectProofsRGLI: SelectProofs = (\n\tproofs: Proof[],\n\tamountToSend: number,\n\tkeyChain: KeyChain,\n\tincludeFees: boolean = false,\n\texactMatch: boolean = false,\n\t_logger: Logger = NULL_LOGGER,\n): SendResponse => {\n\t// Init vars\n\tconst MAX_TRIALS = 60; // 40-80 is optimal (per RGLI paper)\n\tconst MAX_OVRPCT = 0; // Acceptable close match overage (percent)\n\tconst MAX_OVRAMT = 0; // Acceptable close match overage (absolute)\n\tconst MAX_TIMEMS = 1000; // Halt new trials if over time (in ms)\n\tconst MAX_P2SWAP = 5000; // Max number of Phase 2 improvement swaps\n\tconst timer = measureTime(); // start the clock\n\tlet bestSubset: ProofWithFee[] | null = null;\n\tlet bestDelta = Infinity;\n\tlet bestAmount = 0;\n\tlet bestFeePPK = 0;\n\n\t/**\n\t * Helper Functions.\n\t */\n\tinterface ProofWithFee {\n\t\tproof: Proof;\n\t\texFee: number;\n\t\tppkfee: number;\n\t}\n\t// Looks up fee for a proof\n\tconst feeForProof = (proof: Proof): number => {\n\t\ttry {\n\t\t\treturn keyChain.getKeyset(proof.id).fee;\n\t\t} catch (e) {\n\t\t\tfail(`Could not get fee. No keyset found for keyset id: ${proof.id}`, _logger, {\n\t\t\t\terror: e,\n\t\t\t\tkeychain: keyChain.getKeysets(),\n\t\t\t});\n\t\t}\n\t};\n\t// Calculate net amount after fees\n\tconst sumExFees = (amount: number, feePPK: number): number => {\n\t\treturn amount - (includeFees ? Math.ceil(feePPK / 1000) : 0);\n\t};\n\t// Shuffle array for randomization\n\tconst shuffleArray = <T>(array: T[]): T[] => {\n\t\tconst shuffled = [...array];\n\t\tfor (let i = shuffled.length - 1; i > 0; i--) {\n\t\t\tconst j = Math.floor(Math.random() * (i + 1));\n\t\t\t[shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n\t\t}\n\t\treturn shuffled;\n\t};\n\t// Performs a binary search on a sorted (ascending) array of ProofWithFee objects by exFee.\n\t// If lessOrEqual=true, returns the rightmost index where exFee <= value\n\t// If lessOrEqual=false, returns the leftmost index where exFee >= value\n\tconst binarySearchIndex = (\n\t\tarr: ProofWithFee[],\n\t\tvalue: number,\n\t\tlessOrEqual: boolean,\n\t): number | null => {\n\t\tlet left = 0,\n\t\t\tright = arr.length - 1,\n\t\t\tresult: number | null = null;\n\t\twhile (left <= right) {\n\t\t\tconst mid = Math.floor((left + right) / 2);\n\t\t\tconst midValue = arr[mid].exFee;\n\t\t\tif (lessOrEqual ? midValue <= value : midValue >= value) {\n\t\t\t\tresult = mid;\n\t\t\t\tif (lessOrEqual) left = mid + 1;\n\t\t\t\telse right = mid - 1;\n\t\t\t} else {\n\t\t\t\tif (lessOrEqual) right = mid - 1;\n\t\t\t\telse left = mid + 1;\n\t\t\t}\n\t\t}\n\t\treturn lessOrEqual ? result : left < arr.length ? left : null;\n\t};\n\t// Insert into array of ProofWithFee objects sorted by exFee\n\tconst insertSorted = (arr: ProofWithFee[], obj: ProofWithFee): void => {\n\t\tconst value = obj.exFee;\n\t\tlet left = 0,\n\t\t\tright = arr.length;\n\t\twhile (left < right) {\n\t\t\tconst mid = Math.floor((left + right) / 2);\n\t\t\tif (arr[mid].exFee < value) left = mid + 1;\n\t\t\telse right = mid;\n\t\t}\n\t\tarr.splice(left, 0, obj);\n\t};\n\t// \"Delta\" is the excess over amountToSend including fees\n\t// plus a tiebreaker to favour lower PPK keysets\n\t// NB: Solutions under amountToSend are invalid (delta: Infinity)\n\tconst calculateDelta = (amount: number, feePPK: number): number => {\n\t\tconst netSum = sumExFees(amount, feePPK);\n\t\tif (netSum < amountToSend) return Infinity; // no good\n\t\treturn amount + feePPK / 1000 - amountToSend;\n\t};\n\n\t/**\n\t * Pre-processing.\n\t */\n\tlet totalAmount = 0;\n\tlet totalFeePPK = 0;\n\tconst proofWithFees = proofs.map((p) => {\n\t\tconst ppkfee = feeForProof(p);\n\t\tconst exFee = includeFees ? p.amount - ppkfee / 1000 : p.amount;\n\t\tconst obj = { proof: p, exFee, ppkfee };\n\t\t// Sum all economical proofs (filtered below)\n\t\tif (!includeFees || exFee > 0) {\n\t\t\ttotalAmount += p.amount;\n\t\t\ttotalFeePPK += ppkfee;\n\t\t}\n\t\treturn obj;\n\t});\n\n\t// Filter uneconomical proofs (totals computed above)\n\tlet spendableProofs = includeFees ? proofWithFees.filter((obj) => obj.exFee > 0) : proofWithFees;\n\n\t// Sort by exFee ascending\n\tspendableProofs.sort((a, b) => a.exFee - b.exFee);\n\n\t// Remove proofs too large to be useful and adjust totals\n\t// Exact Match: Keep proofs where exFee <= amountToSend\n\t// Close Match: Keep proofs where exFee <= nextBiggerExFee\n\tif (spendableProofs.length > 0) {\n\t\tlet endIndex;\n\t\tif (exactMatch) {\n\t\t\tconst rightIndex = binarySearchIndex(spendableProofs, amountToSend, true);\n\t\t\tendIndex = rightIndex !== null ? rightIndex + 1 : 0;\n\t\t} else {\n\t\t\tconst biggerIndex = binarySearchIndex(spendableProofs, amountToSend, false);\n\t\t\tif (biggerIndex !== null) {\n\t\t\t\tconst nextBiggerExFee = spendableProofs[biggerIndex].exFee;\n\t\t\t\tconst rightIndex = binarySearchIndex(spendableProofs, nextBiggerExFee, true);\n\t\t\t\tfailIfNullish(rightIndex, 'Unexpected null rightIndex in binary search', _logger);\n\t\t\t\tendIndex = rightIndex + 1;\n\t\t\t} else {\n\t\t\t\t// Keep all proofs if all exFee < amountToSend\n\t\t\t\tendIndex = spendableProofs.length;\n\t\t\t}\n\t\t}\n\t\t// Adjust totals for removed proofs\n\t\tfor (let i = endIndex; i < spendableProofs.length; i++) {\n\t\t\ttotalAmount -= spendableProofs[i].proof.amount;\n\t\t\ttotalFeePPK -= spendableProofs[i].ppkfee;\n\t\t}\n\t\tspendableProofs = spendableProofs.slice(0, endIndex);\n\t}\n\n\t// Validate using precomputed totals\n\tconst totalNetSum = sumExFees(totalAmount, totalFeePPK);\n\tif (amountToSend <= 0 || amountToSend > totalNetSum) {\n\t\treturn { keep: proofs, send: [] };\n\t}\n\n\t// Max acceptable amount for non-exact matches\n\tconst maxOverAmount = Math.min(\n\t\tMath.ceil(amountToSend * (1 + MAX_OVRPCT / 100)),\n\t\tamountToSend + MAX_OVRAMT,\n\t\ttotalNetSum,\n\t);\n\n\t/**\n\t * RGLI algorithm: Runs multiple trials (up to MAX_TRIALS) Each trial starts with randomized\n\t * greedy subset (S) and then tries to improve that subset to get a valid solution. NOTE: Fees are\n\t * dynamic, based on number of proofs (PPK), so we perform all calculations based on net amounts.\n\t */\n\tfor (let trial = 0; trial < MAX_TRIALS; trial++) {\n\t\t// PHASE 1: Randomized Greedy Selection\n\t\t// Add proofs up to amountToSend (after adjusting for fees)\n\t\t// for exact match or the first amount over target otherwise\n\t\tconst S: ProofWithFee[] = [];\n\t\tlet amount = 0;\n\t\tlet feePPK = 0;\n\t\tfor (const obj of shuffleArray(spendableProofs)) {\n\t\t\tconst newAmount = amount + obj.proof.amount;\n\t\t\tconst newFeePPK = feePPK + obj.ppkfee;\n\t\t\tconst netSum = sumExFees(newAmount, newFeePPK);\n\t\t\tif (exactMatch && netSum > amountToSend) break;\n\t\t\tS.push(obj);\n\t\t\tamount = newAmount;\n\t\t\tfeePPK = newFeePPK;\n\t\t\tif (netSum >= amountToSend) break;\n\t\t}\n\n\t\t// PHASE 2: Local Improvement\n\t\t// Examine all the amounts found in the first phase, and find the\n\t\t// amount not in the current solution (others), which would get us\n\t\t// closest to the amountToSend.\n\n\t\t// Calculate the \"others\" array (note: spendableProofs is sorted ASC)\n\t\t// Using set.has() for filtering gives faster lookups: O(n+m)\n\t\t// Using array.includes() would be way slower: O(n*m)\n\t\tconst SSet = new Set(S);\n\t\tconst others = spendableProofs.filter((obj) => !SSet.has(obj));\n\t\t// Generate a random order for accessing the trial subset ('S')\n\t\tconst indices = shuffleArray(Array.from({ length: S.length }, (_, i) => i)).slice(\n\t\t\t0,\n\t\t\tMAX_P2SWAP,\n\t\t);\n\t\tfor (const i of indices) {\n\t\t\t// Exact or acceptable close match solution found?\n\t\t\tconst netSum = sumExFees(amount, feePPK);\n\t\t\tif (\n\t\t\t\tnetSum === amountToSend ||\n\t\t\t\t(!exactMatch && netSum >= amountToSend && netSum <= maxOverAmount)\n\t\t\t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Get details for proof being replaced (objP), and temporarily\n\t\t\t// calculate the subset amount/fee with that proof removed.\n\t\t\tconst objP = S[i];\n\t\t\tconst tempAmount = amount - objP.proof.amount;\n\t\t\tconst tempFeePPK = feePPK - objP.ppkfee;\n\t\t\tconst tempNetSum = sumExFees(tempAmount, tempFeePPK);\n\t\t\tconst target = amountToSend - tempNetSum;\n\n\t\t\t// Find a better replacement proof (objQ) and swap it in\n\t\t\t// Exact match can only replace larger to close on the target\n\t\t\t// Close match can replace larger or smaller as needed, but will\n\t\t\t// not replace larger unless it closes on the target\n\t\t\tconst qIndex = binarySearchIndex(others, target, exactMatch);\n\t\t\tif (qIndex !== null) {\n\t\t\t\tconst objQ = others[qIndex];\n\t\t\t\tif (!exactMatch || objQ.exFee > objP.exFee) {\n\t\t\t\t\tif (target >= 0 || objQ.exFee <= objP.exFee) {\n\t\t\t\t\t\tS[i] = objQ;\n\t\t\t\t\t\tamount = tempAmount + objQ.proof.amount;\n\t\t\t\t\t\tfeePPK = tempFeePPK + objQ.ppkfee;\n\t\t\t\t\t\tothers.splice(qIndex, 1);\n\t\t\t\t\t\tinsertSorted(others, objP);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Update best solution\n\t\tconst delta = calculateDelta(amount, feePPK);\n\t\tif (delta < bestDelta) {\n\t\t\t_logger.debug(\n\t\t\t\t`selectProofsToSend: best solution found in trial #${trial} - amount: ${amount}, delta: ${delta}`,\n\t\t\t);\n\t\t\tbestSubset = [...S].sort((a, b) => b.exFee - a.exFee); // copy & sort\n\t\t\tbestDelta = delta;\n\t\t\tbestAmount = amount;\n\t\t\tbestFeePPK = feePPK;\n\n\t\t\t// \"PHASE 3\": Final check to make sure we haven't overpaid fees\n\t\t\t// and see if we can improve the solution. This is an adaptation\n\t\t\t// to the original RGLI, which helps us identify close match and\n\t\t\t// optimal fee solutions more consistently\n\t\t\tconst tempS = [...bestSubset]; // copy\n\t\t\twhile (tempS.length > 1 && bestDelta > 0) {\n\t\t\t\tconst objP = tempS.pop() as ProofWithFee;\n\t\t\t\tconst tempAmount = amount - objP.proof.amount;\n\t\t\t\tconst tempFeePPK = feePPK - objP.ppkfee;\n\t\t\t\tconst tempDelta = calculateDelta(tempAmount, tempFeePPK);\n\t\t\t\tif (tempDelta == Infinity) break;\n\t\t\t\tif (tempDelta < bestDelta) {\n\t\t\t\t\tbestSubset = [...tempS];\n\t\t\t\t\tbestDelta = tempDelta;\n\t\t\t\t\tbestAmount = tempAmount;\n\t\t\t\t\tbestFeePPK = tempFeePPK;\n\t\t\t\t\tamount = tempAmount;\n\t\t\t\t\tfeePPK = tempFeePPK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Check if solution is acceptable\n\t\tif (bestSubset && bestDelta < Infinity) {\n\t\t\tconst bestSum = sumExFees(bestAmount, bestFeePPK);\n\t\t\tif (\n\t\t\t\tbestSum === amountToSend ||\n\t\t\t\t(!exactMatch && bestSum >= amountToSend && bestSum <= maxOverAmount)\n\t\t\t) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// Time limit reached?\n\t\tif (timer.elapsed() > MAX_TIMEMS) {\n\t\t\tfailIf(\n\t\t\t\texactMatch,\n\t\t\t\t'Proof selection took too long. Try again with a smaller proof set.',\n\t\t\t\t_logger,\n\t\t\t);\n\t\t\t_logger.warn('Proof selection took too long. Returning best selection so far.');\n\t\t\tbreak;\n\t\t}\n\t}\n\t// Return Result\n\tif (bestSubset && bestDelta < Infinity) {\n\t\tconst bestProofs = bestSubset.map((obj) => obj.proof);\n\t\tconst bestSubsetSet = new Set(bestProofs);\n\t\tconst keep = proofs.filter((p) => !bestSubsetSet.has(p));\n\t\t_logger.info(`Proof selection took ${timer.elapsed()}ms`);\n\t\treturn { keep, send: bestProofs };\n\t}\n\treturn { keep: proofs, send: [] };\n};\n","/**\n * Usable counters in range is [start, start+count-1]\n *\n * @example // Start: 5, count: 3 => 5,6,7.\n */\nexport interface CounterRange {\n\tstart: number;\n\tcount: number;\n}\n\n// CounterSource.ts\nexport interface CounterSource {\n\t/**\n\t * Reserve n counters for a keyset.\n\t *\n\t * N may be 0. In that case the call MUST NOT mutate state and MUST return { start: currentNext,\n\t * count: 0 }, effectively a read only peek of the cursor.\n\t */\n\treserve(keysetId: string, n: number): Promise<CounterRange>;\n\t/**\n\t * Monotonic bump, ensure the next counter is at least minNext.\n\t */\n\tadvanceToAtLeast(keysetId: string, minNext: number): Promise<void>;\n\t/**\n\t * Optional introspection.\n\t */\n\tsnapshot?(): Promise<Record<string, number>>;\n\t/**\n\t * Optional hard set, useful for tests or migrations.\n\t */\n\tsetNext?(keysetId: string, next: number): Promise<void>;\n}\n\n/**\n * Counter summary for an operation.\n *\n * - `keysetId` - of the transaction.\n * - `start` - beginning of reservation.\n * - `count` - number of reservations.\n * - `next` - counter available after reservation.\n *\n * @example // Start: 5, Count: 3 => 5,6,7. Next: 8.\n */\nexport type OperationCounters = {\n\tkeysetId: string;\n\tstart: number;\n\tcount: number;\n\tnext: number;\n};\n\n/**\n * In memory implementation with per keyset locks for atomic counters.\n */\nexport class EphemeralCounterSource implements CounterSource {\n\tprivate next = new Map<string, number>();\n\tprivate locks = new Map<string, Promise<void>>();\n\n\tconstructor(initial?: Record<string, number>) {\n\t\tif (initial) {\n\t\t\tfor (const [k, v] of Object.entries(initial)) this.next.set(k, v);\n\t\t}\n\t}\n\n\tprivate async withLock<T>(k: string, fn: () => T | Promise<T>): Promise<T> {\n\t\tconst prev = this.locks.get(k) ?? Promise.resolve();\n\t\tlet release!: () => void;\n\t\tconst p = new Promise<void>((resolve) => (release = resolve));\n\t\tconst chain = prev.then(() => p);\n\t\tthis.locks.set(k, chain);\n\t\ttry {\n\t\t\tawait prev;\n\t\t\treturn await fn();\n\t\t} finally {\n\t\t\trelease();\n\t\t\tif (this.locks.get(k) === chain) {\n\t\t\t\tthis.locks.delete(k);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync reserve(keysetId: string, n: number): Promise<CounterRange> {\n\t\tif (n < 0) throw new Error('reserve called with negative count');\n\t\treturn this.withLock(keysetId, () => {\n\t\t\tconst cur = this.next.get(keysetId) ?? 0;\n\t\t\tif (n === 0) return { start: cur, count: 0 }; // report current, do not move\n\t\t\tthis.next.set(keysetId, cur + n);\n\t\t\treturn { start: cur, count: n };\n\t\t});\n\t}\n\n\tasync advanceToAtLeast(keysetId: string, minNext: number): Promise<void> {\n\t\tawait this.withLock(keysetId, () => {\n\t\t\tconst cur = this.next.get(keysetId) ?? 0;\n\t\t\tif (minNext > cur) this.next.set(keysetId, minNext);\n\t\t});\n\t}\n\n\tasync setNext(keysetId: string, next: number): Promise<void> {\n\t\tawait this.withLock(keysetId, () => {\n\t\t\tif (next < 0) throw new Error('setNext: negative next not allowed');\n\t\t\tthis.next.set(keysetId, next);\n\t\t});\n\t}\n\n\tsnapshot(): Promise<Record<string, number>> {\n\t\treturn Promise.resolve(Object.fromEntries(this.next.entries()));\n\t}\n}\n","import {\n\ttype MeltQuoteResponse,\n\ttype MintQuoteResponse,\n\ttype Bolt12MeltQuoteResponse,\n\ttype Bolt12MintQuoteResponse,\n} from '../mint/types';\nimport { type OutputData, type OutputDataFactory } from '../model/OutputData';\nimport type { Proof } from '../model/types/proof';\nimport type { Token } from '../model/types/token';\nimport {\n\ttype OutputType,\n\ttype OutputConfig,\n\ttype SendConfig,\n\ttype ReceiveConfig,\n\ttype MintProofsConfig,\n\ttype P2PKOptions,\n\ttype OnCountersReserved,\n\ttype MeltProofsConfig,\n} from './types';\nimport type { Wallet } from './Wallet';\n\n/**\n * Fluent operations builder for a Wallet instance.\n *\n * @remarks\n * Provides chainable builders for sending, receiving, and minting. Each builder is single use. If\n * you do not customise an output side, the wallet’s policy defaults apply.\n */\nexport class WalletOps {\n\tconstructor(private wallet: Wallet) {}\n\tsend(amount: number, proofs: Proof[]) {\n\t\treturn new SendBuilder(this.wallet, amount, proofs);\n\t}\n\treceive(token: Token | string) {\n\t\treturn new ReceiveBuilder(this.wallet, token);\n\t}\n\tmintBolt11(amount: number, quote: string | MintQuoteResponse) {\n\t\treturn new MintBuilder<'bolt11'>(this.wallet, 'bolt11', amount, quote);\n\t}\n\tmintBolt12(amount: number, quote: Bolt12MintQuoteResponse) {\n\t\treturn new MintBuilder<'bolt12'>(this.wallet, 'bolt12', amount, quote);\n\t}\n\tmeltBolt11(quote: MeltQuoteResponse, proofs: Proof[]) {\n\t\treturn new MeltBuilder(this.wallet, 'bolt11', quote, proofs);\n\t}\n\tmeltBolt12(quote: Bolt12MeltQuoteResponse, proofs: Proof[]) {\n\t\treturn new MeltBuilder(this.wallet, 'bolt12', quote, proofs);\n\t}\n}\n\n/**\n * Builder for composing a send or swap.\n *\n * @remarks\n * If you only customise the send side, keep is omitted so the wallet may still attempt an offline\n * exact match selection where possible.\n * @example\n *\n *     const { keep, send } = await wallet.ops\n *     \t.send(5, proofs)\n *     \t.asDeterministic() // counter 0 means auto reserve via CounterSource\n *     \t.keepAsRandom()\n *     \t.includeFees(true) // sender pays receiver’s future spend fee\n *     \t.run();\n */\nexport class SendBuilder {\n\tprivate sendOT?: OutputType;\n\tprivate keepOT?: OutputType;\n\tprivate config: SendConfig = {};\n\tprivate offlineExact?: { requireDleq: boolean };\n\tprivate offlineClose?: { requireDleq: boolean };\n\n\tconstructor(\n\t\tprivate wallet: Wallet,\n\t\tprivate amount: number,\n\t\tprivate proofs: Proof[],\n\t) {}\n\n\t/**\n\t * Use random blinding for the sent outputs.\n\t *\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasRandom(denoms?: number[]) {\n\t\tthis.sendOT = { type: 'random', denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use deterministic outputs for the sent proofs.\n\t *\n\t * @param counter Starting counter. Zero means auto reserve using the wallet’s CounterSource.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasDeterministic(counter = 0, denoms?: number[]) {\n\t\tthis.sendOT = { type: 'deterministic', counter, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use P2PK locked outputs for the sent proofs.\n\t *\n\t * @param options NUT 11 options like pubkey and locktime.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasP2PK(options: P2PKOptions, denoms?: number[]) {\n\t\tthis.sendOT = { type: 'p2pk', options, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use a factory to generate OutputData for the sent proofs.\n\t *\n\t * @param factory OutputDataFactory used to produce blinded messages.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasFactory(factory: OutputDataFactory, denoms?: number[]) {\n\t\tthis.sendOT = { type: 'factory', factory, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Provide pre created OutputData for the sent proofs.\n\t *\n\t * @param data Fully formed OutputData. Their amounts must sum to the send amount, otherwise the\n\t *   wallet will throw.\n\t */\n\tasCustom(data: OutputData[]) {\n\t\tthis.sendOT = { type: 'custom', data };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use random blinding for change outputs.\n\t *\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tkeepAsRandom(denoms?: number[]) {\n\t\tthis.keepOT = { type: 'random', denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use deterministic outputs for change.\n\t *\n\t * @param counter Starting counter. Zero means auto reserve using the wallet’s CounterSource.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tkeepAsDeterministic(counter = 0, denoms?: number[]) {\n\t\tthis.keepOT = { type: 'deterministic', counter, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use P2PK locked change (NUT 11).\n\t *\n\t * @param options Locking options applied to the kept proofs.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tkeepAsP2PK(options: P2PKOptions, denoms?: number[]) {\n\t\tthis.keepOT = { type: 'p2pk', options, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use a factory to generate OutputData for change.\n\t *\n\t * @param factory OutputDataFactory used to produce blinded messages.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tkeepAsFactory(factory: OutputDataFactory, denoms?: number[]) {\n\t\tthis.keepOT = { type: 'factory', factory, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Provide pre created OutputData for change.\n\t *\n\t * @param data Fully formed OutputData for the keep (change) amount.\n\t */\n\tkeepAsCustom(data: OutputData[]) {\n\t\tthis.keepOT = { type: 'custom', data };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Make the sender cover the receiver’s future spend fee.\n\t *\n\t * @param on When true, include fees in the sent amount. Default true if called.\n\t */\n\tincludeFees(on = true) {\n\t\tthis.config.includeFees = on;\n\t\treturn this;\n\t}\n\t/**\n\t * Use a specific keyset for the operation.\n\t *\n\t * @param id Keyset id to use for mint keys and fee lookup.\n\t */\n\tkeyset(id: string) {\n\t\tthis.config.keysetId = id;\n\t\treturn this;\n\t} /**\n\t * Provide existing proofs to help optimise denomination selection.\n\t *\n\t * @remarks\n\t * Has no effect if denominations (custom split) was specified.\n\t * @param p Proofs currently held by the wallet, used to hit denomination targets.\n\t */\n\tproofsWeHave(p: Proof[]) {\n\t\tthis.config.proofsWeHave = p;\n\t\treturn this;\n\t}\n\t/**\n\t * Receive a callback once counters are atomically reserved for deterministic outputs.\n\t *\n\t * @param cb Called with OperationCounters when counters are reserved.\n\t */\n\tonCountersReserved(cb: OnCountersReserved) {\n\t\tthis.config.onCountersReserved = cb;\n\t\treturn this;\n\t}\n\t/**\n\t * Force a pure offline, exact match selection. No mint calls are made. If an exact match cannot\n\t * be found, this throws.\n\t *\n\t * @param requireDleq Only consider proofs with a DLEQ when true.\n\t */\n\tofflineExactOnly(requireDleq = false) {\n\t\tthis.offlineExact = { requireDleq };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Force a pure offline selection that allows a close match, overspend permitted per wallet RGLI.\n\t * No mint calls are made. Returns the best offline subset found, or throws if funds are\n\t * insufficient.\n\t *\n\t * @param requireDleq Only consider proofs with a DLEQ when true.\n\t */\n\tofflineCloseMatch(requireDleq = false) {\n\t\tthis.offlineClose = { requireDleq };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Execute the send or swap.\n\t *\n\t * @returns The split result with kept and sent proofs.\n\t */\n\tasync run() {\n\t\t// If an offline mode is requested, forbid custom OutputTypes,\n\t\t// because offline uses existing proofs and cannot honour new outputs.\n\t\tif ((this.offlineExact || this.offlineClose) && (this.sendOT || this.keepOT)) {\n\t\t\tthrow new Error(\n\t\t\t\t'Offline selection cannot be combined with custom output types. Remove send/keep output configuration, or use an online swap.',\n\t\t\t);\n\t\t}\n\n\t\t// Strict offline, exact match only\n\t\tif (this.offlineExact) {\n\t\t\treturn this.wallet.sendOffline(this.amount, this.proofs, {\n\t\t\t\tincludeFees: this.config.includeFees,\n\t\t\t\texactMatch: true,\n\t\t\t\trequireDleq: this.offlineExact.requireDleq,\n\t\t\t});\n\t\t}\n\n\t\t// Offline close match, may overshoot\n\t\tif (this.offlineClose) {\n\t\t\treturn this.wallet.sendOffline(this.amount, this.proofs, {\n\t\t\t\tincludeFees: this.config.includeFees,\n\t\t\t\texactMatch: false,\n\t\t\t\trequireDleq: this.offlineClose.requireDleq,\n\t\t\t});\n\t\t}\n\n\t\t// Construct an OutputConfig using default send if no customizations\n\t\tconst outputConfig: OutputConfig = {\n\t\t\tsend: this.sendOT ?? this.wallet.defaultOutputType(),\n\t\t\t...(this.keepOT ? { keep: this.keepOT } : {}),\n\t\t};\n\t\treturn this.wallet.send(this.amount, this.proofs, this.config, outputConfig);\n\t}\n}\n\n/**\n * Builder for receiving a token.\n *\n * @remarks\n * If you do not call a type method, the wallet’s policy default is used.\n * @example\n *\n *     const proofs = await wallet.ops\n *     \t.receive(token)\n *     \t.asDeterministic() // counter 0 auto reserves\n *     \t.requireDleq(true)\n *     \t.run();\n */\nexport class ReceiveBuilder {\n\tprivate outputType?: OutputType;\n\tprivate config: ReceiveConfig = {};\n\n\tconstructor(\n\t\tprivate wallet: Wallet,\n\t\tprivate token: Token | string,\n\t) {}\n\n\t/**\n\t * Use random blinding for the received outputs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasRandom(denoms?: number[]) {\n\t\tthis.outputType = { type: 'random', denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use deterministic outputs for the received proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param counter Starting counter. Zero means auto reserve using the wallet’s CounterSource.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasDeterministic(counter = 0, denoms?: number[]) {\n\t\tthis.outputType = { type: 'deterministic', counter, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use P2PK locked outputs for the received proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param options NUT 11 options like pubkey and locktime.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasP2PK(options: P2PKOptions, denoms?: number[]) {\n\t\tthis.outputType = { type: 'p2pk', options, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use a factory to generate OutputData for received proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param factory OutputDataFactory used to produce blinded messages.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasFactory(factory: OutputDataFactory, denoms?: number[]) {\n\t\tthis.outputType = { type: 'factory', factory, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Provide pre created OutputData for received proofs.\n\t *\n\t * @param data Fully formed OutputData for the final amount.\n\t */\n\tasCustom(data: OutputData[]) {\n\t\tthis.outputType = { type: 'custom', data };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a specific keyset for the operation.\n\t *\n\t * @param id Keyset id to use for mint keys and fee lookup.\n\t */\n\tkeyset(id: string) {\n\t\tthis.config.keysetId = id;\n\t\treturn this;\n\t}\n\t/**\n\t * Require all incoming proofs to have a valid DLEQ for the selected keyset.\n\t *\n\t * @param on When true, proofs without DLEQ are rejected.\n\t */\n\trequireDleq(on = true) {\n\t\tthis.config.requireDleq = on;\n\t\treturn this;\n\t}\n\t/**\n\t * Private key used to sign P2PK locked incoming proofs.\n\t *\n\t * @param k Single key or array of multisig keys.\n\t */\n\tprivkey(k: string | string[]) {\n\t\tthis.config.privkey = k;\n\t\treturn this;\n\t}\n\t/**\n\t * Provide existing proofs to help optimise denomination selection.\n\t *\n\t * @remarks\n\t * Has no effect if denominations (custom split) was specified.\n\t * @param p Proofs currently held by the wallet, used to hit denomination targets.\n\t */\n\tproofsWeHave(p: Proof[]) {\n\t\tthis.config.proofsWeHave = p;\n\t\treturn this;\n\t}\n\t/**\n\t * Receive a callback once counters are atomically reserved for deterministic outputs.\n\t *\n\t * @param cb Called with OperationCounters when counters are reserved.\n\t */\n\tonCountersReserved(cb: OnCountersReserved) {\n\t\tthis.config.onCountersReserved = cb;\n\t\treturn this;\n\t}\n\n\tasync run() {\n\t\treturn this.wallet.receive(this.token, this.config, this.outputType);\n\t}\n}\n\n/**\n * Builder for minting proofs from a quote.\n *\n * @remarks\n * Bolt12 requires privkey by default, bolt11 only for locked quotes. The compiler will throw an\n * error if bolt12 and privkey() is omitted: MintBuilder<\"bolt12\", false>' is not assignable...\n * @example\n *\n *     const proofs = await wallet.ops\n *     \t.mint(100, quote)\n *     \t.asDeterministic() // counter 0 auto reserves\n *     \t.onCountersReserved((info) => console.log(info))\n *     \t.privkey('sk')\n *     \t.run();\n */\nexport class MintBuilder<\n\tM extends 'bolt11' | 'bolt12',\n\tHasPrivKey extends boolean = M extends 'bolt12' ? false : true,\n> {\n\tprivate outputType?: OutputType;\n\tprivate config: MintProofsConfig = {};\n\n\t// phantom field to satisfy linter (erased at emit)\n\tprivate readonly _hasPrivkey!: HasPrivKey;\n\n\tconstructor(\n\t\tprivate wallet: Wallet,\n\t\tprivate method: M,\n\t\tprivate amount: number,\n\t\tprivate quote: string | MintQuoteResponse | Bolt12MintQuoteResponse,\n\t) {\n\t\tvoid this._hasPrivkey; // intentionally unused (phantom field)\n\t}\n\n\t/**\n\t * Use random blinding for the minted proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasRandom(denoms?: number[]) {\n\t\tthis.outputType = { type: 'random', denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use deterministic outputs for the minted proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param counter Starting counter. Zero means auto reserve using the wallet’s CounterSource.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasDeterministic(counter = 0, denoms?: number[]) {\n\t\tthis.outputType = { type: 'deterministic', counter, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use P2PK locked outputs for the minted proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param options NUT 11 options like pubkey and locktime.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasP2PK(options: P2PKOptions, denoms?: number[]) {\n\t\tthis.outputType = { type: 'p2pk', options, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Use a factory to generate OutputData for minted proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param factory OutputDataFactory used to produce blinded messages.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasFactory(factory: OutputDataFactory, denoms?: number[]) {\n\t\tthis.outputType = { type: 'factory', factory, denominations: denoms };\n\t\treturn this;\n\t}\n\t/**\n\t * Provide pre created OutputData for minted proofs.\n\t *\n\t * @param data Fully formed OutputData for the final amount.\n\t */\n\tasCustom(data: OutputData[]) {\n\t\tthis.outputType = { type: 'custom', data };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a specific keyset for the operation.\n\t *\n\t * @param id Keyset id to use for mint keys and fee lookup.\n\t */\n\tkeyset(id: string) {\n\t\tthis.config.keysetId = id;\n\t\treturn this;\n\t}\n\t/**\n\t * Private key to sign locked mint quotes.\n\t *\n\t * @param k Private key for locked quotes.\n\t */\n\tprivkey(k: string): MintBuilder<M, true> {\n\t\t// For bolt11 - privkey is sent in the config\n\t\t// For bolt12 - privkey is sent positionally in run()\n\t\tthis.config.privkey = k;\n\t\treturn this as MintBuilder<M, true>;\n\t}\n\t/**\n\t * Provide existing proofs to help optimise denomination selection.\n\t *\n\t * @remarks\n\t * Has no effect if denominations (custom split) was specified.\n\t * @param p Proofs currently held by the wallet, used to hit denomination targets.\n\t */\n\tproofsWeHave(p: Proof[]) {\n\t\tthis.config.proofsWeHave = p;\n\t\treturn this;\n\t}\n\t/**\n\t * Receive a callback once counters are atomically reserved for deterministic outputs.\n\t *\n\t * @param cb Called with OperationCounters when counters are reserved.\n\t */\n\tonCountersReserved(cb: OnCountersReserved) {\n\t\tthis.config.onCountersReserved = cb;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Execute minting against the quote.\n\t *\n\t * @remarks\n\t * This method can only be called for bolt12 quotes when .privkey() is set.\n\t * @returns The newly minted proofs.\n\t */\n\tasync run(this: MintBuilder<M, true>) {\n\t\t// BOLT 11\n\t\tif (this.method === 'bolt11') {\n\t\t\tconst bolt11 = this.quote as MintQuoteResponse;\n\t\t\tif (bolt11.pubkey && !this.config.privkey) {\n\t\t\t\tthrow new Error('privkey is required for locked BOLT11 mint quotes');\n\t\t\t}\n\t\t\treturn this.wallet.mintProofsBolt11(this.amount, bolt11, this.config, this.outputType);\n\t\t}\n\n\t\t// BOLT 12\n\t\tconst bolt12 = this.quote as Bolt12MintQuoteResponse;\n\t\tif (!this.config.privkey) {\n\t\t\tthrow new Error('privkey is required for BOLT12 mint quotes');\n\t\t}\n\t\treturn this.wallet.mintProofsBolt12(\n\t\t\tthis.amount,\n\t\t\tbolt12,\n\t\t\tthis.config.privkey,\n\t\t\tthis.config,\n\t\t\tthis.outputType,\n\t\t);\n\t}\n}\n\n/**\n * Builder for melting proofs to pay a Lightning invoice or BOLT12 offer.\n *\n * @remarks\n * Supports both BOLT11 and BOLT12. You can optionally receive a callback when NUT-08 blanks are\n * created for async melts.\n * @example\n *\n * ```typescript\n * // Basic BOLT11 melt\n * await wallet.ops.meltBolt11(quote, proofs).run();\n *\n * // BOLT12 melt with deterministic change and NUT-08 blanks callback\n * await wallet.ops\n * \t.meltBolt12(quote12, proofs)\n * \t.asDeterministic() // counter 0 auto reserves\n * \t.onChangeOutputsCreated((blanks) => {\n * \t\t// Persist blanks and retry later with wallet.completeMelt(blanks)\n * \t})\n * \t.onCountersReserved((info) => console.log('Reserved', info))\n * \t.run();\n * ```\n */\nexport class MeltBuilder {\n\tprivate outputType?: OutputType;\n\tprivate config: MeltProofsConfig = {};\n\n\tconstructor(\n\t\tprivate wallet: Wallet,\n\t\tprivate method: 'bolt11' | 'bolt12',\n\t\tprivate quote: MeltQuoteResponse,\n\t\tprivate proofs: Proof[],\n\t) {}\n\n\t/**\n\t * Use random blinding for change outputs.\n\t *\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasRandom(denoms?: number[]) {\n\t\tthis.outputType = { type: 'random', denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use deterministic outputs for change.\n\t *\n\t * @param counter Starting counter. Zero means auto reserve using the wallet’s CounterSource.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasDeterministic(counter = 0, denoms?: number[]) {\n\t\tthis.outputType = { type: 'deterministic', counter, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use P2PK-locked change (NUT-11).\n\t *\n\t * @param options NUT-11 locking options (e.g., pubkey, locktime).\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasP2PK(options: P2PKOptions, denoms?: number[]) {\n\t\tthis.outputType = { type: 'p2pk', options, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a factory to generate OutputData for change.\n\t *\n\t * @param factory Factory used to produce blinded messages.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasFactory(factory: OutputDataFactory, denoms?: number[]) {\n\t\tthis.outputType = { type: 'factory', factory, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Provide pre-created OutputData for change.\n\t *\n\t * @param data Fully formed OutputData for the change amount.\n\t */\n\tasCustom(data: OutputData[]) {\n\t\tthis.outputType = { type: 'custom', data };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a specific keyset for the melt operation.\n\t *\n\t * @param id Keyset id to use for mint keys and fee lookup.\n\t */\n\tkeyset(id: string) {\n\t\tthis.config.keysetId = id;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Receive a callback once counters are atomically reserved for deterministic outputs.\n\t *\n\t * @param cb Called with OperationCounters when counters are reserved.\n\t */\n\tonCountersReserved(cb: OnCountersReserved) {\n\t\tthis.config.onCountersReserved = cb;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Receive a callback when NUT-08 blanks (0-sat change outputs) are created for async melts.\n\t *\n\t * @remarks\n\t * You can persist these blanks and later call `wallet.completeMelt(blanks)` to finalize and\n\t * recover change once the invoice/offer is paid.\n\t * @param cb Callback invoked with the created blanks payload.\n\t */\n\tonChangeOutputsCreated(cb: NonNullable<MeltProofsConfig['onChangeOutputsCreated']>) {\n\t\tthis.config.onChangeOutputsCreated = cb;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Execute the melt against the quote.\n\t *\n\t * @returns The melt result: `{ quote, change }`.\n\t */\n\tasync run() {\n\t\t// BOLT11\n\t\tif (this.method === 'bolt11') {\n\t\t\treturn this.wallet.meltProofsBolt11(this.quote, this.proofs, this.config, this.outputType);\n\t\t}\n\n\t\t// BOLT 12\n\t\treturn this.wallet.meltProofsBolt12(this.quote, this.proofs, this.config, this.outputType);\n\t}\n}\n","import type { Wallet } from './Wallet';\nimport type { Proof, ProofState } from '../model/types';\nimport {\n\tMintQuoteState,\n\tMeltQuoteState,\n\ttype MintQuoteResponse,\n\ttype MeltQuoteResponse,\n} from '../mint/types';\nimport type { MeltBlanks, SubscriptionCanceller } from './types';\nimport { hashToCurve } from '../crypto';\nimport { type OperationCounters } from './CounterSource';\nimport { safeCallback } from '../logger';\n\nexport type CancellerLike = SubscriptionCanceller | Promise<SubscriptionCanceller>;\n\nexport type SubscribeOpts = { signal?: AbortSignal };\n\ntype ErrorWithCause = Error & { cause?: unknown };\n\nfunction safeStringify(obj: unknown): string {\n\tconst seen = new WeakSet<object>();\n\ttry {\n\t\treturn JSON.stringify(obj, (_k: string, v: unknown) => {\n\t\t\tif (typeof v === 'object' && v !== null) {\n\t\t\t\tif (seen.has(v)) return '[Circular]';\n\t\t\t\tseen.add(v);\n\t\t\t}\n\t\t\treturn v; // returning `unknown` is fine\n\t\t});\n\t} catch {\n\t\treturn Object.prototype.toString.call(obj);\n\t}\n}\n\nfunction normalizeError(err: unknown): Error {\n\tif (err instanceof Error) return err;\n\tconst message = typeof err === 'string' ? err : safeStringify(err);\n\tconst e: ErrorWithCause = new Error(message);\n\te.cause = err;\n\treturn e;\n}\n\nfunction makeAbortError(): Error {\n\tconst e = new Error('Aborted');\n\tObject.defineProperty(e, 'name', { value: 'AbortError' });\n\treturn e;\n}\n\nfunction cancelSafely(c: CancellerLike | null | undefined): void {\n\tif (!c) return;\n\tvoid Promise.resolve(c)\n\t\t.then((fn) => {\n\t\t\ttry {\n\t\t\t\tfn();\n\t\t\t} catch {\n\t\t\t\t/* ignore canceller errors */\n\t\t\t}\n\t\t\treturn;\n\t\t})\n\t\t.catch(() => {\n\t\t\t/* ignore awaiting-canceller errors */\n\t\t});\n}\n\nexport class WalletEvents {\n\tconstructor(private wallet: Wallet) {}\n\n\t// Callbacks registered for Counters Reserved events\n\tprivate countersReservedHandlers = new Set<(payload: OperationCounters) => void>();\n\n\t// Callbacks registered for Melt blanks created events\n\tprivate meltBlanksHandlers = new Set<(payload: MeltBlanks) => void>();\n\n\t// Binds an abort signal to each subscription canceller\n\tprivate withAbort(\n\t\tsignal: AbortSignal | undefined,\n\t\tcancel: SubscriptionCanceller,\n\t): SubscriptionCanceller {\n\t\tif (!signal) return cancel;\n\t\tif (signal.aborted) {\n\t\t\tcancel();\n\t\t\treturn () => {\n\t\t\t\t/* noop */\n\t\t\t};\n\t\t}\n\t\tconst onAbort = () => cancel();\n\t\tsignal.addEventListener('abort', onAbort, { once: true });\n\t\treturn () => {\n\t\t\tsignal.removeEventListener('abort', onAbort);\n\t\t\tcancel();\n\t\t};\n\t}\n\n\t// Subscribe to a quote-paid event and resolve when it fires.\n\t// Supports AbortSignal and timeout, and always cleans up.\n\tprivate waitUntilPaid<T>(\n\t\tsubscribeFn: (\n\t\t\tid: string,\n\t\t\tcb: (p: T) => void, // called when the entity becomes PAID\n\t\t\terr: (e: Error) => void, // called if the subscription itself errors\n\t\t\topts?: { signal?: AbortSignal },\n\t\t) => Promise<SubscriptionCanceller>,\n\t\tid: string, // identifier of the mint/melt/etc. to watch\n\t\topts?: SubscribeOpts & { timeoutMs?: number },\n\t\ttimeoutMsg = 'Timeout waiting for paid',\n\t): Promise<T> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlet cancelP: Promise<SubscriptionCanceller> | null = null; // handle to unsub later\n\t\t\tlet to: ReturnType<typeof setTimeout> | null = null; // optional timeout timer\n\n\t\t\t// Common cleanup: cancels subscription, clears timer, detaches abort listener.\n\t\t\t// If an error is provided, rejects the promise with it.\n\t\t\tconst cleanup = (err?: unknown) => {\n\t\t\t\tcancelSafely(cancelP);\n\t\t\t\tif (to) {\n\t\t\t\t\tclearTimeout(to);\n\t\t\t\t\tto = null;\n\t\t\t\t}\n\t\t\t\tif (opts?.signal) opts.signal.removeEventListener('abort', onAbort);\n\t\t\t\tif (err) reject(normalizeError(err));\n\t\t\t};\n\n\t\t\t// Abort handler produces a standardized AbortError and rejects.\n\t\t\tconst onAbort = () => cleanup(makeAbortError());\n\n\t\t\t// Hook up AbortSignal if provided.\n\t\t\tif (opts?.signal) {\n\t\t\t\tif (opts.signal.aborted) return onAbort(); // already aborted\n\t\t\t\topts.signal.addEventListener('abort', onAbort, { once: true });\n\t\t\t}\n\n\t\t\t// Start a timeout if requested.\n\t\t\tif (opts?.timeoutMs && opts.timeoutMs > 0) {\n\t\t\t\tto = setTimeout(() => cleanup(new Error(timeoutMsg)), opts.timeoutMs);\n\t\t\t}\n\n\t\t\t// Subscribe to the actual event. Canceller returned is saved to cancelP.\n\t\t\tcancelP = subscribeFn(\n\t\t\t\tid,\n\t\t\t\t(p) => {\n\t\t\t\t\tcleanup(); // clean up resources\n\t\t\t\t\tresolve(p); // resolve promise with payload\n\t\t\t\t},\n\t\t\t\t(e) => cleanup(e), // reject if subscription itself errors\n\t\t\t\t{ signal: opts?.signal }, // delegate abort to subscription as well\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * Register a callback that fires whenever deterministic counters are reserved.\n\t *\n\t * Timing: the callback is invoked synchronously _after_ a successful reservation and _before_ the\n\t * enclosing wallet method returns. The wallet does **not** await your callback, it is\n\t * fire-and-forget.\n\t *\n\t * Responsibility for async work is on the consumer. If your handler calls an async function (e.g.\n\t * persisting `start + count` to storage), make sure to handle errors inside it to avoid unhandled\n\t * rejections.\n\t *\n\t * Typical use: persist `start + count` for the `keysetId` so counters survive restarts.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * wallet.on.countersReserved(({ keysetId, start, count, next }) => {\n\t * \tsaveNextToDb(keysetId, start + count); // handle async errors inside saveNextToDb\n\t * });\n\t * ```\n\t *\n\t * @param cb Handler called with { keysetId, start, count }.\n\t * @returns A function that unsubscribes the handler.\n\t */\n\tpublic countersReserved(\n\t\tcb: (payload: OperationCounters) => void,\n\t\topts?: SubscribeOpts,\n\t): SubscriptionCanceller {\n\t\tthis.countersReservedHandlers.add(cb);\n\t\tconst cancel = () => this.countersReservedHandlers.delete(cb);\n\t\treturn this.withAbort(opts?.signal, cancel);\n\t}\n\t/**\n\t * @internal\n\t */\n\tpublic _emitCountersReserved(payload: OperationCounters) {\n\t\tfor (const h of this.countersReservedHandlers) {\n\t\t\tsafeCallback(h, payload, this.wallet.logger, { event: 'countersReserved' });\n\t\t}\n\t}\n\n\t/**\n\t * Register a callback fired whenever NUT-08 blanks are created during a melt.\n\t *\n\t * Called synchronously right after blanks are prepared (before the melt request), and the wallet\n\t * does not await your handler.\n\t *\n\t * Typical use: persist `payload` so you can later call `wallet.completeMelt(payload)`.\n\t */\n\tpublic meltBlanksCreated(\n\t\tcb: (payload: MeltBlanks) => void,\n\t\topts?: SubscribeOpts,\n\t): SubscriptionCanceller {\n\t\tthis.meltBlanksHandlers.add(cb);\n\t\tconst cancel = () => this.meltBlanksHandlers.delete(cb);\n\t\treturn this.withAbort(opts?.signal, cancel);\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tpublic _emitMeltBlanksCreated(payload: MeltBlanks) {\n\t\tfor (const h of this.meltBlanksHandlers) {\n\t\t\tsafeCallback(h, payload, this.wallet.logger, { event: 'meltBlanksCreated' });\n\t\t}\n\t}\n\n\t/**\n\t * Register a callback to be called whenever a mint quote's state changes.\n\t *\n\t * @param quoteIds List of mint quote IDs that should be subscribed to.\n\t * @param callback Callback function that will be called whenever a mint quote state changes.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync mintQuoteUpdates(\n\t\tids: string[],\n\t\tcb: (p: MintQuoteResponse) => void,\n\t\terr: (e: Error) => void,\n\t\topts?: SubscribeOpts,\n\t): Promise<SubscriptionCanceller> {\n\t\tawait this.wallet.mint.connectWebSocket();\n\t\tconst ws = this.wallet.mint.webSocketConnection;\n\t\tif (!ws) throw new Error('Failed to establish WebSocket connection.');\n\n\t\tconst uniq = Array.from(new Set(ids));\n\t\tconst subId = ws.createSubscription({ kind: 'bolt11_mint_quote', filters: uniq }, cb, err);\n\t\tconst cancel = () => ws.cancelSubscription(subId, cb);\n\t\treturn this.withAbort(opts?.signal, cancel);\n\t}\n\n\t/**\n\t * Register a callback to be called when a single mint quote gets paid.\n\t *\n\t * @param quoteId Mint quote id that should be subscribed to.\n\t * @param callback Callback function that will be called when this mint quote gets paid.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync mintQuotePaid(\n\t\tid: string,\n\t\tcb: (p: MintQuoteResponse) => void,\n\t\terr: (e: Error) => void,\n\t\topts?: SubscribeOpts,\n\t): Promise<SubscriptionCanceller> {\n\t\treturn this.mintQuoteUpdates(\n\t\t\t[id],\n\t\t\t(p) => {\n\t\t\t\tif (p.state === MintQuoteState.PAID) cb(p);\n\t\t\t},\n\t\t\terr,\n\t\t\topts,\n\t\t);\n\t}\n\n\t/**\n\t * Register a callback to be called whenever a melt quote’s state changes.\n\t *\n\t * @param quoteId Melt quote id that should be subscribed to.\n\t * @param callback Callback function that will be called when this melt quote gets paid.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync meltQuoteUpdates(\n\t\tids: string[],\n\t\tcb: (p: MeltQuoteResponse) => void,\n\t\terr: (e: Error) => void,\n\t\topts?: SubscribeOpts,\n\t): Promise<SubscriptionCanceller> {\n\t\tawait this.wallet.mint.connectWebSocket();\n\t\tconst ws = this.wallet.mint.webSocketConnection;\n\t\tif (!ws) throw new Error('Failed to establish WebSocket connection.');\n\n\t\tconst uniq = Array.from(new Set(ids));\n\t\tconst subId = ws.createSubscription({ kind: 'bolt11_melt_quote', filters: uniq }, cb, err);\n\t\tconst cancel = () => ws.cancelSubscription(subId, cb);\n\t\treturn this.withAbort(opts?.signal, cancel);\n\t}\n\n\t/**\n\t * Register a callback to be called when a single melt quote gets paid.\n\t *\n\t * @param quoteIds List of melt quote IDs that should be subscribed to.\n\t * @param callback Callback function that will be called whenever a melt quote state changes.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync meltQuotePaid(\n\t\tid: string,\n\t\tcb: (p: MeltQuoteResponse) => void,\n\t\terr: (e: Error) => void,\n\t\topts?: SubscribeOpts,\n\t): Promise<SubscriptionCanceller> {\n\t\treturn this.meltQuoteUpdates(\n\t\t\t[id],\n\t\t\t(p) => {\n\t\t\t\tif (p.state === MeltQuoteState.PAID) cb(p);\n\t\t\t},\n\t\t\terr,\n\t\t\topts,\n\t\t);\n\t}\n\n\t/**\n\t * Register a callback to be called whenever a subscribed proof state changes.\n\t *\n\t * @param proofs List of proofs that should be subscribed to.\n\t * @param callback Callback function that will be called whenever a proof's state changes.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync proofStateUpdates(\n\t\tproofs: Proof[],\n\t\tcb: (payload: ProofState & { proof: Proof }) => void,\n\t\terr: (e: Error) => void,\n\t\topts?: SubscribeOpts,\n\t): Promise<SubscriptionCanceller> {\n\t\tawait this.wallet.mint.connectWebSocket();\n\t\tconst ws = this.wallet.mint.webSocketConnection;\n\t\tif (!ws) throw new Error('Failed to establish WebSocket connection.');\n\n\t\tconst enc = new TextEncoder();\n\t\tconst proofMap: Record<string, Proof> = {};\n\t\tfor (const p of proofs) {\n\t\t\tconst y = hashToCurve(enc.encode(p.secret)).toHex(true);\n\t\t\tproofMap[y] = p;\n\t\t}\n\t\tconst ys = Object.keys(proofMap);\n\n\t\tconst handler = (payload: ProofState) => {\n\t\t\tcb({ ...payload, proof: proofMap[payload.Y] });\n\t\t};\n\t\tconst subId = ws.createSubscription({ kind: 'proof_state', filters: ys }, handler, err);\n\t\tconst cancel = () => ws.cancelSubscription(subId, handler);\n\n\t\treturn this.withAbort(opts?.signal, cancel);\n\t}\n\n\t/**\n\t * Resolve once a mint quote transitions to PAID, with automatic unsubscription, optional abort\n\t * signal, and optional timeout.\n\t *\n\t * The underlying subscription is always cancelled after resolution or rejection, including on\n\t * timeout or abort.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const ac = new AbortController();\n\t * // Cancel if the user navigates away\n\t * window.addEventListener('beforeunload', () => ac.abort(), { once: true });\n\t *\n\t * try {\n\t * \tconst paid = await wallet.on.onceMintPaid(quoteId, {\n\t * \t\tsignal: ac.signal,\n\t * \t\ttimeoutMs: 60_000,\n\t * \t});\n\t * \tconsole.log('Mint paid, amount', paid.amount);\n\t * } catch (e) {\n\t * \tif ((e as Error).name === 'AbortError') {\n\t * \t\tconsole.log('User aborted');\n\t * \t} else {\n\t * \t\tconsole.error('Mint not paid', e);\n\t * \t}\n\t * }\n\t * ```\n\t *\n\t * @param id Mint quote id to watch.\n\t * @param opts Optional controls.\n\t * @param opts.signal AbortSignal to cancel the wait early.\n\t * @param opts.timeoutMs Milliseconds to wait before rejecting with a timeout error.\n\t * @returns A promise that resolves with the latest `MintQuoteResponse` once PAID.\n\t */\n\tonceMintPaid(\n\t\tid: string,\n\t\topts?: { signal?: AbortSignal; timeoutMs?: number },\n\t): Promise<MintQuoteResponse> {\n\t\treturn this.waitUntilPaid<MintQuoteResponse>(\n\t\t\tthis.mintQuotePaid.bind(this),\n\t\t\tid,\n\t\t\topts,\n\t\t\t'Timeout waiting for mint paid',\n\t\t);\n\t}\n\n\t/**\n\t * Resolve when ANY of several mint quotes is PAID, cancelling the rest.\n\t *\n\t * Subscribes to all distinct ids, resolves with `{ id, quote }` for the first PAID, and cancels\n\t * all remaining subscriptions.\n\t *\n\t * Errors from individual subscriptions are ignored by default so a single noisy stream does not\n\t * abort the whole race. Set `failOnError: true` to reject on the first error instead. If all\n\t * subscriptions error and none paid, the promise rejects with the last seen error.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Race multiple quotes obtained from splitting a large top up\n\t * const { id, quote } = await wallet.on.onceAnyMintPaid(batchQuoteIds, {\n\t * \ttimeoutMs: 120_000,\n\t * });\n\t * console.log('First top up paid', id, quote.preimage?.length);\n\t * ```\n\t *\n\t * @param ids Array of mint quote ids (duplicates are ignored).\n\t * @param opts Optional controls.\n\t * @param opts.signal AbortSignal to cancel the wait early.\n\t * @param opts.timeoutMs Milliseconds to wait before rejecting with a timeout error.\n\t * @param opts.failOnError When true, reject on first error. Default false.\n\t * @returns A promise resolving to the id that won and its `MintQuoteResponse`.\n\t */\n\tonceAnyMintPaid(\n\t\tids: string[],\n\t\topts?: { signal?: AbortSignal; timeoutMs?: number; failOnError?: boolean },\n\t): Promise<{ id: string; quote: MintQuoteResponse }> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst unique = Array.from(new Set(ids));\n\t\t\tconst cancels: Map<string, CancellerLike> = new Map();\n\t\t\tlet to: ReturnType<typeof setTimeout> | null = null;\n\t\t\tlet lastError: unknown = null;\n\t\t\tlet fullyRegistered = false;\n\n\t\t\tconst cleanup = (err?: unknown) => {\n\t\t\t\tfor (const c of cancels.values()) cancelSafely(c);\n\t\t\t\tcancels.clear();\n\t\t\t\tif (to) {\n\t\t\t\t\tclearTimeout(to);\n\t\t\t\t\tto = null;\n\t\t\t\t}\n\t\t\t\tif (opts?.signal) opts.signal.removeEventListener('abort', onAbort);\n\t\t\t\tif (err) reject(normalizeError(err));\n\t\t\t};\n\n\t\t\tconst onAbort = () => cleanup(makeAbortError());\n\n\t\t\tif (opts?.signal) {\n\t\t\t\tif (opts.signal.aborted) return onAbort();\n\t\t\t\topts.signal.addEventListener('abort', onAbort, { once: true });\n\t\t\t}\n\t\t\tif (opts?.timeoutMs && opts.timeoutMs > 0) {\n\t\t\t\tto = setTimeout(\n\t\t\t\t\t() => cleanup(new Error('Timeout waiting for any mint paid')),\n\t\t\t\t\topts.timeoutMs,\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (unique.length === 0) return cleanup(new Error('No quote ids provided'));\n\n\t\t\tfor (const quoteId of unique) {\n\t\t\t\tconst c = this.mintQuotePaid(\n\t\t\t\t\tquoteId,\n\t\t\t\t\t(p) => {\n\t\t\t\t\t\tcleanup();\n\t\t\t\t\t\tresolve({ id: quoteId, quote: p });\n\t\t\t\t\t},\n\t\t\t\t\t(e) => {\n\t\t\t\t\t\tif (opts?.failOnError) {\n\t\t\t\t\t\t\tcleanup(e);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastError = e;\n\t\t\t\t\t\tconst thisCanceller = cancels.get(quoteId);\n\t\t\t\t\t\tif (thisCanceller) {\n\t\t\t\t\t\t\tcancelSafely(thisCanceller);\n\t\t\t\t\t\t\tcancels.delete(quoteId);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Only decide to fail once we've finished installing all subs\n\t\t\t\t\t\tif (fullyRegistered && cancels.size === 0) {\n\t\t\t\t\t\t\tcleanup(lastError ?? new Error('No subscriptions remaining'));\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t\tcancels.set(quoteId, c);\n\t\t\t}\n\t\t\tfullyRegistered = true;\n\t\t});\n\t}\n\n\t/**\n\t * Resolve once a melt quote transitions to PAID, with automatic unsubscription, optional abort\n\t * signal, and optional timeout.\n\t *\n\t * Mirrors onceMintPaid, but for melts.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * try {\n\t * \tconst paid = await wallet.on.onceMeltPaid(meltId, { timeoutMs: 45_000 });\n\t * \tconsole.log('Invoice paid by mint, paid msat', paid.paid ?? 0);\n\t * } catch (e) {\n\t * \tconsole.error('Payment did not complete in time', e);\n\t * }\n\t * ```\n\t *\n\t * @param id Melt quote id to watch.\n\t * @param opts Optional controls.\n\t * @param opts.signal AbortSignal to cancel the wait early.\n\t * @param opts.timeoutMs Milliseconds to wait before rejecting with a timeout error.\n\t * @returns A promise that resolves with the `MeltQuoteResponse` once PAID.\n\t */\n\tonceMeltPaid(\n\t\tid: string,\n\t\topts?: { signal?: AbortSignal; timeoutMs?: number },\n\t): Promise<MeltQuoteResponse> {\n\t\treturn this.waitUntilPaid<MeltQuoteResponse>(\n\t\t\tthis.meltQuotePaid.bind(this),\n\t\t\tid,\n\t\t\topts,\n\t\t\t'Timeout waiting for melt paid',\n\t\t);\n\t}\n\n\t/**\n\t * Async iterable that yields proof state updates for the provided proofs.\n\t *\n\t * Adds a bounded buffer option:\n\t *\n\t * - If `maxBuffer` is set and the queue is full when a new payload arrives, either drop the oldest\n\t *   queued payload (`drop: 'oldest'`, default) or the incoming payload (`drop: 'newest'`). In\n\t *   both cases `onDrop` is invoked with the dropped payload.\n\t *\n\t * The stream ends and cleans up on abort or on the wallet error callback. Errors from the wallet\n\t * are treated as a graceful end for this iterator.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const ac = new AbortController();\n\t * try {\n\t * \tfor await (const update of wallet.on.proofStatesStream(myProofs)) {\n\t * \t\tif (update.state === CheckStateEnum.SPENT) {\n\t * \t\t\tconsole.warn('Spent proof', update.proof.id);\n\t * \t\t}\n\t * \t}\n\t * } catch (e) {\n\t * \tif ((e as Error).name !== 'AbortError') {\n\t * \t\tconsole.error('Stream error', e);\n\t * \t}\n\t * }\n\t * ```\n\t *\n\t * @param proofs The proofs to subscribe to. Only `secret` is required.\n\t * @param opts Optional controls.\n\t * @param opts.signal AbortSignal that stops the stream when aborted.\n\t * @param opts.maxBuffer Maximum number of queued items before applying the drop strategy.\n\t * @param opts.drop Overflow strategy when `maxBuffer` is reached, 'oldest' | 'newest'. Default\n\t *   'oldest'.\n\t * @param opts.onDrop Callback invoked with the payload that was dropped.\n\t * @returns An async iterable of update payloads.\n\t */\n\tproofStatesStream<T = unknown>(\n\t\tproofs: Proof[],\n\t\topts?: {\n\t\t\tsignal?: AbortSignal;\n\t\t\tmaxBuffer?: number;\n\t\t\tdrop?: 'oldest' | 'newest';\n\t\t\tonDrop?: (payload: T) => void;\n\t\t},\n\t): AsyncIterable<T> {\n\t\treturn async function* (this: WalletEvents) {\n\t\t\tconst queue: T[] = [];\n\t\t\tlet done = false;\n\t\t\tlet notify: (() => void) | null = null;\n\n\t\t\tconst max = opts?.maxBuffer && opts.maxBuffer > 0 ? opts.maxBuffer : Infinity;\n\t\t\tconst dropMode: 'oldest' | 'newest' = opts?.drop ?? 'oldest';\n\n\t\t\tconst wake = () => {\n\t\t\t\tconst n = notify;\n\t\t\t\tnotify = null;\n\t\t\t\tif (n) n();\n\t\t\t};\n\n\t\t\tconst push = (payload: T) => {\n\t\t\t\tif (queue.length >= max) {\n\t\t\t\t\tif (dropMode === 'oldest') {\n\t\t\t\t\t\tconst dropped = queue.shift();\n\t\t\t\t\t\tif (dropped !== undefined) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\topts?.onDrop?.(dropped);\n\t\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t\t/* noop */\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqueue.push(payload);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\topts?.onDrop?.(payload);\n\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t/* noop */\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn; // drop newest\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push(payload);\n\t\t\t\t}\n\t\t\t\twake();\n\t\t\t};\n\n\t\t\tconst cancelP: Promise<SubscriptionCanceller> = this.proofStateUpdates(\n\t\t\t\tproofs,\n\t\t\t\t(payload: ProofState & { proof: Proof }) => {\n\t\t\t\t\t// Accept wallet payload type and expose as generic T to consumer\n\t\t\t\t\tpush(payload as unknown as T);\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\tdone = true;\n\t\t\t\t\twake();\n\t\t\t\t},\n\t\t\t\t{ signal: opts?.signal },\n\t\t\t);\n\n\t\t\tconst onAbort = () => {\n\t\t\t\tdone = true;\n\t\t\t\twake();\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\tif (opts?.signal) {\n\t\t\t\t\tif (opts.signal.aborted) onAbort();\n\t\t\t\t\telse opts.signal.addEventListener('abort', onAbort, { once: true });\n\t\t\t\t}\n\t\t\t\twhile (!done || queue.length) {\n\t\t\t\t\twhile (queue.length) yield queue.shift()!;\n\t\t\t\t\tif (done) break;\n\t\t\t\t\tawait new Promise<void>((resolve) => (notify = resolve));\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tcancelSafely(cancelP);\n\t\t\t\tif (opts?.signal) opts.signal.removeEventListener('abort', onAbort);\n\t\t\t}\n\t\t}.call(this);\n\t}\n\n\t/**\n\t * Create a composite canceller that can collect many subscriptions and dispose them all in one\n\t * call.\n\t *\n\t * Accepts both a `SubscriptionCanceller` and a `Promise<SubscriptionCanceller>`. When the\n\t * composite canceller is called, all collected cancellations are invoked. Errors from individual\n\t * cancellers are caught and ignored.\n\t *\n\t * The returned function also has an `.add()` method to register more cancellers, and a\n\t * `.cancelled` boolean property for debugging.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const cancelAll = wallet.on.group();\n\t * cancelAll.add(wallet.on.mintQuotes(ids, onUpdate, onErr));\n\t * cancelAll.add(asyncSubscribeElsewhere());\n\t *\n\t * // later\n\t * cancelAll(); // disposes everything\n\t * ```\n\t *\n\t * @returns Composite canceller function with `.add()` and `.cancelled` members.\n\t */\n\tgroup(): SubscriptionCanceller & {\n\t\tadd: (c: CancellerLike) => CancellerLike;\n\t\tcancelled: boolean;\n\t} {\n\t\tconst cancels: CancellerLike[] = [];\n\t\tlet cancelled = false;\n\n\t\tconst cancelAll = (() => {\n\t\t\tif (cancelled) return;\n\t\t\tcancelled = true;\n\t\t\twhile (cancels.length) cancelSafely(cancels.pop());\n\t\t}) as SubscriptionCanceller & {\n\t\t\tadd: (c: CancellerLike) => CancellerLike;\n\t\t\tcancelled: boolean;\n\t\t};\n\n\t\tcancelAll.add = (c: CancellerLike) => {\n\t\t\tif (cancelled) {\n\t\t\t\t// already cancelled, immediately dispose newly added subscription\n\t\t\t\tcancelSafely(c);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t\tcancels.push(c);\n\t\t\treturn c;\n\t\t};\n\n\t\tObject.defineProperty(cancelAll, 'cancelled', {\n\t\t\tget: () => cancelled,\n\t\t\tenumerable: true,\n\t\t});\n\n\t\treturn cancelAll;\n\t}\n}\n","import type { CounterSource } from './CounterSource';\n\n/**\n * Developer friendly view of the wallet's deterministic output counters.\n */\nexport class WalletCounters {\n\tconstructor(private readonly src: CounterSource) {}\n\t/**\n\t * Returns the \"next\" counter for a specified keyset.\n\t */\n\tasync peekNext(keysetId: string): Promise<number> {\n\t\tconst r = await this.src.reserve(keysetId, 0);\n\t\treturn r.start;\n\t}\n\n\t/**\n\t * Bumps the counter if it is behind `minNext` (no-op if ahead).\n\t */\n\tasync advanceToAtLeast(keysetId: string, minNext: number): Promise<void> {\n\t\t// Mandatory on CounterSource\n\t\tawait this.src.advanceToAtLeast(keysetId, minNext);\n\t}\n\n\t/**\n\t * Hard-sets the cursor (useful for tests or migrations).\n\t *\n\t * @throws If the CounterSource does not support setNext()\n\t */\n\tasync setNext(keysetId: string, next: number): Promise<void> {\n\t\t// Optional capability\n\t\tif (typeof this.src.setNext === 'function') {\n\t\t\tawait this.src.setNext(keysetId, next);\n\t\t\treturn;\n\t\t}\n\t\tthrow new Error('CounterSource does not support setNext()');\n\t}\n\t/**\n\t * Returns the current \"next\" per keyset (what will be reserved next).\n\t *\n\t * @throws If the CounterSource does not support snapshot()\n\t */\n\tasync snapshot(): Promise<Record<string, number>> {\n\t\t// Optional capability\n\t\tif (typeof this.src.snapshot === 'function') {\n\t\t\treturn await this.src.snapshot();\n\t\t}\n\t\tthrow new Error('CounterSource does not support snapshot()');\n\t}\n}\n","/**\n * Entries of CheckStateResponse with state of the proof.\n */\nexport type ProofState = {\n\tY: string;\n\tstate: CheckStateEnum;\n\twitness: string | null;\n};\n\n/**\n * Enum for the state of a proof.\n */\nexport const CheckStateEnum = {\n\tUNSPENT: 'UNSPENT',\n\tPENDING: 'PENDING',\n\tSPENT: 'SPENT',\n} as const;\nexport type CheckStateEnum = (typeof CheckStateEnum)[keyof typeof CheckStateEnum];\n","/**\n * Cashu Wallet Class.\n *\n * @remarks\n * This is the instantiation point for the Cashu-TS library.\n */\n\nimport {\n\ttype MeltBlanks,\n\ttype OutputType,\n\ttype OutputConfig,\n\ttype SendConfig,\n\ttype SendOfflineConfig,\n\ttype ReceiveConfig,\n\ttype MintProofsConfig,\n\ttype MeltProofsConfig,\n\ttype MeltPayload,\n\ttype MeltQuotePayload,\n\ttype MintPayload,\n\ttype MintQuotePayload,\n\ttype MPPOption,\n\ttype MeltQuoteOptions,\n\ttype SwapTransaction,\n\ttype Bolt12MintQuotePayload,\n\ttype SwapPayload,\n\ttype MeltProofsResponse,\n\ttype SendResponse,\n\ttype RestoreConfig,\n\ttype SecretsPolicy,\n} from './types';\nimport {\n\ttype CounterSource,\n\tEphemeralCounterSource,\n\ttype OperationCounters,\n\ttype CounterRange,\n} from './CounterSource';\n\nimport { signMintQuote, signP2PKProofs, hashToCurve } from '../crypto';\nimport { Mint } from '../mint';\nimport { MintInfo } from '../model/MintInfo';\nimport { KeyChain } from './KeyChain';\nimport { type Keyset } from './Keyset';\nimport { WalletOps } from './WalletOps';\nimport { WalletEvents } from './WalletEvents';\nimport { WalletCounters } from './WalletCounters';\nimport { selectProofsRGLI, type SelectProofs } from './SelectProofs';\nimport { type Logger, NULL_LOGGER, fail, failIf, failIfNullish, safeCallback } from '../logger';\n\n// shared primitives and options\nimport type { Proof } from '../model/types/proof';\nimport type { Token } from '../model/types/token';\nimport type { SerializedBlindedSignature } from '../model/types/blinded';\nimport { CheckStateEnum, type ProofState } from '../model/types/proof-state';\nimport type { MintKeys, MintKeyset } from '../model/types/keyset';\n\n// mint wire DTOs and enums\nimport type {\n\tGetInfoResponse,\n\tMintQuoteResponse,\n\tMeltQuoteResponse,\n\tPartialMintQuoteResponse,\n\tPartialMeltQuoteResponse,\n\tLockedMintQuoteResponse,\n\tBolt12MintQuoteResponse,\n\tBolt12MeltQuoteResponse,\n} from '../mint/types';\n\n// model helpers\nimport { OutputData, type OutputDataLike } from '../model/OutputData';\n\nimport {\n\tgetDecodedToken,\n\tgetKeepAmounts,\n\thasValidDleq,\n\tsplitAmount,\n\tsumProofs,\n\tsanitizeUrl,\n} from '../utils';\nimport { type AuthProvider } from '../auth/AuthProvider';\n\nconst PENDING_KEYSET_ID = '__PENDING__';\n\n/**\n * Class that represents a Cashu wallet.\n *\n * @remarks\n * This class should act as the entry point for this library. Can be instantiated with a mint\n * instance or mint url.\n * @example\n *\n * ```typescript\n * import { Wallet } from '@cashu/cashu-ts';\n * const wallet = new Wallet('http://localhost:3338', { unit: 'sat' });\n * await wallet.loadMint(); // Initialize mint info, keysets, and keys\n * // Wallet is now ready to use, eg:\n * const proofs = [...]; // your array of unspent proofs\n * const { keep, send } = await wallet.send(32, proofs);\n * ```\n */\nclass Wallet {\n\t/**\n\t * Mint instance - allows direct calls to the mint.\n\t */\n\tpublic readonly mint: Mint;\n\t/**\n\t * KeyChain instance - contains wallet keysets/keys.\n\t */\n\tpublic readonly keyChain: KeyChain;\n\t/**\n\t * Entry point for the builder.\n\t *\n\t * @example\n\t *\n\t *     const { keep, send } = await wallet.ops\n\t *     \t.send(5, proofs)\n\t *     \t.asDeterministic() // counter: 0 = auto\n\t *     \t.keepAsRandom()\n\t *     \t.includeFees(true)\n\t *     \t.run();\n\t *\n\t *     const proofs = await wallet.ops\n\t *     \t.receive(token)\n\t *     \t.asDeterministic()\n\t *     \t.keyset(wallet.keysetId)\n\t *     \t.run();\n\t */\n\tpublic readonly ops: WalletOps;\n\t/**\n\t * Convenience wrapper for events.\n\t */\n\tpublic readonly on: WalletEvents;\n\t/**\n\t * Developer-friendly counters API.\n\t */\n\tpublic readonly counters: WalletCounters;\n\tprivate _seed: Uint8Array | undefined = undefined;\n\tprivate _unit = 'sat';\n\tprivate _mintInfo: MintInfo | undefined = undefined;\n\tprivate _denominationTarget = 3;\n\tprivate _secretsPolicy: SecretsPolicy = 'auto';\n\tprivate _counterSource: CounterSource;\n\tprivate _boundKeysetId: string = PENDING_KEYSET_ID;\n\tprivate _selectProofs: SelectProofs;\n\tprivate _logger: Logger;\n\n\t/**\n\t * Create a wallet for a given mint and unit. Call `loadMint` before use.\n\t *\n\t * Binding, if `options.keysetId` is omitted, the wallet binds to the cheapest active keyset for\n\t * this unit during `loadMint`. The keychain only loads keysets for this unit.\n\t *\n\t * Caching, to preload, provide both `keysets` and `keys`, otherwise the cache is ignored.\n\t *\n\t * Deterministic secrets, pass `bip39seed` and optionally `secretsPolicy`. Deterministic outputs\n\t * reserve counters from `counterSource`, or an ephemeral in memory source if not supplied.\n\t * `initialCounter` applies only with a supplied `keysetId` and the ephemeral source.\n\t *\n\t * Splitting, `denominationTarget` guides proof splits, default is 3. Override coin selection with\n\t * `selectProofs` if needed. Logging defaults to a null logger.\n\t *\n\t * @param mint Mint instance or URL.\n\t * @param options Optional settings.\n\t * @param options.unit Wallet unit, default 'sat'.\n\t * @param options.keysetId Bind to this keyset id, else bind on `loadMint`.\n\t * @param options.bip39seed BIP39 seed for deterministic secrets.\n\t * @param options.secretsPolicy Secrets policy, default 'auto'.\n\t * @param options.counterSource Counter source for deterministic outputs. If provided, this takes\n\t *   precedence over counterInit. Use when you need persistence across processes or devices.\n\t * @param options.counterInit Seed values for the built-in EphemeralCounterSource. Ignored if\n\t *   counterSource is also provided.\n\t * @param options.keys Cached keys for this unit, only used when `keysets` is also provided.\n\t * @param options.keysets Cached keysets for this unit, only used when `keys` is also provided.\n\t * @param options.mintInfo Optional cached mint info.\n\t * @param options.denominationTarget Target proofs per denomination, default 3.\n\t * @param options.selectProofs Custom proof selection function.\n\t * @param options.logger Logger instance, default null logger.\n\t */\n\tconstructor(\n\t\tmint: Mint | string,\n\t\toptions?: {\n\t\t\tunit?: string;\n\t\t\tauthProvider?: AuthProvider;\n\t\t\tkeysetId?: string; // if omitted, wallet binds to cheapest in loadMint\n\t\t\tbip39seed?: Uint8Array;\n\t\t\tsecretsPolicy?: SecretsPolicy; // optional, auto\n\t\t\tcounterSource?: CounterSource; // optional, otherwise ephemeral\n\t\t\tcounterInit?: Record<string, number>; // optional, starting \"next\" per keyset\n\t\t\tkeys?: MintKeys[] | MintKeys;\n\t\t\tkeysets?: MintKeyset[];\n\t\t\tmintInfo?: GetInfoResponse;\n\t\t\tdenominationTarget?: number;\n\t\t\tselectProofs?: SelectProofs; // optional override\n\t\t\tlogger?: Logger;\n\t\t},\n\t) {\n\t\tthis.ops = new WalletOps(this);\n\t\tthis.on = new WalletEvents(this);\n\t\tthis._logger = options?.logger ?? NULL_LOGGER; // init early (seed can throw)\n\t\tthis._selectProofs = options?.selectProofs ?? selectProofsRGLI; // vital\n\t\tthis.mint =\n\t\t\ttypeof mint === 'string'\n\t\t\t\t? new Mint(mint, { authProvider: options?.authProvider, logger: this._logger })\n\t\t\t\t: mint;\n\t\tthis._unit = options?.unit ?? this._unit;\n\t\tthis._boundKeysetId = options?.keysetId ?? this._boundKeysetId;\n\t\tif (options?.bip39seed) {\n\t\t\tthis.failIf(\n\t\t\t\t!(options.bip39seed instanceof Uint8Array),\n\t\t\t\t'bip39seed must be a valid Uint8Array',\n\t\t\t\t{\n\t\t\t\t\tbip39seed: options.bip39seed,\n\t\t\t\t},\n\t\t\t);\n\t\t\tthis._seed = options.bip39seed;\n\t\t}\n\t\tthis._secretsPolicy = options?.secretsPolicy ?? this._secretsPolicy;\n\t\tif (options?.counterSource) {\n\t\t\tthis._counterSource = options.counterSource;\n\t\t} else {\n\t\t\tthis._counterSource = new EphemeralCounterSource(options?.counterInit);\n\t\t}\n\t\tthis.counters = new WalletCounters(this._counterSource);\n\t\tthis.keyChain = new KeyChain(this.mint, this._unit, options?.keysets, options?.keys);\n\t\tthis._mintInfo = options?.mintInfo ? new MintInfo(options.mintInfo) : this._mintInfo;\n\t\tthis._denominationTarget = options?.denominationTarget ?? this._denominationTarget;\n\t}\n\n\t// Convenience wrappers for \"log and throw\"\n\tprivate fail(message: string, context?: Record<string, unknown>): never {\n\t\treturn fail(message, this._logger, context);\n\t}\n\tprivate failIf(\n\t\tcondition: boolean,\n\t\tmessage: string,\n\t\tcontext?: Record<string, unknown>,\n\t): asserts condition is false {\n\t\treturn failIf(condition, message, this._logger, context);\n\t}\n\tprivate failIfNullish<T>(\n\t\tvalue: T,\n\t\tmessage: string,\n\t\tcontext?: Record<string, unknown>,\n\t): asserts value is Exclude<T, null | undefined> {\n\t\treturn failIfNullish(value, message, this._logger, context);\n\t}\n\tprivate safeCallback<T>(\n\t\tcb: ((p: T) => void) | undefined,\n\t\tpayload: T,\n\t\tcontext?: Record<string, unknown>,\n\t): void {\n\t\tsafeCallback(cb, payload, this._logger, context);\n\t}\n\n\t/**\n\t * Load mint information, keysets, and keys. Must be called before using other methods.\n\t *\n\t * @param forceRefresh If true, re-fetches data even if cached.\n\t * @throws If fetching mint info, keysets, or keys fails.\n\t */\n\tasync loadMint(forceRefresh?: boolean): Promise<void> {\n\t\tconst promises = [];\n\n\t\t// Load mint info\n\t\tif (!this._mintInfo || forceRefresh) {\n\t\t\tpromises.push(\n\t\t\t\tthis.mint.getInfo().then((info) => {\n\t\t\t\t\tthis._mintInfo = new MintInfo(info);\n\t\t\t\t\treturn null;\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\t// Load KeyChain\n\t\tpromises.push(this.keyChain.init(forceRefresh).then(() => null));\n\n\t\tawait Promise.all(promises);\n\t\tthis._logger.debug('KeyChain', { keychain: this.keyChain.getCache() });\n\n\t\tif (this._boundKeysetId === PENDING_KEYSET_ID) {\n\t\t\tthis._boundKeysetId = this.keyChain.getCheapestKeyset().id;\n\t\t} else {\n\t\t\t// Ensure the bound id is still present and keyed\n\t\t\tconst k = this.keyChain.getKeyset(this._boundKeysetId);\n\t\t\tthis.failIf(!k.hasKeys, 'Wallet keyset has no keys after refresh', { keyset: k.id });\n\t\t}\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Getters\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * Get the wallet's unit.\n\t *\n\t * @returns The unit (e.g., 'sat').\n\t */\n\tget unit(): string {\n\t\treturn this._unit;\n\t}\n\n\t/**\n\t * Get information about the mint.\n\t *\n\t * @remarks\n\t * Returns cached mint info. Call `loadMint` first to initialize the wallet.\n\t * @returns Mint info.\n\t * @throws If mint info is not initialized.\n\t */\n\tgetMintInfo(): MintInfo {\n\t\tthis.failIfNullish(this._mintInfo, 'Mint info not initialized; call loadMint first');\n\t\treturn this._mintInfo;\n\t}\n\n\t/**\n\t * The keyset ID bound to this wallet instance.\n\t */\n\tget keysetId(): string {\n\t\tthis.failIf(this._boundKeysetId === PENDING_KEYSET_ID, 'Wallet not initialised, call loadMint');\n\t\treturn this._boundKeysetId;\n\t}\n\n\t/**\n\t * Gets the requested keyset or the keyset bound to the wallet.\n\t *\n\t * @remarks\n\t * This method enforces wallet policies. If `id` is omitted, it returns the keyset bound to this\n\t * wallet, including validation that:\n\t *\n\t * - The keyset exists in the keychain,\n\t * - The unit matches the wallet's unit,\n\t * - Keys are loaded for that keyset.\n\t *\n\t * Contrast with `keyChain.getKeyset(id?)`, which, when called without an id, returns the cheapest\n\t * active keyset for the unit, ignoring the wallet binding.\n\t * @param id Optional keyset id to resolve. If omitted, the wallet's bound keyset is used.\n\t * @returns The resolved `Keyset`.\n\t * @throws If the keyset is not found, has no keys, or its unit differs from the wallet.\n\t */\n\tpublic getKeyset(id?: string): Keyset {\n\t\tconst keyset = this.keyChain.getKeyset(id ?? this.keysetId);\n\t\tthis.failIf(keyset.unit !== this._unit, 'Keyset unit does not match wallet unit', {\n\t\t\tkeyset: keyset.id,\n\t\t\tunit: keyset.unit,\n\t\t\twalletUnit: this._unit,\n\t\t});\n\t\tthis.failIf(!keyset.hasKeys, 'Keyset has no keys loaded', { keyset: keyset.id });\n\t\treturn keyset;\n\t}\n\n\tpublic get logger(): Logger {\n\t\treturn this._logger;\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Counters\n\t// -----------------------------------------------------------------\n\n\tprivate async reserveFor(keysetId: string, totalOutputs: number): Promise<CounterRange> {\n\t\tif (totalOutputs <= 0) return { start: 0, count: 0 };\n\t\treturn this._counterSource.reserve(keysetId, totalOutputs);\n\t}\n\n\tprivate countersNeeded(ot: OutputType): number {\n\t\tif (ot.type !== 'deterministic' || ot.counter !== 0) return 0;\n\t\treturn (ot.denominations ?? []).length;\n\t}\n\n\tprivate async addCountersToOutputTypes(\n\t\tkeysetId: string,\n\t\t...outputTypes: OutputType[]\n\t): Promise<{ outputTypes: OutputType[]; used?: OperationCounters }> {\n\t\tconst total = outputTypes.reduce((n, ot) => n + this.countersNeeded(ot), 0);\n\t\tif (total === 0) return { outputTypes };\n\n\t\tconst range = await this.reserveFor(keysetId, total);\n\t\tlet cursor = range.start;\n\n\t\tconst patched = outputTypes.map((ot): OutputType => {\n\t\t\tif (ot.type === 'deterministic' && ot.counter === 0) {\n\t\t\t\tconst need = (ot.denominations ?? []).length;\n\t\t\t\tif (need > 0) {\n\t\t\t\t\tconst patched: typeof ot = { ...ot, counter: cursor };\n\t\t\t\t\tcursor += need;\n\t\t\t\t\treturn patched;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ot;\n\t\t});\n\n\t\t// Fire event after successful reservation (wallet does not await handlers)\n\t\tconst used = {\n\t\t\tkeysetId,\n\t\t\tstart: range.start,\n\t\t\tcount: range.count,\n\t\t\tnext: range.start + range.count,\n\t\t} as OperationCounters;\n\t\tthis.on._emitCountersReserved(used);\n\t\treturn { outputTypes: patched, used };\n\t}\n\n\t/**\n\t * Bind this wallet to a specific keyset id.\n\t *\n\t * @remarks\n\t * This changes the default keyset used by all operations that do not explicitly pass a keysetId.\n\t * The method validates that the keyset exists in the keychain, matches the wallet unit, and has\n\t * keys loaded.\n\t *\n\t * Typical uses:\n\t *\n\t * 1. After loadMint, to pin the wallet to a particular active keyset.\n\t * 2. After a refresh, to rebind deliberately rather than falling back to cheapest.\n\t *\n\t * @param id The keyset identifier to bind to.\n\t * @throws If keyset not found, if it has no keys loaded, or if its unit is not the wallet unit.\n\t */\n\tpublic bindKeyset(id: string): void {\n\t\tconst ks = this.keyChain.getKeyset(id);\n\t\tthis.failIf(ks.unit !== this._unit, 'Keyset unit does not match wallet unit', {\n\t\t\tkeyset: ks.id,\n\t\t\tunit: ks.unit,\n\t\t\twalletUnit: this._unit,\n\t\t});\n\t\tthis.failIf(!ks.hasKeys, 'Keyset has no keys loaded', { keyset: ks.id });\n\t\tthis._boundKeysetId = ks.id;\n\t\tthis._logger.debug('Wallet bound to keyset', {\n\t\t\tkeysetId: ks.id,\n\t\t\tunit: ks.unit,\n\t\t\tfeePPK: ks.fee,\n\t\t});\n\t}\n\n\t/**\n\t * Creates a new Wallet bound to a different keyset, sharing the same CounterSource.\n\t *\n\t * Use this to operate on multiple keysets concurrently without mutating your original wallet.\n\t * Counters remain monotonic across instances because the same CounterSource is reused.\n\t *\n\t * Do NOT pass a fresh CounterSource for the same seed unless you know exactly why. Reusing\n\t * counters can recreate secrets that a mint will reject.\n\t *\n\t * @param id The keyset identifier to bind to.\n\t * @throws If keyset not found, if it has no keys loaded, or if its unit is not the wallet unit.\n\t */\n\tpublic withKeyset(id: string, opts?: { counterSource?: CounterSource }): Wallet {\n\t\treturn new Wallet(this.mint, {\n\t\t\tkeysetId: id,\n\t\t\tbip39seed: this._seed,\n\t\t\tsecretsPolicy: this._secretsPolicy,\n\t\t\tlogger: this._logger,\n\t\t\tcounterSource: opts?.counterSource ?? this._counterSource,\n\t\t\t...this.keyChain.getCache(),\n\t\t});\n\t}\n\n\t/**\n\t * Returns the default OutputType for this wallet, based on its configured secrets policy\n\t * (options?.secretsPolicy) and seed state.\n\t *\n\t * - If the secrets policy is 'random', returns { type: 'random' }.\n\t * - If the policy is 'deterministic', requires a seed and returns { type: 'deterministic', counter:\n\t *   0 }. Counter 0 is a flag meaning \"auto-increment from current state\".\n\t * - If no explicit policy is set, falls back to:\n\t *\n\t *   - Deterministic if a seed is present.\n\t *   - Random if no seed is present.\n\t *\n\t * @returns An OutputType object describing the default output strategy.\n\t * @throws Error if the policy is 'deterministic' but no seed has been set.\n\t */\n\tpublic defaultOutputType(): OutputType {\n\t\tif (this._secretsPolicy === 'random') return { type: 'random' };\n\t\tif (this._secretsPolicy === 'deterministic') {\n\t\t\tthis.failIfNullish(this._seed, 'Deterministic policy requires a seed');\n\t\t\treturn { type: 'deterministic', counter: 0 }; // 0 = auto flag\n\t\t}\n\t\treturn this._seed ? { type: 'deterministic', counter: 0 } : { type: 'random' };\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Output Creation\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * Configures output denominations with fee adjustments and optimization.\n\t *\n\t * @remarks\n\t * If 'custom' outputType, data outputs MUST sum to the amount. Other outputTypes may supply\n\t * denominations. If no denominations are passed in, they will be calculated based on proofsWeHave\n\t * or the default split. If partial denominations are passed in, the balance will be added using\n\t * default split. Additional denominations to cover fees will then be added if required.\n\t * @param amount The total amount for outputs.\n\t * @param keyset The mint keyset.\n\t * @param outputType The output configuration.\n\t * @param includeFees Whether to include swap fees in the output amount.\n\t * @param proofsWeHave Optional proofs for optimizing denomination splitting.\n\t * @returns OutputType with required denominations.\n\t */\n\tprivate configureOutputs(\n\t\tamount: number,\n\t\tkeyset: Keyset,\n\t\toutputType: OutputType,\n\t\tincludeFees: boolean = false,\n\t\tproofsWeHave: Proof[] = [],\n\t): OutputType {\n\t\tlet newAmount = amount;\n\n\t\t// Custom outputs don't have automatic optimizations or fee inclusion)\n\t\tif (outputType.type === 'custom') {\n\t\t\tthis.failIf(includeFees, 'The custom OutputType does not support automatic fee inclusion');\n\n\t\t\t// Validate sum early, as no denominations to fill\n\t\t\tconst customTotal = OutputData.sumOutputAmounts(outputType.data);\n\t\t\tthis.failIf(\n\t\t\t\tcustomTotal !== amount,\n\t\t\t\t`Custom output data total (${customTotal}) does not match amount (${amount})`,\n\t\t\t);\n\t\t\treturn outputType;\n\t\t}\n\n\t\t// Start with any denominations provided.\n\t\t// Note: These MAY be partial (\"give me a [16,8], anything for the rest\")\n\t\t// We will complete the denomination set before we are done.\n\t\tlet denominations = outputType.denominations ?? [];\n\n\t\t// If no denominations, but proofsWeHave was provided - optimize\n\t\t// to get around _denominationTarget proofs of each denomination.\n\t\tif (denominations.length === 0 && proofsWeHave.length > 0) {\n\t\t\tdenominations = getKeepAmounts(\n\t\t\t\tproofsWeHave,\n\t\t\t\tnewAmount,\n\t\t\t\tkeyset.keys,\n\t\t\t\tthis._denominationTarget,\n\t\t\t);\n\t\t}\n\n\t\t// Fill in any missing denominations with default split.\n\t\t// NOTE: If we have to fill, the result will be in ASC order.\n\t\t// Original order is only maintained for exact denomination sets.\n\t\tdenominations = splitAmount(newAmount, keyset.keys, denominations);\n\n\t\t// If includeFees, we create additional output amounts to cover the\n\t\t// fee the receiver will pay when they spend the proofs (ie sender pays fees)\n\t\tif (includeFees) {\n\t\t\tlet receiveFee = this.getFeesForKeyset(denominations.length, keyset.id);\n\t\t\tlet receiveFeeAmounts = splitAmount(receiveFee, keyset.keys);\n\t\t\twhile (\n\t\t\t\tthis.getFeesForKeyset(denominations.length + receiveFeeAmounts.length, keyset.id) >\n\t\t\t\treceiveFee\n\t\t\t) {\n\t\t\t\treceiveFee++;\n\t\t\t\treceiveFeeAmounts = splitAmount(receiveFee, keyset.keys);\n\t\t\t}\n\t\t\tnewAmount += receiveFee;\n\t\t\tdenominations = [...denominations, ...receiveFeeAmounts];\n\t\t}\n\t\treturn { ...outputType, denominations };\n\t}\n\n\t/**\n\t * Sum total implied by a prepared OutputType. Note: Empty denomination is valid (e.g: zero\n\t * change).\n\t */\n\tprivate preparedTotal(ot: OutputType): number {\n\t\tif (ot.type === 'custom') return OutputData.sumOutputAmounts(ot.data);\n\t\tconst denoms = ot.denominations ?? [];\n\t\treturn denoms.reduce((a, b) => a + b, 0);\n\t}\n\n\t/**\n\t * Generates blinded messages based on the specified output type.\n\t *\n\t * @param amount The total amount for outputs.\n\t * @param keyset The mint keys.\n\t * @param outputType The output configuration.\n\t * @returns Prepared output data.\n\t */\n\tprivate createOutputData(\n\t\tamount: number,\n\t\tkeyset: Keyset,\n\t\toutputType: OutputType,\n\t): OutputDataLike[] {\n\t\t// we can accept zero (for blanks) or positive values\n\t\tthis.failIf(amount < 0, 'Amount was negative', { amount });\n\t\tif (\n\t\t\t// 'custom' OutputType has no denominations. Every other OutputType does.\n\t\t\t// so let's sanity check those were filled properly (eg: configureOutputs)\n\t\t\t'custom' != outputType.type &&\n\t\t\toutputType.denominations &&\n\t\t\toutputType.denominations.length > 0\n\t\t) {\n\t\t\tconst splitSum = outputType.denominations.reduce((sum, a) => sum + a, 0);\n\t\t\tthis.failIf(splitSum !== amount, 'Denominations do not sum to the expected amount', {\n\t\t\t\tsplitSum,\n\t\t\t\texpected: amount,\n\t\t\t});\n\t\t}\n\t\tlet outputData: OutputDataLike[];\n\t\tswitch (outputType.type) {\n\t\t\tcase 'random':\n\t\t\t\toutputData = OutputData.createRandomData(amount, keyset, outputType.denominations);\n\t\t\t\tbreak;\n\t\t\tcase 'deterministic':\n\t\t\t\tthis.failIfNullish(\n\t\t\t\t\tthis._seed,\n\t\t\t\t\t'Deterministic outputs require a seed configured in the wallet',\n\t\t\t\t);\n\t\t\t\toutputData = OutputData.createDeterministicData(\n\t\t\t\t\tamount,\n\t\t\t\t\tthis._seed,\n\t\t\t\t\toutputType.counter,\n\t\t\t\t\tkeyset,\n\t\t\t\t\toutputType.denominations,\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'p2pk':\n\t\t\t\toutputData = OutputData.createP2PKData(\n\t\t\t\t\toutputType.options,\n\t\t\t\t\tamount,\n\t\t\t\t\tkeyset,\n\t\t\t\t\toutputType.denominations,\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'factory': {\n\t\t\t\tconst factorySplit = splitAmount(amount, keyset.keys, outputType.denominations);\n\t\t\t\toutputData = factorySplit.map((a) => outputType.factory(a, keyset));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'custom': {\n\t\t\t\toutputData = outputType.data;\n\t\t\t\tconst customTotal = OutputData.sumOutputAmounts(outputData);\n\t\t\t\tthis.failIf(\n\t\t\t\t\tcustomTotal !== amount,\n\t\t\t\t\t`Custom output data total (${customTotal}) does not match amount (${amount})`,\n\t\t\t\t);\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthis.fail('Invalid OutputType');\n\t\t\t}\n\t\t}\n\t\treturn outputData;\n\t}\n\n\t/**\n\t * Creates a swap transaction with sorted outputs for privacy. This prevents a mint working out\n\t * which proofs will be sent or kept.\n\t *\n\t * @param inputs Prepared input proofs.\n\t * @param keepOutputs Outputs to keep (change or receiver's proofs).\n\t * @param sendOutputs Outputs to send (optional, default empty for receive/mint).\n\t * @returns Swap transaction with payload and metadata for processing signatures.\n\t */\n\tprivate createSwapTransaction(\n\t\tinputs: Proof[],\n\t\tkeepOutputs: OutputDataLike[],\n\t\tsendOutputs: OutputDataLike[] = [],\n\t): SwapTransaction {\n\t\t// Prepare inputs for mint\n\t\tinputs = this._prepareInputsForMint(inputs);\n\n\t\t// Sort ASC by amount for privacy, but keep indices to return order afterwards\n\t\tconst mergedBlindingData = [...keepOutputs, ...sendOutputs];\n\t\tconst indices = mergedBlindingData\n\t\t\t.map((_, i) => i)\n\t\t\t.sort(\n\t\t\t\t(a, b) =>\n\t\t\t\t\tmergedBlindingData[a].blindedMessage.amount - mergedBlindingData[b].blindedMessage.amount,\n\t\t\t);\n\t\tconst keepVector: boolean[] = [\n\t\t\t...Array.from({ length: keepOutputs.length }, () => true),\n\t\t\t...Array.from({ length: sendOutputs.length }, () => false),\n\t\t];\n\t\tconst sortedOutputData: OutputDataLike[] = indices.map((i) => mergedBlindingData[i]);\n\t\tconst sortedKeepVector: boolean[] = indices.map((i) => keepVector[i]);\n\t\tconst outputs = sortedOutputData.map((d) => d.blindedMessage);\n\t\tthis._logger.debug('createSwapTransaction:', {\n\t\t\tindices,\n\t\t\tsortedKeepVector,\n\t\t\t// outputs, // <-- removed for security\n\t\t});\n\t\tconst payload: SwapPayload = {\n\t\t\tinputs,\n\t\t\toutputs,\n\t\t};\n\t\treturn {\n\t\t\tpayload,\n\t\t\toutputData: sortedOutputData,\n\t\t\tkeepVector: sortedKeepVector,\n\t\t\tsortedIndices: indices,\n\t\t};\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Send and Receive\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * Receive a token (swaps with mint for new proofs)\n\t *\n\t * @example\n\t *\n\t * ```typescript\n\t * const result = await wallet.receive(\n\t * \ttoken,\n\t * \t{ includeFees: true },\n\t * \t{ type: 'deterministic', counter: 0 },\n\t * );\n\t * ```\n\t *\n\t * @param token Token string or decoded token.\n\t * @param config Optional receive config.\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns Newly minted proofs.\n\t */\n\tasync receive(\n\t\ttoken: Token | string,\n\t\tconfig?: ReceiveConfig,\n\t\toutputType?: OutputType,\n\t): Promise<Proof[]> {\n\t\tconst { keysetId, privkey, requireDleq, proofsWeHave, onCountersReserved } = config || {};\n\t\toutputType = outputType ?? this.defaultOutputType(); // Fallback to policy\n\n\t\t// Decode and validate token\n\t\tconst decodedToken = typeof token === 'string' ? this.decodeToken(token) : token;\n\t\tconst tokenMintUrl = sanitizeUrl(decodedToken.mint);\n\t\tthis.failIf(tokenMintUrl !== this.mint.mintUrl, 'Token belongs to a different mint', {\n\t\t\ttoken: tokenMintUrl,\n\t\t\twallet: this.mint.mintUrl,\n\t\t});\n\t\tthis.failIf(decodedToken.unit !== this._unit, 'Token is not in wallet unit', {\n\t\t\ttoken: decodedToken.unit,\n\t\t\twallet: this._unit,\n\t\t});\n\n\t\t// Extract token proofs\n\t\tlet proofs: Proof[] = [];\n\t\t({ proofs } = decodedToken);\n\t\tconst totalAmount = sumProofs(proofs);\n\t\tif (totalAmount === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// Sign proofs if needed\n\t\tif (privkey) {\n\t\t\tproofs = this.signP2PKProofs(proofs, privkey);\n\t\t}\n\n\t\t// Check DLEQs if needed\n\t\tconst keyset = this.getKeyset(keysetId); // specified or wallet keyset\n\t\tif (requireDleq) {\n\t\t\tfor (const p of proofs) {\n\t\t\t\tconst ks = this.keyChain.getKeyset(p.id);\n\t\t\t\tif (!hasValidDleq(p, ks)) {\n\t\t\t\t\tthis.fail('Token contains proofs with invalid or missing DLEQ');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Shape receive output type and denominations\n\t\tconst netAmount = totalAmount - this.getFeesForProofs(proofs);\n\t\tlet receiveOT = this.configureOutputs(\n\t\t\tnetAmount,\n\t\t\tkeyset,\n\t\t\toutputType,\n\t\t\tfalse, // includeFees is not applicable for receive\n\t\t\tproofsWeHave,\n\t\t);\n\n\t\t// Assign counter atomically if OutputType is deterministic\n\t\t// and the counter is zero (auto-assign)\n\t\tconst autoCounters = await this.addCountersToOutputTypes(keyset.id, receiveOT);\n\t\t[receiveOT] = autoCounters.outputTypes;\n\t\tif (autoCounters.used) {\n\t\t\tthis.safeCallback(onCountersReserved, autoCounters.used, { op: 'receive' });\n\t\t}\n\t\tthis._logger.debug('receive counter', { counter: autoCounters.used, receiveOT });\n\n\t\t// Create outputs and execute swap\n\t\tconst outputs = this.createOutputData(this.preparedTotal(receiveOT), keyset, receiveOT);\n\t\tconst swapTransaction = this.createSwapTransaction(proofs, outputs, []);\n\t\tconst { signatures } = await this.mint.swap(swapTransaction.payload);\n\n\t\t// Construct and return proofs\n\t\tconst proofsReceived = swapTransaction.outputData.map((d, i) =>\n\t\t\td.toProof(signatures[i], keyset),\n\t\t);\n\t\tconst orderedProofs: Proof[] = [];\n\t\tswapTransaction.sortedIndices.forEach((s, o) => {\n\t\t\torderedProofs[s] = proofsReceived[o];\n\t\t});\n\t\tthis._logger.debug('RECEIVE COMPLETED', { amounts: orderedProofs.map((p) => p.amount) });\n\t\treturn orderedProofs;\n\t}\n\n\t/**\n\t * Sends proofs of a given amount from provided proofs.\n\t *\n\t * @remarks\n\t * If proofs are P2PK-locked to your public key, call signP2PKProofs first to sign them. The\n\t * default config uses exact match selection, and does not includeFees or requireDleq. Because the\n\t * send is offline, the user will unlock the signed proofs when they receive them online.\n\t * @param amount Amount to send.\n\t * @param proofs Array of proofs (must sum >= amount; pre-sign if P2PK-locked).\n\t * @param config Optional parameters for the send.\n\t * @returns SendResponse with keep/send proofs.\n\t * @throws Throws if the send cannot be completed offline.\n\t */\n\tsendOffline(amount: number, proofs: Proof[], config?: SendOfflineConfig): SendResponse {\n\t\tconst { requireDleq = false, includeFees = false, exactMatch = true } = config || {};\n\t\tif (requireDleq) {\n\t\t\t// Only use proofs that have a DLEQ\n\t\t\tproofs = proofs.filter((p: Proof) => p.dleq != undefined);\n\t\t}\n\t\tthis.failIf(sumProofs(proofs) < amount, 'Not enough funds available to send');\n\n\t\tconst { keep, send } = this.selectProofsToSend(proofs, amount, includeFees, exactMatch);\n\t\t// Ensure witnesses are serialized, strip DLEQ if not required\n\t\tconst sendPrepared = this._prepareInputsForMint(send, requireDleq);\n\t\treturn { keep, send: sendPrepared };\n\t}\n\n\t/**\n\t * Send proofs with online swap if necessary.\n\t *\n\t * @remarks\n\t * If proofs are P2PK-locked to your public key, call signP2PKProofs first to sign them.\n\t * @example\n\t *\n\t * ```typescript\n\t * // Simple send\n\t * const result = await wallet.send(5, proofs);\n\t *\n\t * // With a SendConfig\n\t * const result = await wallet.send(5, proofs, { includeFees: true });\n\t *\n\t * // With Custom output configuration\n\t * const customConfig: OutputConfig = {\n\t * \tsend: { type: 'p2pk', options: { pubkey: '...' } },\n\t * \tkeep: { type: 'deterministic', counter: 0 },\n\t * };\n\t * const customResult = await wallet.send(5, proofs, { includeFees: true }, customConfig);\n\t * ```\n\t *\n\t * @param amount Amount to send (receiver gets this net amount).\n\t * @param proofs Array of proofs to split.\n\t * @param config Optional parameters for the swap.\n\t * @returns SendResponse with keep/send proofs.\n\t * @throws Throws if the send cannot be completed offline or if funds are insufficient.\n\t */\n\tasync send(\n\t\tamount: number,\n\t\tproofs: Proof[],\n\t\tconfig?: SendConfig,\n\t\toutputConfig?: OutputConfig,\n\t): Promise<SendResponse> {\n\t\tconst { keysetId, includeFees = false, onCountersReserved } = config || {};\n\t\t// Fallback to policy defaults if no outputConfig\n\t\toutputConfig = outputConfig ?? {\n\t\t\tsend: this.defaultOutputType(),\n\t\t\tkeep: this.defaultOutputType(),\n\t\t};\n\n\t\t// First, let's see if we can avoid a swap (and fees)\n\t\t// by trying an exact match offline selection, including fees if\n\t\t// we are giving the receiver the amount + their fee to receive\n\t\t// In Wallet.ts, near send()\n\n\t\ttry {\n\t\t\t// Offline exact-match only allowed for plain-random defaults; deterministic implies swap.\n\t\t\tconst wantsDeterministicByPolicy = this.defaultOutputType().type === 'deterministic';\n\t\t\tconst isPlainRandom = (ot?: OutputType) =>\n\t\t\t\t!ot || (ot.type === 'random' && (!ot.denominations || ot.denominations.length === 0));\n\n\t\t\tif (\n\t\t\t\tkeysetId ||\n\t\t\t\twantsDeterministicByPolicy ||\n\t\t\t\t!isPlainRandom(outputConfig.send) ||\n\t\t\t\t(outputConfig.keep && !isPlainRandom(outputConfig.keep))\n\t\t\t) {\n\t\t\t\t// Explain why we must fall back to swap\n\t\t\t\tconst reasons: string[] = [];\n\t\t\t\tif (keysetId) reasons.push('keysetId override');\n\t\t\t\tif (wantsDeterministicByPolicy) reasons.push('wallet default is deterministic');\n\t\t\t\tif (!isPlainRandom(outputConfig.send)) reasons.push('non-default send output type');\n\t\t\t\tif (outputConfig.keep && !isPlainRandom(outputConfig.keep))\n\t\t\t\t\treasons.push('non-default keep output type');\n\n\t\t\t\tthrow new Error(`Options require a swap: ${reasons.join(', ')}`);\n\t\t\t}\n\n\t\t\t// Proceed with offline exact-match attempt\n\t\t\tconst { keep, send } = this.sendOffline(amount, proofs, {\n\t\t\t\tincludeFees,\n\t\t\t\texactMatch: true,\n\t\t\t\trequireDleq: false, // safety\n\t\t\t});\n\t\t\tconst expectedFee = includeFees ? this.getFeesForProofs(send) : 0;\n\n\t\t\tif (sumProofs(send) === amount + expectedFee) {\n\t\t\t\tthis._logger.info('Successful exactMatch offline selection!');\n\t\t\t\treturn { keep, send };\n\t\t\t}\n\t\t} catch (e: unknown) {\n\t\t\tconst message = e instanceof Error ? e.message : 'Unknown error';\n\t\t\tthis._logger.debug('ExactMatch offline selection failed.', { e: message });\n\t\t}\n\n\t\t// Fetch keys\n\t\tconst keyset = this.getKeyset(keysetId); // specified or wallet keyset\n\n\t\t// Shape SEND output type and denominations\n\t\tlet sendOT = this.configureOutputs(\n\t\t\tamount,\n\t\t\tkeyset,\n\t\t\toutputConfig.send ?? this.defaultOutputType(),\n\t\t\tincludeFees,\n\t\t);\n\t\tconst sendAmount = this.preparedTotal(sendOT);\n\n\t\t// Select the subset of proofs needed to cover the swap (sendTarget + swap fee)\n\t\tconst { keep: unselectedProofs, send: selectedProofs } = this.selectProofsToSend(\n\t\t\tproofs,\n\t\t\tsendAmount,\n\t\t\ttrue, // Include fees to cover swap fee\n\t\t);\n\t\t// this._logger.debug('PROOFS SELECTED', {\n\t\t// \tunselectedProofs: unselectedProofs.map(p=>p.amount),\n\t\t// \tselectedProofs: selectedProofs.map(p=>p.amount),\n\t\t// });\n\t\tif (selectedProofs.length === 0) {\n\t\t\tthrow new Error('Not enough funds available to send');\n\t\t}\n\n\t\t// Calculate our expected change from the swap (and sanity check!)\n\t\tconst selectedSum = sumProofs(selectedProofs);\n\t\tconst swapFee = this.getFeesForProofs(selectedProofs);\n\t\tconst changeAmount = selectedSum - swapFee - sendAmount;\n\t\tthis.failIf(changeAmount < 0, 'Not enough funds available for swap', {\n\t\t\tselectedSum,\n\t\t\tswapFee,\n\t\t\tsendAmount,\n\t\t\tchangeAmount,\n\t\t});\n\n\t\t// Shape KEEP (change) output type and denominations\n\t\t// No includeFees, as we are the receiver of the change\n\t\tlet keepOT = this.configureOutputs(\n\t\t\tchangeAmount,\n\t\t\tkeyset,\n\t\t\toutputConfig.keep ?? this.defaultOutputType(),\n\t\t\tfalse,\n\t\t\tconfig?.proofsWeHave,\n\t\t);\n\t\tconst keepAmount = this.preparedTotal(keepOT);\n\n\t\t// Assign counters atomically if either/both OutputTypes are deterministic\n\t\t// and the counter is zero (auto-assign)\n\t\tconst autoCounters = await this.addCountersToOutputTypes(keyset.id, sendOT, keepOT);\n\t\t[sendOT, keepOT] = autoCounters.outputTypes;\n\t\tif (autoCounters.used) {\n\t\t\tthis.safeCallback(onCountersReserved, autoCounters.used, { op: 'send' });\n\t\t}\n\t\tthis._logger.debug('send counters', { counter: autoCounters.used, sendOT, keepOT });\n\n\t\t// Create the output data\n\t\tconst sendOutputs = this.createOutputData(sendAmount, keyset, sendOT);\n\t\tconst keepOutputs = this.createOutputData(keepAmount, keyset, keepOT);\n\n\t\t// Execute swap\n\t\tconst swapTransaction = this.createSwapTransaction(selectedProofs, keepOutputs, sendOutputs);\n\t\tconst { signatures } = await this.mint.swap(swapTransaction.payload);\n\n\t\t// Construct proofs\n\t\tconst swapProofs = swapTransaction.outputData.map((d, i) => d.toProof(signatures[i], keyset));\n\t\tconst reorderedProofs = Array(swapProofs.length);\n\t\tconst reorderedKeepVector = Array(swapTransaction.keepVector.length);\n\t\tswapTransaction.sortedIndices.forEach((s, i) => {\n\t\t\treorderedKeepVector[s] = swapTransaction.keepVector[i];\n\t\t\treorderedProofs[s] = swapProofs[i];\n\t\t});\n\t\tconst keepProofs: Proof[] = [];\n\t\tconst sendProofs: Proof[] = [];\n\t\treorderedProofs.forEach((p: Proof, i) => {\n\t\t\tif (reorderedKeepVector[i]) {\n\t\t\t\tkeepProofs.push(p);\n\t\t\t} else {\n\t\t\t\tsendProofs.push(p);\n\t\t\t}\n\t\t});\n\t\tthis._logger.debug('SEND COMPLETED', {\n\t\t\tunselectedProofs: unselectedProofs.map((p) => p.amount),\n\t\t\tkeepProofs: keepProofs.map((p) => p.amount),\n\t\t\tsendProofs: sendProofs.map((p) => p.amount),\n\t\t});\n\t\treturn {\n\t\t\tkeep: [...keepProofs, ...unselectedProofs],\n\t\t\tsend: sendProofs,\n\t\t};\n\t}\n\t/**\n\t * Swap is an alias of send.\n\t */\n\tpublic readonly swap = this.send.bind(this);\n\n\t// -----------------------------------------------------------------\n\t// Section: Transaction Helpers\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * Selects proofs to send based on amount and fee inclusion.\n\t *\n\t * @remarks\n\t * Uses an adapted Randomized Greedy with Local Improvement (RGLI) algorithm, which has a time\n\t * complexity O(n log n) and space complexity O(n).\n\t * @param proofs Array of Proof objects available to select from.\n\t * @param amountToSend The target amount to send.\n\t * @param includeFees Optional boolean to include fees; Default: false.\n\t * @param exactMatch Optional boolean to require exact match; Default: false.\n\t * @returns SendResponse containing proofs to keep and proofs to send.\n\t * @throws Throws an error if an exact match cannot be found within MAX_TIMEMS.\n\t * @see https://crypto.ethz.ch/publications/files/Przyda02.pdf\n\t */\n\tselectProofsToSend(\n\t\tproofs: Proof[],\n\t\tamountToSend: number,\n\t\tincludeFees = false,\n\t\texactMatch = false,\n\t): SendResponse {\n\t\tconst { keep, send } = this._selectProofs(\n\t\t\tproofs,\n\t\t\tamountToSend,\n\t\t\tthis.keyChain,\n\t\t\tincludeFees,\n\t\t\texactMatch,\n\t\t);\n\t\treturn { keep, send };\n\t}\n\n\t/**\n\t * Prepares proofs for sending by signing P2PK-locked proofs.\n\t *\n\t * @remarks\n\t * Call this method before operations like send if the proofs are P2PK-locked and need unlocking.\n\t * This is a public wrapper for signing.\n\t * @param proofs The proofs to sign.\n\t * @param privkey The private key for signing.\n\t * @returns Signed proofs.\n\t */\n\tsignP2PKProofs(proofs: Proof[], privkey: string | string[]): Proof[] {\n\t\treturn signP2PKProofs(proofs, privkey);\n\t}\n\n\t/**\n\t * Calculates the fees based on inputs (proofs)\n\t *\n\t * @param proofs Input proofs to calculate fees for.\n\t * @returns Fee amount.\n\t * @throws Throws an error if the proofs keyset is unknown.\n\t */\n\tgetFeesForProofs(proofs: Proof[]): number {\n\t\tconst sumPPK = proofs.reduce((a, c) => a + this.getProofFeePPK(c), 0);\n\t\treturn Math.ceil(sumPPK / 1000);\n\t}\n\n\t/**\n\t * Returns the current fee PPK for a proof according to the cached keyset.\n\t *\n\t * @param proof {Proof} A single proof.\n\t * @returns FeePPK {number} The feePPK for the selected proof.\n\t * @throws Throws an error if the proofs keyset is unknown.\n\t */\n\tprivate getProofFeePPK(proof: Proof): number {\n\t\ttry {\n\t\t\t// We need the proof's keyset so use keyChain here\n\t\t\t// We must NOT fallback to wallet's keyset\n\t\t\treturn this.keyChain.getKeyset(proof.id).fee;\n\t\t} catch (e) {\n\t\t\tthis.fail(`Could not get fee. No keyset found for keyset id: ${proof.id}`, {\n\t\t\t\te,\n\t\t\t\tkeychain: this.keyChain.getKeysets(),\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Calculates the fees based on inputs for a given keyset.\n\t *\n\t * @param nInputs Number of inputs.\n\t * @param keysetId KeysetId used to lookup `input_fee_ppk`\n\t * @returns Fee amount.\n\t */\n\tgetFeesForKeyset(nInputs: number, keysetId: string): number {\n\t\ttry {\n\t\t\t// We must NOT fallback to wallet's keyset\n\t\t\tconst feePPK = this.keyChain.getKeyset(keysetId).fee;\n\t\t\treturn Math.floor(Math.max((nInputs * feePPK + 999) / 1000, 0));\n\t\t} catch (e) {\n\t\t\tthis.fail(`No keyset found with ID ${keysetId}`, { e });\n\t\t}\n\t}\n\n\t/**\n\t * Prepares inputs for a mint operation.\n\t *\n\t * @remarks\n\t * Internal method; strips DLEQ (NUT-12) and p2pk_e (NUT-26) for privacy and serializes witnesses.\n\t * Returns an array of new proof objects - does not mutate the originals.\n\t * @param proofs The proofs to prepare.\n\t * @param keepDleq Optional boolean to keep DLEQ (default: false, strips for privacy).\n\t * @returns Prepared proofs for mint payload.\n\t */\n\tprivate _prepareInputsForMint(proofs: Proof[], keepDleq: boolean = false): Proof[] {\n\t\treturn proofs.map((p) => {\n\t\t\tconst witness =\n\t\t\t\tp.witness && typeof p.witness !== 'string' ? JSON.stringify(p.witness) : p.witness;\n\t\t\tconst { dleq, p2pk_e, ...rest } = p; // isolate dleq and p2pk_e\n\t\t\tvoid p2pk_e; // intentionally unused (linter)\n\t\t\t// New proof object\n\t\t\treturn keepDleq && dleq ? { ...rest, dleq, witness } : { ...rest, witness };\n\t\t});\n\t}\n\n\t/**\n\t * Decodes a string token.\n\t *\n\t * @remarks\n\t * Rehydrates a token from the space-saving CBOR format, including mapping short keyset ids to\n\t * their full representation.\n\t * @param token The token in string format (cashuB...)\n\t * @returns Token object.\n\t */\n\tpublic decodeToken(token: string): Token {\n\t\tconst keysets = this.keyChain.getKeysets();\n\t\treturn getDecodedToken(token, keysets);\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Restore\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * Restores batches of deterministic proofs until no more signatures are returned from the mint.\n\t *\n\t * @param [gapLimit=300] The amount of empty counters that should be returned before restoring\n\t *   ends (defaults to 300). Default is `300`\n\t * @param [batchSize=100] The amount of proofs that should be restored at a time (defaults to\n\t *   100). Default is `100`\n\t * @param [counter=0] The counter that should be used as a starting point (defaults to 0). Default\n\t *   is `0`\n\t * @param [keysetId] Which keysetId to use for the restoration. If none is passed the instance's\n\t *   default one will be used.\n\t */\n\tasync batchRestore(\n\t\tgapLimit = 300,\n\t\tbatchSize = 100,\n\t\tcounter = 0,\n\t\tkeysetId?: string,\n\t): Promise<{ proofs: Proof[]; lastCounterWithSignature?: number }> {\n\t\tconst requiredEmptyBatches = Math.ceil(gapLimit / batchSize);\n\t\tconst restoredProofs: Proof[] = [];\n\n\t\tlet lastCounterWithSignature: undefined | number;\n\t\tlet emptyBatchesFound = 0;\n\n\t\twhile (emptyBatchesFound < requiredEmptyBatches) {\n\t\t\tconst restoreRes = await this.restore(counter, batchSize, { keysetId });\n\t\t\tif (restoreRes.proofs.length > 0) {\n\t\t\t\temptyBatchesFound = 0;\n\t\t\t\trestoredProofs.push(...restoreRes.proofs);\n\t\t\t\tlastCounterWithSignature = restoreRes.lastCounterWithSignature;\n\t\t\t} else {\n\t\t\t\temptyBatchesFound++;\n\t\t\t}\n\t\t\tcounter += batchSize;\n\t\t}\n\t\treturn { proofs: restoredProofs, lastCounterWithSignature };\n\t}\n\n\t/**\n\t * Regenerates.\n\t *\n\t * @param start Set starting point for count (first cycle for each keyset should usually be 0)\n\t * @param count Set number of blinded messages that should be generated.\n\t * @param options.keysetId Set a custom keysetId to restore from. @see `keyChain)`\n\t */\n\tasync restore(\n\t\tstart: number,\n\t\tcount: number,\n\t\tconfig?: RestoreConfig,\n\t): Promise<{ proofs: Proof[]; lastCounterWithSignature?: number }> {\n\t\tconst { keysetId } = config || {};\n\t\tconst keyset = this.getKeyset(keysetId); // specified or wallet keyset\n\t\tthis.failIfNullish(this._seed, 'Cashu Wallet must be initialized with a seed to use restore');\n\n\t\t// create deterministic blank outputs for unknown restore amounts\n\t\t// Note: zero amount + zero denomination passes splitAmount validation\n\t\tconst zeros = Array(count).fill(0);\n\t\tconst outputData = OutputData.createDeterministicData(0, this._seed, start, keyset, zeros);\n\n\t\tconst { outputs, signatures } = await this.mint.restore({\n\t\t\toutputs: outputData.map((d) => d.blindedMessage),\n\t\t});\n\n\t\tconst signatureMap: { [sig: string]: SerializedBlindedSignature } = {};\n\t\toutputs.forEach((o, i) => (signatureMap[o.B_] = signatures[i]));\n\n\t\tconst restoredProofs: Proof[] = [];\n\t\tlet lastCounterWithSignature: number | undefined;\n\n\t\tfor (let i = 0; i < outputData.length; i++) {\n\t\t\tconst matchingSig = signatureMap[outputData[i].blindedMessage.B_];\n\t\t\tif (matchingSig) {\n\t\t\t\tlastCounterWithSignature = start + i;\n\t\t\t\toutputData[i].blindedMessage.amount = matchingSig.amount;\n\t\t\t\trestoredProofs.push(outputData[i].toProof(matchingSig, keyset));\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tproofs: restoredProofs,\n\t\t\tlastCounterWithSignature,\n\t\t};\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Create Mint Quote\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * @deprecated Use createMintQuoteBolt11()\n\t */\n\tasync createMintQuote(amount: number, description?: string): Promise<MintQuoteResponse> {\n\t\treturn this.createMintQuoteBolt11(amount, description);\n\t}\n\n\t/**\n\t * Requests a mint quote from the mint. Response returns a Lightning payment request for the\n\t * requested given amount and unit.\n\t *\n\t * @param amount Amount requesting for mint.\n\t * @param description Optional description for the mint quote.\n\t * @param pubkey Optional public key to lock the quote to.\n\t * @returns The mint will return a mint quote with a Lightning invoice for minting tokens of the\n\t *   specified amount and unit.\n\t */\n\tasync createMintQuoteBolt11(amount: number, description?: string): Promise<MintQuoteResponse> {\n\t\t// Check if mint supports description for bolt11\n\t\tif (description) {\n\t\t\tconst mintInfo = this.getMintInfo();\n\t\t\tif (!mintInfo.supportsNut04Description('bolt11', this._unit)) {\n\t\t\t\tthis.fail('Mint does not support description for bolt11');\n\t\t\t}\n\t\t}\n\n\t\tconst mintQuotePayload: MintQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\tamount: amount,\n\t\t\tdescription: description,\n\t\t};\n\t\tconst res = await this.mint.createMintQuoteBolt11(mintQuotePayload);\n\t\treturn { ...res, amount: res.amount || amount, unit: res.unit || this._unit };\n\t}\n\n\t/**\n\t * Requests a mint quote from the mint that is locked to a public key.\n\t *\n\t * @param amount Amount requesting for mint.\n\t * @param pubkey Public key to lock the quote to.\n\t * @param description Optional description for the mint quote.\n\t * @returns The mint will return a mint quote with a Lightning invoice for minting tokens of the\n\t *   specified amount and unit. The quote will be locked to the specified `pubkey`.\n\t */\n\tasync createLockedMintQuote(\n\t\tamount: number,\n\t\tpubkey: string,\n\t\tdescription?: string,\n\t): Promise<LockedMintQuoteResponse> {\n\t\tconst { supported } = this.getMintInfo().isSupported(20);\n\t\tthis.failIf(!supported, 'Mint does not support NUT-20');\n\t\tconst mintQuotePayload: MintQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\tamount: amount,\n\t\t\tdescription: description,\n\t\t\tpubkey: pubkey,\n\t\t};\n\t\tconst res = await this.mint.createMintQuoteBolt11(mintQuotePayload);\n\t\tthis.failIf(typeof res.pubkey !== 'string', 'Mint returned unlocked mint quote');\n\t\tconst resPubkey = res.pubkey!;\n\t\treturn {\n\t\t\t...res,\n\t\t\tpubkey: resPubkey,\n\t\t\tamount: res.amount || amount,\n\t\t\tunit: res.unit || this._unit,\n\t\t};\n\t}\n\n\t/**\n\t * Requests a mint quote from the mint. Response returns a Lightning BOLT12 offer for the\n\t * requested given amount and unit.\n\t *\n\t * @param pubkey Public key to lock the quote to.\n\t * @param options.amount BOLT12 offer amount requesting for mint. If not specified, the offer will\n\t *   be amountless.\n\t * @param options.description Description for the mint quote.\n\t * @returns The mint will return a mint quote with a BOLT12 offer for minting tokens of the\n\t *   specified amount and unit.\n\t */\n\tasync createMintQuoteBolt12(\n\t\tpubkey: string,\n\t\toptions?: {\n\t\t\tamount?: number;\n\t\t\tdescription?: string;\n\t\t},\n\t): Promise<Bolt12MintQuoteResponse> {\n\t\t// Check if mint supports description for bolt12\n\t\tconst mintInfo = this.getMintInfo();\n\t\tif (options?.description && !mintInfo.supportsNut04Description('bolt12', this._unit)) {\n\t\t\tthis.fail('Mint does not support description for bolt12');\n\t\t}\n\n\t\tconst mintQuotePayload: Bolt12MintQuotePayload = {\n\t\t\tpubkey: pubkey,\n\t\t\tunit: this._unit,\n\t\t\tamount: options?.amount,\n\t\t\tdescription: options?.description,\n\t\t};\n\n\t\treturn this.mint.createMintQuoteBolt12(mintQuotePayload);\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Check Mint Quote\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * @deprecated Use checkMintQuoteBolt11()\n\t */\n\tasync checkMintQuote(\n\t\tquote: string | MintQuoteResponse,\n\t): Promise<MintQuoteResponse | PartialMintQuoteResponse> {\n\t\treturn this.checkMintQuoteBolt11(quote);\n\t}\n\n\t/**\n\t * Gets an existing mint quote from the mint.\n\t *\n\t * @param quote Quote ID.\n\t * @returns The mint will create and return a Lightning invoice for the specified amount.\n\t */\n\tasync checkMintQuoteBolt11(\n\t\tquote: string | MintQuoteResponse,\n\t): Promise<MintQuoteResponse | PartialMintQuoteResponse> {\n\t\tconst quoteId = typeof quote === 'string' ? quote : quote.quote;\n\t\tconst baseRes = await this.mint.checkMintQuoteBolt11(quoteId);\n\t\tif (typeof quote === 'string') {\n\t\t\treturn baseRes;\n\t\t}\n\t\treturn { ...baseRes, amount: baseRes.amount || quote.amount, unit: baseRes.unit || quote.unit };\n\t}\n\n\t/**\n\t * Gets an existing BOLT12 mint quote from the mint.\n\t *\n\t * @param quote Quote ID.\n\t * @returns The latest mint quote for the given quote ID.\n\t */\n\tasync checkMintQuoteBolt12(quote: string): Promise<Bolt12MintQuoteResponse> {\n\t\treturn this.mint.checkMintQuoteBolt12(quote);\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Mint Proofs\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * @deprecated Use mintProofsBolt11()\n\t */\n\tasync mintProofs(\n\t\tamount: number,\n\t\tquote: string | MintQuoteResponse,\n\t\tconfig?: MintProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<Proof[]> {\n\t\treturn this._mintProofs('bolt11', amount, quote, config, outputType);\n\t}\n\n\t/**\n\t * Mint proofs for a bolt11 quote.\n\t *\n\t * @param amount Amount to mint.\n\t * @param quote Mint quote ID or object (bolt11).\n\t * @param config Optional parameters (e.g. privkey for locked quotes).\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns Minted proofs.\n\t */\n\tasync mintProofsBolt11(\n\t\tamount: number,\n\t\tquote: string | MintQuoteResponse,\n\t\tconfig?: MintProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<Proof[]> {\n\t\treturn this._mintProofs('bolt11', amount, quote, config, outputType);\n\t}\n\n\t/**\n\t * Mints proofs for a bolt12 quote.\n\t *\n\t * @param amount Amount to mint.\n\t * @param quote Bolt12 mint quote.\n\t * @param privkey Private key to unlock the quote.\n\t * @param config Optional parameters (e.g. keysetId).\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns Minted proofs.\n\t */\n\tasync mintProofsBolt12(\n\t\tamount: number,\n\t\tquote: Bolt12MintQuoteResponse,\n\t\tprivkey: string,\n\t\tconfig?: { keysetId?: string },\n\t\toutputType?: OutputType,\n\t): Promise<Proof[]> {\n\t\treturn this._mintProofs('bolt12', amount, quote, { ...config, privkey }, outputType);\n\t}\n\n\t/**\n\t * Internal helper for minting proofs with bolt11 or bolt12.\n\t *\n\t * @remarks\n\t * Handles blinded messages, signatures, and proof construction. Use public methods like\n\t * mintProofs or helpers for API access.\n\t * @param method 'bolt11' or 'bolt12'.\n\t * @param amount Amount to mint (must be positive).\n\t * @param quote Quote ID or object.\n\t * @param config Optional (privkey, keysetId).\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns Minted proofs.\n\t * @throws If params are invalid or mint returns errors.\n\t */\n\tprivate async _mintProofs<T extends 'bolt11' | 'bolt12'>(\n\t\tmethod: T,\n\t\tamount: number,\n\t\tquote: string | (T extends 'bolt11' ? MintQuoteResponse : Bolt12MintQuoteResponse),\n\t\tconfig?: MintProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<Proof[]> {\n\t\toutputType = outputType ?? this.defaultOutputType(); // Fallback to policy\n\t\tconst { privkey, keysetId, proofsWeHave, onCountersReserved } = config ?? {};\n\t\tthis.failIf(amount <= 0, 'Invalid mint amount: must be positive', { amount });\n\n\t\t// Shape output type and denominations for our proofs\n\t\t// we are receiving, so no includeFees.\n\t\tconst keyset = this.getKeyset(keysetId); // specified or wallet keyset\n\t\tlet mintOT = this.configureOutputs(\n\t\t\tamount,\n\t\t\tkeyset,\n\t\t\toutputType,\n\t\t\tfalse, // no fees\n\t\t\tproofsWeHave,\n\t\t);\n\t\tconst mintAmount = this.preparedTotal(mintOT);\n\n\t\t// Assign counters atomically if OutputType is deterministic\n\t\t// and the counter is zero (auto-assign)\n\t\tconst autoCounters = await this.addCountersToOutputTypes(keyset.id, mintOT);\n\t\t[mintOT] = autoCounters.outputTypes;\n\t\tif (autoCounters.used) {\n\t\t\tthis.safeCallback(onCountersReserved, autoCounters.used, { op: 'mintProofs' });\n\t\t}\n\t\tthis._logger.debug('mint counter', { counter: autoCounters.used, mintOT });\n\n\t\t// Create outputs and mint payload\n\t\tconst outputs = this.createOutputData(mintAmount, keyset, mintOT);\n\t\tconst blindedMessages = outputs.map((d) => d.blindedMessage);\n\t\tconst mintPayload: MintPayload = {\n\t\t\toutputs: blindedMessages,\n\t\t\tquote: typeof quote === 'string' ? quote : quote.quote,\n\t\t};\n\n\t\t// Sign payload if the quote carries a public key\n\t\tif (typeof quote !== 'string' && quote.pubkey) {\n\t\t\tthis.failIf(!privkey, 'Can not sign locked quote without private key');\n\t\t\tconst mintQuoteSignature = signMintQuote(privkey!, quote.quote, blindedMessages);\n\t\t\tmintPayload.signature = mintQuoteSignature;\n\t\t}\n\t\t// Mint proofs\n\t\tlet signatures;\n\t\tif (method === 'bolt12') {\n\t\t\t({ signatures } = await this.mint.mintBolt12(mintPayload));\n\t\t} else {\n\t\t\t({ signatures } = await this.mint.mintBolt11(mintPayload));\n\t\t}\n\t\tthis.failIf(\n\t\t\tsignatures.length !== outputs.length,\n\t\t\t`Mint returned ${signatures.length} signatures, expected ${outputs.length}`,\n\t\t);\n\n\t\tthis._logger.debug('MINT COMPLETED', { amounts: outputs.map((o) => o.blindedMessage.amount) });\n\t\treturn outputs.map((d, i) => d.toProof(signatures[i], keyset));\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Create Melt Quote\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * @deprecated Use createMeltQuoteBolt11.\n\t */\n\tasync createMeltQuote(invoice: string): Promise<MeltQuoteResponse> {\n\t\treturn this.createMeltQuoteBolt11(invoice);\n\t}\n\n\t/**\n\t * Requests a melt quote from the mint. Response returns amount and fees for a given unit in order\n\t * to pay a Lightning invoice.\n\t *\n\t * @param invoice LN invoice that needs to get a fee estimate.\n\t * @returns The mint will create and return a melt quote for the invoice with an amount and fee\n\t *   reserve.\n\t */\n\tasync createMeltQuoteBolt11(invoice: string): Promise<MeltQuoteResponse> {\n\t\tconst meltQuotePayload: MeltQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\trequest: invoice,\n\t\t};\n\t\tconst meltQuote = await this.mint.createMeltQuoteBolt11(meltQuotePayload);\n\t\treturn {\n\t\t\t...meltQuote,\n\t\t\tunit: meltQuote.unit || this._unit,\n\t\t\trequest: meltQuote.request || invoice,\n\t\t};\n\t}\n\n\t/**\n\t * Requests a melt quote from the mint. Response returns amount and fees for a given unit in order\n\t * to pay a BOLT12 offer.\n\t *\n\t * @param offer BOLT12 offer that needs to get a fee estimate.\n\t * @param amountMsat Amount in millisatoshis for amount-less offers. If this is defined and the\n\t *   offer has an amount, they **MUST** be equal.\n\t * @returns The mint will create and return a melt quote for the offer with an amount and fee\n\t *   reserve.\n\t */\n\tasync createMeltQuoteBolt12(\n\t\toffer: string,\n\t\tamountMsat?: number,\n\t): Promise<Bolt12MeltQuoteResponse> {\n\t\treturn this.mint.createMeltQuoteBolt12({\n\t\t\tunit: this._unit,\n\t\t\trequest: offer,\n\t\t\toptions: amountMsat\n\t\t\t\t? {\n\t\t\t\t\t\tamountless: {\n\t\t\t\t\t\t\tamount_msat: amountMsat,\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t: undefined,\n\t\t});\n\t}\n\n\t/**\n\t * Requests a multi path melt quote from the mint.\n\t *\n\t * @remarks\n\t * Uses NUT-15 Partial multi-path payments for BOLT11.\n\t * @param invoice LN invoice that needs to get a fee estimate.\n\t * @param partialAmount The partial amount of the invoice's total to be paid by this instance.\n\t * @returns The mint will create and return a melt quote for the invoice with an amount and fee\n\t *   reserve.\n\t * @see https://github.com/cashubtc/nuts/blob/main/15.md\n\t */\n\tasync createMultiPathMeltQuote(\n\t\tinvoice: string,\n\t\tmillisatPartialAmount: number,\n\t): Promise<MeltQuoteResponse> {\n\t\tconst { supported, params } = this.getMintInfo().isSupported(15);\n\t\tthis.failIf(!supported, 'Mint does not support NUT-15');\n\t\tthis.failIf(\n\t\t\t!params?.some((p) => p.method === 'bolt11' && p.unit === this._unit),\n\t\t\t`Mint does not support MPP for bolt11 and ${this._unit}`,\n\t\t);\n\t\tconst mppOption: MPPOption = {\n\t\t\tamount: millisatPartialAmount,\n\t\t};\n\t\tconst meltOptions: MeltQuoteOptions = {\n\t\t\tmpp: mppOption,\n\t\t};\n\t\tconst meltQuotePayload: MeltQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\trequest: invoice,\n\t\t\toptions: meltOptions,\n\t\t};\n\t\tconst meltQuote = await this.mint.createMeltQuoteBolt11(meltQuotePayload);\n\t\treturn { ...meltQuote, request: invoice, unit: this._unit };\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Check Melt Quote\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * @deprecated Use checkMeltQuoteBolt11()\n\t */\n\tasync checkMeltQuote(\n\t\tquote: string | MeltQuoteResponse,\n\t): Promise<MeltQuoteResponse | PartialMeltQuoteResponse> {\n\t\treturn this.checkMeltQuoteBolt11(quote);\n\t}\n\n\t/**\n\t * Returns an existing bolt11 melt quote from the mint.\n\t *\n\t * @param quote ID of the melt quote.\n\t * @returns The mint will return an existing melt quote.\n\t */\n\tasync checkMeltQuoteBolt11(\n\t\tquote: string | MeltQuoteResponse,\n\t): Promise<MeltQuoteResponse | PartialMeltQuoteResponse> {\n\t\tconst quoteId = typeof quote === 'string' ? quote : quote.quote;\n\t\tconst meltQuote = await this.mint.checkMeltQuoteBolt11(quoteId);\n\t\tif (typeof quote === 'string') {\n\t\t\treturn meltQuote;\n\t\t}\n\t\treturn { ...meltQuote, request: quote.request, unit: quote.unit };\n\t}\n\n\t/**\n\t * Returns an existing bolt12 melt quote from the mint.\n\t *\n\t * @param quote ID of the melt quote.\n\t * @returns The mint will return an existing melt quote.\n\t */\n\tasync checkMeltQuoteBolt12(quote: string): Promise<Bolt12MeltQuoteResponse> {\n\t\treturn this.mint.checkMeltQuoteBolt12(quote);\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Melt Proofs\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * @deprecated Use meltProofsBolt11()\n\t */\n\tasync meltProofs(\n\t\tmeltQuote: MeltQuoteResponse,\n\t\tproofsToSend: Proof[],\n\t\tconfig?: MeltProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<MeltProofsResponse> {\n\t\treturn this._meltProofs('bolt11', meltQuote, proofsToSend, config, outputType);\n\t}\n\n\t/**\n\t * Melt proofs for a bolt11 melt quote.\n\t *\n\t * @remarks\n\t * ProofsToSend must be at least amount+fee_reserve from the melt quote. This function does not\n\t * perform coin selection!.\n\t * @param meltQuote ID of the melt quote.\n\t * @param proofsToSend Proofs to melt.\n\t * @param config Optional parameters.\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns MeltProofsResponse with quote and change proofs.\n\t */\n\tasync meltProofsBolt11(\n\t\tmeltQuote: MeltQuoteResponse,\n\t\tproofsToSend: Proof[],\n\t\tconfig?: MeltProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<MeltProofsResponse> {\n\t\treturn this._meltProofs('bolt11', meltQuote, proofsToSend, config, outputType);\n\t}\n\n\t/**\n\t * Melt proofs for a bolt12 melt quote, returns change proofs using specified outputType.\n\t *\n\t * @remarks\n\t * ProofsToSend must be at least amount+fee_reserve from the melt quote. This function does not\n\t * perform coin selection!.\n\t * @param meltQuote ID of the melt quote.\n\t * @param proofsToSend Proofs to melt.\n\t * @param config Optional parameters.\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns MeltProofsResponse with quote and change proofs.\n\t */\n\tasync meltProofsBolt12(\n\t\tmeltQuote: Bolt12MeltQuoteResponse,\n\t\tproofsToSend: Proof[],\n\t\tconfig?: MeltProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<MeltProofsResponse> {\n\t\treturn this._meltProofs('bolt12', meltQuote, proofsToSend, config, outputType);\n\t}\n\n\t/**\n\t * Melt proofs for a given melt quote created with the bolt11 or bolt12 method.\n\t *\n\t * @remarks\n\t * Creates NUT-08 blanks (1-sat) for Lightning fee return. Get these by setting a\n\t * config.onChangeOutputsCreated callback for async melting. @see completeMelt.\n\t * @param method Payment method of the quote.\n\t * @param meltQuote The bolt11 or bolt12 melt quote.\n\t * @param proofsToSend Proofs to melt.\n\t * @param config Optional (keysetId, onChangeOutputsCreated).\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns MeltProofsResponse.\n\t * @throws If params are invalid or mint returns errors.\n\t * @see https://github.com/cashubtc/nuts/blob/main/08.md.\n\t */\n\tprivate async _meltProofs<T extends 'bolt11' | 'bolt12'>(\n\t\tmethod: T,\n\t\tmeltQuote: T extends 'bolt11' ? MeltQuoteResponse : Bolt12MeltQuoteResponse,\n\t\tproofsToSend: Proof[],\n\t\tconfig?: MeltProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<MeltProofsResponse> {\n\t\toutputType = outputType ?? this.defaultOutputType(); // Fallback to policy\n\t\tconst { keysetId, onChangeOutputsCreated, onCountersReserved } = config || {};\n\t\tconst keyset = this.getKeyset(keysetId); // specified or wallet keyset\n\t\tconst sendAmount = sumProofs(proofsToSend);\n\n\t\t// feeReserve is the overage above the invoice/offer amount.\n\t\t// In the common case where selected proofs = amount + fee_reserve,\n\t\t// this equals the quote’s fee_reserve. If you overshoot more,\n\t\t// the extra also becomes NUT-08 lightning fee change.\n\t\tconst feeReserve = sendAmount - meltQuote.amount;\n\t\tlet outputData: OutputDataLike[] = [];\n\n\t\t// bolt11 does not allow partial payment, and although bolt12 could, mints\n\t\t// like CDK forbids it. So let's fail loudly up front...\n\t\tthis.failIf(feeReserve < 0, 'Not enough proofs to cover amount + fee reserve', {\n\t\t\tsendAmount,\n\t\t\tquoteAmount: meltQuote.amount,\n\t\t});\n\n\t\t// Create NUT-08 blanks for return of Lightning fee change\n\t\t// Note: zero amount + zero denomination passes splitAmount validation\n\t\tif (feeReserve > 0) {\n\t\t\tlet count = Math.ceil(Math.log2(feeReserve)) || 1;\n\t\t\tif (count < 0) count = 0; // Prevents: -Infinity\n\t\t\tconst denominations: number[] = count ? new Array<number>(count).fill(0) : [];\n\t\t\tthis._logger.debug('Creating NUT-08 blanks for fee reserve', {\n\t\t\t\tfeeReserve,\n\t\t\t\tdenominations,\n\t\t\t});\n\n\t\t\t// Build effective OutputType and merge denominations\n\t\t\tif (outputType.type === 'custom') {\n\t\t\t\tthis.fail('Custom OutputType not supported for melt change (must be 0-sat blanks)');\n\t\t\t}\n\t\t\tlet meltOT: OutputType = { ...outputType, denominations };\n\t\t\t// Assign counter atomically if OutputType is deterministic\n\t\t\t// and the counter is zero (auto-assign)\n\t\t\tconst autoCounters = await this.addCountersToOutputTypes(keyset.id, meltOT);\n\t\t\t[meltOT] = autoCounters.outputTypes;\n\t\t\tif (autoCounters.used) {\n\t\t\t\tthis.safeCallback(onCountersReserved, autoCounters.used, { op: 'meltProofs' });\n\t\t\t}\n\t\t\tthis._logger.debug('melt counter', { counter: autoCounters.used, meltOT });\n\n\t\t\t// Generate the blank outputs (no fees as we are receiving change)\n\t\t\t// Remember, zero amount + zero denomination passes splitAmount validation\n\t\t\toutputData = this.createOutputData(0, keyset, meltOT);\n\t\t}\n\n\t\t// Prepare proofs for mint\n\t\tproofsToSend = this._prepareInputsForMint(proofsToSend);\n\n\t\tconst meltPayload: MeltPayload = {\n\t\t\tquote: meltQuote.quote,\n\t\t\tinputs: proofsToSend,\n\t\t\toutputs: outputData.map((d) => d.blindedMessage),\n\t\t};\n\n\t\t// Fire event(s) after blanks creation\n\t\tif (outputData.length > 0) {\n\t\t\tconst blanks: MeltBlanks = {\n\t\t\t\tmethod,\n\t\t\t\tpayload: meltPayload,\n\t\t\t\toutputData,\n\t\t\t\tkeyset,\n\t\t\t\tquote: meltQuote,\n\t\t\t};\n\t\t\tthis.safeCallback(onChangeOutputsCreated, blanks, { op: 'meltProofs' });\n\t\t\tthis.on._emitMeltBlanksCreated(blanks); // global callback\n\t\t}\n\n\t\t// Proceed with melt, setting preferredAsync header if an onChangeOutputsCreated callback was used\n\t\tlet meltResponse;\n\t\tconst preferAsync: boolean = typeof onChangeOutputsCreated === 'function';\n\t\tif (method === 'bolt12') {\n\t\t\tmeltResponse = await this.mint.meltBolt12(meltPayload, { preferAsync });\n\t\t} else {\n\t\t\tmeltResponse = await this.mint.meltBolt11(meltPayload, { preferAsync });\n\t\t}\n\n\t\t// Sanity check mint didn't send too many signatures before mapping\n\t\t// Should not happen, except in case of a broken or malicious mint\n\t\tthis.failIf(\n\t\t\t(meltResponse.change?.length ?? 0) > outputData.length,\n\t\t\t`Mint returned ${meltResponse.change?.length ?? 0} signatures, but only ${outputData.length} blanks were provided`,\n\t\t);\n\n\t\t// Construct change if provided (empty if pending/not paid; shorter ok if less overfee)\n\t\tconst change = meltResponse.change?.map((s, i) => outputData[i].toProof(s, keyset)) ?? [];\n\t\tthis._logger.debug('MELT COMPLETED', { changeAmounts: change.map((p) => p.amount) });\n\t\treturn { quote: { ...meltResponse, unit: meltQuote.unit, request: meltQuote.request }, change };\n\t}\n\n\t/**\n\t * Completes a pending melt by re-calling the melt endpoint and constructing change proofs.\n\t *\n\t * @remarks\n\t * Use with blanks from onChangeOutputsCreated to retry pending melts. Works for Bolt11/Bolt12.\n\t * Returns change proofs if paid, else empty change.\n\t * @param blanks The blanks from onChangeOutputsCreated.\n\t * @returns Updated MeltProofsResponse.\n\t * @throws If melt fails or signatures don't match output count.\n\t */\n\tasync completeMelt<T extends MeltQuoteResponse>(\n\t\tblanks: MeltBlanks<T>,\n\t): Promise<MeltProofsResponse> {\n\t\tconst meltResponse =\n\t\t\tblanks.method === 'bolt12'\n\t\t\t\t? await this.mint.meltBolt12(blanks.payload)\n\t\t\t\t: await this.mint.meltBolt11(blanks.payload);\n\n\t\t// Check for too many signatures before mapping\n\t\tthis.failIf(\n\t\t\t(meltResponse.change?.length ?? 0) > blanks.outputData.length,\n\t\t\t`Mint returned ${meltResponse.change?.length ?? 0} signatures, but only ${blanks.outputData.length} blanks were provided`,\n\t\t);\n\n\t\t// Construct change (shorter ok)\n\t\tconst change =\n\t\t\tmeltResponse.change?.map((s, i) => blanks.outputData[i].toProof(s, blanks.keyset)) ?? [];\n\n\t\tthis._logger.debug('COMPLETE MELT', { changeAmounts: change.map((p) => p.amount) });\n\t\treturn {\n\t\t\tquote: { ...meltResponse, unit: blanks.quote.unit, request: blanks.quote.request },\n\t\t\tchange,\n\t\t};\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Proof States\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * Get an array of the states of proofs from the mint (as an array of CheckStateEnum's)\n\t *\n\t * @param proofs (only the `secret` field is required)\n\t * @returns NUT-07 state for each proof, in same order.\n\t */\n\tasync checkProofsStates(proofs: Array<Pick<Proof, 'secret'>>): Promise<ProofState[]> {\n\t\tconst enc = new TextEncoder();\n\t\tconst Ys = proofs.map((p: Pick<Proof, 'secret'>) =>\n\t\t\thashToCurve(enc.encode(p.secret)).toHex(true),\n\t\t);\n\t\t// TODO: Replace this with a value from the info endpoint of the mint eventually\n\t\tconst BATCH_SIZE = 100;\n\t\tconst states: ProofState[] = [];\n\t\tfor (let i = 0; i < Ys.length; i += BATCH_SIZE) {\n\t\t\tconst YsSlice = Ys.slice(i, i + BATCH_SIZE);\n\t\t\tconst { states: batchStates } = await this.mint.check({\n\t\t\t\tYs: YsSlice,\n\t\t\t});\n\t\t\tconst stateMap: { [y: string]: ProofState } = {};\n\t\t\tbatchStates.forEach((s) => {\n\t\t\t\tstateMap[s.Y] = s;\n\t\t\t});\n\t\t\tfor (let j = 0; j < YsSlice.length; j++) {\n\t\t\t\tconst state = stateMap[YsSlice[j]];\n\t\t\t\tthis.failIfNullish(state, 'Could not find state for proof with Y: ' + YsSlice[j]);\n\t\t\t\tstates.push(state);\n\t\t\t}\n\t\t}\n\t\treturn states;\n\t}\n\n\t/**\n\t * Groups proofs by their corresponding state, preserving order within each group.\n\t *\n\t * @param proofs (only the `secret` field is required)\n\t * @returns An object with arrays of proofs grouped by CheckStateEnum state.\n\t */\n\tasync groupProofsByState(\n\t\tproofs: Proof[],\n\t): Promise<{ unspent: Proof[]; pending: Proof[]; spent: Proof[] }> {\n\t\tconst states: ProofState[] = await this.checkProofsStates(proofs);\n\t\tconst result = {\n\t\t\tunspent: [] as Proof[],\n\t\t\tpending: [] as Proof[],\n\t\t\tspent: [] as Proof[],\n\t\t};\n\t\tfor (let i = 0; i < states.length; i++) {\n\t\t\tconst proof = proofs[i];\n\t\t\tswitch (states[i].state) {\n\t\t\t\tcase CheckStateEnum.UNSPENT:\n\t\t\t\t\tresult.unspent.push(proof);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CheckStateEnum.PENDING:\n\t\t\t\t\tresult.pending.push(proof);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CheckStateEnum.SPENT:\n\t\t\t\t\tresult.spent.push(proof);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n\nexport { Wallet };\n","import { type Proof } from '../../model/types/proof';\n\nexport type RawTransport = {\n\tt: PaymentRequestTransportType; // type\n\ta: string; // target\n\tg?: string[][]; // tags\n};\n\nexport type RawNUT10Option = {\n\tk: string; // kind\n\td: string; // data\n\tt: string[][]; // tags\n};\n\nexport type RawPaymentRequest = {\n\ti?: string; // id\n\ta?: number; // amount\n\tu?: string; // unit\n\ts?: boolean; // single use\n\tm?: string[]; // mints\n\td?: string; // description\n\tt?: RawTransport[]; // transports\n\tnut10?: RawNUT10Option;\n\tnut26?: boolean; // P2BK\n};\n\nexport type PaymentRequestTransport = {\n\ttype: PaymentRequestTransportType;\n\ttarget: string;\n\ttags?: string[][];\n};\n\nexport enum PaymentRequestTransportType {\n\tPOST = 'post',\n\tNOSTR = 'nostr',\n}\n\nexport type PaymentRequestPayload = {\n\tid?: string;\n\tmemo?: string;\n\tunit: string;\n\tmint: string;\n\tproofs: Proof[];\n};\n\n/**\n * Used to express a spending condition that proofs should be encumbered with.\n */\nexport type NUT10Option = {\n\t/**\n\t * The kind of spending condition.\n\t */\n\tkind: string;\n\t/**\n\t * Expresses the spending condition relative to the kind.\n\t */\n\tdata: string;\n\t/**\n\t * Tags associated with the spending condition for additional data.\n\t */\n\ttags: string[][];\n};\n","import type { AuthProvider } from './AuthProvider';\nimport request, { type RequestFn } from '../transport';\nimport { joinUrls, hasValidDleq, encodeJsonToBase64, Bytes } from '../utils';\nimport { MintInfo } from '../model/MintInfo';\nimport { OutputData } from '../model/OutputData';\nimport type { MintActiveKeys, MintAllKeysets, Proof } from '../model/types';\nimport { type GetInfoResponse, type BlindAuthMintResponse } from '../mint/types';\nimport { type Logger, NULL_LOGGER } from '../logger';\nimport { type OIDCAuth, type TokenResponse } from './OIDCAuth';\nimport { KeyChain, type Keyset } from '../wallet';\n\nexport type AuthManagerOptions = {\n\t/**\n\t * Hard limit to target when minting BATs in one request. If omitted, we'll read\n\t * `nuts['22'].bat_max_mint` from the mint \"/v1/info\" endpoint.\n\t */\n\tmaxPerMint?: number;\n\t/**\n\t * Desired BAT pool size. We’ll top-up to min(desiredPoolSize, bat_max_mint) on demand.\n\t */\n\tdesiredPoolSize?: number;\n\t/**\n\t * Custom request fn (e.g. for tests or host env).\n\t */\n\trequest?: RequestFn;\n\t/**\n\t * Logger.\n\t */\n\tlogger?: Logger;\n};\n\ntype StoredTokens = {\n\taccessToken?: string;\n\trefreshToken?: string;\n\t/**\n\t * Epoch timestamp (ms).\n\t */\n\texpiresAt?: number;\n};\n\n/**\n * AuthManager.\n *\n * - Owns CAT lifecycle (stores, optional refresh via attached OIDCAuth)\n * - Mints and serves BATs (NUT-22)\n * - Validates DLEQs for BATs per NUT-12.\n * - Supplies serialized BATs for 'Blind-auth' and CAT for 'Clear-auth'\n */\nexport class AuthManager implements AuthProvider {\n\tprivate readonly mintUrl: string;\n\tprivate readonly req: RequestFn;\n\tprivate readonly logger: Logger;\n\tprivate info?: MintInfo;\n\tprivate lockChain?: Promise<void>;\n\tprivate inflightRefresh?: Promise<void>;\n\tprivate static readonly MIN_VALID_SECS = 30;\n\n\t// Open ID Connect (OIDC)\n\tprivate oidc?: OIDCAuth;\n\tprivate tokens: StoredTokens = {};\n\n\t// Blind Auth Token (BAT) pool\n\tprivate pool: Proof[] = [];\n\tprivate desiredPoolSize = 10;\n\tprivate maxPerMint = 10;\n\n\t// Keychain for 'auth' unit\n\tprivate keychain?: KeyChain;\n\n\tconstructor(mintUrl: string, opts?: AuthManagerOptions) {\n\t\tthis.mintUrl = mintUrl;\n\t\tthis.req = opts?.request ?? request;\n\t\tthis.logger = opts?.logger ?? NULL_LOGGER;\n\t\tthis.desiredPoolSize = Math.max(1, opts?.desiredPoolSize ?? this.desiredPoolSize);\n\t\tthis.maxPerMint = Math.max(1, opts?.maxPerMint ?? this.maxPerMint);\n\t}\n\n\t// ------------------------------\n\t// Public API\n\t// ------------------------------\n\n\t/**\n\t * Attach an OIDCAuth instance so this manager can refresh CATs. Registers a listener to update\n\t * internal CAT/refresh state on new tokens.\n\t */\n\tattachOIDC(oidc: OIDCAuth): this {\n\t\tthis.oidc = oidc;\n\t\tthis.oidc.addTokenListener((t) => this.updateFromOIDC(t));\n\t\treturn this;\n\t}\n\n\tget poolSize(): number {\n\t\treturn this.pool.length;\n\t}\n\tget poolTarget(): number {\n\t\treturn this.desiredPoolSize;\n\t}\n\tget activeAuthKeysetId(): string | undefined {\n\t\ttry {\n\t\t\treturn this.keychain?.getCheapestKeyset().id;\n\t\t} catch {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\tget hasCAT(): boolean {\n\t\treturn !!this.tokens.accessToken;\n\t}\n\n\t// ------------------------------\n\t// AuthProvider (NUT-21, Clear-auth)\n\t// ------------------------------\n\n\tgetCAT(): string | undefined {\n\t\treturn this.tokens.accessToken;\n\t}\n\n\tsetCAT(cat: string | undefined): void {\n\t\tthis.tokens.accessToken = cat;\n\t\tif (!cat) {\n\t\t\tthis.tokens.refreshToken = undefined;\n\t\t\tthis.tokens.expiresAt = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Ensure a valid CAT is available (refresh if expiring soon). Returns a token safe to send right\n\t * now, or undefined if unobtainable.\n\t */\n\tasync ensureCAT(minValidSecs?: number): Promise<string | undefined> {\n\t\tif (this.validForAtLeast(minValidSecs)) {\n\t\t\treturn this.tokens.accessToken;\n\t\t}\n\n\t\tif (!this.oidc || !this.tokens.refreshToken) {\n\t\t\treturn this.tokens.accessToken; // nothing we can do\n\t\t}\n\n\t\t// One refresh at a time\n\t\tif (!this.inflightRefresh) {\n\t\t\tthis.inflightRefresh = (async () => {\n\t\t\t\ttry {\n\t\t\t\t\tconst tok = await this.oidc!.refresh(this.tokens.refreshToken!);\n\t\t\t\t\tthis.updateFromOIDC(tok);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tthis.logger.warn('AuthManager: CAT refresh failed', { err });\n\t\t\t\t} finally {\n\t\t\t\t\tthis.inflightRefresh = undefined;\n\t\t\t\t}\n\t\t\t})();\n\t\t}\n\t\tawait this.inflightRefresh;\n\t\treturn this.validForAtLeast(0) ? this.tokens.accessToken : undefined;\n\t}\n\n\t// Returns true if expiry date is >minValidSecs away\n\tprivate validForAtLeast(minValidSecs: number = AuthManager.MIN_VALID_SECS): boolean {\n\t\tconst { accessToken, expiresAt } = this.tokens;\n\t\tif (!accessToken) return false;\n\t\tif (!expiresAt) return true; // Unknown expiry, allow and rely on server to reject if invalid\n\t\treturn Date.now() + minValidSecs * 1000 < expiresAt;\n\t}\n\n\t// Updates access and refresh tokens in our store, using either the explicit expires_in key or falling back to the JWT expiry.\n\tprivate updateFromOIDC(t: TokenResponse): void {\n\t\tif (!t.access_token) return;\n\t\tconst nowMs = Date.now();\n\t\tthis.tokens.accessToken = t.access_token;\n\t\tif (t.refresh_token) this.tokens.refreshToken = t.refresh_token;\n\t\tif (typeof t.expires_in === 'number' && t.expires_in > 0) {\n\t\t\tthis.tokens.expiresAt = nowMs + t.expires_in * 1000; // Prefer expires_in\n\t\t} else {\n\t\t\t// Fall back to JWT exp, else undefined\n\t\t\tconst expSec = this.parseJwtExpSec(t.access_token);\n\t\t\tthis.tokens.expiresAt = expSec ? expSec * 1000 : undefined;\n\t\t}\n\t\tthis.logger.debug('AuthManager: OIDC tokens updated', { expiresAt: this.tokens.expiresAt });\n\t}\n\n\t// ------------------------------\n\t// AuthProvider (NUT-22, Blind-auth)\n\t// ------------------------------\n\n\t/**\n\t * Ensure there are enough BAT tokens (topping up if needed)\n\t *\n\t * @param minTokens Minimum tokens needed.\n\t */\n\tasync ensure(minTokens: number): Promise<void> {\n\t\tawait this.init();\n\t\tif (this.pool.length >= minTokens) return;\n\t\tconst toTarget = Math.max(this.desiredPoolSize, minTokens);\n\t\tconst batMax = this.getBatMaxMint();\n\t\tconst batch = Math.min(toTarget - this.pool.length, batMax);\n\t\tif (batch <= 0) return;\n\t\tawait this.topUp(batch);\n\t}\n\n\t/**\n\t * Gets a Blind Authentication Token (BAT)\n\t *\n\t * @param {method, path} to Call (not used in our implementation)\n\t * @returns The serialized BAT ready to insert into request header.\n\t */\n\tasync getBlindAuthToken({\n\t\tmethod,\n\t\tpath,\n\t}: {\n\t\tmethod: 'GET' | 'POST';\n\t\tpath: string;\n\t}): Promise<string> {\n\t\tif (this.info && !this.info.requiresBlindAuthToken(method, path)) {\n\t\t\tthis.logger.warn('Endpoint is not marked as protected by NUT-22; still issuing BAT', {\n\t\t\t\tmethod,\n\t\t\t\tpath,\n\t\t\t});\n\t\t}\n\n\t\treturn this.withLock(async () => {\n\t\t\tawait this.ensure(1);\n\t\t\tif (this.pool.length === 0) {\n\t\t\t\tthrow new Error('AuthManager: no BATs available and minting failed');\n\t\t\t}\n\t\t\t// Pop one BAT and serialize without DLEQ for the header. Per NUT-22, wallets\n\t\t\t// SHOULD delete BAT even on error, so no need to track it in-flight.\n\t\t\tconst proof = this.pool.pop()!;\n\t\t\tthis.logger.debug('AuthManager: BAT requested', {\n\t\t\t\tmethod,\n\t\t\t\tpath,\n\t\t\t\tremaining: this.pool.length,\n\t\t\t});\n\t\t\treturn serializeBAT(proof);\n\t\t});\n\t}\n\n\t/**\n\t * Replace or merge the current BAT pool with previously persisted BATs.\n\t */\n\timportPool(proofs: Proof[], mode: 'replace' | 'merge' = 'replace'): void {\n\t\tif (mode === 'replace') {\n\t\t\tthis.pool = [];\n\t\t}\n\t\tconst seen = new Map(this.pool.map((p) => [p.secret, p]));\n\t\tfor (const p of proofs) {\n\t\t\tif (!p || !p.secret || !p.C || !p.id) continue; // shape check\n\t\t\tif (!seen.has(p.secret)) {\n\t\t\t\tthis.pool.push(p);\n\t\t\t\tseen.set(p.secret, p);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Return a deep-copied snapshot of the current BAT pool (full Proofs, including dleq).\n\t */\n\texportPool(): Proof[] {\n\t\treturn this.pool.map((p) => ({ ...p, dleq: p.dleq ? { ...p.dleq } : undefined }));\n\t}\n\n\t// ------------------------------\n\t// Internals\n\t// ------------------------------\n\n\t/**\n\t * Extract exp, seconds since epoch, from a JWT access token.\n\t */\n\tprivate parseJwtExpSec(token?: string): number | undefined {\n\t\tif (!token) return;\n\t\tconst parts = token.split('.');\n\t\tif (parts.length !== 3) return;\n\t\ttry {\n\t\t\tconst jsonStr = Bytes.toString(Bytes.fromBase64(parts[1]));\n\t\t\tconst obj = JSON.parse(jsonStr) as { exp?: unknown };\n\t\t\tconst exp = typeof obj.exp === 'number' ? obj.exp : Number(obj.exp);\n\t\t\tif (Number.isFinite(exp) && exp > 0) return exp;\n\t\t} catch {\n\t\t\tthis.logger.warn('JWT access token was malformed.', {\n\t\t\t\ttoken,\n\t\t\t});\n\t\t}\n\t\treturn;\n\t}\n\n\t/**\n\t * Simple mutex lock - chains promises in order.\n\t */\n\tprivate async withLock<T>(fn: () => T | Promise<T>): Promise<T> {\n\t\tconst prev = this.lockChain ?? Promise.resolve();\n\t\tlet release!: () => void;\n\t\tconst lock = new Promise<void>((resolve) => {\n\t\t\trelease = resolve;\n\t\t});\n\t\tconst chain = prev.then(() => lock); // capture the exact Promise we assign\n\t\tthis.lockChain = chain;\n\t\ttry {\n\t\t\tawait prev;\n\t\t\treturn await fn();\n\t\t} finally {\n\t\t\trelease();\n\t\t\t// Only clear if no newer chain has been installed\n\t\t\tif (this.lockChain === chain) this.lockChain = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Initialise mint info and auth keysets/keys as needed.\n\t */\n\tprivate async init(): Promise<void> {\n\t\tif (!this.info) {\n\t\t\tconst info = await this.req<GetInfoResponse>({\n\t\t\t\tendpoint: joinUrls(this.mintUrl, '/v1/info'),\n\t\t\t\tmethod: 'GET',\n\t\t\t});\n\t\t\tthis.info = new MintInfo(info);\n\t\t}\n\t\tif (!this.keychain) {\n\t\t\t// fetch blind keysets and keys for unit 'auth'\n\t\t\tconst [allKeysets, allKeys] = await Promise.all([\n\t\t\t\tthis.req<MintAllKeysets>({\n\t\t\t\t\tendpoint: joinUrls(this.mintUrl, '/v1/auth/blind/keysets'),\n\t\t\t\t\tmethod: 'GET',\n\t\t\t\t}),\n\t\t\t\tthis.req<MintActiveKeys>({\n\t\t\t\t\tendpoint: joinUrls(this.mintUrl, '/v1/auth/blind/keys'),\n\t\t\t\t\tmethod: 'GET',\n\t\t\t\t}),\n\t\t\t]);\n\t\t\t// build a KeyChain preloaded with caches, unit 'auth'\n\t\t\t// Then smoke test to surface errors early - no need to init() with cached keys\n\t\t\tthis.keychain = new KeyChain(this.mintUrl, 'auth', allKeysets.keysets, allKeys.keysets);\n\t\t\tthis.keychain.getCheapestKeyset();\n\t\t}\n\t}\n\n\t/**\n\t * Gets the BAT minting limit: lower of manager limit and Mint’s NUT-22 limit.\n\t */\n\tprivate getBatMaxMint(): number {\n\t\tif (!this.info) throw new Error('AuthManager: mint info not loaded');\n\t\tconst n22 = this.info.nuts['22'];\n\t\tconst mintMax = n22?.bat_max_mint ?? this.maxPerMint;\n\t\treturn Math.max(1, Math.min(this.maxPerMint, mintMax));\n\t}\n\n\tprivate getActiveKeys(): Keyset {\n\t\tif (!this.keychain) throw new Error('AuthManager: keyset not loaded for active keyset');\n\t\treturn this.keychain.getCheapestKeyset();\n\t}\n\n\t/**\n\t * Mint a batch of BATs using the current CAT if the endpoint is protected by NUT-21.\n\t */\n\tprivate async topUp(n: number): Promise<void> {\n\t\tif (!this.info) throw new Error('AuthManager: mint info not loaded');\n\n\t\t// Check NUT-21 protection of the BAT mint endpoint\n\t\tconst needsCAT = this.info.requiresClearAuthToken('POST', '/v1/auth/blind/mint');\n\t\tlet cat: string | undefined;\n\t\tif (needsCAT) {\n\t\t\tcat = await this.ensureCAT();\n\t\t\tif (!cat) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'AuthManager: Clear-auth token required for /v1/auth/blind/mint but not available. Authenticate with the mint to obtain a CAT first.',\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\t// Create blinded messages for amount n in unit 'auth' (supports only 1s)\n\t\tconst keys = this.getActiveKeys();\n\t\tconst outputs = OutputData.createRandomData(n, keys);\n\t\tconst payload = { outputs: outputs.map((d) => d.blindedMessage) };\n\t\t// Set CAT header if needed\n\t\tconst headers: Record<string, string> = {};\n\t\tif (cat) headers['Clear-auth'] = cat;\n\t\t// Do the topup\n\t\tconst res = await this.req<BlindAuthMintResponse>({\n\t\t\tendpoint: joinUrls(this.mintUrl, '/v1/auth/blind/mint'),\n\t\t\tmethod: 'POST',\n\t\t\theaders,\n\t\t\trequestBody: payload as unknown as Record<string, unknown>,\n\t\t});\n\t\tif (!Array.isArray(res?.signatures) || res.signatures.length !== outputs.length) {\n\t\t\tthrow new Error('AuthManager: bad BAT mint response');\n\t\t}\n\t\t// Create BAT proofs and check DLEQ\n\t\tconst proofs = outputs.map((d, i) => d.toProof(res.signatures[i], keys));\n\t\tfor (const p of proofs) {\n\t\t\tif (!hasValidDleq(p, keys)) {\n\t\t\t\tthrow new Error('AuthManager: mint returned BAT with invalid DLEQ');\n\t\t\t}\n\t\t}\n\t\t// Add BAT proofs to pool\n\t\tthis.pool.push(...proofs);\n\t\tthis.logger.debug('AuthManager: performed topUp', {\n\t\t\tminted: proofs.length,\n\t\t\tpool: this.pool.length,\n\t\t});\n\t}\n}\n\n// ------------------------------\n// Helpers\n// ------------------------------\n\n/**\n * Serialize an Auth Proof as a BAT header value: \"authA\" + base64(JSON_without_dleq)\n */\nfunction serializeBAT(proof: Proof): string {\n\t// strip dleq per NUT-22\n\tconst token = { id: proof.id, secret: proof.secret, C: proof.C };\n\tconst base64Data = encodeJsonToBase64(token);\n\treturn `authA${base64Data}`;\n}\n","import { type Logger } from '../logger';\nimport { Mint } from '../mint/Mint';\nimport { Wallet } from '../wallet/Wallet';\nimport { AuthManager } from './AuthManager';\nimport type { OIDCAuth, OIDCAuthOptions } from './OIDCAuth';\n\n/**\n * High-level helper to create a fully authenticated wallet session.\n *\n * @remarks\n * Like a dependency injector, it wires AuthManager->Mint->OIDCAuth->Wallet in the correct order.\n * Wallet is returned ready to use.\n * @param mintUrl URL of the mint to connect to.\n * @param options.authPool Optional. Desired BAT pool size (default 10)\n * @param options.oidc Optional. Options for OIDCAuth (scope, clientId, logger, etc.)\n * @returns {mint, auth, oidc, wallet} — hydrated, ready to use.\n * @throws If mint does not require authentication.\n */\nexport async function createAuthWallet(\n\tmintUrl: string,\n\toptions?: {\n\t\tauthPool?: number;\n\t\toidc?: OIDCAuthOptions;\n\t\tlogger?: Logger;\n\t},\n): Promise<{ mint: Mint; auth: AuthManager; oidc: OIDCAuth; wallet: Wallet }> {\n\t// 1. Create an AuthManager for both BAT and CAT handling\n\tconst auth = new AuthManager(mintUrl, {\n\t\tdesiredPoolSize: options?.authPool ?? 10,\n\t\tlogger: options?.logger,\n\t});\n\n\t// 2. Create a Mint instance using the AuthManager\n\tconst mint = new Mint(mintUrl, { authProvider: auth, logger: options?.logger });\n\n\t// 3. Discover and configure OIDCAuth from the mint\n\tconst oidc = await mint.oidcAuth({\n\t\t...options?.oidc,\n\t\tlogger: options?.logger,\n\t\tonTokens: (t) => auth.setCAT(t.access_token), // set CAT automatically\n\t});\n\n\t// 4. Attach OIDCAuth back into AuthManager for refresh, etc.\n\tauth.attachOIDC(oidc);\n\n\t// 5. Hydrate wallet using the same mint and auth provider\n\tconst wallet = new Wallet(mint, { authProvider: auth, logger: options?.logger });\n\tawait wallet.loadMint();\n\n\treturn { mint, auth, oidc, wallet };\n}\n"],"names":["MeltQuoteState","MintQuoteState","HttpResponseError","message","status","NetworkError","MintOperationError","code","detail","NULL_LOGGER","fail","logger","context","failIf","condition","failIfNullish","value","safeCallback","cb","payload","maybePromise","error","LEVEL_ORDER","ConsoleLogger","minLevel","level","ctx","out","k","v","line","fn","msg","measureTime","start","globalRequestOptions","requestLogger","setGlobalRequestOptions","options","setRequestLogger","_request","endpoint","requestBody","requestHeaders","body","headers","response","err","errorData","errorMessage","request","_WS","injectWebSocketImpl","ws","getWebSocketImpl","Bytes","hex","matches","byte","bytes","str","arrays","totalLength","sum","arr","result","offset","size","buffer","i","chunk","base64","normalizedBase64","c","a","b","minLength","encodeUint8toBase64Url","encodeBase64toUint8","base64String","encodeJsonToBase64","jsonObj","jsonString","base64urlFromBase64","encodeBase64ToJson","base64urlToBase64","isBase64String","base64url","normalized","padLength","padded","decoded","reStandard","reUrl","originalNoPad","isResultKeyType","encodeCBOR","encodeItem","encodeNumber","encodeString","encodeArray","encodeByteString","encodeObject","encodeUnsigned","encodeSigned","unsigned","encodeFloat64","ab","dv","length","utf8","item","keys","key","decodeCBOR","data","view","decodeItem","initialByte","majorType","additionalInfo","decodeUnsigned","decodeSigned","decodeByteString","decodeString","decodeArray","decodeMap","decodeSimpleAndFloat","ensureAvailable","needed","decodeLength","hi","lo","newOffset","array","currentOffset","map","keyResult","valueResult","decodeFloat16","uint16","exponent","fraction","sign","P2BK_DST","utf8ToBytes","deriveP2BKBlindedPubkeys","pubkeys","keysetId","eBytes","secp256k1","e","E","kid","hexToBytes","pubkey","P","pointFromHex","r","deriveP2BKBlindingTweakFromECDH","P_","bytesToHex","deriveP2BKSecretKeys","Ehex","privateKey","blindPubKey","keysetIdHex","privs","pubs","privHex","p","hexP_","kHex","deriveP2BKSecretKey","privkey","rBlind","blindPubkey","naturalPub","n","hexToNumber","skStd","skNeg","numberToHexPadded64","R","xP","xNaturalPub","yP","yNaturalPub","point","scalar","slotIndex","Zx","iByte","bytesToNumber","sha256","createP2PKsecret","newSecret","randomBytes","parseP2PKSecret","secret","signP2PKSecret","msghash","sig","schnorr","signBlindedMessage","B_","msgHash","verifyP2PKSecretSignature","signature","pubkeyX","hasP2PKSignedProof","proof","getP2PKWitnessSignatures","getP2PKExpectedKWitnessPubkeys","secretStr","now","getP2PKLocktime","getP2PKWitnessPubkeys","getP2PKWitnessRefundkeys","tags","pubkeysTag","tag","refundTag","locktimeTag","getP2PKNSigs","n_sigsTag","n_sigs_refundTag","getP2PKSigFlag","sigFlagTag","witness","signP2PKProofs","proofs","index","privateKeys","maybeDeriveP2BKPrivateKeys","signedProof","priv","signP2PKProof","parsed","witnesses","w","signatures","verifyP2PKSig","parsedSecret","signatories","requiredSigs","verifyP2PKSigOutput","output","publicKey","getSignedOutput","getSignedOutputs","outputs","o","DOMAIN_SEPARATOR","hashToCurve","msgToHash","counter","maxIterations","counterBytes","hash","hash_e","e_","pointFromBytes","getKeysetIdInt","keysetIdInt","createRandomSecretKey","createBlindSignature","amount","id","createRandomBlindedMessage","blindMessage","Y","rG","unblindSignature","C_","A","constructProofFromPromise","promise","C","serializeProof","deserializeProof","DERIVATION_PATH","serializeMintKeys","mintKeys","serializedMintKeys","deserializeMintKeys","getPubKeyFromPrivKey","privKey","createNewMintKeys","pow2height","seed","pubKeys","privKeys","masterKey","HDKey","deriveKeysetId","verifyProof","STANDARD_DERIVATION_PATH","deriveSecret","isValidHex","derive_deprecated","derive","deriveBlindingFactor","secretOrBlinding","hmac","hdkey","derivationPath","derived","arraysEqual","arr1","arr2","verifyDLEQProof","dleq","sG","eA","sB_","eC_","R_1","R_2","verifyDLEQProof_reblind","bG","createDLEQProof","scalar_a","scalar_e","s_scalar","numberToBytesBE","constructMessage","quote","blindedMessages","blindedMessage","msgbytes","signMintQuote","privkeyBytes","verifyMintQuoteSignature","sigbytes","pubkeyBytes","PaymentRequest","transport","unit","mints","description","singleUse","nut10","nut26","rawRequest","t","type","rawPaymentRequest","transports","encodedRequest","encodedData","splitAmount","keyset","split","order","totalSplitAmount","sumArray","positive","amt","totalPositive","hasCorrespondingKey","sortedKeyAmounts","getKeysetAmounts","requireCount","getKeepAmounts","proofsWeHave","amountToKeep","targetCount","amountsWeWant","amountsWeHave","countWeHave","countWeWant","amountDiff","number","hasNonHexId","bigIntStringify","_key","getEncodedTokenV3","token","removeDleq","convertToShortKeysetId","stripDleq","v3TokenObj","newP","getEncodedToken","opts","getEncodedTokenV4","tokenTemplate","templateFromToken","prefix","version","base64Data","idMap","mint","tokenFromTemplate","template","decodedToken","getDecodedToken","tokenString","keysets","removePrefix","tokenObj","handleTokens","mapShortKeysetIds","getTokenMetadata","sumProofs","encodedToken","parsedV3Token","entry","uInt8Token","tokenData","expiry","versionByte","isDeprecatedBase64","pubkeysConcat","pubKey","prev","curr","mergeUInt8Arrays","hashHex","a1","a2","mergedArray","sortProofsById","isObj","checkResponse","joinUrls","parts","part","sanitizeUrl","url","acc","decodePaymentRequest","paymentRequest","MessageNode","node","MessageQueue","messageNode","newNode","verifyKeysetId","isBase64","newProofs","idBytes","found","hasValidDleq","concatByteArrays","byteArray","pointer","getEncodedTokenBinary","utf8Encoder","binaryTemplate","getDecodedTokenBinary","utfDecoder","binaryToken","deepEqual","keysA","keysB","ConnectionManager","newConn","WSConnection","resolve","reject","method","params","subId","callback","errorCallback","notification","handleMeltQuoteResponseDeprecated","handleMintQuoteResponseDeprecated","handleMintInfoContactFieldDeprecated","contact","MintInfo","info","pe22","pe21","num","path","idx","cacheKey","cached","exactHit","regexHit","res","mintMeltInfo","maybe","rec","mm","pp","endpoints","exact","regex","metachar","met","OIDCAuth","discoveryUrl","n21","clientId","scope","text","json","cfg","rnd","verifier","vBytes","chBytes","challenge","input","form","tok","ep","device_code","intervalSec","delay","interval","aborted","refresh_token","username","password","listener","enc","formBody","ms","Mint","mintUrl","customRequest","swapPayload","errDetail","mintQuotePayload","mintPayload","meltQuotePayload","meltPayload","checkPayload","targetUrl","restorePayload","wsSegment","bat","init","requestInstance","cat","Keyset","active","input_fee_ppk","final_expiry","KeyChain","cachedKeysets","cachedKeys","arrayOfKeys","forceRefresh","allKeysetsResponse","allKeysResponse","allKeysets","allKeys","keysMap","mk","activeKeysets","BlindedMessage","RESERVED_P2PK_TAGS","assertValidTagKey","MAX_SECRET_LENGTH","EPHEMERAL_E","setEphemeralE","target","takeEphemeralE","OutputData","blindingFactor","blindSignature","serializedProof","p2pk","customSplit","lockKeys","refundKeys","reqLock","reqRefund","refund","ordered","blinded","_E","ts","vals","charCount","secretBytes","od","randomHex","secretBytesAsHex","utf8SecretBytes","deterministicR","normalisePubkey","pk","toUnixSeconds","P2PKBuilder","when","values","locks","refunds","total","selectProofsRGLI","amountToSend","keyChain","includeFees","exactMatch","_logger","timer","bestSubset","bestDelta","bestAmount","bestFeePPK","feeForProof","sumExFees","feePPK","shuffleArray","shuffled","j","binarySearchIndex","lessOrEqual","left","right","mid","midValue","insertSorted","obj","calculateDelta","totalAmount","totalFeePPK","proofWithFees","ppkfee","exFee","spendableProofs","endIndex","rightIndex","biggerIndex","nextBiggerExFee","totalNetSum","maxOverAmount","trial","S","newAmount","newFeePPK","netSum","SSet","others","indices","_","objP","tempAmount","tempFeePPK","tempNetSum","qIndex","objQ","delta","tempS","tempDelta","bestSum","bestProofs","bestSubsetSet","keep","EphemeralCounterSource","initial","release","chain","cur","minNext","next","WalletOps","wallet","SendBuilder","ReceiveBuilder","MintBuilder","MeltBuilder","denoms","factory","on","requireDleq","outputConfig","bolt11","bolt12","safeStringify","seen","_k","normalizeError","makeAbortError","cancelSafely","WalletEvents","signal","cancel","onAbort","subscribeFn","timeoutMsg","cancelP","to","cleanup","h","ids","uniq","proofMap","y","ys","handler","unique","cancels","lastError","fullyRegistered","quoteId","thisCanceller","queue","done","notify","max","dropMode","wake","push","dropped","cancelled","cancelAll","WalletCounters","src","CheckStateEnum","PENDING_KEYSET_ID","Wallet","promises","totalOutputs","ot","outputTypes","range","cursor","patched","need","used","ks","outputType","customTotal","denominations","receiveFee","receiveFeeAmounts","splitSum","outputData","inputs","keepOutputs","sendOutputs","mergedBlindingData","keepVector","sortedOutputData","sortedKeepVector","d","config","onCountersReserved","tokenMintUrl","netAmount","receiveOT","autoCounters","swapTransaction","proofsReceived","orderedProofs","s","send","sendPrepared","wantsDeterministicByPolicy","isPlainRandom","reasons","expectedFee","sendOT","sendAmount","unselectedProofs","selectedProofs","selectedSum","swapFee","changeAmount","keepOT","keepAmount","swapProofs","reorderedProofs","reorderedKeepVector","keepProofs","sendProofs","sumPPK","nInputs","keepDleq","p2pk_e","rest","gapLimit","batchSize","requiredEmptyBatches","restoredProofs","lastCounterWithSignature","emptyBatchesFound","restoreRes","count","zeros","signatureMap","matchingSig","supported","resPubkey","mintInfo","baseRes","mintOT","mintAmount","mintQuoteSignature","invoice","meltQuote","offer","amountMsat","millisatPartialAmount","meltOptions","proofsToSend","onChangeOutputsCreated","feeReserve","meltOT","blanks","meltResponse","preferAsync","change","Ys","BATCH_SIZE","states","YsSlice","batchStates","stateMap","state","PaymentRequestTransportType","_AuthManager","oidc","minValidSecs","accessToken","expiresAt","nowMs","expSec","minTokens","toTarget","batMax","batch","serializeBAT","mode","jsonStr","exp","lock","mintMax","needsCAT","AuthManager","createAuthWallet","auth"],"mappings":"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"}