import {
  __commonJS
} from "./chunk-UXIASGQL.js";

// node_modules/cbor-web/dist/cbor.js
var require_cbor = __commonJS({
  "node_modules/cbor-web/dist/cbor.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.cbor = t() : e.cbor = t();
    }(exports, () => (() => {
      var e = { 207: (e2, t2, r2) => {
        "use strict";
        const n2 = r2(2893), i = r2(9744), { Buffer: o } = r2(8287);
        class s extends n2 {
          constructor(e3) {
            super(e3), this.valueSharing = new i();
          }
          _pushObject(e3, t3) {
            if (null !== e3) {
              const t4 = this.valueSharing.check(e3);
              switch (t4) {
                case i.FIRST:
                  this._pushTag(28);
                  break;
                case i.NEVER:
                  break;
                default:
                  return this._pushTag(29) && this._pushIntNum(t4);
              }
            }
            return super._pushObject(e3, t3);
          }
          stopRecording() {
            this.valueSharing.stop();
          }
          clearRecording() {
            this.valueSharing.clear();
          }
          static encode(...e3) {
            const t3 = new s();
            t3.on("data", () => {
            });
            for (const r3 of e3)
              t3.pushAny(r3);
            return t3.stopRecording(), t3.removeAllListeners("data"), t3._encodeAll(e3);
          }
          static encodeCanonical(...e3) {
            throw new Error("Cannot encode canonically in a SharedValueEncoder, which serializes objects multiple times.");
          }
          static encodeOne(e3, t3) {
            const r3 = new s(t3);
            return r3.on("data", () => {
            }), r3.pushAny(e3), r3.stopRecording(), r3.removeAllListeners("data"), r3._encodeAll([e3]);
          }
          static encodeAsync(e3, t3) {
            return new Promise((r3, n3) => {
              const i2 = [], a = new s(t3);
              a.on("data", () => {
              }), a.on("error", n3), a.on("finish", () => r3(o.concat(i2))), a.pushAny(e3), a.stopRecording(), a.removeAllListeners("data"), a.on("data", (e4) => i2.push(e4)), a.pushAny(e3), a.end();
            });
          }
        }
        e2.exports = s;
      }, 251: (e2, t2) => {
        t2.read = function(e3, t3, r2, n2, i) {
          var o, s, a = 8 * i - n2 - 1, l = (1 << a) - 1, u = l >> 1, c = -7, f = r2 ? i - 1 : 0, h = r2 ? -1 : 1, d = e3[t3 + f];
          for (f += h, o = d & (1 << -c) - 1, d >>= -c, c += a; c > 0; o = 256 * o + e3[t3 + f], f += h, c -= 8)
            ;
          for (s = o & (1 << -c) - 1, o >>= -c, c += n2; c > 0; s = 256 * s + e3[t3 + f], f += h, c -= 8)
            ;
          if (0 === o)
            o = 1 - u;
          else {
            if (o === l)
              return s ? NaN : 1 / 0 * (d ? -1 : 1);
            s += Math.pow(2, n2), o -= u;
          }
          return (d ? -1 : 1) * s * Math.pow(2, o - n2);
        }, t2.write = function(e3, t3, r2, n2, i, o) {
          var s, a, l, u = 8 * o - i - 1, c = (1 << u) - 1, f = c >> 1, h = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = n2 ? 0 : o - 1, p = n2 ? 1 : -1, b = t3 < 0 || 0 === t3 && 1 / t3 < 0 ? 1 : 0;
          for (t3 = Math.abs(t3), isNaN(t3) || t3 === 1 / 0 ? (a = isNaN(t3) ? 1 : 0, s = c) : (s = Math.floor(Math.log(t3) / Math.LN2), t3 * (l = Math.pow(2, -s)) < 1 && (s--, l *= 2), (t3 += s + f >= 1 ? h / l : h * Math.pow(2, 1 - f)) * l >= 2 && (s++, l /= 2), s + f >= c ? (a = 0, s = c) : s + f >= 1 ? (a = (t3 * l - 1) * Math.pow(2, i), s += f) : (a = t3 * Math.pow(2, f - 1) * Math.pow(2, i), s = 0)); i >= 8; e3[r2 + d] = 255 & a, d += p, a /= 256, i -= 8)
            ;
          for (s = s << i | a, u += i; u > 0; e3[r2 + d] = 255 & s, d += p, s /= 256, u -= 8)
            ;
          e3[r2 + d - p] |= 128 * b;
        };
      }, 277: (e2, t2, r2) => {
        "use strict";
        const { ArrayIsArray: n2, ArrayPrototypeIncludes: i, ArrayPrototypeJoin: o, ArrayPrototypeMap: s, NumberIsInteger: a, NumberIsNaN: l, NumberMAX_SAFE_INTEGER: u, NumberMIN_SAFE_INTEGER: c, NumberParseInt: f, ObjectPrototypeHasOwnProperty: h, RegExpPrototypeExec: d, String: p, StringPrototypeToUpperCase: b, StringPrototypeTrim: y } = r2(4134), { hideStackFrames: g, codes: { ERR_SOCKET_BAD_PORT: w, ERR_INVALID_ARG_TYPE: _, ERR_INVALID_ARG_VALUE: m, ERR_OUT_OF_RANGE: E, ERR_UNKNOWN_SIGNAL: S } } = r2(6371), { normalizeEncoding: v } = r2(7760), { isAsyncFunction: A, isArrayBufferView: I } = r2(7760).types, T = {}, R = /^[0-7]+$/, B = g((e3, t3, r3 = c, n3 = u) => {
          if ("number" != typeof e3)
            throw new _(t3, "number", e3);
          if (!a(e3))
            throw new E(t3, "an integer", e3);
          if (e3 < r3 || e3 > n3)
            throw new E(t3, `>= ${r3} && <= ${n3}`, e3);
        }), N = g((e3, t3, r3 = -2147483648, n3 = 2147483647) => {
          if ("number" != typeof e3)
            throw new _(t3, "number", e3);
          if (!a(e3))
            throw new E(t3, "an integer", e3);
          if (e3 < r3 || e3 > n3)
            throw new E(t3, `>= ${r3} && <= ${n3}`, e3);
        }), L = g((e3, t3, r3 = false) => {
          if ("number" != typeof e3)
            throw new _(t3, "number", e3);
          if (!a(e3))
            throw new E(t3, "an integer", e3);
          const n3 = r3 ? 1 : 0, i2 = 4294967295;
          if (e3 < n3 || e3 > i2)
            throw new E(t3, `>= ${n3} && <= ${i2}`, e3);
        });
        function U(e3, t3) {
          if ("string" != typeof e3)
            throw new _(t3, "string", e3);
        }
        const M = g((e3, t3, r3) => {
          if (!i(r3, e3)) {
            const n3 = o(s(r3, (e4) => "string" == typeof e4 ? `'${e4}'` : p(e4)), ", ");
            throw new m(t3, e3, "must be one of: " + n3);
          }
        });
        function O(e3, t3) {
          if ("boolean" != typeof e3)
            throw new _(t3, "boolean", e3);
        }
        function x(e3, t3, r3) {
          return null != e3 && h(e3, t3) ? e3[t3] : r3;
        }
        const k = g((e3, t3, r3 = null) => {
          const i2 = x(r3, "allowArray", false), o2 = x(r3, "allowFunction", false);
          if (!x(r3, "nullable", false) && null === e3 || !i2 && n2(e3) || "object" != typeof e3 && (!o2 || "function" != typeof e3))
            throw new _(t3, "Object", e3);
        }), P = g((e3, t3) => {
          if (null != e3 && "object" != typeof e3 && "function" != typeof e3)
            throw new _(t3, "a dictionary", e3);
        }), j = g((e3, t3, r3 = 0) => {
          if (!n2(e3))
            throw new _(t3, "Array", e3);
          if (e3.length < r3)
            throw new m(t3, e3, `must be longer than ${r3}`);
        }), D = g((e3, t3 = "buffer") => {
          if (!I(e3))
            throw new _(t3, ["Buffer", "TypedArray", "DataView"], e3);
        }), F = g((e3, t3) => {
          if (void 0 !== e3 && (null === e3 || "object" != typeof e3 || !("aborted" in e3)))
            throw new _(t3, "AbortSignal", e3);
        }), C = g((e3, t3) => {
          if ("function" != typeof e3)
            throw new _(t3, "Function", e3);
        }), $ = g((e3, t3) => {
          if ("function" != typeof e3 || A(e3))
            throw new _(t3, "Function", e3);
        }), W = g((e3, t3) => {
          if (void 0 !== e3)
            throw new _(t3, "undefined", e3);
        }), G = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
        function H(e3, t3) {
          if (void 0 === e3 || !d(G, e3))
            throw new m(t3, e3, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
        }
        e2.exports = { isInt32: function(e3) {
          return e3 === (0 | e3);
        }, isUint32: function(e3) {
          return e3 === e3 >>> 0;
        }, parseFileMode: function(e3, t3, r3) {
          if (void 0 === e3 && (e3 = r3), "string" == typeof e3) {
            if (null === d(R, e3))
              throw new m(t3, e3, "must be a 32-bit unsigned integer or an octal string");
            e3 = f(e3, 8);
          }
          return L(e3, t3), e3;
        }, validateArray: j, validateStringArray: function(e3, t3) {
          j(e3, t3);
          for (let r3 = 0; r3 < e3.length; r3++)
            U(e3[r3], `${t3}[${r3}]`);
        }, validateBooleanArray: function(e3, t3) {
          j(e3, t3);
          for (let r3 = 0; r3 < e3.length; r3++)
            O(e3[r3], `${t3}[${r3}]`);
        }, validateAbortSignalArray: function(e3, t3) {
          j(e3, t3);
          for (let r3 = 0; r3 < e3.length; r3++) {
            const n3 = e3[r3], i2 = `${t3}[${r3}]`;
            if (null == n3)
              throw new _(i2, "AbortSignal", n3);
            F(n3, i2);
          }
        }, validateBoolean: O, validateBuffer: D, validateDictionary: P, validateEncoding: function(e3, t3) {
          const r3 = v(t3), n3 = e3.length;
          if ("hex" === r3 && n3 % 2 != 0)
            throw new m("encoding", t3, `is invalid for data of length ${n3}`);
        }, validateFunction: C, validateInt32: N, validateInteger: B, validateNumber: function(e3, t3, r3 = void 0, n3) {
          if ("number" != typeof e3)
            throw new _(t3, "number", e3);
          if (null != r3 && e3 < r3 || null != n3 && e3 > n3 || (null != r3 || null != n3) && l(e3))
            throw new E(t3, `${null != r3 ? `>= ${r3}` : ""}${null != r3 && null != n3 ? " && " : ""}${null != n3 ? `<= ${n3}` : ""}`, e3);
        }, validateObject: k, validateOneOf: M, validatePlainFunction: $, validatePort: function(e3, t3 = "Port", r3 = true) {
          if ("number" != typeof e3 && "string" != typeof e3 || "string" == typeof e3 && 0 === y(e3).length || +e3 !== +e3 >>> 0 || e3 > 65535 || 0 === e3 && !r3)
            throw new w(t3, e3, r3);
          return 0 | e3;
        }, validateSignalName: function(e3, t3 = "signal") {
          if (U(e3, t3), void 0 === T[e3]) {
            if (void 0 !== T[b(e3)])
              throw new S(e3 + " (signals must use all capital letters)");
            throw new S(e3);
          }
        }, validateString: U, validateUint32: L, validateUndefined: W, validateUnion: function(e3, t3, r3) {
          if (!i(r3, e3))
            throw new _(t3, `('${o(r3, "|")}')`, e3);
        }, validateAbortSignal: F, validateLinkHeaderValue: function(e3) {
          if ("string" == typeof e3)
            return H(e3, "hints"), e3;
          if (n2(e3)) {
            const t3 = e3.length;
            let r3 = "";
            if (0 === t3)
              return r3;
            for (let n3 = 0; n3 < t3; n3++) {
              const i2 = e3[n3];
              H(i2, "hints"), r3 += i2, n3 !== t3 - 1 && (r3 += ", ");
            }
            return r3;
          }
          throw new m("hints", e3, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
        } };
      }, 345: (e2, t2, r2) => {
        "use strict";
        const { StringPrototypeSlice: n2, SymbolIterator: i, TypedArrayPrototypeSet: o, Uint8Array: s } = r2(4134), { Buffer: a } = r2(8287), { inspect: l } = r2(7760);
        e2.exports = class {
          constructor() {
            this.head = null, this.tail = null, this.length = 0;
          }
          push(e3) {
            const t3 = { data: e3, next: null };
            this.length > 0 ? this.tail.next = t3 : this.head = t3, this.tail = t3, ++this.length;
          }
          unshift(e3) {
            const t3 = { data: e3, next: this.head };
            0 === this.length && (this.tail = t3), this.head = t3, ++this.length;
          }
          shift() {
            if (0 === this.length)
              return;
            const e3 = this.head.data;
            return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, e3;
          }
          clear() {
            this.head = this.tail = null, this.length = 0;
          }
          join(e3) {
            if (0 === this.length)
              return "";
            let t3 = this.head, r3 = "" + t3.data;
            for (; null !== (t3 = t3.next); )
              r3 += e3 + t3.data;
            return r3;
          }
          concat(e3) {
            if (0 === this.length)
              return a.alloc(0);
            const t3 = a.allocUnsafe(e3 >>> 0);
            let r3 = this.head, n3 = 0;
            for (; r3; )
              o(t3, r3.data, n3), n3 += r3.data.length, r3 = r3.next;
            return t3;
          }
          consume(e3, t3) {
            const r3 = this.head.data;
            if (e3 < r3.length) {
              const t4 = r3.slice(0, e3);
              return this.head.data = r3.slice(e3), t4;
            }
            return e3 === r3.length ? this.shift() : t3 ? this._getString(e3) : this._getBuffer(e3);
          }
          first() {
            return this.head.data;
          }
          *[i]() {
            for (let e3 = this.head; e3; e3 = e3.next)
              yield e3.data;
          }
          _getString(e3) {
            let t3 = "", r3 = this.head, i2 = 0;
            do {
              const o2 = r3.data;
              if (!(e3 > o2.length)) {
                e3 === o2.length ? (t3 += o2, ++i2, r3.next ? this.head = r3.next : this.head = this.tail = null) : (t3 += n2(o2, 0, e3), this.head = r3, r3.data = n2(o2, e3));
                break;
              }
              t3 += o2, e3 -= o2.length, ++i2;
            } while (null !== (r3 = r3.next));
            return this.length -= i2, t3;
          }
          _getBuffer(e3) {
            const t3 = a.allocUnsafe(e3), r3 = e3;
            let n3 = this.head, i2 = 0;
            do {
              const a2 = n3.data;
              if (!(e3 > a2.length)) {
                e3 === a2.length ? (o(t3, a2, r3 - e3), ++i2, n3.next ? this.head = n3.next : this.head = this.tail = null) : (o(t3, new s(a2.buffer, a2.byteOffset, e3), r3 - e3), this.head = n3, n3.data = a2.slice(e3));
                break;
              }
              o(t3, a2, r3 - e3), e3 -= a2.length, ++i2;
            } while (null !== (n3 = n3.next));
            return this.length -= i2, t3;
          }
          [Symbol.for("nodejs.util.inspect.custom")](e3, t3) {
            return l(this, { ...t3, depth: 0, customInspect: false });
          }
        };
      }, 672: (e2, t2, r2) => {
        "use strict";
        const n2 = r2(8310), { Buffer: i } = r2(8287), o = new TextDecoder("utf8", { fatal: true, ignoreBOM: true });
        class s extends n2.Transform {
          constructor(e3, t3, r3 = {}) {
            let n3 = null, o2 = null;
            switch (typeof e3) {
              case "object":
                i.isBuffer(e3) ? n3 = e3 : e3 && (r3 = e3);
                break;
              case "string":
                n3 = e3;
                break;
              case "undefined":
                break;
              default:
                throw new TypeError("Invalid input");
            }
            switch (typeof t3) {
              case "object":
                t3 && (r3 = t3);
                break;
              case "string":
                o2 = t3;
                break;
              case "undefined":
                break;
              default:
                throw new TypeError("Invalid inputEncoding");
            }
            if (!r3 || "object" != typeof r3)
              throw new TypeError("Invalid options");
            null == n3 && (n3 = r3.input), null == o2 && (o2 = r3.inputEncoding), delete r3.input, delete r3.inputEncoding;
            const s2 = null == r3.watchPipe || r3.watchPipe;
            delete r3.watchPipe;
            const a = Boolean(r3.readError);
            delete r3.readError, super(r3), this.readError = a, s2 && this.on("pipe", (e4) => {
              const t4 = e4._readableState.objectMode;
              if (this.length > 0 && t4 !== this._readableState.objectMode)
                throw new Error("Do not switch objectMode in the middle of the stream");
              this._readableState.objectMode = t4, this._writableState.objectMode = t4;
            }), null != n3 && this.end(n3, o2);
          }
          static isNoFilter(e3) {
            return e3 instanceof this;
          }
          static compare(e3, t3) {
            if (!(e3 instanceof this))
              throw new TypeError("Arguments must be NoFilters");
            return e3 === t3 ? 0 : e3.compare(t3);
          }
          static concat(e3, t3) {
            if (!Array.isArray(e3))
              throw new TypeError("list argument must be an Array of NoFilters");
            if (0 === e3.length || 0 === t3)
              return i.alloc(0);
            null == t3 && (t3 = e3.reduce((e4, t4) => {
              if (!(t4 instanceof s))
                throw new TypeError("list argument must be an Array of NoFilters");
              return e4 + t4.length;
            }, 0));
            let r3 = true, n3 = true;
            const o2 = e3.map((e4) => {
              if (!(e4 instanceof s))
                throw new TypeError("list argument must be an Array of NoFilters");
              const t4 = e4.slice();
              return i.isBuffer(t4) ? n3 = false : r3 = false, t4;
            });
            if (r3)
              return i.concat(o2, t3);
            if (n3)
              return [].concat(...o2).slice(0, t3);
            throw new Error("Concatenating mixed object and byte streams not supported");
          }
          _transform(e3, t3, r3) {
            this._readableState.objectMode || i.isBuffer(e3) || (e3 = i.from(e3, t3)), this.push(e3), r3();
          }
          _bufArray() {
            let e3 = this._readableState.buffer;
            if (!Array.isArray(e3)) {
              let t3 = e3.head;
              for (e3 = []; null != t3; )
                e3.push(t3.data), t3 = t3.next;
            }
            return e3;
          }
          read(e3) {
            const t3 = super.read(e3);
            if (null != t3) {
              if (this.emit("read", t3), this.readError && t3.length < e3)
                throw new Error(`Read ${t3.length}, wanted ${e3}`);
            } else if (this.readError)
              throw new Error(`No data available, wanted ${e3}`);
            return t3;
          }
          readFull(e3) {
            let t3 = null, r3 = null, n3 = null;
            return new Promise((i2, o2) => {
              this.length >= e3 ? i2(this.read(e3)) : this.writableFinished ? o2(new Error(`Stream finished before ${e3} bytes were available`)) : (t3 = (t4) => {
                this.length >= e3 && i2(this.read(e3));
              }, r3 = () => {
                o2(new Error(`Stream finished before ${e3} bytes were available`));
              }, n3 = o2, this.on("readable", t3), this.on("error", n3), this.on("finish", r3));
            }).finally(() => {
              t3 && (this.removeListener("readable", t3), this.removeListener("error", n3), this.removeListener("finish", r3));
            });
          }
          promise(e3) {
            let t3 = false;
            return new Promise((r3, n3) => {
              this.on("finish", () => {
                const n4 = this.read();
                null == e3 || t3 || (t3 = true, e3(null, n4)), r3(n4);
              }), this.on("error", (r4) => {
                null == e3 || t3 || (t3 = true, e3(r4)), n3(r4);
              });
            });
          }
          compare(e3) {
            if (!(e3 instanceof s))
              throw new TypeError("Arguments must be NoFilters");
            if (this === e3)
              return 0;
            const t3 = this.slice(), r3 = e3.slice();
            if (i.isBuffer(t3) && i.isBuffer(r3))
              return t3.compare(r3);
            throw new Error("Cannot compare streams in object mode");
          }
          equals(e3) {
            return 0 === this.compare(e3);
          }
          slice(e3, t3) {
            if (this._readableState.objectMode)
              return this._bufArray().slice(e3, t3);
            const r3 = this._bufArray();
            switch (r3.length) {
              case 0:
                return i.alloc(0);
              case 1:
                return r3[0].slice(e3, t3);
              default:
                return i.concat(r3).slice(e3, t3);
            }
          }
          get(e3) {
            return this.slice()[e3];
          }
          toJSON() {
            const e3 = this.slice();
            return i.isBuffer(e3) ? e3.toJSON() : e3;
          }
          toString(e3, t3, r3) {
            const n3 = this.slice(t3, r3);
            return i.isBuffer(n3) ? e3 && "utf8" !== e3 ? n3.toString(e3) : o.decode(n3) : JSON.stringify(n3);
          }
          [Symbol.for("nodejs.util.inspect.custom")](e3, t3) {
            const r3 = this._bufArray().map((e4) => i.isBuffer(e4) ? t3.stylize(e4.toString("hex"), "string") : JSON.stringify(e4)).join(", ");
            return `${this.constructor.name} [${r3}]`;
          }
          get length() {
            return this._readableState.length;
          }
          writeBigInt(e3) {
            let t3 = e3.toString(16);
            if (e3 < 0) {
              const r3 = BigInt(Math.floor(t3.length / 2));
              t3 = (e3 = (BigInt(1) << r3 * BigInt(8)) + e3).toString(16);
            }
            return t3.length % 2 && (t3 = `0${t3}`), this.push(i.from(t3, "hex"));
          }
          readUBigInt(e3) {
            const t3 = this.read(e3);
            return i.isBuffer(t3) ? BigInt(`0x${t3.toString("hex")}`) : null;
          }
          readBigInt(e3) {
            const t3 = this.read(e3);
            if (!i.isBuffer(t3))
              return null;
            let r3 = BigInt(`0x${t3.toString("hex")}`);
            return 128 & t3[0] && (r3 -= BigInt(1) << BigInt(t3.length) * BigInt(8)), r3;
          }
          writeUInt8(e3) {
            const t3 = i.from([e3]);
            return this.push(t3);
          }
          writeUInt16LE(e3) {
            const t3 = i.alloc(2);
            return t3.writeUInt16LE(e3), this.push(t3);
          }
          writeUInt16BE(e3) {
            const t3 = i.alloc(2);
            return t3.writeUInt16BE(e3), this.push(t3);
          }
          writeUInt32LE(e3) {
            const t3 = i.alloc(4);
            return t3.writeUInt32LE(e3), this.push(t3);
          }
          writeUInt32BE(e3) {
            const t3 = i.alloc(4);
            return t3.writeUInt32BE(e3), this.push(t3);
          }
          writeInt8(e3) {
            const t3 = i.from([e3]);
            return this.push(t3);
          }
          writeInt16LE(e3) {
            const t3 = i.alloc(2);
            return t3.writeUInt16LE(e3), this.push(t3);
          }
          writeInt16BE(e3) {
            const t3 = i.alloc(2);
            return t3.writeUInt16BE(e3), this.push(t3);
          }
          writeInt32LE(e3) {
            const t3 = i.alloc(4);
            return t3.writeUInt32LE(e3), this.push(t3);
          }
          writeInt32BE(e3) {
            const t3 = i.alloc(4);
            return t3.writeUInt32BE(e3), this.push(t3);
          }
          writeFloatLE(e3) {
            const t3 = i.alloc(4);
            return t3.writeFloatLE(e3), this.push(t3);
          }
          writeFloatBE(e3) {
            const t3 = i.alloc(4);
            return t3.writeFloatBE(e3), this.push(t3);
          }
          writeDoubleLE(e3) {
            const t3 = i.alloc(8);
            return t3.writeDoubleLE(e3), this.push(t3);
          }
          writeDoubleBE(e3) {
            const t3 = i.alloc(8);
            return t3.writeDoubleBE(e3), this.push(t3);
          }
          writeBigInt64LE(e3) {
            const t3 = i.alloc(8);
            return t3.writeBigInt64LE(e3), this.push(t3);
          }
          writeBigInt64BE(e3) {
            const t3 = i.alloc(8);
            return t3.writeBigInt64BE(e3), this.push(t3);
          }
          writeBigUInt64LE(e3) {
            const t3 = i.alloc(8);
            return t3.writeBigUInt64LE(e3), this.push(t3);
          }
          writeBigUInt64BE(e3) {
            const t3 = i.alloc(8);
            return t3.writeBigUInt64BE(e3), this.push(t3);
          }
          readUInt8() {
            const e3 = this.read(1);
            return i.isBuffer(e3) ? e3.readUInt8() : null;
          }
          readUInt16LE() {
            const e3 = this.read(2);
            return i.isBuffer(e3) ? e3.readUInt16LE() : null;
          }
          readUInt16BE() {
            const e3 = this.read(2);
            return i.isBuffer(e3) ? e3.readUInt16BE() : null;
          }
          readUInt32LE() {
            const e3 = this.read(4);
            return i.isBuffer(e3) ? e3.readUInt32LE() : null;
          }
          readUInt32BE() {
            const e3 = this.read(4);
            return i.isBuffer(e3) ? e3.readUInt32BE() : null;
          }
          readInt8() {
            const e3 = this.read(1);
            return i.isBuffer(e3) ? e3.readInt8() : null;
          }
          readInt16LE() {
            const e3 = this.read(2);
            return i.isBuffer(e3) ? e3.readInt16LE() : null;
          }
          readInt16BE() {
            const e3 = this.read(2);
            return i.isBuffer(e3) ? e3.readInt16BE() : null;
          }
          readInt32LE() {
            const e3 = this.read(4);
            return i.isBuffer(e3) ? e3.readInt32LE() : null;
          }
          readInt32BE() {
            const e3 = this.read(4);
            return i.isBuffer(e3) ? e3.readInt32BE() : null;
          }
          readFloatLE() {
            const e3 = this.read(4);
            return i.isBuffer(e3) ? e3.readFloatLE() : null;
          }
          readFloatBE() {
            const e3 = this.read(4);
            return i.isBuffer(e3) ? e3.readFloatBE() : null;
          }
          readDoubleLE() {
            const e3 = this.read(8);
            return i.isBuffer(e3) ? e3.readDoubleLE() : null;
          }
          readDoubleBE() {
            const e3 = this.read(8);
            return i.isBuffer(e3) ? e3.readDoubleBE() : null;
          }
          readBigInt64LE() {
            const e3 = this.read(8);
            return i.isBuffer(e3) ? e3.readBigInt64LE() : null;
          }
          readBigInt64BE() {
            const e3 = this.read(8);
            return i.isBuffer(e3) ? e3.readBigInt64BE() : null;
          }
          readBigUInt64LE() {
            const e3 = this.read(8);
            return i.isBuffer(e3) ? e3.readBigUInt64LE() : null;
          }
          readBigUInt64BE() {
            const e3 = this.read(8);
            return i.isBuffer(e3) ? e3.readBigUInt64BE() : null;
          }
        }
        e2.exports = s;
      }, 823: (e2, t2, r2) => {
        "use strict";
        const n2 = globalThis.AbortController || r2(5568).AbortController, { codes: { ERR_INVALID_ARG_VALUE: i, ERR_INVALID_ARG_TYPE: o, ERR_MISSING_ARGS: s, ERR_OUT_OF_RANGE: a }, AbortError: l } = r2(6371), { validateAbortSignal: u, validateInteger: c, validateObject: f } = r2(277), h = r2(4134).Symbol("kWeak"), d = r2(4134).Symbol("kResistStopPropagation"), { finished: p } = r2(6238), b = r2(7830), { addAbortSignalNoValidate: y } = r2(4147), { isWritable: g, isNodeStream: w } = r2(6115), { deprecate: _ } = r2(7760), { ArrayPrototypePush: m, Boolean: E, MathFloor: S, Number: v, NumberIsNaN: A, Promise: I, PromiseReject: T, PromiseResolve: R, PromisePrototypeThen: B, Symbol: N } = r2(4134), L = N("kEmpty"), U = N("kEof");
        function M(e3, t3) {
          if ("function" != typeof e3)
            throw new o("fn", ["Function", "AsyncFunction"], e3);
          null != t3 && f(t3, "options"), null != (null == t3 ? void 0 : t3.signal) && u(t3.signal, "options.signal");
          let n3 = 1;
          null != (null == t3 ? void 0 : t3.concurrency) && (n3 = S(t3.concurrency));
          let i2 = n3 - 1;
          return null != (null == t3 ? void 0 : t3.highWaterMark) && (i2 = S(t3.highWaterMark)), c(n3, "options.concurrency", 1), c(i2, "options.highWaterMark", 0), i2 += n3, (async function* () {
            const o2 = r2(7760).AbortSignalAny([null == t3 ? void 0 : t3.signal].filter(E)), s2 = this, a2 = [], u2 = { signal: o2 };
            let c2, f2, h2 = false, d2 = 0;
            function p2() {
              h2 = true, b2();
            }
            function b2() {
              d2 -= 1, y2();
            }
            function y2() {
              f2 && !h2 && d2 < n3 && a2.length < i2 && (f2(), f2 = null);
            }
            !async function() {
              try {
                for await (let t4 of s2) {
                  if (h2)
                    return;
                  if (o2.aborted)
                    throw new l();
                  try {
                    if (t4 = e3(t4, u2), t4 === L)
                      continue;
                    t4 = R(t4);
                  } catch (e4) {
                    t4 = T(e4);
                  }
                  d2 += 1, B(t4, b2, p2), a2.push(t4), c2 && (c2(), c2 = null), !h2 && (a2.length >= i2 || d2 >= n3) && await new I((e4) => {
                    f2 = e4;
                  });
                }
                a2.push(U);
              } catch (e4) {
                const t4 = T(e4);
                B(t4, b2, p2), a2.push(t4);
              } finally {
                h2 = true, c2 && (c2(), c2 = null);
              }
            }();
            try {
              for (; ; ) {
                for (; a2.length > 0; ) {
                  const e4 = await a2[0];
                  if (e4 === U)
                    return;
                  if (o2.aborted)
                    throw new l();
                  e4 !== L && (yield e4), a2.shift(), y2();
                }
                await new I((e4) => {
                  c2 = e4;
                });
              }
            } finally {
              h2 = true, f2 && (f2(), f2 = null);
            }
          }).call(this);
        }
        async function O(e3, t3 = void 0) {
          for await (const r3 of x.call(this, e3, t3))
            return true;
          return false;
        }
        function x(e3, t3) {
          if ("function" != typeof e3)
            throw new o("fn", ["Function", "AsyncFunction"], e3);
          return M.call(this, async function(t4, r3) {
            return await e3(t4, r3) ? t4 : L;
          }, t3);
        }
        class k extends s {
          constructor() {
            super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
          }
        }
        function P(e3) {
          if (e3 = v(e3), A(e3))
            return 0;
          if (e3 < 0)
            throw new a("number", ">= 0", e3);
          return e3;
        }
        e2.exports.streamReturningOperators = { asIndexedPairs: _(function(e3 = void 0) {
          return null != e3 && f(e3, "options"), null != (null == e3 ? void 0 : e3.signal) && u(e3.signal, "options.signal"), (async function* () {
            let t3 = 0;
            for await (const n3 of this) {
              var r3;
              if (null != e3 && null !== (r3 = e3.signal) && void 0 !== r3 && r3.aborted)
                throw new l({ cause: e3.signal.reason });
              yield [t3++, n3];
            }
          }).call(this);
        }, "readable.asIndexedPairs will be removed in a future version."), drop: function(e3, t3 = void 0) {
          return null != t3 && f(t3, "options"), null != (null == t3 ? void 0 : t3.signal) && u(t3.signal, "options.signal"), e3 = P(e3), (async function* () {
            var r3;
            if (null != t3 && null !== (r3 = t3.signal) && void 0 !== r3 && r3.aborted)
              throw new l();
            for await (const r4 of this) {
              var n3;
              if (null != t3 && null !== (n3 = t3.signal) && void 0 !== n3 && n3.aborted)
                throw new l();
              e3-- <= 0 && (yield r4);
            }
          }).call(this);
        }, filter: x, flatMap: function(e3, t3) {
          const r3 = M.call(this, e3, t3);
          return (async function* () {
            for await (const e4 of r3)
              yield* e4;
          }).call(this);
        }, map: M, take: function(e3, t3 = void 0) {
          return null != t3 && f(t3, "options"), null != (null == t3 ? void 0 : t3.signal) && u(t3.signal, "options.signal"), e3 = P(e3), (async function* () {
            var r3;
            if (null != t3 && null !== (r3 = t3.signal) && void 0 !== r3 && r3.aborted)
              throw new l();
            for await (const r4 of this) {
              var n3;
              if (null != t3 && null !== (n3 = t3.signal) && void 0 !== n3 && n3.aborted)
                throw new l();
              if (e3-- > 0 && (yield r4), e3 <= 0)
                return;
            }
          }).call(this);
        }, compose: function(e3, t3) {
          if (null != t3 && f(t3, "options"), null != (null == t3 ? void 0 : t3.signal) && u(t3.signal, "options.signal"), w(e3) && !g(e3))
            throw new i("stream", e3, "must be writable");
          const r3 = b(this, e3);
          return null != t3 && t3.signal && y(t3.signal, r3), r3;
        } }, e2.exports.promiseReturningOperators = { every: async function(e3, t3 = void 0) {
          if ("function" != typeof e3)
            throw new o("fn", ["Function", "AsyncFunction"], e3);
          return !await O.call(this, async (...t4) => !await e3(...t4), t3);
        }, forEach: async function(e3, t3) {
          if ("function" != typeof e3)
            throw new o("fn", ["Function", "AsyncFunction"], e3);
          for await (const r3 of M.call(this, async function(t4, r4) {
            return await e3(t4, r4), L;
          }, t3))
            ;
        }, reduce: async function(e3, t3, r3) {
          var i2;
          if ("function" != typeof e3)
            throw new o("reducer", ["Function", "AsyncFunction"], e3);
          null != r3 && f(r3, "options"), null != (null == r3 ? void 0 : r3.signal) && u(r3.signal, "options.signal");
          let s2 = arguments.length > 1;
          if (null != r3 && null !== (i2 = r3.signal) && void 0 !== i2 && i2.aborted) {
            const e4 = new l(void 0, { cause: r3.signal.reason });
            throw this.once("error", () => {
            }), await p(this.destroy(e4)), e4;
          }
          const a2 = new n2(), c2 = a2.signal;
          if (null != r3 && r3.signal) {
            const e4 = { once: true, [h]: this, [d]: true };
            r3.signal.addEventListener("abort", () => a2.abort(), e4);
          }
          let b2 = false;
          try {
            for await (const n3 of this) {
              var y2;
              if (b2 = true, null != r3 && null !== (y2 = r3.signal) && void 0 !== y2 && y2.aborted)
                throw new l();
              s2 ? t3 = await e3(t3, n3, { signal: c2 }) : (t3 = n3, s2 = true);
            }
            if (!b2 && !s2)
              throw new k();
          } finally {
            a2.abort();
          }
          return t3;
        }, toArray: async function(e3) {
          null != e3 && f(e3, "options"), null != (null == e3 ? void 0 : e3.signal) && u(e3.signal, "options.signal");
          const t3 = [];
          for await (const n3 of this) {
            var r3;
            if (null != e3 && null !== (r3 = e3.signal) && void 0 !== r3 && r3.aborted)
              throw new l(void 0, { cause: e3.signal.reason });
            m(t3, n3);
          }
          return t3;
        }, some: O, find: async function(e3, t3) {
          for await (const r3 of x.call(this, e3, t3))
            return r3;
        } };
      }, 893: (e2, t2, r2) => {
        "use strict";
        const n2 = r2(8310), i = r2(7328), o = r2(3737), s = r2(672), { MT: a, NUMBYTES: l, SYMS: u } = r2(9452), { Buffer: c } = r2(8287);
        function f(e3) {
          return e3 > 1 ? "s" : "";
        }
        class h extends n2.Transform {
          constructor(e3 = {}) {
            const { depth: t3 = 1, max_depth: r3 = 10, no_summary: n3 = false, tags: i2 = {}, preferWeb: a2, encoding: l2, ...u2 } = e3;
            super({ ...u2, readableObjectMode: false, writableObjectMode: false }), this.depth = t3, this.max_depth = r3, this.all = new s(), i2[24] || (i2[24] = this._tag_24.bind(this)), this.parser = new o({ tags: i2, max_depth: r3, preferWeb: a2, encoding: l2 }), this.parser.on("value", this._on_value.bind(this)), this.parser.on("start", this._on_start.bind(this)), this.parser.on("start-string", this._on_start_string.bind(this)), this.parser.on("stop", this._on_stop.bind(this)), this.parser.on("more-bytes", this._on_more.bind(this)), this.parser.on("error", this._on_error.bind(this)), n3 || this.parser.on("data", this._on_data.bind(this)), this.parser.bs.on("read", this._on_read.bind(this));
          }
          _tag_24(e3) {
            const t3 = new h({ depth: this.depth + 1, no_summary: true });
            t3.on("data", (e4) => this.push(e4)), t3.on("error", (e4) => this.emit("error", e4)), t3.end(e3);
          }
          _transform(e3, t3, r3) {
            this.parser.write(e3, t3, r3);
          }
          _flush(e3) {
            return this.parser._flush(e3);
          }
          static comment(e3, t3 = {}, r3 = null) {
            if (null == e3)
              throw new Error("input required");
            ({ options: t3, cb: r3 } = function(e4, t4) {
              switch (typeof e4) {
                case "function":
                  return { options: {}, cb: e4 };
                case "string":
                  return { options: { encoding: e4 }, cb: t4 };
                case "number":
                  return { options: { max_depth: e4 }, cb: t4 };
                case "object":
                  return { options: e4 || {}, cb: t4 };
                default:
                  throw new TypeError("Unknown option type");
              }
            }(t3, r3));
            const n3 = new s(), { encoding: o2 = "hex", ...a2 } = t3, l2 = new h(a2);
            let u2 = null;
            return "function" == typeof r3 ? (l2.on("end", () => {
              r3(null, n3.toString("utf8"));
            }), l2.on("error", r3)) : u2 = new Promise((e4, t4) => {
              l2.on("end", () => {
                e4(n3.toString("utf8"));
              }), l2.on("error", t4);
            }), l2.pipe(n3), i.guessEncoding(e3, o2).pipe(l2), u2;
          }
          _on_error(e3) {
            this.push("ERROR: "), this.push(e3.toString()), this.push("\n");
          }
          _on_read(e3) {
            this.all.write(e3);
            const t3 = e3.toString("hex");
            this.push(new Array(this.depth + 1).join("  ")), this.push(t3);
            let r3 = 2 * (this.max_depth - this.depth) - t3.length;
            r3 < 1 && (r3 = 1), this.push(new Array(r3 + 1).join(" ")), this.push("-- ");
          }
          _on_more(e3, t3, r3, n3) {
            let i2 = "";
            switch (this.depth++, e3) {
              case a.POS_INT:
                i2 = "Positive number,";
                break;
              case a.NEG_INT:
                i2 = "Negative number,";
                break;
              case a.ARRAY:
                i2 = "Array, length";
                break;
              case a.MAP:
                i2 = "Map, count";
                break;
              case a.BYTE_STRING:
                i2 = "Bytes, length";
                break;
              case a.UTF8_STRING:
                i2 = "String, length";
                break;
              case a.SIMPLE_FLOAT:
                i2 = 1 === t3 ? "Simple value," : "Float,";
            }
            this.push(`${i2} next ${t3} byte${f(t3)}
`);
          }
          _on_start_string(e3, t3, r3, n3) {
            let i2 = "";
            switch (this.depth++, e3) {
              case a.BYTE_STRING:
                i2 = `Bytes, length: ${t3}`;
                break;
              case a.UTF8_STRING:
                i2 = `String, length: ${t3.toString()}`;
            }
            this.push(`${i2}
`);
          }
          _on_start(e3, t3, r3, n3) {
            switch (this.depth++, r3) {
              case a.ARRAY:
                this.push(`[${n3}], `);
                break;
              case a.MAP:
                n3 % 2 ? this.push(`{Val:${Math.floor(n3 / 2)}}, `) : this.push(`{Key:${Math.floor(n3 / 2)}}, `);
            }
            switch (e3) {
              case a.TAG:
                this.push(`Tag #${t3}`), 24 === t3 && this.push(" Encoded CBOR data item");
                break;
              case a.ARRAY:
                t3 === u.STREAM ? this.push("Array (streaming)") : this.push(`Array, ${t3} item${f(t3)}`);
                break;
              case a.MAP:
                t3 === u.STREAM ? this.push("Map (streaming)") : this.push(`Map, ${t3} pair${f(t3)}`);
                break;
              case a.BYTE_STRING:
                this.push("Bytes (streaming)");
                break;
              case a.UTF8_STRING:
                this.push("String (streaming)");
            }
            this.push("\n");
          }
          _on_stop(e3) {
            this.depth--;
          }
          _on_value(e3, t3, r3, n3) {
            if (e3 !== u.BREAK)
              switch (t3) {
                case a.ARRAY:
                  this.push(`[${r3}], `);
                  break;
                case a.MAP:
                  r3 % 2 ? this.push(`{Val:${Math.floor(r3 / 2)}}, `) : this.push(`{Key:${Math.floor(r3 / 2)}}, `);
              }
            const o2 = i.cborValueToString(e3, -1 / 0);
            switch ("string" == typeof e3 || c.isBuffer(e3) ? (e3.length > 0 && (this.push(o2), this.push("\n")), this.depth--) : (this.push(o2), this.push("\n")), n3) {
              case l.ONE:
              case l.TWO:
              case l.FOUR:
              case l.EIGHT:
                this.depth--;
            }
          }
          _on_data() {
            this.push("0x"), this.push(this.all.read().toString("hex")), this.push("\n");
          }
        }
        e2.exports = h;
      }, 2861: (e2, t2, r2) => {
        var n2 = r2(8287), i = n2.Buffer;
        function o(e3, t3) {
          for (var r3 in e3)
            t3[r3] = e3[r3];
        }
        function s(e3, t3, r3) {
          return i(e3, t3, r3);
        }
        i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? e2.exports = n2 : (o(n2, t2), t2.Buffer = s), s.prototype = Object.create(i.prototype), o(i, s), s.from = function(e3, t3, r3) {
          if ("number" == typeof e3)
            throw new TypeError("Argument must not be a number");
          return i(e3, t3, r3);
        }, s.alloc = function(e3, t3, r3) {
          if ("number" != typeof e3)
            throw new TypeError("Argument must be a number");
          var n3 = i(e3);
          return void 0 !== t3 ? "string" == typeof r3 ? n3.fill(t3, r3) : n3.fill(t3) : n3.fill(0), n3;
        }, s.allocUnsafe = function(e3) {
          if ("number" != typeof e3)
            throw new TypeError("Argument must be a number");
          return i(e3);
        }, s.allocUnsafeSlow = function(e3) {
          if ("number" != typeof e3)
            throw new TypeError("Argument must be a number");
          return n2.SlowBuffer(e3);
        };
      }, 2893: (e2, t2, r2) => {
        "use strict";
        const n2 = r2(8310), i = r2(672), o = r2(7328), s = r2(9452), { MT: a, NUMBYTES: l, SHIFT32: u, SIMPLE: c, SYMS: f, TAG: h, BI: d } = s, { Buffer: p } = r2(8287), b = a.SIMPLE_FLOAT << 5 | l.TWO, y = a.SIMPLE_FLOAT << 5 | l.FOUR, g = a.SIMPLE_FLOAT << 5 | l.EIGHT, w = a.SIMPLE_FLOAT << 5 | c.TRUE, _ = a.SIMPLE_FLOAT << 5 | c.FALSE, m = a.SIMPLE_FLOAT << 5 | c.UNDEFINED, E = a.SIMPLE_FLOAT << 5 | c.NULL, S = p.from([255]), v = p.from("f97e00", "hex"), A = p.from("f9fc00", "hex"), I = p.from("f97c00", "hex"), T = p.from("f98000", "hex"), R = {};
        let B = {};
        class N extends n2.Transform {
          constructor(e3 = {}) {
            const { canonical: t3 = false, encodeUndefined: r3, disallowUndefinedKeys: n3 = false, dateType: i2 = "number", collapseBigIntegers: o2 = false, detectLoops: s2 = false, omitUndefinedProperties: a2 = false, genTypes: l2 = [], ...u2 } = e3;
            if (super({ ...u2, readableObjectMode: false, writableObjectMode: true }), this.canonical = t3, this.encodeUndefined = r3, this.disallowUndefinedKeys = n3, this.dateType = function(e4) {
              if (!e4)
                return "number";
              switch (e4.toLowerCase()) {
                case "number":
                  return "number";
                case "float":
                  return "float";
                case "int":
                case "integer":
                  return "int";
                case "string":
                  return "string";
              }
              throw new TypeError(`dateType invalid, got "${e4}"`);
            }(i2), this.collapseBigIntegers = !!this.canonical || o2, this.detectLoops = void 0, "boolean" == typeof s2)
              s2 && (this.detectLoops = /* @__PURE__ */ new WeakSet());
            else {
              if (!(s2 instanceof WeakSet))
                throw new TypeError("detectLoops must be boolean or WeakSet");
              this.detectLoops = s2;
            }
            if (this.omitUndefinedProperties = a2, this.semanticTypes = { ...N.SEMANTIC_TYPES }, Array.isArray(l2))
              for (let e4 = 0, t4 = l2.length; e4 < t4; e4 += 2)
                this.addSemanticType(l2[e4], l2[e4 + 1]);
            else
              for (const [e4, t4] of Object.entries(l2))
                this.addSemanticType(e4, t4);
          }
          _transform(e3, t3, r3) {
            r3(false === this.pushAny(e3) ? new Error("Push Error") : void 0);
          }
          _flush(e3) {
            e3();
          }
          _pushUInt8(e3) {
            const t3 = p.allocUnsafe(1);
            return t3.writeUInt8(e3, 0), this.push(t3);
          }
          _pushUInt16BE(e3) {
            const t3 = p.allocUnsafe(2);
            return t3.writeUInt16BE(e3, 0), this.push(t3);
          }
          _pushUInt32BE(e3) {
            const t3 = p.allocUnsafe(4);
            return t3.writeUInt32BE(e3, 0), this.push(t3);
          }
          _pushFloatBE(e3) {
            const t3 = p.allocUnsafe(4);
            return t3.writeFloatBE(e3, 0), this.push(t3);
          }
          _pushDoubleBE(e3) {
            const t3 = p.allocUnsafe(8);
            return t3.writeDoubleBE(e3, 0), this.push(t3);
          }
          _pushNaN() {
            return this.push(v);
          }
          _pushInfinity(e3) {
            const t3 = e3 < 0 ? A : I;
            return this.push(t3);
          }
          _pushFloat(e3) {
            if (this.canonical) {
              const t3 = p.allocUnsafe(2);
              if (o.writeHalf(t3, e3))
                return this._pushUInt8(b) && this.push(t3);
            }
            return Math.fround(e3) === e3 ? this._pushUInt8(y) && this._pushFloatBE(e3) : this._pushUInt8(g) && this._pushDoubleBE(e3);
          }
          _pushInt(e3, t3, r3) {
            const n3 = t3 << 5;
            if (e3 < 24)
              return this._pushUInt8(n3 | e3);
            if (e3 <= 255)
              return this._pushUInt8(n3 | l.ONE) && this._pushUInt8(e3);
            if (e3 <= 65535)
              return this._pushUInt8(n3 | l.TWO) && this._pushUInt16BE(e3);
            if (e3 <= 4294967295)
              return this._pushUInt8(n3 | l.FOUR) && this._pushUInt32BE(e3);
            let i2 = Number.MAX_SAFE_INTEGER;
            return t3 === a.NEG_INT && i2--, e3 <= i2 ? this._pushUInt8(n3 | l.EIGHT) && this._pushUInt32BE(Math.floor(e3 / u)) && this._pushUInt32BE(e3 % u) : t3 === a.NEG_INT ? this._pushFloat(r3) : this._pushFloat(e3);
          }
          _pushIntNum(e3) {
            return Object.is(e3, -0) ? this.push(T) : e3 < 0 ? this._pushInt(-e3 - 1, a.NEG_INT, e3) : this._pushInt(e3, a.POS_INT);
          }
          _pushNumber(e3) {
            return isNaN(e3) ? this._pushNaN() : isFinite(e3) ? Math.round(e3) === e3 ? this._pushIntNum(e3) : this._pushFloat(e3) : this._pushInfinity(e3);
          }
          _pushString(e3) {
            const t3 = p.byteLength(e3, "utf8");
            return this._pushInt(t3, a.UTF8_STRING) && this.push(e3, "utf8");
          }
          _pushBoolean(e3) {
            return this._pushUInt8(e3 ? w : _);
          }
          _pushUndefined(e3) {
            switch (typeof this.encodeUndefined) {
              case "undefined":
                return this._pushUInt8(m);
              case "function":
                return this.pushAny(this.encodeUndefined(e3));
              case "object": {
                const e4 = o.bufferishToBuffer(this.encodeUndefined);
                if (e4)
                  return this.push(e4);
              }
            }
            return this.pushAny(this.encodeUndefined);
          }
          _pushNull(e3) {
            return this._pushUInt8(E);
          }
          _pushTag(e3) {
            return this._pushInt(e3, a.TAG);
          }
          _pushJSBigint(e3) {
            let t3 = a.POS_INT, r3 = h.POS_BIGINT;
            if (e3 < 0 && (e3 = -e3 + d.MINUS_ONE, t3 = a.NEG_INT, r3 = h.NEG_BIGINT), this.collapseBigIntegers && e3 <= d.MAXINT64)
              return e3 <= 4294967295 ? this._pushInt(Number(e3), t3) : this._pushUInt8(t3 << 5 | l.EIGHT) && this._pushUInt32BE(Number(e3 / d.SHIFT32)) && this._pushUInt32BE(Number(e3 % d.SHIFT32));
            let n3 = e3.toString(16);
            n3.length % 2 && (n3 = `0${n3}`);
            const i2 = p.from(n3, "hex");
            return this._pushTag(r3) && N._pushBuffer(this, i2);
          }
          _pushObject(e3, t3) {
            if (!e3)
              return this._pushNull(e3);
            if (!(t3 = { indefinite: false, skipTypes: false, ...t3 }).indefinite && this.detectLoops) {
              if (this.detectLoops.has(e3))
                throw new Error("Loop detected while CBOR encoding.\nCall removeLoopDetectors before resuming.");
              this.detectLoops.add(e3);
            }
            if (!t3.skipTypes) {
              const t4 = e3.encodeCBOR;
              if ("function" == typeof t4)
                return t4.call(e3, this);
              const r4 = this.semanticTypes[e3.constructor.name];
              if (r4)
                return r4.call(e3, this, e3);
            }
            const r3 = Object.keys(e3).filter((t4) => {
              const r4 = typeof e3[t4];
              return "function" !== r4 && (!this.omitUndefinedProperties || "undefined" !== r4);
            }), n3 = {};
            if (this.canonical && r3.sort((e4, t4) => {
              const r4 = n3[e4] || (n3[e4] = N.encode(e4)), i3 = n3[t4] || (n3[t4] = N.encode(t4));
              return r4.compare(i3);
            }), t3.indefinite) {
              if (!this._pushUInt8(a.MAP << 5 | l.INDEFINITE))
                return false;
            } else if (!this._pushInt(r3.length, a.MAP))
              return false;
            let i2 = null;
            for (let t4 = 0, o2 = r3.length; t4 < o2; t4++) {
              const o3 = r3[t4];
              if (this.canonical && (i2 = n3[o3])) {
                if (!this.push(i2))
                  return false;
              } else if (!this._pushString(o3))
                return false;
              if (!this.pushAny(e3[o3]))
                return false;
            }
            if (t3.indefinite) {
              if (!this.push(S))
                return false;
            } else
              this.detectLoops && this.detectLoops.delete(e3);
            return true;
          }
          _encodeAll(e3) {
            const t3 = new i({ highWaterMark: this.readableHighWaterMark });
            this.pipe(t3);
            for (const t4 of e3)
              this.pushAny(t4);
            return this.end(), t3.read();
          }
          addSemanticType(e3, t3) {
            const r3 = "string" == typeof e3 ? e3 : e3.name, n3 = this.semanticTypes[r3];
            if (t3) {
              if ("function" != typeof t3)
                throw new TypeError("fun must be of type function");
              this.semanticTypes[r3] = t3;
            } else
              n3 && delete this.semanticTypes[r3];
            return n3;
          }
          pushAny(e3) {
            switch (typeof e3) {
              case "number":
                return this._pushNumber(e3);
              case "bigint":
                return this._pushJSBigint(e3);
              case "string":
                return this._pushString(e3);
              case "boolean":
                return this._pushBoolean(e3);
              case "undefined":
                return this._pushUndefined(e3);
              case "object":
                return this._pushObject(e3);
              case "symbol":
                switch (e3) {
                  case f.NULL:
                    return this._pushNull(null);
                  case f.UNDEFINED:
                    return this._pushUndefined(void 0);
                  default:
                    throw new TypeError(`Unknown symbol: ${e3.toString()}`);
                }
              default:
                throw new TypeError(`Unknown type: ${typeof e3}, ${"function" == typeof e3.toString ? e3.toString() : ""}`);
            }
          }
          static pushArray(e3, t3, r3) {
            r3 = { indefinite: false, ...r3 };
            const n3 = t3.length;
            if (r3.indefinite) {
              if (!e3._pushUInt8(a.ARRAY << 5 | l.INDEFINITE))
                return false;
            } else if (!e3._pushInt(n3, a.ARRAY))
              return false;
            for (let r4 = 0; r4 < n3; r4++)
              if (!e3.pushAny(t3[r4]))
                return false;
            return !(r3.indefinite && !e3.push(S));
          }
          removeLoopDetectors() {
            return !!this.detectLoops && (this.detectLoops = /* @__PURE__ */ new WeakSet(), true);
          }
          static _pushDate(e3, t3) {
            switch (e3.dateType) {
              case "string":
                return e3._pushTag(h.DATE_STRING) && e3._pushString(t3.toISOString());
              case "int":
                return e3._pushTag(h.DATE_EPOCH) && e3._pushIntNum(Math.round(t3.getTime() / 1e3));
              case "float":
                return e3._pushTag(h.DATE_EPOCH) && e3._pushFloat(t3.getTime() / 1e3);
              default:
                return e3._pushTag(h.DATE_EPOCH) && e3.pushAny(t3.getTime() / 1e3);
            }
          }
          static _pushBuffer(e3, t3) {
            return e3._pushInt(t3.length, a.BYTE_STRING) && e3.push(t3);
          }
          static _pushNoFilter(e3, t3) {
            return N._pushBuffer(e3, t3.slice());
          }
          static _pushRegexp(e3, t3) {
            return e3._pushTag(h.REGEXP) && e3.pushAny(t3.source);
          }
          static _pushSet(e3, t3) {
            if (!e3._pushTag(h.SET))
              return false;
            if (!e3._pushInt(t3.size, a.ARRAY))
              return false;
            for (const r3 of t3)
              if (!e3.pushAny(r3))
                return false;
            return true;
          }
          static _pushURL(e3, t3) {
            return e3._pushTag(h.URI) && e3.pushAny(t3.toString());
          }
          static _pushBoxed(e3, t3) {
            return e3.pushAny(t3.valueOf());
          }
          static _pushMap(e3, t3, r3) {
            r3 = { indefinite: false, ...r3 };
            let n3 = [...t3.entries()];
            if (e3.omitUndefinedProperties && (n3 = n3.filter(([e4, t4]) => void 0 !== t4)), r3.indefinite) {
              if (!e3._pushUInt8(a.MAP << 5 | l.INDEFINITE))
                return false;
            } else if (!e3._pushInt(n3.length, a.MAP))
              return false;
            if (e3.canonical) {
              const t4 = new N({ genTypes: e3.semanticTypes, canonical: e3.canonical, detectLoops: Boolean(e3.detectLoops), dateType: e3.dateType, disallowUndefinedKeys: e3.disallowUndefinedKeys, collapseBigIntegers: e3.collapseBigIntegers }), r4 = new i({ highWaterMark: e3.readableHighWaterMark });
              t4.pipe(r4), n3.sort(([e4], [n4]) => {
                t4.pushAny(e4);
                const i2 = r4.read();
                t4.pushAny(n4);
                const o2 = r4.read();
                return i2.compare(o2);
              });
              for (const [t5, r5] of n3) {
                if (e3.disallowUndefinedKeys && void 0 === t5)
                  throw new Error("Invalid Map key: undefined");
                if (!e3.pushAny(t5) || !e3.pushAny(r5))
                  return false;
              }
            } else
              for (const [t4, r4] of n3) {
                if (e3.disallowUndefinedKeys && void 0 === t4)
                  throw new Error("Invalid Map key: undefined");
                if (!e3.pushAny(t4) || !e3.pushAny(r4))
                  return false;
              }
            return !(r3.indefinite && !e3.push(S));
          }
          static _pushTypedArray(e3, t3) {
            let r3 = 64, n3 = t3.BYTES_PER_ELEMENT;
            const { name: i2 } = t3.constructor;
            return i2.startsWith("Float") ? (r3 |= 16, n3 /= 2) : i2.includes("U") || (r3 |= 8), (i2.includes("Clamped") || 1 !== n3 && !o.isBigEndian()) && (r3 |= 4), r3 |= { 1: 0, 2: 1, 4: 2, 8: 3 }[n3], !!e3._pushTag(r3) && N._pushBuffer(e3, p.from(t3.buffer, t3.byteOffset, t3.byteLength));
          }
          static _pushArrayBuffer(e3, t3) {
            return N._pushBuffer(e3, p.from(t3));
          }
          static encodeIndefinite(e3, t3, r3 = {}) {
            if (null == t3) {
              if (null == this)
                throw new Error("No object to encode");
              t3 = this;
            }
            const { chunkSize: n3 = 4096 } = r3;
            let i2 = true;
            const s2 = typeof t3;
            let u2 = null;
            if ("string" === s2) {
              i2 = i2 && e3._pushUInt8(a.UTF8_STRING << 5 | l.INDEFINITE);
              let r4 = 0;
              for (; r4 < t3.length; ) {
                const o2 = r4 + n3;
                i2 = i2 && e3._pushString(t3.slice(r4, o2)), r4 = o2;
              }
              i2 = i2 && e3.push(S);
            } else if (u2 = o.bufferishToBuffer(t3)) {
              i2 = i2 && e3._pushUInt8(a.BYTE_STRING << 5 | l.INDEFINITE);
              let t4 = 0;
              for (; t4 < u2.length; ) {
                const r4 = t4 + n3;
                i2 = i2 && N._pushBuffer(e3, u2.slice(t4, r4)), t4 = r4;
              }
              i2 = i2 && e3.push(S);
            } else if (Array.isArray(t3))
              i2 = i2 && N.pushArray(e3, t3, { indefinite: true });
            else if (t3 instanceof Map)
              i2 = i2 && N._pushMap(e3, t3, { indefinite: true });
            else {
              if ("object" !== s2)
                throw new Error("Invalid indefinite encoding");
              i2 = i2 && e3._pushObject(t3, { indefinite: true, skipTypes: true });
            }
            return i2;
          }
          static encode(...e3) {
            return new N()._encodeAll(e3);
          }
          static encodeCanonical(...e3) {
            return new N({ canonical: true })._encodeAll(e3);
          }
          static encodeOne(e3, t3) {
            return new N(t3)._encodeAll([e3]);
          }
          static encodeAsync(e3, t3) {
            return new Promise((r3, n3) => {
              const i2 = [], o2 = new N(t3);
              o2.on("data", (e4) => i2.push(e4)), o2.on("error", n3), o2.on("finish", () => r3(p.concat(i2))), o2.pushAny(e3), o2.end();
            });
          }
          static get SEMANTIC_TYPES() {
            return B;
          }
          static set SEMANTIC_TYPES(e3) {
            B = e3;
          }
          static reset() {
            N.SEMANTIC_TYPES = { ...R };
          }
        }
        Object.assign(R, { Array: N.pushArray, Date: N._pushDate, Buffer: N._pushBuffer, [p.name]: N._pushBuffer, Map: N._pushMap, NoFilter: N._pushNoFilter, [i.name]: N._pushNoFilter, RegExp: N._pushRegexp, Set: N._pushSet, ArrayBuffer: N._pushArrayBuffer, Uint8ClampedArray: N._pushTypedArray, Uint8Array: N._pushTypedArray, Uint16Array: N._pushTypedArray, Uint32Array: N._pushTypedArray, Int8Array: N._pushTypedArray, Int16Array: N._pushTypedArray, Int32Array: N._pushTypedArray, Float32Array: N._pushTypedArray, Float64Array: N._pushTypedArray, URL: N._pushURL, Boolean: N._pushBoxed, Number: N._pushBoxed, String: N._pushBoxed }), "undefined" != typeof BigUint64Array && (R[BigUint64Array.name] = N._pushTypedArray), "undefined" != typeof BigInt64Array && (R[BigInt64Array.name] = N._pushTypedArray), N.reset(), e2.exports = N;
      }, 2903: (e2, t2, r2) => {
        "use strict";
        const { Buffer: n2 } = r2(8287), i = r2(2893), o = r2(3737), { MT: s } = r2(9452);
        class a extends Map {
          constructor(e3) {
            super(e3);
          }
          static _encode(e3) {
            return i.encodeCanonical(e3).toString("base64");
          }
          static _decode(e3) {
            return o.decodeFirstSync(e3, "base64");
          }
          get(e3) {
            return super.get(a._encode(e3));
          }
          set(e3, t3) {
            return super.set(a._encode(e3), t3);
          }
          delete(e3) {
            return super.delete(a._encode(e3));
          }
          has(e3) {
            return super.has(a._encode(e3));
          }
          *keys() {
            for (const e3 of super.keys())
              yield a._decode(e3);
          }
          *entries() {
            for (const e3 of super.entries())
              yield [a._decode(e3[0]), e3[1]];
          }
          [Symbol.iterator]() {
            return this.entries();
          }
          forEach(e3, t3 = this) {
            if ("function" != typeof e3)
              throw new TypeError("Must be function");
            for (const r3 of super.entries())
              e3.call(t3, r3[1], a._decode(r3[0]), this);
          }
          encodeCBOR(e3) {
            if (!e3._pushInt(this.size, s.MAP))
              return false;
            if (e3.canonical) {
              const t3 = Array.from(super.entries()).map((e4) => [n2.from(e4[0], "base64"), e4[1]]);
              t3.sort((e4, t4) => e4[0].compare(t4[0]));
              for (const r3 of t3)
                if (!e3.push(r3[0]) || !e3.pushAny(r3[1]))
                  return false;
            } else
              for (const t3 of super.entries())
                if (!e3.push(n2.from(t3[0], "base64")) || !e3.pushAny(t3[1]))
                  return false;
            return true;
          }
        }
        e2.exports = a;
      }, 3095: (e2, t2, r2) => {
        "use strict";
        const { ArrayPrototypePop: n2, Promise: i } = r2(4134), { isIterable: o, isNodeStream: s, isWebStream: a } = r2(6115), { pipelineImpl: l } = r2(7758), { finished: u } = r2(6238);
        r2(5506), e2.exports = { finished: u, pipeline: function(...e3) {
          return new i((t3, r3) => {
            let i2, u2;
            const c = e3[e3.length - 1];
            if (c && "object" == typeof c && !s(c) && !o(c) && !a(c)) {
              const t4 = n2(e3);
              i2 = t4.signal, u2 = t4.end;
            }
            l(e3, (e4, n3) => {
              e4 ? r3(e4) : t3(n3);
            }, { signal: i2, end: u2 });
          });
        } };
      }, 3141: (e2, t2, r2) => {
        "use strict";
        var n2 = r2(2861).Buffer, i = n2.isEncoding || function(e3) {
          switch ((e3 = "" + e3) && e3.toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
              return true;
            default:
              return false;
          }
        };
        function o(e3) {
          var t3;
          switch (this.encoding = function(e4) {
            var t4 = function(e5) {
              if (!e5)
                return "utf8";
              for (var t5; ; )
                switch (e5) {
                  case "utf8":
                  case "utf-8":
                    return "utf8";
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return "utf16le";
                  case "latin1":
                  case "binary":
                    return "latin1";
                  case "base64":
                  case "ascii":
                  case "hex":
                    return e5;
                  default:
                    if (t5)
                      return;
                    e5 = ("" + e5).toLowerCase(), t5 = true;
                }
            }(e4);
            if ("string" != typeof t4 && (n2.isEncoding === i || !i(e4)))
              throw new Error("Unknown encoding: " + e4);
            return t4 || e4;
          }(e3), this.encoding) {
            case "utf16le":
              this.text = l, this.end = u, t3 = 4;
              break;
            case "utf8":
              this.fillLast = a, t3 = 4;
              break;
            case "base64":
              this.text = c, this.end = f, t3 = 3;
              break;
            default:
              return this.write = h, void (this.end = d);
          }
          this.lastNeed = 0, this.lastTotal = 0, this.lastChar = n2.allocUnsafe(t3);
        }
        function s(e3) {
          return e3 <= 127 ? 0 : e3 >> 5 == 6 ? 2 : e3 >> 4 == 14 ? 3 : e3 >> 3 == 30 ? 4 : e3 >> 6 == 2 ? -1 : -2;
        }
        function a(e3) {
          var t3 = this.lastTotal - this.lastNeed, r3 = function(e4, t4) {
            if (128 != (192 & t4[0]))
              return e4.lastNeed = 0, "";
            if (e4.lastNeed > 1 && t4.length > 1) {
              if (128 != (192 & t4[1]))
                return e4.lastNeed = 1, "";
              if (e4.lastNeed > 2 && t4.length > 2 && 128 != (192 & t4[2]))
                return e4.lastNeed = 2, "";
            }
          }(this, e3);
          return void 0 !== r3 ? r3 : this.lastNeed <= e3.length ? (e3.copy(this.lastChar, t3, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (e3.copy(this.lastChar, t3, 0, e3.length), void (this.lastNeed -= e3.length));
        }
        function l(e3, t3) {
          if ((e3.length - t3) % 2 == 0) {
            var r3 = e3.toString("utf16le", t3);
            if (r3) {
              var n3 = r3.charCodeAt(r3.length - 1);
              if (n3 >= 55296 && n3 <= 56319)
                return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e3[e3.length - 2], this.lastChar[1] = e3[e3.length - 1], r3.slice(0, -1);
            }
            return r3;
          }
          return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e3[e3.length - 1], e3.toString("utf16le", t3, e3.length - 1);
        }
        function u(e3) {
          var t3 = e3 && e3.length ? this.write(e3) : "";
          if (this.lastNeed) {
            var r3 = this.lastTotal - this.lastNeed;
            return t3 + this.lastChar.toString("utf16le", 0, r3);
          }
          return t3;
        }
        function c(e3, t3) {
          var r3 = (e3.length - t3) % 3;
          return 0 === r3 ? e3.toString("base64", t3) : (this.lastNeed = 3 - r3, this.lastTotal = 3, 1 === r3 ? this.lastChar[0] = e3[e3.length - 1] : (this.lastChar[0] = e3[e3.length - 2], this.lastChar[1] = e3[e3.length - 1]), e3.toString("base64", t3, e3.length - r3));
        }
        function f(e3) {
          var t3 = e3 && e3.length ? this.write(e3) : "";
          return this.lastNeed ? t3 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t3;
        }
        function h(e3) {
          return e3.toString(this.encoding);
        }
        function d(e3) {
          return e3 && e3.length ? this.write(e3) : "";
        }
        t2.StringDecoder = o, o.prototype.write = function(e3) {
          if (0 === e3.length)
            return "";
          var t3, r3;
          if (this.lastNeed) {
            if (void 0 === (t3 = this.fillLast(e3)))
              return "";
            r3 = this.lastNeed, this.lastNeed = 0;
          } else
            r3 = 0;
          return r3 < e3.length ? t3 ? t3 + this.text(e3, r3) : this.text(e3, r3) : t3 || "";
        }, o.prototype.end = function(e3) {
          var t3 = e3 && e3.length ? this.write(e3) : "";
          return this.lastNeed ? t3 + "" : t3;
        }, o.prototype.text = function(e3, t3) {
          var r3 = function(e4, t4, r4) {
            var n4 = t4.length - 1;
            if (n4 < r4)
              return 0;
            var i2 = s(t4[n4]);
            return i2 >= 0 ? (i2 > 0 && (e4.lastNeed = i2 - 1), i2) : --n4 < r4 || -2 === i2 ? 0 : (i2 = s(t4[n4])) >= 0 ? (i2 > 0 && (e4.lastNeed = i2 - 2), i2) : --n4 < r4 || -2 === i2 ? 0 : (i2 = s(t4[n4])) >= 0 ? (i2 > 0 && (2 === i2 ? i2 = 0 : e4.lastNeed = i2 - 3), i2) : 0;
          }(this, e3, t3);
          if (!this.lastNeed)
            return e3.toString("utf8", t3);
          this.lastTotal = r3;
          var n3 = e3.length - (r3 - this.lastNeed);
          return e3.copy(this.lastChar, 0, n3), e3.toString("utf8", t3, n3);
        }, o.prototype.fillLast = function(e3) {
          if (this.lastNeed <= e3.length)
            return e3.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
          e3.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e3.length), this.lastNeed -= e3.length;
        };
      }, 3370: (e2, t2, r2) => {
        "use strict";
        const { ObjectDefineProperties: n2, ObjectGetOwnPropertyDescriptor: i, ObjectKeys: o, ObjectSetPrototypeOf: s } = r2(4134);
        e2.exports = u;
        const a = r2(7576), l = r2(8584);
        s(u.prototype, a.prototype), s(u, a);
        {
          const e3 = o(l.prototype);
          for (let t3 = 0; t3 < e3.length; t3++) {
            const r3 = e3[t3];
            u.prototype[r3] || (u.prototype[r3] = l.prototype[r3]);
          }
        }
        function u(e3) {
          if (!(this instanceof u))
            return new u(e3);
          a.call(this, e3), l.call(this, e3), e3 ? (this.allowHalfOpen = false !== e3.allowHalfOpen, false === e3.readable && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), false === e3.writable && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true)) : this.allowHalfOpen = true;
        }
        let c, f;
        function h() {
          return void 0 === c && (c = {}), c;
        }
        n2(u.prototype, { writable: { __proto__: null, ...i(l.prototype, "writable") }, writableHighWaterMark: { __proto__: null, ...i(l.prototype, "writableHighWaterMark") }, writableObjectMode: { __proto__: null, ...i(l.prototype, "writableObjectMode") }, writableBuffer: { __proto__: null, ...i(l.prototype, "writableBuffer") }, writableLength: { __proto__: null, ...i(l.prototype, "writableLength") }, writableFinished: { __proto__: null, ...i(l.prototype, "writableFinished") }, writableCorked: { __proto__: null, ...i(l.prototype, "writableCorked") }, writableEnded: { __proto__: null, ...i(l.prototype, "writableEnded") }, writableNeedDrain: { __proto__: null, ...i(l.prototype, "writableNeedDrain") }, destroyed: { __proto__: null, get() {
          return void 0 !== this._readableState && void 0 !== this._writableState && this._readableState.destroyed && this._writableState.destroyed;
        }, set(e3) {
          this._readableState && this._writableState && (this._readableState.destroyed = e3, this._writableState.destroyed = e3);
        } } }), u.fromWeb = function(e3, t3) {
          return h().newStreamDuplexFromReadableWritablePair(e3, t3);
        }, u.toWeb = function(e3) {
          return h().newReadableWritablePairFromDuplex(e3);
        }, u.from = function(e3) {
          return f || (f = r2(6706)), f(e3, "body");
        };
      }, 3557: (e2, t2, r2) => {
        "use strict";
        const n2 = r2(9452), i = r2(7328), o = Symbol("INTERNAL_JSON");
        function s(e3, t3) {
          if (i.isBufferish(e3))
            e3.toJSON = t3;
          else if (Array.isArray(e3))
            for (const r3 of e3)
              s(r3, t3);
          else if (e3 && "object" == typeof e3 && (!(e3 instanceof p) || e3.tag < 21 || e3.tag > 23))
            for (const r3 of Object.values(e3))
              s(r3, t3);
        }
        function a() {
          return i.base64(this);
        }
        function l() {
          return i.base64url(this);
        }
        function u() {
          return this.toString("hex");
        }
        const c = { 0: (e3) => new Date(e3), 1: (e3) => new Date(1e3 * e3), 2: (e3) => i.bufferToBigInt(e3), 3: (e3) => n2.BI.MINUS_ONE - i.bufferToBigInt(e3), 21: (e3, t3) => (i.isBufferish(e3) ? t3[o] = l : s(e3, l), t3), 22: (e3, t3) => (i.isBufferish(e3) ? t3[o] = a : s(e3, a), t3), 23: (e3, t3) => (i.isBufferish(e3) ? t3[o] = u : s(e3, u), t3), 32: (e3) => new URL(e3), 33: (e3, t3) => {
          if (!e3.match(/^[a-zA-Z0-9_-]+$/))
            throw new Error("Invalid base64url characters");
          const r3 = e3.length % 4;
          if (1 === r3)
            throw new Error("Invalid base64url length");
          if (2 === r3) {
            if (-1 === "AQgw".indexOf(e3[e3.length - 1]))
              throw new Error("Invalid base64 padding");
          } else if (3 === r3 && -1 === "AEIMQUYcgkosw048".indexOf(e3[e3.length - 1]))
            throw new Error("Invalid base64 padding");
          return t3;
        }, 34: (e3, t3) => {
          const r3 = e3.match(/^[a-zA-Z0-9+/]+(?<padding>={0,2})$/);
          if (!r3)
            throw new Error("Invalid base64 characters");
          if (e3.length % 4 != 0)
            throw new Error("Invalid base64 length");
          if ("=" === r3.groups.padding) {
            if (-1 === "AQgw".indexOf(e3[e3.length - 2]))
              throw new Error("Invalid base64 padding");
          } else if ("==" === r3.groups.padding && -1 === "AEIMQUYcgkosw048".indexOf(e3[e3.length - 3]))
            throw new Error("Invalid base64 padding");
          return t3;
        }, 35: (e3) => new RegExp(e3), 258: (e3) => new Set(e3) }, f = { 64: Uint8Array, 65: Uint16Array, 66: Uint32Array, 68: Uint8ClampedArray, 69: Uint16Array, 70: Uint32Array, 72: Int8Array, 73: Int16Array, 74: Int32Array, 77: Int16Array, 78: Int32Array, 81: Float32Array, 82: Float64Array, 85: Float32Array, 86: Float64Array };
        function h(e3, t3) {
          if (!i.isBufferish(e3))
            throw new TypeError("val not a buffer");
          const { tag: r3 } = t3, n3 = f[r3];
          if (!n3)
            throw new Error(`Invalid typed array tag: ${r3}`);
          const o2 = 2 ** (((16 & r3) >> 4) + (3 & r3));
          return !(4 & r3) !== i.isBigEndian() && o2 > 1 && function(e4, t4, r4, n4) {
            const i2 = new DataView(e4), [o3, s2] = { 2: [i2.getUint16, i2.setUint16], 4: [i2.getUint32, i2.setUint32], 8: [i2.getBigUint64, i2.setBigUint64] }[t4], a2 = r4 + n4;
            for (let e5 = r4; e5 < a2; e5 += t4)
              s2.call(i2, e5, o3.call(i2, e5, true));
          }(e3.buffer, o2, e3.byteOffset, e3.byteLength), new n3(e3.buffer.slice(e3.byteOffset, e3.byteOffset + e3.byteLength));
        }
        "undefined" != typeof BigUint64Array && (f[67] = BigUint64Array, f[71] = BigUint64Array), "undefined" != typeof BigInt64Array && (f[75] = BigInt64Array, f[79] = BigInt64Array);
        for (const e3 of Object.keys(f))
          c[e3] = h;
        let d = {};
        class p {
          constructor(e3, t3, r3) {
            if (this.tag = e3, this.value = t3, this.err = r3, "number" != typeof this.tag)
              throw new Error(`Invalid tag type (${typeof this.tag})`);
            if (this.tag < 0 || (0 | this.tag) !== this.tag)
              throw new Error(`Tag must be a positive integer: ${this.tag}`);
          }
          toJSON() {
            if (this[o])
              return this[o].call(this.value);
            const e3 = { tag: this.tag, value: this.value };
            return this.err && (e3.err = this.err), e3;
          }
          toString() {
            return `${this.tag}(${JSON.stringify(this.value)})`;
          }
          encodeCBOR(e3) {
            return e3._pushTag(this.tag), e3.pushAny(this.value);
          }
          convert(e3) {
            let t3 = null == e3 ? void 0 : e3[this.tag];
            if (null === t3)
              return this;
            if ("function" != typeof t3 && (t3 = p.TAGS[this.tag], "function" != typeof t3))
              return this;
            try {
              return t3.call(this, this.value, this);
            } catch (e4) {
              return e4 && e4.message && e4.message.length > 0 ? this.err = e4.message : this.err = e4, this;
            }
          }
          static get TAGS() {
            return d;
          }
          static set TAGS(e3) {
            d = e3;
          }
          static reset() {
            p.TAGS = { ...c };
          }
        }
        p.INTERNAL_JSON = o, p.reset(), e2.exports = p;
      }, 3600: (e2, t2, r2) => {
        "use strict";
        e2.exports = r2(5506).PassThrough;
      }, 3737: (e2, t2, r2) => {
        "use strict";
        const n2 = r2(4957), i = r2(3557), o = r2(5059), s = r2(7328), a = r2(672), l = r2(9452), { MT: u, NUMBYTES: c, SYMS: f, BI: h } = l, { Buffer: d } = r2(8287), p = Symbol("count"), b = Symbol("major type"), y = Symbol("error"), g = Symbol("not found");
        function w(e3, t3, r3) {
          const n3 = [];
          return n3[p] = r3, n3[f.PARENT] = e3, n3[b] = t3, n3;
        }
        function _(e3, t3) {
          const r3 = new a();
          return r3[p] = -1, r3[f.PARENT] = e3, r3[b] = t3, r3;
        }
        class m extends Error {
          constructor(e3, t3) {
            super(`Unexpected data: 0x${e3.toString(16)}`), this.name = "UnexpectedDataError", this.byte = e3, this.value = t3;
          }
        }
        function E(e3, t3) {
          switch (typeof e3) {
            case "function":
              return { options: {}, cb: e3 };
            case "string":
              return { options: { encoding: e3 }, cb: t3 };
            case "object":
              return { options: e3 || {}, cb: t3 };
            default:
              throw new TypeError("Unknown option type");
          }
        }
        class S extends n2 {
          constructor(e3 = {}) {
            const { tags: t3 = {}, max_depth: r3 = -1, preferMap: n3 = false, preferWeb: i2 = false, required: o2 = false, encoding: s2 = "hex", extendedResults: l2 = false, preventDuplicateKeys: u2 = false, ...c2 } = e3;
            super({ defaultEncoding: s2, ...c2 }), this.running = true, this.max_depth = r3, this.tags = t3, this.preferMap = n3, this.preferWeb = i2, this.extendedResults = l2, this.required = o2, this.preventDuplicateKeys = u2, l2 && (this.bs.on("read", this._onRead.bind(this)), this.valueBytes = new a());
          }
          static nullcheck(e3) {
            switch (e3) {
              case f.NULL:
                return null;
              case f.UNDEFINED:
                return;
              case g:
                throw new Error("Value not found");
              default:
                return e3;
            }
          }
          static decodeFirstSync(e3, t3 = {}) {
            if (null == e3)
              throw new TypeError("input required");
            ({ options: t3 } = E(t3));
            const { encoding: r3 = "hex", ...n3 } = t3, i2 = new S(n3), o2 = s.guessEncoding(e3, r3), a2 = i2._parse();
            let l2 = a2.next();
            for (; !l2.done; ) {
              const e4 = o2.read(l2.value);
              if (null == e4 || e4.length !== l2.value)
                throw new Error("Insufficient data");
              i2.extendedResults && i2.valueBytes.write(e4), l2 = a2.next(e4);
            }
            let u2 = null;
            if (i2.extendedResults)
              u2 = l2.value, u2.unused = o2.read();
            else if (u2 = S.nullcheck(l2.value), o2.length > 0) {
              const e4 = o2.read(1);
              throw o2.unshift(e4), new m(e4[0], u2);
            }
            return u2;
          }
          static decodeAllSync(e3, t3 = {}) {
            if (null == e3)
              throw new TypeError("input required");
            ({ options: t3 } = E(t3));
            const { encoding: r3 = "hex", ...n3 } = t3, i2 = new S(n3), o2 = s.guessEncoding(e3, r3), a2 = [];
            for (; o2.length > 0; ) {
              const e4 = i2._parse();
              let t4 = e4.next();
              for (; !t4.done; ) {
                const r4 = o2.read(t4.value);
                if (null == r4 || r4.length !== t4.value)
                  throw new Error("Insufficient data");
                i2.extendedResults && i2.valueBytes.write(r4), t4 = e4.next(r4);
              }
              a2.push(S.nullcheck(t4.value));
            }
            return a2;
          }
          static decodeFirst(e3, t3 = {}, r3 = null) {
            if (null == e3)
              throw new TypeError("input required");
            ({ options: t3, cb: r3 } = E(t3, r3));
            const { encoding: n3 = "hex", required: i2 = false, ...o2 } = t3, a2 = new S(o2);
            let l2 = g;
            const u2 = s.guessEncoding(e3, n3), c2 = new Promise((e4, t4) => {
              a2.on("data", (e5) => {
                l2 = S.nullcheck(e5), a2.close();
              }), a2.once("error", (r4) => a2.extendedResults && r4 instanceof m ? (l2.unused = a2.bs.slice(), e4(l2)) : (l2 !== g && (r4.value = l2), l2 = y, a2.close(), t4(r4))), a2.once("end", () => {
                switch (l2) {
                  case g:
                    return i2 ? t4(new Error("No CBOR found")) : e4(l2);
                  case y:
                    return;
                  default:
                    return e4(l2);
                }
              });
            });
            return "function" == typeof r3 && c2.then((e4) => r3(null, e4), r3), u2.pipe(a2), c2;
          }
          static decodeAll(e3, t3 = {}, r3 = null) {
            if (null == e3)
              throw new TypeError("input required");
            ({ options: t3, cb: r3 } = E(t3, r3));
            const { encoding: n3 = "hex", ...i2 } = t3, o2 = new S(i2), a2 = [];
            o2.on("data", (e4) => a2.push(S.nullcheck(e4)));
            const l2 = new Promise((e4, t4) => {
              o2.on("error", t4), o2.on("end", () => e4(a2));
            });
            return "function" == typeof r3 && l2.then((e4) => r3(void 0, e4), (e4) => r3(e4, void 0)), s.guessEncoding(e3, n3).pipe(o2), l2;
          }
          close() {
            this.running = false, this.__fresh = true;
          }
          _onRead(e3) {
            this.valueBytes.write(e3);
          }
          *_parse() {
            let e3 = null, t3 = 0, r3 = null;
            for (; ; ) {
              if (this.max_depth >= 0 && t3 > this.max_depth)
                throw new Error(`Maximum depth ${this.max_depth} exceeded`);
              const [n3] = yield 1;
              if (!this.running)
                throw this.bs.unshift(d.from([n3])), new m(n3);
              const l2 = n3 >> 5, y2 = 31 & n3, g2 = null == e3 ? void 0 : e3[b], E2 = null == e3 ? void 0 : e3.length;
              switch (y2) {
                case c.ONE:
                  this.emit("more-bytes", l2, 1, g2, E2), [r3] = yield 1;
                  break;
                case c.TWO:
                case c.FOUR:
                case c.EIGHT: {
                  const e4 = 1 << y2 - 24;
                  this.emit("more-bytes", l2, e4, g2, E2);
                  const t4 = yield e4;
                  r3 = l2 === u.SIMPLE_FLOAT ? t4 : s.parseCBORint(y2, t4);
                  break;
                }
                case 28:
                case 29:
                case 30:
                  throw this.running = false, new Error(`Additional info not implemented: ${y2}`);
                case c.INDEFINITE:
                  switch (l2) {
                    case u.POS_INT:
                    case u.NEG_INT:
                    case u.TAG:
                      throw new Error(`Invalid indefinite encoding for MT ${l2}`);
                  }
                  r3 = -1;
                  break;
                default:
                  r3 = y2;
              }
              switch (l2) {
                case u.POS_INT:
                  break;
                case u.NEG_INT:
                  r3 = r3 === Number.MAX_SAFE_INTEGER ? h.NEG_MAX : "bigint" == typeof r3 ? h.MINUS_ONE - r3 : -1 - r3;
                  break;
                case u.BYTE_STRING:
                case u.UTF8_STRING:
                  switch (r3) {
                    case 0:
                      this.emit("start-string", l2, r3, g2, E2), r3 = l2 === u.UTF8_STRING ? "" : this.preferWeb ? new Uint8Array(0) : d.allocUnsafe(0);
                      break;
                    case -1:
                      this.emit("start", l2, f.STREAM, g2, E2), e3 = _(e3, l2), t3++;
                      continue;
                    default:
                      this.emit("start-string", l2, r3, g2, E2), r3 = yield r3, l2 === u.UTF8_STRING ? r3 = s.utf8(r3) : this.preferWeb && (r3 = new Uint8Array(r3.buffer, r3.byteOffset, r3.length));
                  }
                  break;
                case u.ARRAY:
                case u.MAP:
                  switch (r3) {
                    case 0:
                      r3 = l2 === u.MAP ? this.preferMap ? /* @__PURE__ */ new Map() : {} : [];
                      break;
                    case -1:
                      this.emit("start", l2, f.STREAM, g2, E2), e3 = w(e3, l2, -1), t3++;
                      continue;
                    default:
                      this.emit("start", l2, r3, g2, E2), e3 = w(e3, l2, r3 * (l2 - 3)), t3++;
                      continue;
                  }
                  break;
                case u.TAG:
                  this.emit("start", l2, r3, g2, E2), e3 = w(e3, l2, 1), e3.push(r3), t3++;
                  continue;
                case u.SIMPLE_FLOAT:
                  if ("number" == typeof r3) {
                    if (y2 === c.ONE && r3 < 32)
                      throw new Error(`Invalid two-byte encoding of simple value ${r3}`);
                    const t4 = null != e3;
                    r3 = o.decode(r3, t4, t4 && e3[p] < 0);
                  } else
                    r3 = s.parseCBORfloat(r3);
              }
              this.emit("value", r3, g2, E2, y2);
              let v = false;
              for (; null != e3; ) {
                if (r3 === f.BREAK)
                  e3[p] = 1;
                else if (Array.isArray(e3))
                  e3.push(r3);
                else {
                  const t4 = e3[b];
                  if (null != t4 && t4 !== l2)
                    throw this.running = false, new Error("Invalid major type in indefinite encoding");
                  e3.write(r3);
                }
                if (0 !== --e3[p]) {
                  v = true;
                  break;
                }
                if (--t3, delete e3[p], Array.isArray(e3))
                  switch (e3[b]) {
                    case u.ARRAY:
                      r3 = e3;
                      break;
                    case u.MAP: {
                      let t4 = !this.preferMap;
                      if (e3.length % 2 != 0)
                        throw new Error(`Invalid map length: ${e3.length}`);
                      for (let r4 = 0, n5 = e3.length; t4 && r4 < n5; r4 += 2)
                        if ("string" != typeof e3[r4] || "__proto__" === e3[r4]) {
                          t4 = false;
                          break;
                        }
                      if (t4) {
                        r3 = {};
                        for (let t5 = 0, n5 = e3.length; t5 < n5; t5 += 2) {
                          if (this.preventDuplicateKeys && Object.prototype.hasOwnProperty.call(r3, e3[t5]))
                            throw new Error("Duplicate keys in a map");
                          r3[e3[t5]] = e3[t5 + 1];
                        }
                      } else {
                        r3 = /* @__PURE__ */ new Map();
                        for (let t5 = 0, n5 = e3.length; t5 < n5; t5 += 2) {
                          if (this.preventDuplicateKeys && r3.has(e3[t5]))
                            throw new Error("Duplicate keys in a map");
                          r3.set(e3[t5], e3[t5 + 1]);
                        }
                      }
                      break;
                    }
                    case u.TAG:
                      r3 = new i(e3[0], e3[1]).convert(this.tags);
                  }
                else if (e3 instanceof a)
                  switch (e3[b]) {
                    case u.BYTE_STRING:
                      r3 = e3.slice(), this.preferWeb && (r3 = new Uint8Array(r3.buffer, r3.byteOffset, r3.length));
                      break;
                    case u.UTF8_STRING:
                      r3 = e3.toString("utf-8");
                  }
                this.emit("stop", e3[b]);
                const n4 = e3;
                e3 = e3[f.PARENT], delete n4[f.PARENT], delete n4[b];
              }
              if (!v) {
                if (this.extendedResults) {
                  const e4 = this.valueBytes.slice(), t4 = { value: S.nullcheck(r3), bytes: e4, length: e4.length };
                  return this.valueBytes = new a(), t4;
                }
                return r3;
              }
            }
          }
        }
        S.NOT_FOUND = g, e2.exports = S;
      }, 4134: (e2) => {
        "use strict";
        class t2 extends Error {
          constructor(e3) {
            if (!Array.isArray(e3))
              throw new TypeError("Expected input to be an Array, got " + typeof e3);
            let t3 = "";
            for (let r2 = 0; r2 < e3.length; r2++)
              t3 += `    ${e3[r2].stack}
`;
            super(t3), this.name = "AggregateError", this.errors = e3;
          }
        }
        e2.exports = { AggregateError: t2, ArrayIsArray: (e3) => Array.isArray(e3), ArrayPrototypeIncludes: (e3, t3) => e3.includes(t3), ArrayPrototypeIndexOf: (e3, t3) => e3.indexOf(t3), ArrayPrototypeJoin: (e3, t3) => e3.join(t3), ArrayPrototypeMap: (e3, t3) => e3.map(t3), ArrayPrototypePop: (e3, t3) => e3.pop(t3), ArrayPrototypePush: (e3, t3) => e3.push(t3), ArrayPrototypeSlice: (e3, t3, r2) => e3.slice(t3, r2), Error, FunctionPrototypeCall: (e3, t3, ...r2) => e3.call(t3, ...r2), FunctionPrototypeSymbolHasInstance: (e3, t3) => Function.prototype[Symbol.hasInstance].call(e3, t3), MathFloor: Math.floor, Number, NumberIsInteger: Number.isInteger, NumberIsNaN: Number.isNaN, NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER, NumberParseInt: Number.parseInt, ObjectDefineProperties: (e3, t3) => Object.defineProperties(e3, t3), ObjectDefineProperty: (e3, t3, r2) => Object.defineProperty(e3, t3, r2), ObjectGetOwnPropertyDescriptor: (e3, t3) => Object.getOwnPropertyDescriptor(e3, t3), ObjectKeys: (e3) => Object.keys(e3), ObjectSetPrototypeOf: (e3, t3) => Object.setPrototypeOf(e3, t3), Promise, PromisePrototypeCatch: (e3, t3) => e3.catch(t3), PromisePrototypeThen: (e3, t3, r2) => e3.then(t3, r2), PromiseReject: (e3) => Promise.reject(e3), PromiseResolve: (e3) => Promise.resolve(e3), ReflectApply: Reflect.apply, RegExpPrototypeTest: (e3, t3) => e3.test(t3), SafeSet: Set, String, StringPrototypeSlice: (e3, t3, r2) => e3.slice(t3, r2), StringPrototypeToLowerCase: (e3) => e3.toLowerCase(), StringPrototypeToUpperCase: (e3) => e3.toUpperCase(), StringPrototypeTrim: (e3) => e3.trim(), Symbol, SymbolFor: Symbol.for, SymbolAsyncIterator: Symbol.asyncIterator, SymbolHasInstance: Symbol.hasInstance, SymbolIterator: Symbol.iterator, SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"), SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"), TypedArrayPrototypeSet: (e3, t3, r2) => e3.set(t3, r2), Boolean, Uint8Array };
      }, 4147: (e2, t2, r2) => {
        "use strict";
        const { SymbolDispose: n2 } = r2(4134), { AbortError: i, codes: o } = r2(6371), { isNodeStream: s, isWebStream: a, kControllerErrorFunction: l } = r2(6115), u = r2(6238), { ERR_INVALID_ARG_TYPE: c } = o;
        let f;
        e2.exports.addAbortSignal = function(t3, r3) {
          if (((e3) => {
            if ("object" != typeof e3 || !("aborted" in e3))
              throw new c("signal", "AbortSignal", e3);
          })(t3), !s(r3) && !a(r3))
            throw new c("stream", ["ReadableStream", "WritableStream", "Stream"], r3);
          return e2.exports.addAbortSignalNoValidate(t3, r3);
        }, e2.exports.addAbortSignalNoValidate = function(e3, t3) {
          if ("object" != typeof e3 || !("aborted" in e3))
            return t3;
          const o2 = s(t3) ? () => {
            t3.destroy(new i(void 0, { cause: e3.reason }));
          } : () => {
            t3[l](new i(void 0, { cause: e3.reason }));
          };
          if (e3.aborted)
            o2();
          else {
            f = f || r2(7760).addAbortListener;
            const i2 = f(e3, o2);
            u(t3, i2[n2]);
          }
          return t3;
        };
      }, 4259: (e2, t2, r2) => {
        "use strict";
        const { ArrayIsArray: n2, ObjectSetPrototypeOf: i } = r2(4134), { EventEmitter: o } = r2(7007);
        function s(e3) {
          o.call(this, e3);
        }
        function a(e3, t3, r3) {
          if ("function" == typeof e3.prependListener)
            return e3.prependListener(t3, r3);
          e3._events && e3._events[t3] ? n2(e3._events[t3]) ? e3._events[t3].unshift(r3) : e3._events[t3] = [r3, e3._events[t3]] : e3.on(t3, r3);
        }
        i(s.prototype, o.prototype), i(s, o), s.prototype.pipe = function(e3, t3) {
          const r3 = this;
          function n3(t4) {
            e3.writable && false === e3.write(t4) && r3.pause && r3.pause();
          }
          function i2() {
            r3.readable && r3.resume && r3.resume();
          }
          r3.on("data", n3), e3.on("drain", i2), e3._isStdio || t3 && false === t3.end || (r3.on("end", l), r3.on("close", u));
          let s2 = false;
          function l() {
            s2 || (s2 = true, e3.end());
          }
          function u() {
            s2 || (s2 = true, "function" == typeof e3.destroy && e3.destroy());
          }
          function c(e4) {
            f(), 0 === o.listenerCount(this, "error") && this.emit("error", e4);
          }
          function f() {
            r3.removeListener("data", n3), e3.removeListener("drain", i2), r3.removeListener("end", l), r3.removeListener("close", u), r3.removeListener("error", c), e3.removeListener("error", c), r3.removeListener("end", f), r3.removeListener("close", f), e3.removeListener("close", f);
          }
          return a(r3, "error", c), a(e3, "error", c), r3.on("end", f), r3.on("close", f), e3.on("close", f), e3.emit("pipe", r3), e3;
        }, e2.exports = { Stream: s, prependListener: a };
      }, 4610: (e2, t2, r2) => {
        "use strict";
        e2.exports = r2(5506).Transform;
      }, 4957: (e2, t2, r2) => {
        "use strict";
        const n2 = r2(8310), i = r2(672);
        class o extends n2.Transform {
          constructor(e3) {
            super(e3), this._writableState.objectMode = false, this._readableState.objectMode = true, this.bs = new i(), this.__restart();
          }
          _transform(e3, t3, r3) {
            for (this.bs.write(e3); this.bs.length >= this.__needed; ) {
              let e4 = null;
              const t4 = null === this.__needed ? void 0 : this.bs.read(this.__needed);
              try {
                e4 = this.__parser.next(t4);
              } catch (e5) {
                return r3(e5);
              }
              this.__needed && (this.__fresh = false), e4.done ? (this.push(e4.value), this.__restart()) : this.__needed = e4.value || 1 / 0;
            }
            return r3();
          }
          *_parse() {
            throw new Error("Must be implemented in subclass");
          }
          __restart() {
            this.__needed = null, this.__parser = this._parse(), this.__fresh = true;
          }
          _flush(e3) {
            e3(this.__fresh ? null : new Error("unexpected end of input"));
          }
        }
        e2.exports = o;
      }, 5059: (e2, t2, r2) => {
        "use strict";
        const { MT: n2, SIMPLE: i, SYMS: o } = r2(9452);
        class s {
          constructor(e3) {
            if ("number" != typeof e3)
              throw new Error("Invalid Simple type: " + typeof e3);
            if (e3 < 0 || e3 > 255 || (0 | e3) !== e3)
              throw new Error(`value must be a small positive integer: ${e3}`);
            this.value = e3;
          }
          toString() {
            return `simple(${this.value})`;
          }
          [Symbol.for("nodejs.util.inspect.custom")](e3, t3) {
            return `simple(${this.value})`;
          }
          encodeCBOR(e3) {
            return e3._pushInt(this.value, n2.SIMPLE_FLOAT);
          }
          static isSimple(e3) {
            return e3 instanceof s;
          }
          static decode(e3, t3 = true, r3 = false) {
            switch (e3) {
              case i.FALSE:
                return false;
              case i.TRUE:
                return true;
              case i.NULL:
                return t3 ? null : o.NULL;
              case i.UNDEFINED:
                if (t3)
                  return;
                return o.UNDEFINED;
              case -1:
                if (!t3 || !r3)
                  throw new Error("Invalid BREAK");
                return o.BREAK;
              default:
                return new s(e3);
            }
          }
        }
        e2.exports = s;
      }, 5291: (e2, t2, r2) => {
        "use strict";
        const { MathFloor: n2, NumberIsInteger: i } = r2(4134), { validateInteger: o } = r2(277), { ERR_INVALID_ARG_VALUE: s } = r2(6371).codes;
        let a = 16384, l = 16;
        function u(e3) {
          return e3 ? l : a;
        }
        e2.exports = { getHighWaterMark: function(e3, t3, r3, o2) {
          const a2 = function(e4, t4, r4) {
            return null != e4.highWaterMark ? e4.highWaterMark : t4 ? e4[r4] : null;
          }(t3, o2, r3);
          if (null != a2) {
            if (!i(a2) || a2 < 0)
              throw new s(o2 ? `options.${r3}` : "options.highWaterMark", a2);
            return n2(a2);
          }
          return u(e3.objectMode);
        }, getDefaultHighWaterMark: u, setDefaultHighWaterMark: function(e3, t3) {
          o(t3, "value", 0), e3 ? l = t3 : a = t3;
        } };
      }, 5382: (e2, t2, r2) => {
        "use strict";
        e2.exports = r2(5506).Duplex;
      }, 5412: (e2, t2, r2) => {
        "use strict";
        e2.exports = r2(5506).Readable;
      }, 5506: (e2, t2, r2) => {
        "use strict";
        const { Buffer: n2 } = r2(8287), { ObjectDefineProperty: i, ObjectKeys: o, ReflectApply: s } = r2(4134), { promisify: { custom: a } } = r2(7760), { streamReturningOperators: l, promiseReturningOperators: u } = r2(823), { codes: { ERR_ILLEGAL_CONSTRUCTOR: c } } = r2(6371), f = r2(7830), { setDefaultHighWaterMark: h, getDefaultHighWaterMark: d } = r2(5291), { pipeline: p } = r2(7758), { destroyer: b } = r2(5896), y = r2(6238), g = r2(3095), w = r2(6115), _ = e2.exports = r2(4259).Stream;
        _.isDestroyed = w.isDestroyed, _.isDisturbed = w.isDisturbed, _.isErrored = w.isErrored, _.isReadable = w.isReadable, _.isWritable = w.isWritable, _.Readable = r2(7576);
        for (const E of o(l)) {
          let v = function(...e3) {
            if (new.target)
              throw c();
            return _.Readable.from(s(S, this, e3));
          };
          const S = l[E];
          i(v, "name", { __proto__: null, value: S.name }), i(v, "length", { __proto__: null, value: S.length }), i(_.Readable.prototype, E, { __proto__: null, value: v, enumerable: false, configurable: true, writable: true });
        }
        for (const A of o(u)) {
          let T = function(...e3) {
            if (new.target)
              throw c();
            return s(I, this, e3);
          };
          const I = u[A];
          i(T, "name", { __proto__: null, value: I.name }), i(T, "length", { __proto__: null, value: I.length }), i(_.Readable.prototype, A, { __proto__: null, value: T, enumerable: false, configurable: true, writable: true });
        }
        _.Writable = r2(8584), _.Duplex = r2(3370), _.Transform = r2(7382), _.PassThrough = r2(6524), _.pipeline = p;
        const { addAbortSignal: m } = r2(4147);
        _.addAbortSignal = m, _.finished = y, _.destroy = b, _.compose = f, _.setDefaultHighWaterMark = h, _.getDefaultHighWaterMark = d, i(_, "promises", { __proto__: null, configurable: true, enumerable: true, get: () => g }), i(p, a, { __proto__: null, enumerable: true, get: () => g.pipeline }), i(y, a, { __proto__: null, enumerable: true, get: () => g.finished }), _.Stream = _, _._isUint8Array = function(e3) {
          return e3 instanceof Uint8Array;
        }, _._uint8ArrayToBuffer = function(e3) {
          return n2.from(e3.buffer, e3.byteOffset, e3.byteLength);
        };
      }, 5568: (e2) => {
        "use strict";
        const { AbortController: t2, AbortSignal: r2 } = "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0;
        e2.exports = t2, e2.exports.AbortSignal = r2, e2.exports.default = t2;
      }, 5606: (e2) => {
        var t2, r2, n2 = e2.exports = {};
        function i() {
          throw new Error("setTimeout has not been defined");
        }
        function o() {
          throw new Error("clearTimeout has not been defined");
        }
        function s(e3) {
          if (t2 === setTimeout)
            return setTimeout(e3, 0);
          if ((t2 === i || !t2) && setTimeout)
            return t2 = setTimeout, setTimeout(e3, 0);
          try {
            return t2(e3, 0);
          } catch (r3) {
            try {
              return t2.call(null, e3, 0);
            } catch (r4) {
              return t2.call(this, e3, 0);
            }
          }
        }
        !function() {
          try {
            t2 = "function" == typeof setTimeout ? setTimeout : i;
          } catch (e3) {
            t2 = i;
          }
          try {
            r2 = "function" == typeof clearTimeout ? clearTimeout : o;
          } catch (e3) {
            r2 = o;
          }
        }();
        var a, l = [], u = false, c = -1;
        function f() {
          u && a && (u = false, a.length ? l = a.concat(l) : c = -1, l.length && h());
        }
        function h() {
          if (!u) {
            var e3 = s(f);
            u = true;
            for (var t3 = l.length; t3; ) {
              for (a = l, l = []; ++c < t3; )
                a && a[c].run();
              c = -1, t3 = l.length;
            }
            a = null, u = false, function(e4) {
              if (r2 === clearTimeout)
                return clearTimeout(e4);
              if ((r2 === o || !r2) && clearTimeout)
                return r2 = clearTimeout, clearTimeout(e4);
              try {
                return r2(e4);
              } catch (t4) {
                try {
                  return r2.call(null, e4);
                } catch (t5) {
                  return r2.call(this, e4);
                }
              }
            }(e3);
          }
        }
        function d(e3, t3) {
          this.fun = e3, this.array = t3;
        }
        function p() {
        }
        n2.nextTick = function(e3) {
          var t3 = new Array(arguments.length - 1);
          if (arguments.length > 1)
            for (var r3 = 1; r3 < arguments.length; r3++)
              t3[r3 - 1] = arguments[r3];
          l.push(new d(e3, t3)), 1 !== l.length || u || s(h);
        }, d.prototype.run = function() {
          this.fun.apply(null, this.array);
        }, n2.title = "browser", n2.browser = true, n2.env = {}, n2.argv = [], n2.version = "", n2.versions = {}, n2.on = p, n2.addListener = p, n2.once = p, n2.off = p, n2.removeListener = p, n2.removeAllListeners = p, n2.emit = p, n2.prependListener = p, n2.prependOnceListener = p, n2.listeners = function(e3) {
          return [];
        }, n2.binding = function(e3) {
          throw new Error("process.binding is not supported");
        }, n2.cwd = function() {
          return "/";
        }, n2.chdir = function(e3) {
          throw new Error("process.chdir is not supported");
        }, n2.umask = function() {
          return 0;
        };
      }, 5896: (e2, t2, r2) => {
        "use strict";
        const n2 = r2(5606), { aggregateTwoErrors: i, codes: { ERR_MULTIPLE_CALLBACK: o }, AbortError: s } = r2(6371), { Symbol: a } = r2(4134), { kIsDestroyed: l, isDestroyed: u, isFinished: c, isServerRequest: f } = r2(6115), h = a("kDestroy"), d = a("kConstruct");
        function p(e3, t3, r3) {
          e3 && (e3.stack, t3 && !t3.errored && (t3.errored = e3), r3 && !r3.errored && (r3.errored = e3));
        }
        function b(e3, t3, r3) {
          let i2 = false;
          function o2(t4) {
            if (i2)
              return;
            i2 = true;
            const o3 = e3._readableState, s2 = e3._writableState;
            p(t4, s2, o3), s2 && (s2.closed = true), o3 && (o3.closed = true), "function" == typeof r3 && r3(t4), t4 ? n2.nextTick(y, e3, t4) : n2.nextTick(g, e3);
          }
          try {
            e3._destroy(t3 || null, o2);
          } catch (t4) {
            o2(t4);
          }
        }
        function y(e3, t3) {
          w(e3, t3), g(e3);
        }
        function g(e3) {
          const t3 = e3._readableState, r3 = e3._writableState;
          r3 && (r3.closeEmitted = true), t3 && (t3.closeEmitted = true), (null != r3 && r3.emitClose || null != t3 && t3.emitClose) && e3.emit("close");
        }
        function w(e3, t3) {
          const r3 = e3._readableState, n3 = e3._writableState;
          null != n3 && n3.errorEmitted || null != r3 && r3.errorEmitted || (n3 && (n3.errorEmitted = true), r3 && (r3.errorEmitted = true), e3.emit("error", t3));
        }
        function _(e3, t3, r3) {
          const i2 = e3._readableState, o2 = e3._writableState;
          if (null != o2 && o2.destroyed || null != i2 && i2.destroyed)
            return this;
          null != i2 && i2.autoDestroy || null != o2 && o2.autoDestroy ? e3.destroy(t3) : t3 && (t3.stack, o2 && !o2.errored && (o2.errored = t3), i2 && !i2.errored && (i2.errored = t3), r3 ? n2.nextTick(w, e3, t3) : w(e3, t3));
        }
        function m(e3) {
          let t3 = false;
          function r3(r4) {
            if (t3)
              return void _(e3, null != r4 ? r4 : new o());
            t3 = true;
            const i2 = e3._readableState, s2 = e3._writableState, a2 = s2 || i2;
            i2 && (i2.constructed = true), s2 && (s2.constructed = true), a2.destroyed ? e3.emit(h, r4) : r4 ? _(e3, r4, true) : n2.nextTick(E, e3);
          }
          try {
            e3._construct((e4) => {
              n2.nextTick(r3, e4);
            });
          } catch (e4) {
            n2.nextTick(r3, e4);
          }
        }
        function E(e3) {
          e3.emit(d);
        }
        function S(e3) {
          return (null == e3 ? void 0 : e3.setHeader) && "function" == typeof e3.abort;
        }
        function v(e3) {
          e3.emit("close");
        }
        function A(e3, t3) {
          e3.emit("error", t3), n2.nextTick(v, e3);
        }
        e2.exports = { construct: function(e3, t3) {
          if ("function" != typeof e3._construct)
            return;
          const r3 = e3._readableState, i2 = e3._writableState;
          r3 && (r3.constructed = false), i2 && (i2.constructed = false), e3.once(d, t3), e3.listenerCount(d) > 1 || n2.nextTick(m, e3);
        }, destroyer: function(e3, t3) {
          e3 && !u(e3) && (t3 || c(e3) || (t3 = new s()), f(e3) ? (e3.socket = null, e3.destroy(t3)) : S(e3) ? e3.abort() : S(e3.req) ? e3.req.abort() : "function" == typeof e3.destroy ? e3.destroy(t3) : "function" == typeof e3.close ? e3.close() : t3 ? n2.nextTick(A, e3, t3) : n2.nextTick(v, e3), e3.destroyed || (e3[l] = true));
        }, destroy: function(e3, t3) {
          const r3 = this._readableState, n3 = this._writableState, o2 = n3 || r3;
          return null != n3 && n3.destroyed || null != r3 && r3.destroyed ? ("function" == typeof t3 && t3(), this) : (p(e3, n3, r3), n3 && (n3.destroyed = true), r3 && (r3.destroyed = true), o2.constructed ? b(this, e3, t3) : this.once(h, function(r4) {
            b(this, i(r4, e3), t3);
          }), this);
        }, undestroy: function() {
          const e3 = this._readableState, t3 = this._writableState;
          e3 && (e3.constructed = true, e3.closed = false, e3.closeEmitted = false, e3.destroyed = false, e3.errored = null, e3.errorEmitted = false, e3.reading = false, e3.ended = false === e3.readable, e3.endEmitted = false === e3.readable), t3 && (t3.constructed = true, t3.destroyed = false, t3.closed = false, t3.closeEmitted = false, t3.errored = null, t3.errorEmitted = false, t3.finalCalled = false, t3.prefinished = false, t3.ended = false === t3.writable, t3.ending = false === t3.writable, t3.finished = false === t3.writable);
        }, errorOrDestroy: _ };
      }, 6115: (e2, t2, r2) => {
        "use strict";
        const { SymbolAsyncIterator: n2, SymbolIterator: i, SymbolFor: o } = r2(4134), s = o("nodejs.stream.destroyed"), a = o("nodejs.stream.errored"), l = o("nodejs.stream.readable"), u = o("nodejs.stream.writable"), c = o("nodejs.stream.disturbed"), f = o("nodejs.webstream.isClosedPromise"), h = o("nodejs.webstream.controllerErrorFunction");
        function d(e3, t3 = false) {
          var r3;
          return !(!e3 || "function" != typeof e3.pipe || "function" != typeof e3.on || t3 && ("function" != typeof e3.pause || "function" != typeof e3.resume) || e3._writableState && false === (null === (r3 = e3._readableState) || void 0 === r3 ? void 0 : r3.readable) || e3._writableState && !e3._readableState);
        }
        function p(e3) {
          var t3;
          return !(!e3 || "function" != typeof e3.write || "function" != typeof e3.on || e3._readableState && false === (null === (t3 = e3._writableState) || void 0 === t3 ? void 0 : t3.writable));
        }
        function b(e3) {
          return e3 && (e3._readableState || e3._writableState || "function" == typeof e3.write && "function" == typeof e3.on || "function" == typeof e3.pipe && "function" == typeof e3.on);
        }
        function y(e3) {
          return !(!e3 || b(e3) || "function" != typeof e3.pipeThrough || "function" != typeof e3.getReader || "function" != typeof e3.cancel);
        }
        function g(e3) {
          return !(!e3 || b(e3) || "function" != typeof e3.getWriter || "function" != typeof e3.abort);
        }
        function w(e3) {
          return !(!e3 || b(e3) || "object" != typeof e3.readable || "object" != typeof e3.writable);
        }
        function _(e3) {
          if (!b(e3))
            return null;
          const t3 = e3._writableState, r3 = e3._readableState, n3 = t3 || r3;
          return !!(e3.destroyed || e3[s] || null != n3 && n3.destroyed);
        }
        function m(e3) {
          if (!p(e3))
            return null;
          if (true === e3.writableEnded)
            return true;
          const t3 = e3._writableState;
          return (null == t3 || !t3.errored) && ("boolean" != typeof (null == t3 ? void 0 : t3.ended) ? null : t3.ended);
        }
        function E(e3, t3) {
          if (!d(e3))
            return null;
          const r3 = e3._readableState;
          return (null == r3 || !r3.errored) && ("boolean" != typeof (null == r3 ? void 0 : r3.endEmitted) ? null : !!(r3.endEmitted || false === t3 && true === r3.ended && 0 === r3.length));
        }
        function S(e3) {
          return e3 && null != e3[l] ? e3[l] : "boolean" != typeof (null == e3 ? void 0 : e3.readable) ? null : !_(e3) && d(e3) && e3.readable && !E(e3);
        }
        function v(e3) {
          return e3 && null != e3[u] ? e3[u] : "boolean" != typeof (null == e3 ? void 0 : e3.writable) ? null : !_(e3) && p(e3) && e3.writable && !m(e3);
        }
        function A(e3) {
          return "boolean" == typeof e3._closed && "boolean" == typeof e3._defaultKeepAlive && "boolean" == typeof e3._removedConnection && "boolean" == typeof e3._removedContLen;
        }
        function I(e3) {
          return "boolean" == typeof e3._sent100 && A(e3);
        }
        e2.exports = { isDestroyed: _, kIsDestroyed: s, isDisturbed: function(e3) {
          var t3;
          return !(!e3 || !(null !== (t3 = e3[c]) && void 0 !== t3 ? t3 : e3.readableDidRead || e3.readableAborted));
        }, kIsDisturbed: c, isErrored: function(e3) {
          var t3, r3, n3, i2, o2, s2, l2, u2, c2, f2;
          return !(!e3 || !(null !== (t3 = null !== (r3 = null !== (n3 = null !== (i2 = null !== (o2 = null !== (s2 = e3[a]) && void 0 !== s2 ? s2 : e3.readableErrored) && void 0 !== o2 ? o2 : e3.writableErrored) && void 0 !== i2 ? i2 : null === (l2 = e3._readableState) || void 0 === l2 ? void 0 : l2.errorEmitted) && void 0 !== n3 ? n3 : null === (u2 = e3._writableState) || void 0 === u2 ? void 0 : u2.errorEmitted) && void 0 !== r3 ? r3 : null === (c2 = e3._readableState) || void 0 === c2 ? void 0 : c2.errored) && void 0 !== t3 ? t3 : null === (f2 = e3._writableState) || void 0 === f2 ? void 0 : f2.errored));
        }, kIsErrored: a, isReadable: S, kIsReadable: l, kIsClosedPromise: f, kControllerErrorFunction: h, kIsWritable: u, isClosed: function(e3) {
          if (!b(e3))
            return null;
          if ("boolean" == typeof e3.closed)
            return e3.closed;
          const t3 = e3._writableState, r3 = e3._readableState;
          return "boolean" == typeof (null == t3 ? void 0 : t3.closed) || "boolean" == typeof (null == r3 ? void 0 : r3.closed) ? (null == t3 ? void 0 : t3.closed) || (null == r3 ? void 0 : r3.closed) : "boolean" == typeof e3._closed && A(e3) ? e3._closed : null;
        }, isDuplexNodeStream: function(e3) {
          return !(!e3 || "function" != typeof e3.pipe || !e3._readableState || "function" != typeof e3.on || "function" != typeof e3.write);
        }, isFinished: function(e3, t3) {
          return b(e3) ? !(!_(e3) && (false !== (null == t3 ? void 0 : t3.readable) && S(e3) || false !== (null == t3 ? void 0 : t3.writable) && v(e3))) : null;
        }, isIterable: function(e3, t3) {
          return null != e3 && (true === t3 ? "function" == typeof e3[n2] : false === t3 ? "function" == typeof e3[i] : "function" == typeof e3[n2] || "function" == typeof e3[i]);
        }, isReadableNodeStream: d, isReadableStream: y, isReadableEnded: function(e3) {
          if (!d(e3))
            return null;
          if (true === e3.readableEnded)
            return true;
          const t3 = e3._readableState;
          return !(!t3 || t3.errored) && ("boolean" != typeof (null == t3 ? void 0 : t3.ended) ? null : t3.ended);
        }, isReadableFinished: E, isReadableErrored: function(e3) {
          var t3, r3;
          return b(e3) ? e3.readableErrored ? e3.readableErrored : null !== (t3 = null === (r3 = e3._readableState) || void 0 === r3 ? void 0 : r3.errored) && void 0 !== t3 ? t3 : null : null;
        }, isNodeStream: b, isWebStream: function(e3) {
          return y(e3) || g(e3) || w(e3);
        }, isWritable: v, isWritableNodeStream: p, isWritableStream: g, isWritableEnded: m, isWritableFinished: function(e3, t3) {
          if (!p(e3))
            return null;
          if (true === e3.writableFinished)
            return true;
          const r3 = e3._writableState;
          return (null == r3 || !r3.errored) && ("boolean" != typeof (null == r3 ? void 0 : r3.finished) ? null : !!(r3.finished || false === t3 && true === r3.ended && 0 === r3.length));
        }, isWritableErrored: function(e3) {
          var t3, r3;
          return b(e3) ? e3.writableErrored ? e3.writableErrored : null !== (t3 = null === (r3 = e3._writableState) || void 0 === r3 ? void 0 : r3.errored) && void 0 !== t3 ? t3 : null : null;
        }, isServerRequest: function(e3) {
          var t3;
          return "boolean" == typeof e3._consuming && "boolean" == typeof e3._dumped && void 0 === (null === (t3 = e3.req) || void 0 === t3 ? void 0 : t3.upgradeOrConnect);
        }, isServerResponse: I, willEmitClose: function(e3) {
          if (!b(e3))
            return null;
          const t3 = e3._writableState, r3 = e3._readableState, n3 = t3 || r3;
          return !n3 && I(e3) || !!(n3 && n3.autoDestroy && n3.emitClose && false === n3.closed);
        }, isTransformStream: w };
      }, 6238: (e2, t2, r2) => {
        "use strict";
        const n2 = r2(5606), { AbortError: i, codes: o } = r2(6371), { ERR_INVALID_ARG_TYPE: s, ERR_STREAM_PREMATURE_CLOSE: a } = o, { kEmptyObject: l, once: u } = r2(7760), { validateAbortSignal: c, validateFunction: f, validateObject: h, validateBoolean: d } = r2(277), { Promise: p, PromisePrototypeThen: b, SymbolDispose: y } = r2(4134), { isClosed: g, isReadable: w, isReadableNodeStream: _, isReadableStream: m, isReadableFinished: E, isReadableErrored: S, isWritable: v, isWritableNodeStream: A, isWritableStream: I, isWritableFinished: T, isWritableErrored: R, isNodeStream: B, willEmitClose: N, kIsClosedPromise: L } = r2(6115);
        let U;
        const M = () => {
        };
        function O(e3, t3, o2) {
          var d2, p2;
          if (2 === arguments.length ? (o2 = t3, t3 = l) : null == t3 ? t3 = l : h(t3, "options"), f(o2, "callback"), c(t3.signal, "options.signal"), o2 = u(o2), m(e3) || I(e3))
            return function(e4, t4, o3) {
              let s2 = false, a2 = M;
              if (t4.signal)
                if (a2 = () => {
                  s2 = true, o3.call(e4, new i(void 0, { cause: t4.signal.reason }));
                }, t4.signal.aborted)
                  n2.nextTick(a2);
                else {
                  U = U || r2(7760).addAbortListener;
                  const n3 = U(t4.signal, a2), i2 = o3;
                  o3 = u((...t5) => {
                    n3[y](), i2.apply(e4, t5);
                  });
                }
              const l2 = (...t5) => {
                s2 || n2.nextTick(() => o3.apply(e4, t5));
              };
              return b(e4[L].promise, l2, l2), M;
            }(e3, t3, o2);
          if (!B(e3))
            throw new s("stream", ["ReadableStream", "WritableStream", "Stream"], e3);
          const O2 = null !== (d2 = t3.readable) && void 0 !== d2 ? d2 : _(e3), x = null !== (p2 = t3.writable) && void 0 !== p2 ? p2 : A(e3), k = e3._writableState, P = e3._readableState, j = () => {
            e3.writable || C();
          };
          let D = N(e3) && _(e3) === O2 && A(e3) === x, F = T(e3, false);
          const C = () => {
            F = true, e3.destroyed && (D = false), (!D || e3.readable && !O2) && (O2 && !$ || o2.call(e3));
          };
          let $ = E(e3, false);
          const W = () => {
            $ = true, e3.destroyed && (D = false), (!D || e3.writable && !x) && (x && !F || o2.call(e3));
          }, G = (t4) => {
            o2.call(e3, t4);
          };
          let H = g(e3);
          const Y = () => {
            H = true;
            const t4 = R(e3) || S(e3);
            return t4 && "boolean" != typeof t4 ? o2.call(e3, t4) : O2 && !$ && _(e3, true) && !E(e3, false) ? o2.call(e3, new a()) : !x || F || T(e3, false) ? void o2.call(e3) : o2.call(e3, new a());
          }, V = () => {
            H = true;
            const t4 = R(e3) || S(e3);
            if (t4 && "boolean" != typeof t4)
              return o2.call(e3, t4);
            o2.call(e3);
          }, K = () => {
            e3.req.on("finish", C);
          };
          !function(e4) {
            return e4.setHeader && "function" == typeof e4.abort;
          }(e3) ? x && !k && (e3.on("end", j), e3.on("close", j)) : (e3.on("complete", C), D || e3.on("abort", Y), e3.req ? K() : e3.on("request", K)), D || "boolean" != typeof e3.aborted || e3.on("aborted", Y), e3.on("end", W), e3.on("finish", C), false !== t3.error && e3.on("error", G), e3.on("close", Y), H ? n2.nextTick(Y) : null != k && k.errorEmitted || null != P && P.errorEmitted ? D || n2.nextTick(V) : (O2 || D && !w(e3) || !F && false !== v(e3)) && (x || D && !v(e3) || !$ && false !== w(e3)) ? P && e3.req && e3.aborted && n2.nextTick(V) : n2.nextTick(V);
          const q = () => {
            o2 = M, e3.removeListener("aborted", Y), e3.removeListener("complete", C), e3.removeListener("abort", Y), e3.removeListener("request", K), e3.req && e3.req.removeListener("finish", C), e3.removeListener("end", j), e3.removeListener("close", j), e3.removeListener("finish", C), e3.removeListener("end", W), e3.removeListener("error", G), e3.removeListener("close", Y);
          };
          if (t3.signal && !H) {
            const s2 = () => {
              const r3 = o2;
              q(), r3.call(e3, new i(void 0, { cause: t3.signal.reason }));
            };
            if (t3.signal.aborted)
              n2.nextTick(s2);
            else {
              U = U || r2(7760).addAbortListener;
              const n3 = U(t3.signal, s2), i2 = o2;
              o2 = u((...t4) => {
                n3[y](), i2.apply(e3, t4);
              });
            }
          }
          return q;
        }
        e2.exports = O, e2.exports.finished = function(e3, t3) {
          var r3;
          let n3 = false;
          return null === t3 && (t3 = l), null !== (r3 = t3) && void 0 !== r3 && r3.cleanup && (d(t3.cleanup, "cleanup"), n3 = t3.cleanup), new p((r4, i2) => {
            const o2 = O(e3, t3, (e4) => {
              n3 && o2(), e4 ? i2(e4) : r4();
            });
          });
        };
      }, 6371: (e2, t2, r2) => {
        "use strict";
        const { format: n2, inspect: i } = r2(9231), { AggregateError: o } = r2(4134), s = globalThis.AggregateError || o, a = Symbol("kIsNodeError"), l = ["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"], u = /^([A-Z][a-z0-9]*)+$/, c = {};
        function f(e3, t3) {
          if (!e3)
            throw new c.ERR_INTERNAL_ASSERTION(t3);
        }
        function h(e3) {
          let t3 = "", r3 = e3.length;
          const n3 = "-" === e3[0] ? 1 : 0;
          for (; r3 >= n3 + 4; r3 -= 3)
            t3 = `_${e3.slice(r3 - 3, r3)}${t3}`;
          return `${e3.slice(0, r3)}${t3}`;
        }
        function d(e3, t3, r3) {
          r3 || (r3 = Error);
          class i2 extends r3 {
            constructor(...r4) {
              super(function(e4, t4, r5) {
                if ("function" == typeof t4)
                  return f(t4.length <= r5.length, `Code: ${e4}; The provided arguments length (${r5.length}) does not match the required ones (${t4.length}).`), t4(...r5);
                const i3 = (t4.match(/%[dfijoOs]/g) || []).length;
                return f(i3 === r5.length, `Code: ${e4}; The provided arguments length (${r5.length}) does not match the required ones (${i3}).`), 0 === r5.length ? t4 : n2(t4, ...r5);
              }(e3, t3, r4));
            }
            toString() {
              return `${this.name} [${e3}]: ${this.message}`;
            }
          }
          Object.defineProperties(i2.prototype, { name: { value: r3.name, writable: true, enumerable: false, configurable: true }, toString: { value() {
            return `${this.name} [${e3}]: ${this.message}`;
          }, writable: true, enumerable: false, configurable: true } }), i2.prototype.code = e3, i2.prototype[a] = true, c[e3] = i2;
        }
        function p(e3) {
          const t3 = "__node_internal_" + e3.name;
          return Object.defineProperty(e3, "name", { value: t3 }), e3;
        }
        class b extends Error {
          constructor(e3 = "The operation was aborted", t3 = void 0) {
            if (void 0 !== t3 && "object" != typeof t3)
              throw new c.ERR_INVALID_ARG_TYPE("options", "Object", t3);
            super(e3, t3), this.code = "ABORT_ERR", this.name = "AbortError";
          }
        }
        d("ERR_ASSERTION", "%s", Error), d("ERR_INVALID_ARG_TYPE", (e3, t3, r3) => {
          f("string" == typeof e3, "'name' must be a string"), Array.isArray(t3) || (t3 = [t3]);
          let n3 = "The ";
          e3.endsWith(" argument") ? n3 += `${e3} ` : n3 += `"${e3}" ${e3.includes(".") ? "property" : "argument"} `, n3 += "must be ";
          const o2 = [], s2 = [], a2 = [];
          for (const e4 of t3)
            f("string" == typeof e4, "All expected entries have to be of type string"), l.includes(e4) ? o2.push(e4.toLowerCase()) : u.test(e4) ? s2.push(e4) : (f("object" !== e4, 'The value "object" should be written as "Object"'), a2.push(e4));
          if (s2.length > 0) {
            const e4 = o2.indexOf("object");
            -1 !== e4 && (o2.splice(o2, e4, 1), s2.push("Object"));
          }
          if (o2.length > 0) {
            switch (o2.length) {
              case 1:
                n3 += `of type ${o2[0]}`;
                break;
              case 2:
                n3 += `one of type ${o2[0]} or ${o2[1]}`;
                break;
              default: {
                const e4 = o2.pop();
                n3 += `one of type ${o2.join(", ")}, or ${e4}`;
              }
            }
            (s2.length > 0 || a2.length > 0) && (n3 += " or ");
          }
          if (s2.length > 0) {
            switch (s2.length) {
              case 1:
                n3 += `an instance of ${s2[0]}`;
                break;
              case 2:
                n3 += `an instance of ${s2[0]} or ${s2[1]}`;
                break;
              default: {
                const e4 = s2.pop();
                n3 += `an instance of ${s2.join(", ")}, or ${e4}`;
              }
            }
            a2.length > 0 && (n3 += " or ");
          }
          switch (a2.length) {
            case 0:
              break;
            case 1:
              a2[0].toLowerCase() !== a2[0] && (n3 += "an "), n3 += `${a2[0]}`;
              break;
            case 2:
              n3 += `one of ${a2[0]} or ${a2[1]}`;
              break;
            default: {
              const e4 = a2.pop();
              n3 += `one of ${a2.join(", ")}, or ${e4}`;
            }
          }
          if (null == r3)
            n3 += `. Received ${r3}`;
          else if ("function" == typeof r3 && r3.name)
            n3 += `. Received function ${r3.name}`;
          else if ("object" == typeof r3) {
            var c2;
            null !== (c2 = r3.constructor) && void 0 !== c2 && c2.name ? n3 += `. Received an instance of ${r3.constructor.name}` : n3 += `. Received ${i(r3, { depth: -1 })}`;
          } else {
            let e4 = i(r3, { colors: false });
            e4.length > 25 && (e4 = `${e4.slice(0, 25)}...`), n3 += `. Received type ${typeof r3} (${e4})`;
          }
          return n3;
        }, TypeError), d("ERR_INVALID_ARG_VALUE", (e3, t3, r3 = "is invalid") => {
          let n3 = i(t3);
          return n3.length > 128 && (n3 = n3.slice(0, 128) + "..."), `The ${e3.includes(".") ? "property" : "argument"} '${e3}' ${r3}. Received ${n3}`;
        }, TypeError), d("ERR_INVALID_RETURN_VALUE", (e3, t3, r3) => {
          var n3;
          return `Expected ${e3} to be returned from the "${t3}" function but got ${null != r3 && null !== (n3 = r3.constructor) && void 0 !== n3 && n3.name ? `instance of ${r3.constructor.name}` : "type " + typeof r3}.`;
        }, TypeError), d("ERR_MISSING_ARGS", (...e3) => {
          let t3;
          f(e3.length > 0, "At least one arg needs to be specified");
          const r3 = e3.length;
          switch (e3 = (Array.isArray(e3) ? e3 : [e3]).map((e4) => `"${e4}"`).join(" or "), r3) {
            case 1:
              t3 += `The ${e3[0]} argument`;
              break;
            case 2:
              t3 += `The ${e3[0]} and ${e3[1]} arguments`;
              break;
            default: {
              const r4 = e3.pop();
              t3 += `The ${e3.join(", ")}, and ${r4} arguments`;
            }
          }
          return `${t3} must be specified`;
        }, TypeError), d("ERR_OUT_OF_RANGE", (e3, t3, r3) => {
          let n3;
          if (f(t3, 'Missing "range" argument'), Number.isInteger(r3) && Math.abs(r3) > 2 ** 32)
            n3 = h(String(r3));
          else if ("bigint" == typeof r3) {
            n3 = String(r3);
            const e4 = BigInt(2) ** BigInt(32);
            (r3 > e4 || r3 < -e4) && (n3 = h(n3)), n3 += "n";
          } else
            n3 = i(r3);
          return `The value of "${e3}" is out of range. It must be ${t3}. Received ${n3}`;
        }, RangeError), d("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error), d("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error), d("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error), d("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error), d("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error), d("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), d("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error), d("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error), d("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error), d("ERR_STREAM_WRITE_AFTER_END", "write after end", Error), d("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError), e2.exports = { AbortError: b, aggregateTwoErrors: p(function(e3, t3) {
          if (e3 && t3 && e3 !== t3) {
            if (Array.isArray(t3.errors))
              return t3.errors.push(e3), t3;
            const r3 = new s([t3, e3], t3.message);
            return r3.code = t3.code, r3;
          }
          return e3 || t3;
        }), hideStackFrames: p, codes: c };
      }, 6524: (e2, t2, r2) => {
        "use strict";
        const { ObjectSetPrototypeOf: n2 } = r2(4134);
        e2.exports = o;
        const i = r2(7382);
        function o(e3) {
          if (!(this instanceof o))
            return new o(e3);
          i.call(this, e3);
        }
        n2(o.prototype, i.prototype), n2(o, i), o.prototype._transform = function(e3, t3, r3) {
          r3(null, e3);
        };
      }, 6532: (e2, t2, r2) => {
        "use strict";
        const n2 = r2(5606), { PromisePrototypeThen: i, SymbolAsyncIterator: o, SymbolIterator: s } = r2(4134), { Buffer: a } = r2(8287), { ERR_INVALID_ARG_TYPE: l, ERR_STREAM_NULL_VALUES: u } = r2(6371).codes;
        e2.exports = function(e3, t3, r3) {
          let c, f;
          if ("string" == typeof t3 || t3 instanceof a)
            return new e3({ objectMode: true, ...r3, read() {
              this.push(t3), this.push(null);
            } });
          if (t3 && t3[o])
            f = true, c = t3[o]();
          else {
            if (!t3 || !t3[s])
              throw new l("iterable", ["Iterable"], t3);
            f = false, c = t3[s]();
          }
          const h = new e3({ objectMode: true, highWaterMark: 1, ...r3 });
          let d = false;
          return h._read = function() {
            d || (d = true, async function() {
              for (; ; ) {
                try {
                  const { value: e4, done: t4 } = f ? await c.next() : c.next();
                  if (t4)
                    h.push(null);
                  else {
                    const t5 = e4 && "function" == typeof e4.then ? await e4 : e4;
                    if (null === t5)
                      throw d = false, new u();
                    if (h.push(t5))
                      continue;
                    d = false;
                  }
                } catch (e4) {
                  h.destroy(e4);
                }
                break;
              }
            }());
          }, h._destroy = function(e4, t4) {
            i(async function(e5) {
              const t5 = null != e5, r4 = "function" == typeof c.throw;
              if (t5 && r4) {
                const { value: t6, done: r5 } = await c.throw(e5);
                if (await t6, r5)
                  return;
              }
              if ("function" == typeof c.return) {
                const { value: e6 } = await c.return();
                await e6;
              }
            }(e4), () => n2.nextTick(t4, e4), (r4) => n2.nextTick(t4, r4 || e4));
          }, h;
        };
      }, 6698: (e2) => {
        "function" == typeof Object.create ? e2.exports = function(e3, t2) {
          t2 && (e3.super_ = t2, e3.prototype = Object.create(t2.prototype, { constructor: { value: e3, enumerable: false, writable: true, configurable: true } }));
        } : e2.exports = function(e3, t2) {
          if (t2) {
            e3.super_ = t2;
            var r2 = function() {
            };
            r2.prototype = t2.prototype, e3.prototype = new r2(), e3.prototype.constructor = e3;
          }
        };
      }, 6706: (e2, t2, r2) => {
        const n2 = r2(5606), i = r2(8287), { isReadable: o, isWritable: s, isIterable: a, isNodeStream: l, isReadableNodeStream: u, isWritableNodeStream: c, isDuplexNodeStream: f, isReadableStream: h, isWritableStream: d } = r2(6115), p = r2(6238), { AbortError: b, codes: { ERR_INVALID_ARG_TYPE: y, ERR_INVALID_RETURN_VALUE: g } } = r2(6371), { destroyer: w } = r2(5896), _ = r2(3370), m = r2(7576), E = r2(8584), { createDeferredPromise: S } = r2(7760), v = r2(6532), A = globalThis.Blob || i.Blob, I = void 0 !== A ? function(e3) {
          return e3 instanceof A;
        } : function(e3) {
          return false;
        }, T = globalThis.AbortController || r2(5568).AbortController, { FunctionPrototypeCall: R } = r2(4134);
        class B extends _ {
          constructor(e3) {
            super(e3), false === (null == e3 ? void 0 : e3.readable) && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), false === (null == e3 ? void 0 : e3.writable) && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true);
          }
        }
        function N(e3) {
          const t3 = e3.readable && "function" != typeof e3.readable.read ? m.wrap(e3.readable) : e3.readable, r3 = e3.writable;
          let n3, i2, a2, l2, u2, c2 = !!o(t3), f2 = !!s(r3);
          function h2(e4) {
            const t4 = l2;
            l2 = null, t4 ? t4(e4) : e4 && u2.destroy(e4);
          }
          return u2 = new B({ readableObjectMode: !(null == t3 || !t3.readableObjectMode), writableObjectMode: !(null == r3 || !r3.writableObjectMode), readable: c2, writable: f2 }), f2 && (p(r3, (e4) => {
            f2 = false, e4 && w(t3, e4), h2(e4);
          }), u2._write = function(e4, t4, i3) {
            r3.write(e4, t4) ? i3() : n3 = i3;
          }, u2._final = function(e4) {
            r3.end(), i2 = e4;
          }, r3.on("drain", function() {
            if (n3) {
              const e4 = n3;
              n3 = null, e4();
            }
          }), r3.on("finish", function() {
            if (i2) {
              const e4 = i2;
              i2 = null, e4();
            }
          })), c2 && (p(t3, (e4) => {
            c2 = false, e4 && w(t3, e4), h2(e4);
          }), t3.on("readable", function() {
            if (a2) {
              const e4 = a2;
              a2 = null, e4();
            }
          }), t3.on("end", function() {
            u2.push(null);
          }), u2._read = function() {
            for (; ; ) {
              const e4 = t3.read();
              if (null === e4)
                return void (a2 = u2._read);
              if (!u2.push(e4))
                return;
            }
          }), u2._destroy = function(e4, o2) {
            e4 || null === l2 || (e4 = new b()), a2 = null, n3 = null, i2 = null, null === l2 ? o2(e4) : (l2 = o2, w(r3, e4), w(t3, e4));
          }, u2;
        }
        e2.exports = function e3(t3, r3) {
          if (f(t3))
            return t3;
          if (u(t3))
            return N({ readable: t3 });
          if (c(t3))
            return N({ writable: t3 });
          if (l(t3))
            return N({ writable: false, readable: false });
          if (h(t3))
            return N({ readable: m.fromWeb(t3) });
          if (d(t3))
            return N({ writable: E.fromWeb(t3) });
          if ("function" == typeof t3) {
            const { value: e4, write: i3, final: o2, destroy: s2 } = function(e5) {
              let { promise: t4, resolve: r4 } = S();
              const i4 = new T(), o3 = i4.signal;
              return { value: e5(async function* () {
                for (; ; ) {
                  const e6 = t4;
                  t4 = null;
                  const { chunk: i5, done: s3, cb: a2 } = await e6;
                  if (n2.nextTick(a2), s3)
                    return;
                  if (o3.aborted)
                    throw new b(void 0, { cause: o3.reason });
                  ({ promise: t4, resolve: r4 } = S()), yield i5;
                }
              }(), { signal: o3 }), write(e6, t5, n3) {
                const i5 = r4;
                r4 = null, i5({ chunk: e6, done: false, cb: n3 });
              }, final(e6) {
                const t5 = r4;
                r4 = null, t5({ done: true, cb: e6 });
              }, destroy(e6, t5) {
                i4.abort(), t5(e6);
              } };
            }(t3);
            if (a(e4))
              return v(B, e4, { objectMode: true, write: i3, final: o2, destroy: s2 });
            const l2 = null == e4 ? void 0 : e4.then;
            if ("function" == typeof l2) {
              let t4;
              const r4 = R(l2, e4, (e5) => {
                if (null != e5)
                  throw new g("nully", "body", e5);
              }, (e5) => {
                w(t4, e5);
              });
              return t4 = new B({ objectMode: true, readable: false, write: i3, final(e5) {
                o2(async () => {
                  try {
                    await r4, n2.nextTick(e5, null);
                  } catch (t5) {
                    n2.nextTick(e5, t5);
                  }
                });
              }, destroy: s2 });
            }
            throw new g("Iterable, AsyncIterable or AsyncFunction", r3, e4);
          }
          if (I(t3))
            return e3(t3.arrayBuffer());
          if (a(t3))
            return v(B, t3, { objectMode: true, writable: false });
          if (h(null == t3 ? void 0 : t3.readable) && d(null == t3 ? void 0 : t3.writable))
            return B.fromWeb(t3);
          if ("object" == typeof (null == t3 ? void 0 : t3.writable) || "object" == typeof (null == t3 ? void 0 : t3.readable))
            return N({ readable: null != t3 && t3.readable ? u(null == t3 ? void 0 : t3.readable) ? null == t3 ? void 0 : t3.readable : e3(t3.readable) : void 0, writable: null != t3 && t3.writable ? c(null == t3 ? void 0 : t3.writable) ? null == t3 ? void 0 : t3.writable : e3(t3.writable) : void 0 });
          const i2 = null == t3 ? void 0 : t3.then;
          if ("function" == typeof i2) {
            let e4;
            return R(i2, t3, (t4) => {
              null != t4 && e4.push(t4), e4.push(null);
            }, (t4) => {
              w(e4, t4);
            }), e4 = new B({ objectMode: true, writable: false, read() {
            } });
          }
          throw new y(r3, ["Blob", "ReadableStream", "WritableStream", "Stream", "Iterable", "AsyncIterable", "Function", "{ readable, writable } pair", "Promise"], t3);
        };
      }, 6708: (e2, t2, r2) => {
        "use strict";
        e2.exports = r2(5506).Writable;
      }, 7007: (e2) => {
        "use strict";
        var t2, r2 = "object" == typeof Reflect ? Reflect : null, n2 = r2 && "function" == typeof r2.apply ? r2.apply : function(e3, t3, r3) {
          return Function.prototype.apply.call(e3, t3, r3);
        };
        t2 = r2 && "function" == typeof r2.ownKeys ? r2.ownKeys : Object.getOwnPropertySymbols ? function(e3) {
          return Object.getOwnPropertyNames(e3).concat(Object.getOwnPropertySymbols(e3));
        } : function(e3) {
          return Object.getOwnPropertyNames(e3);
        };
        var i = Number.isNaN || function(e3) {
          return e3 != e3;
        };
        function o() {
          o.init.call(this);
        }
        e2.exports = o, e2.exports.once = function(e3, t3) {
          return new Promise(function(r3, n3) {
            function i2(r4) {
              e3.removeListener(t3, o2), n3(r4);
            }
            function o2() {
              "function" == typeof e3.removeListener && e3.removeListener("error", i2), r3([].slice.call(arguments));
            }
            b(e3, t3, o2, { once: true }), "error" !== t3 && function(e4, t4) {
              "function" == typeof e4.on && b(e4, "error", t4, { once: true });
            }(e3, i2);
          });
        }, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
        var s = 10;
        function a(e3) {
          if ("function" != typeof e3)
            throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e3);
        }
        function l(e3) {
          return void 0 === e3._maxListeners ? o.defaultMaxListeners : e3._maxListeners;
        }
        function u(e3, t3, r3, n3) {
          var i2, o2, s2, u2;
          if (a(r3), void 0 === (o2 = e3._events) ? (o2 = e3._events = /* @__PURE__ */ Object.create(null), e3._eventsCount = 0) : (void 0 !== o2.newListener && (e3.emit("newListener", t3, r3.listener ? r3.listener : r3), o2 = e3._events), s2 = o2[t3]), void 0 === s2)
            s2 = o2[t3] = r3, ++e3._eventsCount;
          else if ("function" == typeof s2 ? s2 = o2[t3] = n3 ? [r3, s2] : [s2, r3] : n3 ? s2.unshift(r3) : s2.push(r3), (i2 = l(e3)) > 0 && s2.length > i2 && !s2.warned) {
            s2.warned = true;
            var c2 = new Error("Possible EventEmitter memory leak detected. " + s2.length + " " + String(t3) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            c2.name = "MaxListenersExceededWarning", c2.emitter = e3, c2.type = t3, c2.count = s2.length, u2 = c2, console && console.warn && console.warn(u2);
          }
          return e3;
        }
        function c() {
          if (!this.fired)
            return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
        }
        function f(e3, t3, r3) {
          var n3 = { fired: false, wrapFn: void 0, target: e3, type: t3, listener: r3 }, i2 = c.bind(n3);
          return i2.listener = r3, n3.wrapFn = i2, i2;
        }
        function h(e3, t3, r3) {
          var n3 = e3._events;
          if (void 0 === n3)
            return [];
          var i2 = n3[t3];
          return void 0 === i2 ? [] : "function" == typeof i2 ? r3 ? [i2.listener || i2] : [i2] : r3 ? function(e4) {
            for (var t4 = new Array(e4.length), r4 = 0; r4 < t4.length; ++r4)
              t4[r4] = e4[r4].listener || e4[r4];
            return t4;
          }(i2) : p(i2, i2.length);
        }
        function d(e3) {
          var t3 = this._events;
          if (void 0 !== t3) {
            var r3 = t3[e3];
            if ("function" == typeof r3)
              return 1;
            if (void 0 !== r3)
              return r3.length;
          }
          return 0;
        }
        function p(e3, t3) {
          for (var r3 = new Array(t3), n3 = 0; n3 < t3; ++n3)
            r3[n3] = e3[n3];
          return r3;
        }
        function b(e3, t3, r3, n3) {
          if ("function" == typeof e3.on)
            n3.once ? e3.once(t3, r3) : e3.on(t3, r3);
          else {
            if ("function" != typeof e3.addEventListener)
              throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e3);
            e3.addEventListener(t3, function i2(o2) {
              n3.once && e3.removeEventListener(t3, i2), r3(o2);
            });
          }
        }
        Object.defineProperty(o, "defaultMaxListeners", { enumerable: true, get: function() {
          return s;
        }, set: function(e3) {
          if ("number" != typeof e3 || e3 < 0 || i(e3))
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e3 + ".");
          s = e3;
        } }), o.init = function() {
          void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
        }, o.prototype.setMaxListeners = function(e3) {
          if ("number" != typeof e3 || e3 < 0 || i(e3))
            throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e3 + ".");
          return this._maxListeners = e3, this;
        }, o.prototype.getMaxListeners = function() {
          return l(this);
        }, o.prototype.emit = function(e3) {
          for (var t3 = [], r3 = 1; r3 < arguments.length; r3++)
            t3.push(arguments[r3]);
          var i2 = "error" === e3, o2 = this._events;
          if (void 0 !== o2)
            i2 = i2 && void 0 === o2.error;
          else if (!i2)
            return false;
          if (i2) {
            var s2;
            if (t3.length > 0 && (s2 = t3[0]), s2 instanceof Error)
              throw s2;
            var a2 = new Error("Unhandled error." + (s2 ? " (" + s2.message + ")" : ""));
            throw a2.context = s2, a2;
          }
          var l2 = o2[e3];
          if (void 0 === l2)
            return false;
          if ("function" == typeof l2)
            n2(l2, this, t3);
          else {
            var u2 = l2.length, c2 = p(l2, u2);
            for (r3 = 0; r3 < u2; ++r3)
              n2(c2[r3], this, t3);
          }
          return true;
        }, o.prototype.addListener = function(e3, t3) {
          return u(this, e3, t3, false);
        }, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(e3, t3) {
          return u(this, e3, t3, true);
        }, o.prototype.once = function(e3, t3) {
          return a(t3), this.on(e3, f(this, e3, t3)), this;
        }, o.prototype.prependOnceListener = function(e3, t3) {
          return a(t3), this.prependListener(e3, f(this, e3, t3)), this;
        }, o.prototype.removeListener = function(e3, t3) {
          var r3, n3, i2, o2, s2;
          if (a(t3), void 0 === (n3 = this._events))
            return this;
          if (void 0 === (r3 = n3[e3]))
            return this;
          if (r3 === t3 || r3.listener === t3)
            0 === --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete n3[e3], n3.removeListener && this.emit("removeListener", e3, r3.listener || t3));
          else if ("function" != typeof r3) {
            for (i2 = -1, o2 = r3.length - 1; o2 >= 0; o2--)
              if (r3[o2] === t3 || r3[o2].listener === t3) {
                s2 = r3[o2].listener, i2 = o2;
                break;
              }
            if (i2 < 0)
              return this;
            0 === i2 ? r3.shift() : function(e4, t4) {
              for (; t4 + 1 < e4.length; t4++)
                e4[t4] = e4[t4 + 1];
              e4.pop();
            }(r3, i2), 1 === r3.length && (n3[e3] = r3[0]), void 0 !== n3.removeListener && this.emit("removeListener", e3, s2 || t3);
          }
          return this;
        }, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function(e3) {
          var t3, r3, n3;
          if (void 0 === (r3 = this._events))
            return this;
          if (void 0 === r3.removeListener)
            return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== r3[e3] && (0 === --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete r3[e3]), this;
          if (0 === arguments.length) {
            var i2, o2 = Object.keys(r3);
            for (n3 = 0; n3 < o2.length; ++n3)
              "removeListener" !== (i2 = o2[n3]) && this.removeAllListeners(i2);
            return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
          }
          if ("function" == typeof (t3 = r3[e3]))
            this.removeListener(e3, t3);
          else if (void 0 !== t3)
            for (n3 = t3.length - 1; n3 >= 0; n3--)
              this.removeListener(e3, t3[n3]);
          return this;
        }, o.prototype.listeners = function(e3) {
          return h(this, e3, true);
        }, o.prototype.rawListeners = function(e3) {
          return h(this, e3, false);
        }, o.listenerCount = function(e3, t3) {
          return "function" == typeof e3.listenerCount ? e3.listenerCount(t3) : d.call(e3, t3);
        }, o.prototype.listenerCount = d, o.prototype.eventNames = function() {
          return this._eventsCount > 0 ? t2(this._events) : [];
        };
      }, 7328: (e2, t2, r2) => {
        "use strict";
        const { Buffer: n2 } = r2(8287), i = r2(672), o = r2(8310), s = r2(9452), { NUMBYTES: a, SHIFT32: l, BI: u, SYMS: c } = s, f = new TextDecoder("utf8", { fatal: true, ignoreBOM: true });
        t2.utf8 = (e3) => f.decode(e3), t2.utf8.checksUTF8 = true, t2.isBufferish = function(e3) {
          return e3 && "object" == typeof e3 && (n2.isBuffer(e3) || e3 instanceof Uint8Array || e3 instanceof Uint8ClampedArray || e3 instanceof ArrayBuffer || e3 instanceof DataView);
        }, t2.bufferishToBuffer = function(e3) {
          return n2.isBuffer(e3) ? e3 : ArrayBuffer.isView(e3) ? n2.from(e3.buffer, e3.byteOffset, e3.byteLength) : e3 instanceof ArrayBuffer ? n2.from(e3) : null;
        }, t2.parseCBORint = function(e3, t3) {
          switch (e3) {
            case a.ONE:
              return t3.readUInt8(0);
            case a.TWO:
              return t3.readUInt16BE(0);
            case a.FOUR:
              return t3.readUInt32BE(0);
            case a.EIGHT: {
              const e4 = t3.readUInt32BE(0), r3 = t3.readUInt32BE(4);
              return e4 > 2097151 ? BigInt(e4) * u.SHIFT32 + BigInt(r3) : e4 * l + r3;
            }
            default:
              throw new Error(`Invalid additional info for int: ${e3}`);
          }
        }, t2.writeHalf = function(e3, t3) {
          const r3 = n2.allocUnsafe(4);
          r3.writeFloatBE(t3, 0);
          const i2 = r3.readUInt32BE(0);
          if (8191 & i2)
            return false;
          let o2 = i2 >> 16 & 32768;
          const s2 = i2 >> 23 & 255, a2 = 8388607 & i2;
          if (s2 >= 113 && s2 <= 142)
            o2 += (s2 - 112 << 10) + (a2 >> 13);
          else {
            if (!(s2 >= 103 && s2 < 113))
              return false;
            if (a2 & (1 << 126 - s2) - 1)
              return false;
            o2 += a2 + 8388608 >> 126 - s2;
          }
          return e3.writeUInt16BE(o2), true;
        }, t2.parseHalf = function(e3) {
          const t3 = 128 & e3[0] ? -1 : 1, r3 = (124 & e3[0]) >> 2, n3 = (3 & e3[0]) << 8 | e3[1];
          return r3 ? 31 === r3 ? t3 * (n3 ? NaN : 1 / 0) : t3 * 2 ** (r3 - 25) * (1024 + n3) : 5960464477539063e-23 * t3 * n3;
        }, t2.parseCBORfloat = function(e3) {
          switch (e3.length) {
            case 2:
              return t2.parseHalf(e3);
            case 4:
              return e3.readFloatBE(0);
            case 8:
              return e3.readDoubleBE(0);
            default:
              throw new Error(`Invalid float size: ${e3.length}`);
          }
        }, t2.hex = function(e3) {
          return n2.from(e3.replace(/^0x/, ""), "hex");
        }, t2.bin = function(e3) {
          let t3 = 0, r3 = (e3 = e3.replace(/\s/g, "")).length % 8 || 8;
          const i2 = [];
          for (; r3 <= e3.length; )
            i2.push(parseInt(e3.slice(t3, r3), 2)), t3 = r3, r3 += 8;
          return n2.from(i2);
        }, t2.arrayEqual = function(e3, t3) {
          return null == e3 && null == t3 || null != e3 && null != t3 && e3.length === t3.length && e3.every((e4, r3) => e4 === t3[r3]);
        }, t2.bufferToBigInt = function(e3) {
          return BigInt(`0x${e3.toString("hex")}`);
        }, t2.cborValueToString = function(e3, r3 = -1) {
          switch (typeof e3) {
            case "symbol": {
              switch (e3) {
                case c.NULL:
                  return "null";
                case c.UNDEFINED:
                  return "undefined";
                case c.BREAK:
                  return "BREAK";
              }
              if (e3.description)
                return e3.description;
              const t3 = e3.toString().match(/^Symbol\((?<name>.*)\)/);
              return t3 && t3.groups.name ? t3.groups.name : "Symbol";
            }
            case "string":
              return JSON.stringify(e3);
            case "bigint":
              return e3.toString();
            case "number": {
              const t3 = Object.is(e3, -0) ? "-0" : String(e3);
              return r3 > 0 ? `${t3}_${r3}` : t3;
            }
            case "object": {
              if (!e3)
                return "null";
              const n3 = t2.bufferishToBuffer(e3);
              if (n3) {
                const e4 = n3.toString("hex");
                return r3 === -1 / 0 ? e4 : `h'${e4}'`;
              }
              return e3 && "function" == typeof e3[Symbol.for("nodejs.util.inspect.custom")] ? e3[Symbol.for("nodejs.util.inspect.custom")]() : Array.isArray(e3) ? "[]" : "{}";
            }
          }
          return String(e3);
        }, t2.guessEncoding = function(e3, r3) {
          if ("string" == typeof e3)
            return new i(e3, null == r3 ? "hex" : r3);
          const n3 = t2.bufferishToBuffer(e3);
          if (n3)
            return new i(n3);
          if ((s2 = e3) instanceof o.Readable || ["read", "on", "pipe"].every((e4) => "function" == typeof s2[e4]))
            return e3;
          var s2;
          throw new Error("Unknown input type");
        };
        const h = { "=": "", "+": "-", "/": "_" };
        t2.base64url = function(e3) {
          return t2.bufferishToBuffer(e3).toString("base64").replace(/[=+/]/g, (e4) => h[e4]);
        }, t2.base64 = function(e3) {
          return t2.bufferishToBuffer(e3).toString("base64");
        }, t2.isBigEndian = function() {
          const e3 = new Uint8Array(4);
          return !((new Uint32Array(e3.buffer)[0] = 1) & e3[0]);
        };
      }, 7382: (e2, t2, r2) => {
        "use strict";
        const { ObjectSetPrototypeOf: n2, Symbol: i } = r2(4134);
        e2.exports = u;
        const { ERR_METHOD_NOT_IMPLEMENTED: o } = r2(6371).codes, s = r2(3370), { getHighWaterMark: a } = r2(5291);
        n2(u.prototype, s.prototype), n2(u, s);
        const l = i("kCallback");
        function u(e3) {
          if (!(this instanceof u))
            return new u(e3);
          const t3 = e3 ? a(this, e3, "readableHighWaterMark", true) : null;
          0 === t3 && (e3 = { ...e3, highWaterMark: null, readableHighWaterMark: t3, writableHighWaterMark: e3.writableHighWaterMark || 0 }), s.call(this, e3), this._readableState.sync = false, this[l] = null, e3 && ("function" == typeof e3.transform && (this._transform = e3.transform), "function" == typeof e3.flush && (this._flush = e3.flush)), this.on("prefinish", f);
        }
        function c(e3) {
          "function" != typeof this._flush || this.destroyed ? (this.push(null), e3 && e3()) : this._flush((t3, r3) => {
            t3 ? e3 ? e3(t3) : this.destroy(t3) : (null != r3 && this.push(r3), this.push(null), e3 && e3());
          });
        }
        function f() {
          this._final !== c && c.call(this);
        }
        u.prototype._final = c, u.prototype._transform = function(e3, t3, r3) {
          throw new o("_transform()");
        }, u.prototype._write = function(e3, t3, r3) {
          const n3 = this._readableState, i2 = this._writableState, o2 = n3.length;
          this._transform(e3, t3, (e4, t4) => {
            e4 ? r3(e4) : (null != t4 && this.push(t4), i2.ended || o2 === n3.length || n3.length < n3.highWaterMark ? r3() : this[l] = r3);
          });
        }, u.prototype._read = function() {
          if (this[l]) {
            const e3 = this[l];
            this[l] = null, e3();
          }
        };
      }, 7526: (e2, t2) => {
        "use strict";
        t2.byteLength = function(e3) {
          var t3 = a(e3), r3 = t3[0], n3 = t3[1];
          return 3 * (r3 + n3) / 4 - n3;
        }, t2.toByteArray = function(e3) {
          var t3, r3, o2 = a(e3), s2 = o2[0], l2 = o2[1], u2 = new i(function(e4, t4, r4) {
            return 3 * (t4 + r4) / 4 - r4;
          }(0, s2, l2)), c = 0, f = l2 > 0 ? s2 - 4 : s2;
          for (r3 = 0; r3 < f; r3 += 4)
            t3 = n2[e3.charCodeAt(r3)] << 18 | n2[e3.charCodeAt(r3 + 1)] << 12 | n2[e3.charCodeAt(r3 + 2)] << 6 | n2[e3.charCodeAt(r3 + 3)], u2[c++] = t3 >> 16 & 255, u2[c++] = t3 >> 8 & 255, u2[c++] = 255 & t3;
          return 2 === l2 && (t3 = n2[e3.charCodeAt(r3)] << 2 | n2[e3.charCodeAt(r3 + 1)] >> 4, u2[c++] = 255 & t3), 1 === l2 && (t3 = n2[e3.charCodeAt(r3)] << 10 | n2[e3.charCodeAt(r3 + 1)] << 4 | n2[e3.charCodeAt(r3 + 2)] >> 2, u2[c++] = t3 >> 8 & 255, u2[c++] = 255 & t3), u2;
        }, t2.fromByteArray = function(e3) {
          for (var t3, n3 = e3.length, i2 = n3 % 3, o2 = [], s2 = 16383, a2 = 0, l2 = n3 - i2; a2 < l2; a2 += s2)
            o2.push(u(e3, a2, a2 + s2 > l2 ? l2 : a2 + s2));
          return 1 === i2 ? (t3 = e3[n3 - 1], o2.push(r2[t3 >> 2] + r2[t3 << 4 & 63] + "==")) : 2 === i2 && (t3 = (e3[n3 - 2] << 8) + e3[n3 - 1], o2.push(r2[t3 >> 10] + r2[t3 >> 4 & 63] + r2[t3 << 2 & 63] + "=")), o2.join("");
        };
        for (var r2 = [], n2 = [], i = "undefined" != typeof Uint8Array ? Uint8Array : Array, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = 0; s < 64; ++s)
          r2[s] = o[s], n2[o.charCodeAt(s)] = s;
        function a(e3) {
          var t3 = e3.length;
          if (t3 % 4 > 0)
            throw new Error("Invalid string. Length must be a multiple of 4");
          var r3 = e3.indexOf("=");
          return -1 === r3 && (r3 = t3), [r3, r3 === t3 ? 0 : 4 - r3 % 4];
        }
        function l(e3) {
          return r2[e3 >> 18 & 63] + r2[e3 >> 12 & 63] + r2[e3 >> 6 & 63] + r2[63 & e3];
        }
        function u(e3, t3, r3) {
          for (var n3, i2 = [], o2 = t3; o2 < r3; o2 += 3)
            n3 = (e3[o2] << 16 & 16711680) + (e3[o2 + 1] << 8 & 65280) + (255 & e3[o2 + 2]), i2.push(l(n3));
          return i2.join("");
        }
        n2["-".charCodeAt(0)] = 62, n2["_".charCodeAt(0)] = 63;
      }, 7576: (e2, t2, r2) => {
        "use strict";
        const n2 = r2(5606), { ArrayPrototypeIndexOf: i, NumberIsInteger: o, NumberIsNaN: s, NumberParseInt: a, ObjectDefineProperties: l, ObjectKeys: u, ObjectSetPrototypeOf: c, Promise: f, SafeSet: h, SymbolAsyncDispose: d, SymbolAsyncIterator: p, Symbol: b } = r2(4134);
        e2.exports = K, K.ReadableState = V;
        const { EventEmitter: y } = r2(7007), { Stream: g, prependListener: w } = r2(4259), { Buffer: _ } = r2(8287), { addAbortSignal: m } = r2(4147), E = r2(6238);
        let S = r2(7760).debuglog("stream", (e3) => {
          S = e3;
        });
        const v = r2(345), A = r2(5896), { getHighWaterMark: I, getDefaultHighWaterMark: T } = r2(5291), { aggregateTwoErrors: R, codes: { ERR_INVALID_ARG_TYPE: B, ERR_METHOD_NOT_IMPLEMENTED: N, ERR_OUT_OF_RANGE: L, ERR_STREAM_PUSH_AFTER_EOF: U, ERR_STREAM_UNSHIFT_AFTER_END_EVENT: M }, AbortError: O } = r2(6371), { validateObject: x } = r2(277), k = b("kPaused"), { StringDecoder: P } = r2(3141), j = r2(6532);
        c(K.prototype, g.prototype), c(K, g);
        const D = () => {
        }, { errorOrDestroy: F } = A, C = 1, $ = 16, W = 32, G = 2048, H = 4096;
        function Y(e3) {
          return { enumerable: false, get() {
            return 0 !== (this.state & e3);
          }, set(t3) {
            t3 ? this.state |= e3 : this.state &= ~e3;
          } };
        }
        function V(e3, t3, n3) {
          "boolean" != typeof n3 && (n3 = t3 instanceof r2(3370)), this.state = G | H | $ | W, e3 && e3.objectMode && (this.state |= C), n3 && e3 && e3.readableObjectMode && (this.state |= C), this.highWaterMark = e3 ? I(this, e3, "readableHighWaterMark", n3) : T(false), this.buffer = new v(), this.length = 0, this.pipes = [], this.flowing = null, this[k] = null, e3 && false === e3.emitClose && (this.state &= ~G), e3 && false === e3.autoDestroy && (this.state &= ~H), this.errored = null, this.defaultEncoding = e3 && e3.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.decoder = null, this.encoding = null, e3 && e3.encoding && (this.decoder = new P(e3.encoding), this.encoding = e3.encoding);
        }
        function K(e3) {
          if (!(this instanceof K))
            return new K(e3);
          const t3 = this instanceof r2(3370);
          this._readableState = new V(e3, this, t3), e3 && ("function" == typeof e3.read && (this._read = e3.read), "function" == typeof e3.destroy && (this._destroy = e3.destroy), "function" == typeof e3.construct && (this._construct = e3.construct), e3.signal && !t3 && m(e3.signal, this)), g.call(this, e3), A.construct(this, () => {
            this._readableState.needReadable && Q(this, this._readableState);
          });
        }
        function q(e3, t3, r3, n3) {
          S("readableAddChunk", t3);
          const i2 = e3._readableState;
          let o2;
          if (0 === (i2.state & C) && ("string" == typeof t3 ? (r3 = r3 || i2.defaultEncoding, i2.encoding !== r3 && (n3 && i2.encoding ? t3 = _.from(t3, r3).toString(i2.encoding) : (t3 = _.from(t3, r3), r3 = ""))) : t3 instanceof _ ? r3 = "" : g._isUint8Array(t3) ? (t3 = g._uint8ArrayToBuffer(t3), r3 = "") : null != t3 && (o2 = new B("chunk", ["string", "Buffer", "Uint8Array"], t3))), o2)
            F(e3, o2);
          else if (null === t3)
            i2.state &= -9, function(e4, t4) {
              if (S("onEofChunk"), !t4.ended) {
                if (t4.decoder) {
                  const e5 = t4.decoder.end();
                  e5 && e5.length && (t4.buffer.push(e5), t4.length += t4.objectMode ? 1 : e5.length);
                }
                t4.ended = true, t4.sync ? J(e4) : (t4.needReadable = false, t4.emittedReadable = true, Z(e4));
              }
            }(e3, i2);
          else if (0 !== (i2.state & C) || t3 && t3.length > 0)
            if (n3)
              if (4 & i2.state)
                F(e3, new M());
              else {
                if (i2.destroyed || i2.errored)
                  return false;
                z(e3, i2, t3, true);
              }
            else if (i2.ended)
              F(e3, new U());
            else {
              if (i2.destroyed || i2.errored)
                return false;
              i2.state &= -9, i2.decoder && !r3 ? (t3 = i2.decoder.write(t3), i2.objectMode || 0 !== t3.length ? z(e3, i2, t3, false) : Q(e3, i2)) : z(e3, i2, t3, false);
            }
          else
            n3 || (i2.state &= -9, Q(e3, i2));
          return !i2.ended && (i2.length < i2.highWaterMark || 0 === i2.length);
        }
        function z(e3, t3, r3, n3) {
          t3.flowing && 0 === t3.length && !t3.sync && e3.listenerCount("data") > 0 ? (65536 & t3.state ? t3.awaitDrainWriters.clear() : t3.awaitDrainWriters = null, t3.dataEmitted = true, e3.emit("data", r3)) : (t3.length += t3.objectMode ? 1 : r3.length, n3 ? t3.buffer.unshift(r3) : t3.buffer.push(r3), 64 & t3.state && J(e3)), Q(e3, t3);
        }
        function X(e3, t3) {
          return e3 <= 0 || 0 === t3.length && t3.ended ? 0 : 0 !== (t3.state & C) ? 1 : s(e3) ? t3.flowing && t3.length ? t3.buffer.first().length : t3.length : e3 <= t3.length ? e3 : t3.ended ? t3.length : 0;
        }
        function J(e3) {
          const t3 = e3._readableState;
          S("emitReadable", t3.needReadable, t3.emittedReadable), t3.needReadable = false, t3.emittedReadable || (S("emitReadable", t3.flowing), t3.emittedReadable = true, n2.nextTick(Z, e3));
        }
        function Z(e3) {
          const t3 = e3._readableState;
          S("emitReadable_", t3.destroyed, t3.length, t3.ended), t3.destroyed || t3.errored || !t3.length && !t3.ended || (e3.emit("readable"), t3.emittedReadable = false), t3.needReadable = !t3.flowing && !t3.ended && t3.length <= t3.highWaterMark, ie(e3);
        }
        function Q(e3, t3) {
          !t3.readingMore && t3.constructed && (t3.readingMore = true, n2.nextTick(ee, e3, t3));
        }
        function ee(e3, t3) {
          for (; !t3.reading && !t3.ended && (t3.length < t3.highWaterMark || t3.flowing && 0 === t3.length); ) {
            const r3 = t3.length;
            if (S("maybeReadMore read 0"), e3.read(0), r3 === t3.length)
              break;
          }
          t3.readingMore = false;
        }
        function te(e3) {
          const t3 = e3._readableState;
          t3.readableListening = e3.listenerCount("readable") > 0, t3.resumeScheduled && false === t3[k] ? t3.flowing = true : e3.listenerCount("data") > 0 ? e3.resume() : t3.readableListening || (t3.flowing = null);
        }
        function re(e3) {
          S("readable nexttick read 0"), e3.read(0);
        }
        function ne(e3, t3) {
          S("resume", t3.reading), t3.reading || e3.read(0), t3.resumeScheduled = false, e3.emit("resume"), ie(e3), t3.flowing && !t3.reading && e3.read(0);
        }
        function ie(e3) {
          const t3 = e3._readableState;
          for (S("flow", t3.flowing); t3.flowing && null !== e3.read(); )
            ;
        }
        function oe(e3, t3) {
          "function" != typeof e3.read && (e3 = K.wrap(e3, { objectMode: true }));
          const r3 = async function* (e4, t4) {
            let r4, n3 = D;
            function i2(t5) {
              this === e4 ? (n3(), n3 = D) : n3 = t5;
            }
            e4.on("readable", i2);
            const o2 = E(e4, { writable: false }, (e5) => {
              r4 = e5 ? R(r4, e5) : null, n3(), n3 = D;
            });
            try {
              for (; ; ) {
                const t5 = e4.destroyed ? null : e4.read();
                if (null !== t5)
                  yield t5;
                else {
                  if (r4)
                    throw r4;
                  if (null === r4)
                    return;
                  await new f(i2);
                }
              }
            } catch (e5) {
              throw r4 = R(r4, e5), r4;
            } finally {
              !r4 && false === (null == t4 ? void 0 : t4.destroyOnReturn) || void 0 !== r4 && !e4._readableState.autoDestroy ? (e4.off("readable", i2), o2()) : A.destroyer(e4, null);
            }
          }(e3, t3);
          return r3.stream = e3, r3;
        }
        function se(e3, t3) {
          if (0 === t3.length)
            return null;
          let r3;
          return t3.objectMode ? r3 = t3.buffer.shift() : !e3 || e3 >= t3.length ? (r3 = t3.decoder ? t3.buffer.join("") : 1 === t3.buffer.length ? t3.buffer.first() : t3.buffer.concat(t3.length), t3.buffer.clear()) : r3 = t3.buffer.consume(e3, t3.decoder), r3;
        }
        function ae(e3) {
          const t3 = e3._readableState;
          S("endReadable", t3.endEmitted), t3.endEmitted || (t3.ended = true, n2.nextTick(le, t3, e3));
        }
        function le(e3, t3) {
          if (S("endReadableNT", e3.endEmitted, e3.length), !e3.errored && !e3.closeEmitted && !e3.endEmitted && 0 === e3.length) {
            if (e3.endEmitted = true, t3.emit("end"), t3.writable && false === t3.allowHalfOpen)
              n2.nextTick(ue, t3);
            else if (e3.autoDestroy) {
              const e4 = t3._writableState;
              (!e4 || e4.autoDestroy && (e4.finished || false === e4.writable)) && t3.destroy();
            }
          }
        }
        function ue(e3) {
          e3.writable && !e3.writableEnded && !e3.destroyed && e3.end();
        }
        let ce;
        function fe() {
          return void 0 === ce && (ce = {}), ce;
        }
        l(V.prototype, { objectMode: Y(C), ended: Y(2), endEmitted: Y(4), reading: Y(8), constructed: Y($), sync: Y(W), needReadable: Y(64), emittedReadable: Y(128), readableListening: Y(256), resumeScheduled: Y(512), errorEmitted: Y(1024), emitClose: Y(G), autoDestroy: Y(H), destroyed: Y(8192), closed: Y(16384), closeEmitted: Y(32768), multiAwaitDrain: Y(65536), readingMore: Y(1 << 17), dataEmitted: Y(1 << 18) }), K.prototype.destroy = A.destroy, K.prototype._undestroy = A.undestroy, K.prototype._destroy = function(e3, t3) {
          t3(e3);
        }, K.prototype[y.captureRejectionSymbol] = function(e3) {
          this.destroy(e3);
        }, K.prototype[d] = function() {
          let e3;
          return this.destroyed || (e3 = this.readableEnded ? null : new O(), this.destroy(e3)), new f((t3, r3) => E(this, (n3) => n3 && n3 !== e3 ? r3(n3) : t3(null)));
        }, K.prototype.push = function(e3, t3) {
          return q(this, e3, t3, false);
        }, K.prototype.unshift = function(e3, t3) {
          return q(this, e3, t3, true);
        }, K.prototype.isPaused = function() {
          const e3 = this._readableState;
          return true === e3[k] || false === e3.flowing;
        }, K.prototype.setEncoding = function(e3) {
          const t3 = new P(e3);
          this._readableState.decoder = t3, this._readableState.encoding = this._readableState.decoder.encoding;
          const r3 = this._readableState.buffer;
          let n3 = "";
          for (const e4 of r3)
            n3 += t3.write(e4);
          return r3.clear(), "" !== n3 && r3.push(n3), this._readableState.length = n3.length, this;
        }, K.prototype.read = function(e3) {
          S("read", e3), void 0 === e3 ? e3 = NaN : o(e3) || (e3 = a(e3, 10));
          const t3 = this._readableState, r3 = e3;
          if (e3 > t3.highWaterMark && (t3.highWaterMark = function(e4) {
            if (e4 > 1073741824)
              throw new L("size", "<= 1GiB", e4);
            return e4--, e4 |= e4 >>> 1, e4 |= e4 >>> 2, e4 |= e4 >>> 4, e4 |= e4 >>> 8, e4 |= e4 >>> 16, ++e4;
          }(e3)), 0 !== e3 && (t3.state &= -129), 0 === e3 && t3.needReadable && ((0 !== t3.highWaterMark ? t3.length >= t3.highWaterMark : t3.length > 0) || t3.ended))
            return S("read: emitReadable", t3.length, t3.ended), 0 === t3.length && t3.ended ? ae(this) : J(this), null;
          if (0 === (e3 = X(e3, t3)) && t3.ended)
            return 0 === t3.length && ae(this), null;
          let n3, i2 = !!(64 & t3.state);
          if (S("need readable", i2), (0 === t3.length || t3.length - e3 < t3.highWaterMark) && (i2 = true, S("length less than watermark", i2)), t3.ended || t3.reading || t3.destroyed || t3.errored || !t3.constructed)
            i2 = false, S("reading, ended or constructing", i2);
          else if (i2) {
            S("do read"), t3.state |= 8 | W, 0 === t3.length && (t3.state |= 64);
            try {
              this._read(t3.highWaterMark);
            } catch (e4) {
              F(this, e4);
            }
            t3.state &= ~W, t3.reading || (e3 = X(r3, t3));
          }
          return n3 = e3 > 0 ? se(e3, t3) : null, null === n3 ? (t3.needReadable = t3.length <= t3.highWaterMark, e3 = 0) : (t3.length -= e3, t3.multiAwaitDrain ? t3.awaitDrainWriters.clear() : t3.awaitDrainWriters = null), 0 === t3.length && (t3.ended || (t3.needReadable = true), r3 !== e3 && t3.ended && ae(this)), null === n3 || t3.errorEmitted || t3.closeEmitted || (t3.dataEmitted = true, this.emit("data", n3)), n3;
        }, K.prototype._read = function(e3) {
          throw new N("_read()");
        }, K.prototype.pipe = function(e3, t3) {
          const r3 = this, i2 = this._readableState;
          1 === i2.pipes.length && (i2.multiAwaitDrain || (i2.multiAwaitDrain = true, i2.awaitDrainWriters = new h(i2.awaitDrainWriters ? [i2.awaitDrainWriters] : []))), i2.pipes.push(e3), S("pipe count=%d opts=%j", i2.pipes.length, t3);
          const o2 = t3 && false === t3.end || e3 === n2.stdout || e3 === n2.stderr ? b2 : s2;
          function s2() {
            S("onend"), e3.end();
          }
          let a2;
          i2.endEmitted ? n2.nextTick(o2) : r3.once("end", o2), e3.on("unpipe", function t4(n3, o3) {
            S("onunpipe"), n3 === r3 && o3 && false === o3.hasUnpiped && (o3.hasUnpiped = true, S("cleanup"), e3.removeListener("close", d2), e3.removeListener("finish", p2), a2 && e3.removeListener("drain", a2), e3.removeListener("error", f2), e3.removeListener("unpipe", t4), r3.removeListener("end", s2), r3.removeListener("end", b2), r3.removeListener("data", c2), l2 = true, a2 && i2.awaitDrainWriters && (!e3._writableState || e3._writableState.needDrain) && a2());
          });
          let l2 = false;
          function u2() {
            l2 || (1 === i2.pipes.length && i2.pipes[0] === e3 ? (S("false write response, pause", 0), i2.awaitDrainWriters = e3, i2.multiAwaitDrain = false) : i2.pipes.length > 1 && i2.pipes.includes(e3) && (S("false write response, pause", i2.awaitDrainWriters.size), i2.awaitDrainWriters.add(e3)), r3.pause()), a2 || (a2 = function(e4, t4) {
              return function() {
                const r4 = e4._readableState;
                r4.awaitDrainWriters === t4 ? (S("pipeOnDrain", 1), r4.awaitDrainWriters = null) : r4.multiAwaitDrain && (S("pipeOnDrain", r4.awaitDrainWriters.size), r4.awaitDrainWriters.delete(t4)), r4.awaitDrainWriters && 0 !== r4.awaitDrainWriters.size || !e4.listenerCount("data") || e4.resume();
              };
            }(r3, e3), e3.on("drain", a2));
          }
          function c2(t4) {
            S("ondata");
            const r4 = e3.write(t4);
            S("dest.write", r4), false === r4 && u2();
          }
          function f2(t4) {
            if (S("onerror", t4), b2(), e3.removeListener("error", f2), 0 === e3.listenerCount("error")) {
              const r4 = e3._writableState || e3._readableState;
              r4 && !r4.errorEmitted ? F(e3, t4) : e3.emit("error", t4);
            }
          }
          function d2() {
            e3.removeListener("finish", p2), b2();
          }
          function p2() {
            S("onfinish"), e3.removeListener("close", d2), b2();
          }
          function b2() {
            S("unpipe"), r3.unpipe(e3);
          }
          return r3.on("data", c2), w(e3, "error", f2), e3.once("close", d2), e3.once("finish", p2), e3.emit("pipe", r3), true === e3.writableNeedDrain ? u2() : i2.flowing || (S("pipe resume"), r3.resume()), e3;
        }, K.prototype.unpipe = function(e3) {
          const t3 = this._readableState;
          if (0 === t3.pipes.length)
            return this;
          if (!e3) {
            const e4 = t3.pipes;
            t3.pipes = [], this.pause();
            for (let t4 = 0; t4 < e4.length; t4++)
              e4[t4].emit("unpipe", this, { hasUnpiped: false });
            return this;
          }
          const r3 = i(t3.pipes, e3);
          return -1 === r3 || (t3.pipes.splice(r3, 1), 0 === t3.pipes.length && this.pause(), e3.emit("unpipe", this, { hasUnpiped: false })), this;
        }, K.prototype.on = function(e3, t3) {
          const r3 = g.prototype.on.call(this, e3, t3), i2 = this._readableState;
          return "data" === e3 ? (i2.readableListening = this.listenerCount("readable") > 0, false !== i2.flowing && this.resume()) : "readable" === e3 && (i2.endEmitted || i2.readableListening || (i2.readableListening = i2.needReadable = true, i2.flowing = false, i2.emittedReadable = false, S("on readable", i2.length, i2.reading), i2.length ? J(this) : i2.reading || n2.nextTick(re, this))), r3;
        }, K.prototype.addListener = K.prototype.on, K.prototype.removeListener = function(e3, t3) {
          const r3 = g.prototype.removeListener.call(this, e3, t3);
          return "readable" === e3 && n2.nextTick(te, this), r3;
        }, K.prototype.off = K.prototype.removeListener, K.prototype.removeAllListeners = function(e3) {
          const t3 = g.prototype.removeAllListeners.apply(this, arguments);
          return "readable" !== e3 && void 0 !== e3 || n2.nextTick(te, this), t3;
        }, K.prototype.resume = function() {
          const e3 = this._readableState;
          return e3.flowing || (S("resume"), e3.flowing = !e3.readableListening, function(e4, t3) {
            t3.resumeScheduled || (t3.resumeScheduled = true, n2.nextTick(ne, e4, t3));
          }(this, e3)), e3[k] = false, this;
        }, K.prototype.pause = function() {
          return S("call pause flowing=%j", this._readableState.flowing), false !== this._readableState.flowing && (S("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState[k] = true, this;
        }, K.prototype.wrap = function(e3) {
          let t3 = false;
          e3.on("data", (r4) => {
            !this.push(r4) && e3.pause && (t3 = true, e3.pause());
          }), e3.on("end", () => {
            this.push(null);
          }), e3.on("error", (e4) => {
            F(this, e4);
          }), e3.on("close", () => {
            this.destroy();
          }), e3.on("destroy", () => {
            this.destroy();
          }), this._read = () => {
            t3 && e3.resume && (t3 = false, e3.resume());
          };
          const r3 = u(e3);
          for (let t4 = 1; t4 < r3.length; t4++) {
            const n3 = r3[t4];
            void 0 === this[n3] && "function" == typeof e3[n3] && (this[n3] = e3[n3].bind(e3));
          }
          return this;
        }, K.prototype[p] = function() {
          return oe(this);
        }, K.prototype.iterator = function(e3) {
          return void 0 !== e3 && x(e3, "options"), oe(this, e3);
        }, l(K.prototype, { readable: { __proto__: null, get() {
          const e3 = this._readableState;
          return !(!e3 || false === e3.readable || e3.destroyed || e3.errorEmitted || e3.endEmitted);
        }, set(e3) {
          this._readableState && (this._readableState.readable = !!e3);
        } }, readableDidRead: { __proto__: null, enumerable: false, get: function() {
          return this._readableState.dataEmitted;
        } }, readableAborted: { __proto__: null, enumerable: false, get: function() {
          return !(false === this._readableState.readable || !this._readableState.destroyed && !this._readableState.errored || this._readableState.endEmitted);
        } }, readableHighWaterMark: { __proto__: null, enumerable: false, get: function() {
          return this._readableState.highWaterMark;
        } }, readableBuffer: { __proto__: null, enumerable: false, get: function() {
          return this._readableState && this._readableState.buffer;
        } }, readableFlowing: { __proto__: null, enumerable: false, get: function() {
          return this._readableState.flowing;
        }, set: function(e3) {
          this._readableState && (this._readableState.flowing = e3);
        } }, readableLength: { __proto__: null, enumerable: false, get() {
          return this._readableState.length;
        } }, readableObjectMode: { __proto__: null, enumerable: false, get() {
          return !!this._readableState && this._readableState.objectMode;
        } }, readableEncoding: { __proto__: null, enumerable: false, get() {
          return this._readableState ? this._readableState.encoding : null;
        } }, errored: { __proto__: null, enumerable: false, get() {
          return this._readableState ? this._readableState.errored : null;
        } }, closed: { __proto__: null, get() {
          return !!this._readableState && this._readableState.closed;
        } }, destroyed: { __proto__: null, enumerable: false, get() {
          return !!this._readableState && this._readableState.destroyed;
        }, set(e3) {
          this._readableState && (this._readableState.destroyed = e3);
        } }, readableEnded: { __proto__: null, enumerable: false, get() {
          return !!this._readableState && this._readableState.endEmitted;
        } } }), l(V.prototype, { pipesCount: { __proto__: null, get() {
          return this.pipes.length;
        } }, paused: { __proto__: null, get() {
          return false !== this[k];
        }, set(e3) {
          this[k] = !!e3;
        } } }), K._fromList = se, K.from = function(e3, t3) {
          return j(K, e3, t3);
        }, K.fromWeb = function(e3, t3) {
          return fe().newStreamReadableFromReadableStream(e3, t3);
        }, K.toWeb = function(e3, t3) {
          return fe().newReadableStreamFromStreamReadable(e3, t3);
        }, K.wrap = function(e3, t3) {
          var r3, n3;
          return new K({ objectMode: null === (r3 = null !== (n3 = e3.readableObjectMode) && void 0 !== n3 ? n3 : e3.objectMode) || void 0 === r3 || r3, ...t3, destroy(t4, r4) {
            A.destroyer(e3, t4), r4(t4);
          } }).wrap(e3);
        };
      }, 7758: (e2, t2, r2) => {
        const n2 = r2(5606), { ArrayIsArray: i, Promise: o, SymbolAsyncIterator: s, SymbolDispose: a } = r2(4134), l = r2(6238), { once: u } = r2(7760), c = r2(5896), f = r2(3370), { aggregateTwoErrors: h, codes: { ERR_INVALID_ARG_TYPE: d, ERR_INVALID_RETURN_VALUE: p, ERR_MISSING_ARGS: b, ERR_STREAM_DESTROYED: y, ERR_STREAM_PREMATURE_CLOSE: g }, AbortError: w } = r2(6371), { validateFunction: _, validateAbortSignal: m } = r2(277), { isIterable: E, isReadable: S, isReadableNodeStream: v, isNodeStream: A, isTransformStream: I, isWebStream: T, isReadableStream: R, isReadableFinished: B } = r2(6115), N = globalThis.AbortController || r2(5568).AbortController;
        let L, U, M;
        function O(e3, t3, r3) {
          let n3 = false;
          return e3.on("close", () => {
            n3 = true;
          }), { destroy: (t4) => {
            n3 || (n3 = true, c.destroyer(e3, t4 || new y("pipe")));
          }, cleanup: l(e3, { readable: t3, writable: r3 }, (e4) => {
            n3 = !e4;
          }) };
        }
        function x(e3) {
          if (E(e3))
            return e3;
          if (v(e3))
            return async function* (e4) {
              U || (U = r2(7576)), yield* U.prototype[s].call(e4);
            }(e3);
          throw new d("val", ["Readable", "Iterable", "AsyncIterable"], e3);
        }
        async function k(e3, t3, r3, { end: n3 }) {
          let i2, s2 = null;
          const a2 = (e4) => {
            if (e4 && (i2 = e4), s2) {
              const e5 = s2;
              s2 = null, e5();
            }
          }, u2 = () => new o((e4, t4) => {
            i2 ? t4(i2) : s2 = () => {
              i2 ? t4(i2) : e4();
            };
          });
          t3.on("drain", a2);
          const c2 = l(t3, { readable: false }, a2);
          try {
            t3.writableNeedDrain && await u2();
            for await (const r4 of e3)
              t3.write(r4) || await u2();
            n3 && (t3.end(), await u2()), r3();
          } catch (e4) {
            r3(i2 !== e4 ? h(i2, e4) : e4);
          } finally {
            c2(), t3.off("drain", a2);
          }
        }
        async function P(e3, t3, r3, { end: n3 }) {
          I(t3) && (t3 = t3.writable);
          const i2 = t3.getWriter();
          try {
            for await (const t4 of e3)
              await i2.ready, i2.write(t4).catch(() => {
              });
            await i2.ready, n3 && await i2.close(), r3();
          } catch (e4) {
            try {
              await i2.abort(e4), r3(e4);
            } catch (e5) {
              r3(e5);
            }
          }
        }
        function j(e3, t3, o2) {
          if (1 === e3.length && i(e3[0]) && (e3 = e3[0]), e3.length < 2)
            throw new b("streams");
          const s2 = new N(), l2 = s2.signal, u2 = null == o2 ? void 0 : o2.signal, c2 = [];
          function h2() {
            C(new w());
          }
          let y2, g2, _2;
          m(u2, "options.signal"), M = M || r2(7760).addAbortListener, u2 && (y2 = M(u2, h2));
          const B2 = [];
          let U2, j2 = 0;
          function F(e4) {
            C(e4, 0 === --j2);
          }
          function C(e4, r3) {
            var i2;
            if (!e4 || g2 && "ERR_STREAM_PREMATURE_CLOSE" !== g2.code || (g2 = e4), g2 || r3) {
              for (; B2.length; )
                B2.shift()(g2);
              null === (i2 = y2) || void 0 === i2 || i2[a](), s2.abort(), r3 && (g2 || c2.forEach((e5) => e5()), n2.nextTick(t3, g2, _2));
            }
          }
          for (let H = 0; H < e3.length; H++) {
            const Y = e3[H], V = H < e3.length - 1, K = H > 0, q = V || false !== (null == o2 ? void 0 : o2.end), z = H === e3.length - 1;
            if (A(Y)) {
              let $2 = function(e4) {
                e4 && "AbortError" !== e4.name && "ERR_STREAM_PREMATURE_CLOSE" !== e4.code && F(e4);
              };
              var $ = $2;
              if (q) {
                const { destroy: X, cleanup: J } = O(Y, V, K);
                B2.push(X), S(Y) && z && c2.push(J);
              }
              Y.on("error", $2), S(Y) && z && c2.push(() => {
                Y.removeListener("error", $2);
              });
            }
            if (0 === H)
              if ("function" == typeof Y) {
                if (U2 = Y({ signal: l2 }), !E(U2))
                  throw new p("Iterable, AsyncIterable or Stream", "source", U2);
              } else
                U2 = E(Y) || v(Y) || I(Y) ? Y : f.from(Y);
            else if ("function" == typeof Y) {
              var W;
              if (U2 = I(U2) ? x(null === (W = U2) || void 0 === W ? void 0 : W.readable) : x(U2), U2 = Y(U2, { signal: l2 }), V) {
                if (!E(U2, true))
                  throw new p("AsyncIterable", `transform[${H - 1}]`, U2);
              } else {
                var G;
                L || (L = r2(6524));
                const Z = new L({ objectMode: true }), Q = null === (G = U2) || void 0 === G ? void 0 : G.then;
                if ("function" == typeof Q)
                  j2++, Q.call(U2, (e4) => {
                    _2 = e4, null != e4 && Z.write(e4), q && Z.end(), n2.nextTick(F);
                  }, (e4) => {
                    Z.destroy(e4), n2.nextTick(F, e4);
                  });
                else if (E(U2, true))
                  j2++, k(U2, Z, F, { end: q });
                else {
                  if (!R(U2) && !I(U2))
                    throw new p("AsyncIterable or Promise", "destination", U2);
                  {
                    const re = U2.readable || U2;
                    j2++, k(re, Z, F, { end: q });
                  }
                }
                U2 = Z;
                const { destroy: ee, cleanup: te } = O(U2, false, true);
                B2.push(ee), z && c2.push(te);
              }
            } else if (A(Y)) {
              if (v(U2)) {
                j2 += 2;
                const ne = D(U2, Y, F, { end: q });
                S(Y) && z && c2.push(ne);
              } else if (I(U2) || R(U2)) {
                const ie = U2.readable || U2;
                j2++, k(ie, Y, F, { end: q });
              } else {
                if (!E(U2))
                  throw new d("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], U2);
                j2++, k(U2, Y, F, { end: q });
              }
              U2 = Y;
            } else if (T(Y)) {
              if (v(U2))
                j2++, P(x(U2), Y, F, { end: q });
              else if (R(U2) || E(U2))
                j2++, P(U2, Y, F, { end: q });
              else {
                if (!I(U2))
                  throw new d("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], U2);
                j2++, P(U2.readable, Y, F, { end: q });
              }
              U2 = Y;
            } else
              U2 = f.from(Y);
          }
          return (null != l2 && l2.aborted || null != u2 && u2.aborted) && n2.nextTick(h2), U2;
        }
        function D(e3, t3, r3, { end: i2 }) {
          let o2 = false;
          if (t3.on("close", () => {
            o2 || r3(new g());
          }), e3.pipe(t3, { end: false }), i2) {
            let s3 = function() {
              o2 = true, t3.end();
            };
            var s2 = s3;
            B(e3) ? n2.nextTick(s3) : e3.once("end", s3);
          } else
            r3();
          return l(e3, { readable: true, writable: false }, (t4) => {
            const n3 = e3._readableState;
            t4 && "ERR_STREAM_PREMATURE_CLOSE" === t4.code && n3 && n3.ended && !n3.errored && !n3.errorEmitted ? e3.once("end", r3).once("error", r3) : r3(t4);
          }), l(t3, { readable: false, writable: true }, r3);
        }
        e2.exports = { pipelineImpl: j, pipeline: function(...e3) {
          return j(e3, u(function(e4) {
            return _(e4[e4.length - 1], "streams[stream.length - 1]"), e4.pop();
          }(e3)));
        } };
      }, 7760: (e2, t2, r2) => {
        "use strict";
        const n2 = r2(8287), { format: i, inspect: o } = r2(9231), { codes: { ERR_INVALID_ARG_TYPE: s } } = r2(6371), { kResistStopPropagation: a, AggregateError: l, SymbolDispose: u } = r2(4134), c = globalThis.AbortSignal || r2(5568).AbortSignal, f = globalThis.AbortController || r2(5568).AbortController, h = Object.getPrototypeOf(async function() {
        }).constructor, d = globalThis.Blob || n2.Blob, p = void 0 !== d ? function(e3) {
          return e3 instanceof d;
        } : function(e3) {
          return false;
        }, b = (e3, t3) => {
          if (void 0 !== e3 && (null === e3 || "object" != typeof e3 || !("aborted" in e3)))
            throw new s(t3, "AbortSignal", e3);
        };
        e2.exports = { AggregateError: l, kEmptyObject: Object.freeze({}), once(e3) {
          let t3 = false;
          return function(...r3) {
            t3 || (t3 = true, e3.apply(this, r3));
          };
        }, createDeferredPromise: function() {
          let e3, t3;
          return { promise: new Promise((r3, n3) => {
            e3 = r3, t3 = n3;
          }), resolve: e3, reject: t3 };
        }, promisify: (e3) => new Promise((t3, r3) => {
          e3((e4, ...n3) => e4 ? r3(e4) : t3(...n3));
        }), debuglog: () => function() {
        }, format: i, inspect: o, types: { isAsyncFunction: (e3) => e3 instanceof h, isArrayBufferView: (e3) => ArrayBuffer.isView(e3) }, isBlob: p, deprecate: (e3, t3) => e3, addAbortListener: r2(7007).addAbortListener || function(e3, t3) {
          if (void 0 === e3)
            throw new s("signal", "AbortSignal", e3);
          let r3;
          return b(e3, "signal"), ((e4) => {
            if ("function" != typeof e4)
              throw new s("listener", "Function", e4);
          })(t3), e3.aborted ? queueMicrotask(() => t3()) : (e3.addEventListener("abort", t3, { __proto__: null, once: true, [a]: true }), r3 = () => {
            e3.removeEventListener("abort", t3);
          }), { __proto__: null, [u]() {
            var e4;
            null === (e4 = r3) || void 0 === e4 || e4();
          } };
        }, AbortSignalAny: c.any || function(e3) {
          if (1 === e3.length)
            return e3[0];
          const t3 = new f(), r3 = () => t3.abort();
          return e3.forEach((e4) => {
            b(e4, "signals"), e4.addEventListener("abort", r3, { once: true });
          }), t3.signal.addEventListener("abort", () => {
            e3.forEach((e4) => e4.removeEventListener("abort", r3));
          }, { once: true }), t3.signal;
        } }, e2.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
      }, 7830: (e2, t2, r2) => {
        "use strict";
        const { pipeline: n2 } = r2(7758), i = r2(3370), { destroyer: o } = r2(5896), { isNodeStream: s, isReadable: a, isWritable: l, isWebStream: u, isTransformStream: c, isWritableStream: f, isReadableStream: h } = r2(6115), { AbortError: d, codes: { ERR_INVALID_ARG_VALUE: p, ERR_MISSING_ARGS: b } } = r2(6371), y = r2(6238);
        e2.exports = function(...e3) {
          if (0 === e3.length)
            throw new b("streams");
          if (1 === e3.length)
            return i.from(e3[0]);
          const t3 = [...e3];
          if ("function" == typeof e3[0] && (e3[0] = i.from(e3[0])), "function" == typeof e3[e3.length - 1]) {
            const t4 = e3.length - 1;
            e3[t4] = i.from(e3[t4]);
          }
          for (let r4 = 0; r4 < e3.length; ++r4)
            if (s(e3[r4]) || u(e3[r4])) {
              if (r4 < e3.length - 1 && !(a(e3[r4]) || h(e3[r4]) || c(e3[r4])))
                throw new p(`streams[${r4}]`, t3[r4], "must be readable");
              if (r4 > 0 && !(l(e3[r4]) || f(e3[r4]) || c(e3[r4])))
                throw new p(`streams[${r4}]`, t3[r4], "must be writable");
            }
          let r3, g, w, _, m;
          const E = e3[0], S = n2(e3, function(e4) {
            const t4 = _;
            _ = null, t4 ? t4(e4) : e4 ? m.destroy(e4) : A || v || m.destroy();
          }), v = !!(l(E) || f(E) || c(E)), A = !!(a(S) || h(S) || c(S));
          if (m = new i({ writableObjectMode: !(null == E || !E.writableObjectMode), readableObjectMode: !(null == S || !S.readableObjectMode), writable: v, readable: A }), v) {
            if (s(E))
              m._write = function(e5, t4, n3) {
                E.write(e5, t4) ? n3() : r3 = n3;
              }, m._final = function(e5) {
                E.end(), g = e5;
              }, E.on("drain", function() {
                if (r3) {
                  const e5 = r3;
                  r3 = null, e5();
                }
              });
            else if (u(E)) {
              const e5 = (c(E) ? E.writable : E).getWriter();
              m._write = async function(t4, r4, n3) {
                try {
                  await e5.ready, e5.write(t4).catch(() => {
                  }), n3();
                } catch (e6) {
                  n3(e6);
                }
              }, m._final = async function(t4) {
                try {
                  await e5.ready, e5.close().catch(() => {
                  }), g = t4;
                } catch (e6) {
                  t4(e6);
                }
              };
            }
            const e4 = c(S) ? S.readable : S;
            y(e4, () => {
              if (g) {
                const e5 = g;
                g = null, e5();
              }
            });
          }
          if (A) {
            if (s(S))
              S.on("readable", function() {
                if (w) {
                  const e4 = w;
                  w = null, e4();
                }
              }), S.on("end", function() {
                m.push(null);
              }), m._read = function() {
                for (; ; ) {
                  const e4 = S.read();
                  if (null === e4)
                    return void (w = m._read);
                  if (!m.push(e4))
                    return;
                }
              };
            else if (u(S)) {
              const e4 = (c(S) ? S.readable : S).getReader();
              m._read = async function() {
                for (; ; )
                  try {
                    const { value: t4, done: r4 } = await e4.read();
                    if (!m.push(t4))
                      return;
                    if (r4)
                      return void m.push(null);
                  } catch {
                    return;
                  }
              };
            }
          }
          return m._destroy = function(e4, t4) {
            e4 || null === _ || (e4 = new d()), w = null, r3 = null, g = null, null === _ ? t4(e4) : (_ = t4, s(S) && o(S, e4));
          }, m;
        };
      }, 8287: (e2, t2, r2) => {
        "use strict";
        const n2 = r2(7526), i = r2(251), o = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
        t2.Buffer = l, t2.SlowBuffer = function(e3) {
          return +e3 != e3 && (e3 = 0), l.alloc(+e3);
        }, t2.INSPECT_MAX_BYTES = 50;
        const s = 2147483647;
        function a(e3) {
          if (e3 > s)
            throw new RangeError('The value "' + e3 + '" is invalid for option "size"');
          const t3 = new Uint8Array(e3);
          return Object.setPrototypeOf(t3, l.prototype), t3;
        }
        function l(e3, t3, r3) {
          if ("number" == typeof e3) {
            if ("string" == typeof t3)
              throw new TypeError('The "string" argument must be of type string. Received type number');
            return f(e3);
          }
          return u(e3, t3, r3);
        }
        function u(e3, t3, r3) {
          if ("string" == typeof e3)
            return function(e4, t4) {
              if ("string" == typeof t4 && "" !== t4 || (t4 = "utf8"), !l.isEncoding(t4))
                throw new TypeError("Unknown encoding: " + t4);
              const r4 = 0 | b(e4, t4);
              let n4 = a(r4);
              const i3 = n4.write(e4, t4);
              return i3 !== r4 && (n4 = n4.slice(0, i3)), n4;
            }(e3, t3);
          if (ArrayBuffer.isView(e3))
            return function(e4) {
              if (z(e4, Uint8Array)) {
                const t4 = new Uint8Array(e4);
                return d(t4.buffer, t4.byteOffset, t4.byteLength);
              }
              return h(e4);
            }(e3);
          if (null == e3)
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e3);
          if (z(e3, ArrayBuffer) || e3 && z(e3.buffer, ArrayBuffer))
            return d(e3, t3, r3);
          if ("undefined" != typeof SharedArrayBuffer && (z(e3, SharedArrayBuffer) || e3 && z(e3.buffer, SharedArrayBuffer)))
            return d(e3, t3, r3);
          if ("number" == typeof e3)
            throw new TypeError('The "value" argument must not be of type number. Received type number');
          const n3 = e3.valueOf && e3.valueOf();
          if (null != n3 && n3 !== e3)
            return l.from(n3, t3, r3);
          const i2 = function(e4) {
            if (l.isBuffer(e4)) {
              const t4 = 0 | p(e4.length), r4 = a(t4);
              return 0 === r4.length || e4.copy(r4, 0, 0, t4), r4;
            }
            return void 0 !== e4.length ? "number" != typeof e4.length || X(e4.length) ? a(0) : h(e4) : "Buffer" === e4.type && Array.isArray(e4.data) ? h(e4.data) : void 0;
          }(e3);
          if (i2)
            return i2;
          if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e3[Symbol.toPrimitive])
            return l.from(e3[Symbol.toPrimitive]("string"), t3, r3);
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e3);
        }
        function c(e3) {
          if ("number" != typeof e3)
            throw new TypeError('"size" argument must be of type number');
          if (e3 < 0)
            throw new RangeError('The value "' + e3 + '" is invalid for option "size"');
        }
        function f(e3) {
          return c(e3), a(e3 < 0 ? 0 : 0 | p(e3));
        }
        function h(e3) {
          const t3 = e3.length < 0 ? 0 : 0 | p(e3.length), r3 = a(t3);
          for (let n3 = 0; n3 < t3; n3 += 1)
            r3[n3] = 255 & e3[n3];
          return r3;
        }
        function d(e3, t3, r3) {
          if (t3 < 0 || e3.byteLength < t3)
            throw new RangeError('"offset" is outside of buffer bounds');
          if (e3.byteLength < t3 + (r3 || 0))
            throw new RangeError('"length" is outside of buffer bounds');
          let n3;
          return n3 = void 0 === t3 && void 0 === r3 ? new Uint8Array(e3) : void 0 === r3 ? new Uint8Array(e3, t3) : new Uint8Array(e3, t3, r3), Object.setPrototypeOf(n3, l.prototype), n3;
        }
        function p(e3) {
          if (e3 >= s)
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s.toString(16) + " bytes");
          return 0 | e3;
        }
        function b(e3, t3) {
          if (l.isBuffer(e3))
            return e3.length;
          if (ArrayBuffer.isView(e3) || z(e3, ArrayBuffer))
            return e3.byteLength;
          if ("string" != typeof e3)
            throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e3);
          const r3 = e3.length, n3 = arguments.length > 2 && true === arguments[2];
          if (!n3 && 0 === r3)
            return 0;
          let i2 = false;
          for (; ; )
            switch (t3) {
              case "ascii":
              case "latin1":
              case "binary":
                return r3;
              case "utf8":
              case "utf-8":
                return V(e3).length;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return 2 * r3;
              case "hex":
                return r3 >>> 1;
              case "base64":
                return K(e3).length;
              default:
                if (i2)
                  return n3 ? -1 : V(e3).length;
                t3 = ("" + t3).toLowerCase(), i2 = true;
            }
        }
        function y(e3, t3, r3) {
          let n3 = false;
          if ((void 0 === t3 || t3 < 0) && (t3 = 0), t3 > this.length)
            return "";
          if ((void 0 === r3 || r3 > this.length) && (r3 = this.length), r3 <= 0)
            return "";
          if ((r3 >>>= 0) <= (t3 >>>= 0))
            return "";
          for (e3 || (e3 = "utf8"); ; )
            switch (e3) {
              case "hex":
                return L(this, t3, r3);
              case "utf8":
              case "utf-8":
                return T(this, t3, r3);
              case "ascii":
                return B(this, t3, r3);
              case "latin1":
              case "binary":
                return N(this, t3, r3);
              case "base64":
                return I(this, t3, r3);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return U(this, t3, r3);
              default:
                if (n3)
                  throw new TypeError("Unknown encoding: " + e3);
                e3 = (e3 + "").toLowerCase(), n3 = true;
            }
        }
        function g(e3, t3, r3) {
          const n3 = e3[t3];
          e3[t3] = e3[r3], e3[r3] = n3;
        }
        function w(e3, t3, r3, n3, i2) {
          if (0 === e3.length)
            return -1;
          if ("string" == typeof r3 ? (n3 = r3, r3 = 0) : r3 > 2147483647 ? r3 = 2147483647 : r3 < -2147483648 && (r3 = -2147483648), X(r3 = +r3) && (r3 = i2 ? 0 : e3.length - 1), r3 < 0 && (r3 = e3.length + r3), r3 >= e3.length) {
            if (i2)
              return -1;
            r3 = e3.length - 1;
          } else if (r3 < 0) {
            if (!i2)
              return -1;
            r3 = 0;
          }
          if ("string" == typeof t3 && (t3 = l.from(t3, n3)), l.isBuffer(t3))
            return 0 === t3.length ? -1 : _(e3, t3, r3, n3, i2);
          if ("number" == typeof t3)
            return t3 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? i2 ? Uint8Array.prototype.indexOf.call(e3, t3, r3) : Uint8Array.prototype.lastIndexOf.call(e3, t3, r3) : _(e3, [t3], r3, n3, i2);
          throw new TypeError("val must be string, number or Buffer");
        }
        function _(e3, t3, r3, n3, i2) {
          let o2, s2 = 1, a2 = e3.length, l2 = t3.length;
          if (void 0 !== n3 && ("ucs2" === (n3 = String(n3).toLowerCase()) || "ucs-2" === n3 || "utf16le" === n3 || "utf-16le" === n3)) {
            if (e3.length < 2 || t3.length < 2)
              return -1;
            s2 = 2, a2 /= 2, l2 /= 2, r3 /= 2;
          }
          function u2(e4, t4) {
            return 1 === s2 ? e4[t4] : e4.readUInt16BE(t4 * s2);
          }
          if (i2) {
            let n4 = -1;
            for (o2 = r3; o2 < a2; o2++)
              if (u2(e3, o2) === u2(t3, -1 === n4 ? 0 : o2 - n4)) {
                if (-1 === n4 && (n4 = o2), o2 - n4 + 1 === l2)
                  return n4 * s2;
              } else
                -1 !== n4 && (o2 -= o2 - n4), n4 = -1;
          } else
            for (r3 + l2 > a2 && (r3 = a2 - l2), o2 = r3; o2 >= 0; o2--) {
              let r4 = true;
              for (let n4 = 0; n4 < l2; n4++)
                if (u2(e3, o2 + n4) !== u2(t3, n4)) {
                  r4 = false;
                  break;
                }
              if (r4)
                return o2;
            }
          return -1;
        }
        function m(e3, t3, r3, n3) {
          r3 = Number(r3) || 0;
          const i2 = e3.length - r3;
          n3 ? (n3 = Number(n3)) > i2 && (n3 = i2) : n3 = i2;
          const o2 = t3.length;
          let s2;
          for (n3 > o2 / 2 && (n3 = o2 / 2), s2 = 0; s2 < n3; ++s2) {
            const n4 = parseInt(t3.substr(2 * s2, 2), 16);
            if (X(n4))
              return s2;
            e3[r3 + s2] = n4;
          }
          return s2;
        }
        function E(e3, t3, r3, n3) {
          return q(V(t3, e3.length - r3), e3, r3, n3);
        }
        function S(e3, t3, r3, n3) {
          return q(function(e4) {
            const t4 = [];
            for (let r4 = 0; r4 < e4.length; ++r4)
              t4.push(255 & e4.charCodeAt(r4));
            return t4;
          }(t3), e3, r3, n3);
        }
        function v(e3, t3, r3, n3) {
          return q(K(t3), e3, r3, n3);
        }
        function A(e3, t3, r3, n3) {
          return q(function(e4, t4) {
            let r4, n4, i2;
            const o2 = [];
            for (let s2 = 0; s2 < e4.length && !((t4 -= 2) < 0); ++s2)
              r4 = e4.charCodeAt(s2), n4 = r4 >> 8, i2 = r4 % 256, o2.push(i2), o2.push(n4);
            return o2;
          }(t3, e3.length - r3), e3, r3, n3);
        }
        function I(e3, t3, r3) {
          return 0 === t3 && r3 === e3.length ? n2.fromByteArray(e3) : n2.fromByteArray(e3.slice(t3, r3));
        }
        function T(e3, t3, r3) {
          r3 = Math.min(e3.length, r3);
          const n3 = [];
          let i2 = t3;
          for (; i2 < r3; ) {
            const t4 = e3[i2];
            let o2 = null, s2 = t4 > 239 ? 4 : t4 > 223 ? 3 : t4 > 191 ? 2 : 1;
            if (i2 + s2 <= r3) {
              let r4, n4, a2, l2;
              switch (s2) {
                case 1:
                  t4 < 128 && (o2 = t4);
                  break;
                case 2:
                  r4 = e3[i2 + 1], 128 == (192 & r4) && (l2 = (31 & t4) << 6 | 63 & r4, l2 > 127 && (o2 = l2));
                  break;
                case 3:
                  r4 = e3[i2 + 1], n4 = e3[i2 + 2], 128 == (192 & r4) && 128 == (192 & n4) && (l2 = (15 & t4) << 12 | (63 & r4) << 6 | 63 & n4, l2 > 2047 && (l2 < 55296 || l2 > 57343) && (o2 = l2));
                  break;
                case 4:
                  r4 = e3[i2 + 1], n4 = e3[i2 + 2], a2 = e3[i2 + 3], 128 == (192 & r4) && 128 == (192 & n4) && 128 == (192 & a2) && (l2 = (15 & t4) << 18 | (63 & r4) << 12 | (63 & n4) << 6 | 63 & a2, l2 > 65535 && l2 < 1114112 && (o2 = l2));
              }
            }
            null === o2 ? (o2 = 65533, s2 = 1) : o2 > 65535 && (o2 -= 65536, n3.push(o2 >>> 10 & 1023 | 55296), o2 = 56320 | 1023 & o2), n3.push(o2), i2 += s2;
          }
          return function(e4) {
            const t4 = e4.length;
            if (t4 <= R)
              return String.fromCharCode.apply(String, e4);
            let r4 = "", n4 = 0;
            for (; n4 < t4; )
              r4 += String.fromCharCode.apply(String, e4.slice(n4, n4 += R));
            return r4;
          }(n3);
        }
        t2.kMaxLength = s, l.TYPED_ARRAY_SUPPORT = function() {
          try {
            const e3 = new Uint8Array(1), t3 = { foo: function() {
              return 42;
            } };
            return Object.setPrototypeOf(t3, Uint8Array.prototype), Object.setPrototypeOf(e3, t3), 42 === e3.foo();
          } catch (e3) {
            return false;
          }
        }(), l.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(l.prototype, "parent", { enumerable: true, get: function() {
          if (l.isBuffer(this))
            return this.buffer;
        } }), Object.defineProperty(l.prototype, "offset", { enumerable: true, get: function() {
          if (l.isBuffer(this))
            return this.byteOffset;
        } }), l.poolSize = 8192, l.from = function(e3, t3, r3) {
          return u(e3, t3, r3);
        }, Object.setPrototypeOf(l.prototype, Uint8Array.prototype), Object.setPrototypeOf(l, Uint8Array), l.alloc = function(e3, t3, r3) {
          return function(e4, t4, r4) {
            return c(e4), e4 <= 0 ? a(e4) : void 0 !== t4 ? "string" == typeof r4 ? a(e4).fill(t4, r4) : a(e4).fill(t4) : a(e4);
          }(e3, t3, r3);
        }, l.allocUnsafe = function(e3) {
          return f(e3);
        }, l.allocUnsafeSlow = function(e3) {
          return f(e3);
        }, l.isBuffer = function(e3) {
          return null != e3 && true === e3._isBuffer && e3 !== l.prototype;
        }, l.compare = function(e3, t3) {
          if (z(e3, Uint8Array) && (e3 = l.from(e3, e3.offset, e3.byteLength)), z(t3, Uint8Array) && (t3 = l.from(t3, t3.offset, t3.byteLength)), !l.isBuffer(e3) || !l.isBuffer(t3))
            throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
          if (e3 === t3)
            return 0;
          let r3 = e3.length, n3 = t3.length;
          for (let i2 = 0, o2 = Math.min(r3, n3); i2 < o2; ++i2)
            if (e3[i2] !== t3[i2]) {
              r3 = e3[i2], n3 = t3[i2];
              break;
            }
          return r3 < n3 ? -1 : n3 < r3 ? 1 : 0;
        }, l.isEncoding = function(e3) {
          switch (String(e3).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return true;
            default:
              return false;
          }
        }, l.concat = function(e3, t3) {
          if (!Array.isArray(e3))
            throw new TypeError('"list" argument must be an Array of Buffers');
          if (0 === e3.length)
            return l.alloc(0);
          let r3;
          if (void 0 === t3)
            for (t3 = 0, r3 = 0; r3 < e3.length; ++r3)
              t3 += e3[r3].length;
          const n3 = l.allocUnsafe(t3);
          let i2 = 0;
          for (r3 = 0; r3 < e3.length; ++r3) {
            let t4 = e3[r3];
            if (z(t4, Uint8Array))
              i2 + t4.length > n3.length ? (l.isBuffer(t4) || (t4 = l.from(t4)), t4.copy(n3, i2)) : Uint8Array.prototype.set.call(n3, t4, i2);
            else {
              if (!l.isBuffer(t4))
                throw new TypeError('"list" argument must be an Array of Buffers');
              t4.copy(n3, i2);
            }
            i2 += t4.length;
          }
          return n3;
        }, l.byteLength = b, l.prototype._isBuffer = true, l.prototype.swap16 = function() {
          const e3 = this.length;
          if (e3 % 2 != 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits");
          for (let t3 = 0; t3 < e3; t3 += 2)
            g(this, t3, t3 + 1);
          return this;
        }, l.prototype.swap32 = function() {
          const e3 = this.length;
          if (e3 % 4 != 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits");
          for (let t3 = 0; t3 < e3; t3 += 4)
            g(this, t3, t3 + 3), g(this, t3 + 1, t3 + 2);
          return this;
        }, l.prototype.swap64 = function() {
          const e3 = this.length;
          if (e3 % 8 != 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits");
          for (let t3 = 0; t3 < e3; t3 += 8)
            g(this, t3, t3 + 7), g(this, t3 + 1, t3 + 6), g(this, t3 + 2, t3 + 5), g(this, t3 + 3, t3 + 4);
          return this;
        }, l.prototype.toString = function() {
          const e3 = this.length;
          return 0 === e3 ? "" : 0 === arguments.length ? T(this, 0, e3) : y.apply(this, arguments);
        }, l.prototype.toLocaleString = l.prototype.toString, l.prototype.equals = function(e3) {
          if (!l.isBuffer(e3))
            throw new TypeError("Argument must be a Buffer");
          return this === e3 || 0 === l.compare(this, e3);
        }, l.prototype.inspect = function() {
          let e3 = "";
          const r3 = t2.INSPECT_MAX_BYTES;
          return e3 = this.toString("hex", 0, r3).replace(/(.{2})/g, "$1 ").trim(), this.length > r3 && (e3 += " ... "), "<Buffer " + e3 + ">";
        }, o && (l.prototype[o] = l.prototype.inspect), l.prototype.compare = function(e3, t3, r3, n3, i2) {
          if (z(e3, Uint8Array) && (e3 = l.from(e3, e3.offset, e3.byteLength)), !l.isBuffer(e3))
            throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e3);
          if (void 0 === t3 && (t3 = 0), void 0 === r3 && (r3 = e3 ? e3.length : 0), void 0 === n3 && (n3 = 0), void 0 === i2 && (i2 = this.length), t3 < 0 || r3 > e3.length || n3 < 0 || i2 > this.length)
            throw new RangeError("out of range index");
          if (n3 >= i2 && t3 >= r3)
            return 0;
          if (n3 >= i2)
            return -1;
          if (t3 >= r3)
            return 1;
          if (this === e3)
            return 0;
          let o2 = (i2 >>>= 0) - (n3 >>>= 0), s2 = (r3 >>>= 0) - (t3 >>>= 0);
          const a2 = Math.min(o2, s2), u2 = this.slice(n3, i2), c2 = e3.slice(t3, r3);
          for (let e4 = 0; e4 < a2; ++e4)
            if (u2[e4] !== c2[e4]) {
              o2 = u2[e4], s2 = c2[e4];
              break;
            }
          return o2 < s2 ? -1 : s2 < o2 ? 1 : 0;
        }, l.prototype.includes = function(e3, t3, r3) {
          return -1 !== this.indexOf(e3, t3, r3);
        }, l.prototype.indexOf = function(e3, t3, r3) {
          return w(this, e3, t3, r3, true);
        }, l.prototype.lastIndexOf = function(e3, t3, r3) {
          return w(this, e3, t3, r3, false);
        }, l.prototype.write = function(e3, t3, r3, n3) {
          if (void 0 === t3)
            n3 = "utf8", r3 = this.length, t3 = 0;
          else if (void 0 === r3 && "string" == typeof t3)
            n3 = t3, r3 = this.length, t3 = 0;
          else {
            if (!isFinite(t3))
              throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            t3 >>>= 0, isFinite(r3) ? (r3 >>>= 0, void 0 === n3 && (n3 = "utf8")) : (n3 = r3, r3 = void 0);
          }
          const i2 = this.length - t3;
          if ((void 0 === r3 || r3 > i2) && (r3 = i2), e3.length > 0 && (r3 < 0 || t3 < 0) || t3 > this.length)
            throw new RangeError("Attempt to write outside buffer bounds");
          n3 || (n3 = "utf8");
          let o2 = false;
          for (; ; )
            switch (n3) {
              case "hex":
                return m(this, e3, t3, r3);
              case "utf8":
              case "utf-8":
                return E(this, e3, t3, r3);
              case "ascii":
              case "latin1":
              case "binary":
                return S(this, e3, t3, r3);
              case "base64":
                return v(this, e3, t3, r3);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return A(this, e3, t3, r3);
              default:
                if (o2)
                  throw new TypeError("Unknown encoding: " + n3);
                n3 = ("" + n3).toLowerCase(), o2 = true;
            }
        }, l.prototype.toJSON = function() {
          return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
        };
        const R = 4096;
        function B(e3, t3, r3) {
          let n3 = "";
          r3 = Math.min(e3.length, r3);
          for (let i2 = t3; i2 < r3; ++i2)
            n3 += String.fromCharCode(127 & e3[i2]);
          return n3;
        }
        function N(e3, t3, r3) {
          let n3 = "";
          r3 = Math.min(e3.length, r3);
          for (let i2 = t3; i2 < r3; ++i2)
            n3 += String.fromCharCode(e3[i2]);
          return n3;
        }
        function L(e3, t3, r3) {
          const n3 = e3.length;
          (!t3 || t3 < 0) && (t3 = 0), (!r3 || r3 < 0 || r3 > n3) && (r3 = n3);
          let i2 = "";
          for (let n4 = t3; n4 < r3; ++n4)
            i2 += J[e3[n4]];
          return i2;
        }
        function U(e3, t3, r3) {
          const n3 = e3.slice(t3, r3);
          let i2 = "";
          for (let e4 = 0; e4 < n3.length - 1; e4 += 2)
            i2 += String.fromCharCode(n3[e4] + 256 * n3[e4 + 1]);
          return i2;
        }
        function M(e3, t3, r3) {
          if (e3 % 1 != 0 || e3 < 0)
            throw new RangeError("offset is not uint");
          if (e3 + t3 > r3)
            throw new RangeError("Trying to access beyond buffer length");
        }
        function O(e3, t3, r3, n3, i2, o2) {
          if (!l.isBuffer(e3))
            throw new TypeError('"buffer" argument must be a Buffer instance');
          if (t3 > i2 || t3 < o2)
            throw new RangeError('"value" argument is out of bounds');
          if (r3 + n3 > e3.length)
            throw new RangeError("Index out of range");
        }
        function x(e3, t3, r3, n3, i2) {
          W(t3, n3, i2, e3, r3, 7);
          let o2 = Number(t3 & BigInt(4294967295));
          e3[r3++] = o2, o2 >>= 8, e3[r3++] = o2, o2 >>= 8, e3[r3++] = o2, o2 >>= 8, e3[r3++] = o2;
          let s2 = Number(t3 >> BigInt(32) & BigInt(4294967295));
          return e3[r3++] = s2, s2 >>= 8, e3[r3++] = s2, s2 >>= 8, e3[r3++] = s2, s2 >>= 8, e3[r3++] = s2, r3;
        }
        function k(e3, t3, r3, n3, i2) {
          W(t3, n3, i2, e3, r3, 7);
          let o2 = Number(t3 & BigInt(4294967295));
          e3[r3 + 7] = o2, o2 >>= 8, e3[r3 + 6] = o2, o2 >>= 8, e3[r3 + 5] = o2, o2 >>= 8, e3[r3 + 4] = o2;
          let s2 = Number(t3 >> BigInt(32) & BigInt(4294967295));
          return e3[r3 + 3] = s2, s2 >>= 8, e3[r3 + 2] = s2, s2 >>= 8, e3[r3 + 1] = s2, s2 >>= 8, e3[r3] = s2, r3 + 8;
        }
        function P(e3, t3, r3, n3, i2, o2) {
          if (r3 + n3 > e3.length)
            throw new RangeError("Index out of range");
          if (r3 < 0)
            throw new RangeError("Index out of range");
        }
        function j(e3, t3, r3, n3, o2) {
          return t3 = +t3, r3 >>>= 0, o2 || P(e3, 0, r3, 4), i.write(e3, t3, r3, n3, 23, 4), r3 + 4;
        }
        function D(e3, t3, r3, n3, o2) {
          return t3 = +t3, r3 >>>= 0, o2 || P(e3, 0, r3, 8), i.write(e3, t3, r3, n3, 52, 8), r3 + 8;
        }
        l.prototype.slice = function(e3, t3) {
          const r3 = this.length;
          (e3 = ~~e3) < 0 ? (e3 += r3) < 0 && (e3 = 0) : e3 > r3 && (e3 = r3), (t3 = void 0 === t3 ? r3 : ~~t3) < 0 ? (t3 += r3) < 0 && (t3 = 0) : t3 > r3 && (t3 = r3), t3 < e3 && (t3 = e3);
          const n3 = this.subarray(e3, t3);
          return Object.setPrototypeOf(n3, l.prototype), n3;
        }, l.prototype.readUintLE = l.prototype.readUIntLE = function(e3, t3, r3) {
          e3 >>>= 0, t3 >>>= 0, r3 || M(e3, t3, this.length);
          let n3 = this[e3], i2 = 1, o2 = 0;
          for (; ++o2 < t3 && (i2 *= 256); )
            n3 += this[e3 + o2] * i2;
          return n3;
        }, l.prototype.readUintBE = l.prototype.readUIntBE = function(e3, t3, r3) {
          e3 >>>= 0, t3 >>>= 0, r3 || M(e3, t3, this.length);
          let n3 = this[e3 + --t3], i2 = 1;
          for (; t3 > 0 && (i2 *= 256); )
            n3 += this[e3 + --t3] * i2;
          return n3;
        }, l.prototype.readUint8 = l.prototype.readUInt8 = function(e3, t3) {
          return e3 >>>= 0, t3 || M(e3, 1, this.length), this[e3];
        }, l.prototype.readUint16LE = l.prototype.readUInt16LE = function(e3, t3) {
          return e3 >>>= 0, t3 || M(e3, 2, this.length), this[e3] | this[e3 + 1] << 8;
        }, l.prototype.readUint16BE = l.prototype.readUInt16BE = function(e3, t3) {
          return e3 >>>= 0, t3 || M(e3, 2, this.length), this[e3] << 8 | this[e3 + 1];
        }, l.prototype.readUint32LE = l.prototype.readUInt32LE = function(e3, t3) {
          return e3 >>>= 0, t3 || M(e3, 4, this.length), (this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16) + 16777216 * this[e3 + 3];
        }, l.prototype.readUint32BE = l.prototype.readUInt32BE = function(e3, t3) {
          return e3 >>>= 0, t3 || M(e3, 4, this.length), 16777216 * this[e3] + (this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3]);
        }, l.prototype.readBigUInt64LE = Z(function(e3) {
          G(e3 >>>= 0, "offset");
          const t3 = this[e3], r3 = this[e3 + 7];
          void 0 !== t3 && void 0 !== r3 || H(e3, this.length - 8);
          const n3 = t3 + 256 * this[++e3] + 65536 * this[++e3] + this[++e3] * 2 ** 24, i2 = this[++e3] + 256 * this[++e3] + 65536 * this[++e3] + r3 * 2 ** 24;
          return BigInt(n3) + (BigInt(i2) << BigInt(32));
        }), l.prototype.readBigUInt64BE = Z(function(e3) {
          G(e3 >>>= 0, "offset");
          const t3 = this[e3], r3 = this[e3 + 7];
          void 0 !== t3 && void 0 !== r3 || H(e3, this.length - 8);
          const n3 = t3 * 2 ** 24 + 65536 * this[++e3] + 256 * this[++e3] + this[++e3], i2 = this[++e3] * 2 ** 24 + 65536 * this[++e3] + 256 * this[++e3] + r3;
          return (BigInt(n3) << BigInt(32)) + BigInt(i2);
        }), l.prototype.readIntLE = function(e3, t3, r3) {
          e3 >>>= 0, t3 >>>= 0, r3 || M(e3, t3, this.length);
          let n3 = this[e3], i2 = 1, o2 = 0;
          for (; ++o2 < t3 && (i2 *= 256); )
            n3 += this[e3 + o2] * i2;
          return i2 *= 128, n3 >= i2 && (n3 -= Math.pow(2, 8 * t3)), n3;
        }, l.prototype.readIntBE = function(e3, t3, r3) {
          e3 >>>= 0, t3 >>>= 0, r3 || M(e3, t3, this.length);
          let n3 = t3, i2 = 1, o2 = this[e3 + --n3];
          for (; n3 > 0 && (i2 *= 256); )
            o2 += this[e3 + --n3] * i2;
          return i2 *= 128, o2 >= i2 && (o2 -= Math.pow(2, 8 * t3)), o2;
        }, l.prototype.readInt8 = function(e3, t3) {
          return e3 >>>= 0, t3 || M(e3, 1, this.length), 128 & this[e3] ? -1 * (255 - this[e3] + 1) : this[e3];
        }, l.prototype.readInt16LE = function(e3, t3) {
          e3 >>>= 0, t3 || M(e3, 2, this.length);
          const r3 = this[e3] | this[e3 + 1] << 8;
          return 32768 & r3 ? 4294901760 | r3 : r3;
        }, l.prototype.readInt16BE = function(e3, t3) {
          e3 >>>= 0, t3 || M(e3, 2, this.length);
          const r3 = this[e3 + 1] | this[e3] << 8;
          return 32768 & r3 ? 4294901760 | r3 : r3;
        }, l.prototype.readInt32LE = function(e3, t3) {
          return e3 >>>= 0, t3 || M(e3, 4, this.length), this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16 | this[e3 + 3] << 24;
        }, l.prototype.readInt32BE = function(e3, t3) {
          return e3 >>>= 0, t3 || M(e3, 4, this.length), this[e3] << 24 | this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3];
        }, l.prototype.readBigInt64LE = Z(function(e3) {
          G(e3 >>>= 0, "offset");
          const t3 = this[e3], r3 = this[e3 + 7];
          void 0 !== t3 && void 0 !== r3 || H(e3, this.length - 8);
          const n3 = this[e3 + 4] + 256 * this[e3 + 5] + 65536 * this[e3 + 6] + (r3 << 24);
          return (BigInt(n3) << BigInt(32)) + BigInt(t3 + 256 * this[++e3] + 65536 * this[++e3] + this[++e3] * 2 ** 24);
        }), l.prototype.readBigInt64BE = Z(function(e3) {
          G(e3 >>>= 0, "offset");
          const t3 = this[e3], r3 = this[e3 + 7];
          void 0 !== t3 && void 0 !== r3 || H(e3, this.length - 8);
          const n3 = (t3 << 24) + 65536 * this[++e3] + 256 * this[++e3] + this[++e3];
          return (BigInt(n3) << BigInt(32)) + BigInt(this[++e3] * 2 ** 24 + 65536 * this[++e3] + 256 * this[++e3] + r3);
        }), l.prototype.readFloatLE = function(e3, t3) {
          return e3 >>>= 0, t3 || M(e3, 4, this.length), i.read(this, e3, true, 23, 4);
        }, l.prototype.readFloatBE = function(e3, t3) {
          return e3 >>>= 0, t3 || M(e3, 4, this.length), i.read(this, e3, false, 23, 4);
        }, l.prototype.readDoubleLE = function(e3, t3) {
          return e3 >>>= 0, t3 || M(e3, 8, this.length), i.read(this, e3, true, 52, 8);
        }, l.prototype.readDoubleBE = function(e3, t3) {
          return e3 >>>= 0, t3 || M(e3, 8, this.length), i.read(this, e3, false, 52, 8);
        }, l.prototype.writeUintLE = l.prototype.writeUIntLE = function(e3, t3, r3, n3) {
          e3 = +e3, t3 >>>= 0, r3 >>>= 0, n3 || O(this, e3, t3, r3, Math.pow(2, 8 * r3) - 1, 0);
          let i2 = 1, o2 = 0;
          for (this[t3] = 255 & e3; ++o2 < r3 && (i2 *= 256); )
            this[t3 + o2] = e3 / i2 & 255;
          return t3 + r3;
        }, l.prototype.writeUintBE = l.prototype.writeUIntBE = function(e3, t3, r3, n3) {
          e3 = +e3, t3 >>>= 0, r3 >>>= 0, n3 || O(this, e3, t3, r3, Math.pow(2, 8 * r3) - 1, 0);
          let i2 = r3 - 1, o2 = 1;
          for (this[t3 + i2] = 255 & e3; --i2 >= 0 && (o2 *= 256); )
            this[t3 + i2] = e3 / o2 & 255;
          return t3 + r3;
        }, l.prototype.writeUint8 = l.prototype.writeUInt8 = function(e3, t3, r3) {
          return e3 = +e3, t3 >>>= 0, r3 || O(this, e3, t3, 1, 255, 0), this[t3] = 255 & e3, t3 + 1;
        }, l.prototype.writeUint16LE = l.prototype.writeUInt16LE = function(e3, t3, r3) {
          return e3 = +e3, t3 >>>= 0, r3 || O(this, e3, t3, 2, 65535, 0), this[t3] = 255 & e3, this[t3 + 1] = e3 >>> 8, t3 + 2;
        }, l.prototype.writeUint16BE = l.prototype.writeUInt16BE = function(e3, t3, r3) {
          return e3 = +e3, t3 >>>= 0, r3 || O(this, e3, t3, 2, 65535, 0), this[t3] = e3 >>> 8, this[t3 + 1] = 255 & e3, t3 + 2;
        }, l.prototype.writeUint32LE = l.prototype.writeUInt32LE = function(e3, t3, r3) {
          return e3 = +e3, t3 >>>= 0, r3 || O(this, e3, t3, 4, 4294967295, 0), this[t3 + 3] = e3 >>> 24, this[t3 + 2] = e3 >>> 16, this[t3 + 1] = e3 >>> 8, this[t3] = 255 & e3, t3 + 4;
        }, l.prototype.writeUint32BE = l.prototype.writeUInt32BE = function(e3, t3, r3) {
          return e3 = +e3, t3 >>>= 0, r3 || O(this, e3, t3, 4, 4294967295, 0), this[t3] = e3 >>> 24, this[t3 + 1] = e3 >>> 16, this[t3 + 2] = e3 >>> 8, this[t3 + 3] = 255 & e3, t3 + 4;
        }, l.prototype.writeBigUInt64LE = Z(function(e3, t3 = 0) {
          return x(this, e3, t3, BigInt(0), BigInt("0xffffffffffffffff"));
        }), l.prototype.writeBigUInt64BE = Z(function(e3, t3 = 0) {
          return k(this, e3, t3, BigInt(0), BigInt("0xffffffffffffffff"));
        }), l.prototype.writeIntLE = function(e3, t3, r3, n3) {
          if (e3 = +e3, t3 >>>= 0, !n3) {
            const n4 = Math.pow(2, 8 * r3 - 1);
            O(this, e3, t3, r3, n4 - 1, -n4);
          }
          let i2 = 0, o2 = 1, s2 = 0;
          for (this[t3] = 255 & e3; ++i2 < r3 && (o2 *= 256); )
            e3 < 0 && 0 === s2 && 0 !== this[t3 + i2 - 1] && (s2 = 1), this[t3 + i2] = (e3 / o2 | 0) - s2 & 255;
          return t3 + r3;
        }, l.prototype.writeIntBE = function(e3, t3, r3, n3) {
          if (e3 = +e3, t3 >>>= 0, !n3) {
            const n4 = Math.pow(2, 8 * r3 - 1);
            O(this, e3, t3, r3, n4 - 1, -n4);
          }
          let i2 = r3 - 1, o2 = 1, s2 = 0;
          for (this[t3 + i2] = 255 & e3; --i2 >= 0 && (o2 *= 256); )
            e3 < 0 && 0 === s2 && 0 !== this[t3 + i2 + 1] && (s2 = 1), this[t3 + i2] = (e3 / o2 | 0) - s2 & 255;
          return t3 + r3;
        }, l.prototype.writeInt8 = function(e3, t3, r3) {
          return e3 = +e3, t3 >>>= 0, r3 || O(this, e3, t3, 1, 127, -128), e3 < 0 && (e3 = 255 + e3 + 1), this[t3] = 255 & e3, t3 + 1;
        }, l.prototype.writeInt16LE = function(e3, t3, r3) {
          return e3 = +e3, t3 >>>= 0, r3 || O(this, e3, t3, 2, 32767, -32768), this[t3] = 255 & e3, this[t3 + 1] = e3 >>> 8, t3 + 2;
        }, l.prototype.writeInt16BE = function(e3, t3, r3) {
          return e3 = +e3, t3 >>>= 0, r3 || O(this, e3, t3, 2, 32767, -32768), this[t3] = e3 >>> 8, this[t3 + 1] = 255 & e3, t3 + 2;
        }, l.prototype.writeInt32LE = function(e3, t3, r3) {
          return e3 = +e3, t3 >>>= 0, r3 || O(this, e3, t3, 4, 2147483647, -2147483648), this[t3] = 255 & e3, this[t3 + 1] = e3 >>> 8, this[t3 + 2] = e3 >>> 16, this[t3 + 3] = e3 >>> 24, t3 + 4;
        }, l.prototype.writeInt32BE = function(e3, t3, r3) {
          return e3 = +e3, t3 >>>= 0, r3 || O(this, e3, t3, 4, 2147483647, -2147483648), e3 < 0 && (e3 = 4294967295 + e3 + 1), this[t3] = e3 >>> 24, this[t3 + 1] = e3 >>> 16, this[t3 + 2] = e3 >>> 8, this[t3 + 3] = 255 & e3, t3 + 4;
        }, l.prototype.writeBigInt64LE = Z(function(e3, t3 = 0) {
          return x(this, e3, t3, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
        }), l.prototype.writeBigInt64BE = Z(function(e3, t3 = 0) {
          return k(this, e3, t3, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
        }), l.prototype.writeFloatLE = function(e3, t3, r3) {
          return j(this, e3, t3, true, r3);
        }, l.prototype.writeFloatBE = function(e3, t3, r3) {
          return j(this, e3, t3, false, r3);
        }, l.prototype.writeDoubleLE = function(e3, t3, r3) {
          return D(this, e3, t3, true, r3);
        }, l.prototype.writeDoubleBE = function(e3, t3, r3) {
          return D(this, e3, t3, false, r3);
        }, l.prototype.copy = function(e3, t3, r3, n3) {
          if (!l.isBuffer(e3))
            throw new TypeError("argument should be a Buffer");
          if (r3 || (r3 = 0), n3 || 0 === n3 || (n3 = this.length), t3 >= e3.length && (t3 = e3.length), t3 || (t3 = 0), n3 > 0 && n3 < r3 && (n3 = r3), n3 === r3)
            return 0;
          if (0 === e3.length || 0 === this.length)
            return 0;
          if (t3 < 0)
            throw new RangeError("targetStart out of bounds");
          if (r3 < 0 || r3 >= this.length)
            throw new RangeError("Index out of range");
          if (n3 < 0)
            throw new RangeError("sourceEnd out of bounds");
          n3 > this.length && (n3 = this.length), e3.length - t3 < n3 - r3 && (n3 = e3.length - t3 + r3);
          const i2 = n3 - r3;
          return this === e3 && "function" == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(t3, r3, n3) : Uint8Array.prototype.set.call(e3, this.subarray(r3, n3), t3), i2;
        }, l.prototype.fill = function(e3, t3, r3, n3) {
          if ("string" == typeof e3) {
            if ("string" == typeof t3 ? (n3 = t3, t3 = 0, r3 = this.length) : "string" == typeof r3 && (n3 = r3, r3 = this.length), void 0 !== n3 && "string" != typeof n3)
              throw new TypeError("encoding must be a string");
            if ("string" == typeof n3 && !l.isEncoding(n3))
              throw new TypeError("Unknown encoding: " + n3);
            if (1 === e3.length) {
              const t4 = e3.charCodeAt(0);
              ("utf8" === n3 && t4 < 128 || "latin1" === n3) && (e3 = t4);
            }
          } else
            "number" == typeof e3 ? e3 &= 255 : "boolean" == typeof e3 && (e3 = Number(e3));
          if (t3 < 0 || this.length < t3 || this.length < r3)
            throw new RangeError("Out of range index");
          if (r3 <= t3)
            return this;
          let i2;
          if (t3 >>>= 0, r3 = void 0 === r3 ? this.length : r3 >>> 0, e3 || (e3 = 0), "number" == typeof e3)
            for (i2 = t3; i2 < r3; ++i2)
              this[i2] = e3;
          else {
            const o2 = l.isBuffer(e3) ? e3 : l.from(e3, n3), s2 = o2.length;
            if (0 === s2)
              throw new TypeError('The value "' + e3 + '" is invalid for argument "value"');
            for (i2 = 0; i2 < r3 - t3; ++i2)
              this[i2 + t3] = o2[i2 % s2];
          }
          return this;
        };
        const F = {};
        function C(e3, t3, r3) {
          F[e3] = class extends r3 {
            constructor() {
              super(), Object.defineProperty(this, "message", { value: t3.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${e3}]`, this.stack, delete this.name;
            }
            get code() {
              return e3;
            }
            set code(e4) {
              Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: e4, writable: true });
            }
            toString() {
              return `${this.name} [${e3}]: ${this.message}`;
            }
          };
        }
        function $(e3) {
          let t3 = "", r3 = e3.length;
          const n3 = "-" === e3[0] ? 1 : 0;
          for (; r3 >= n3 + 4; r3 -= 3)
            t3 = `_${e3.slice(r3 - 3, r3)}${t3}`;
          return `${e3.slice(0, r3)}${t3}`;
        }
        function W(e3, t3, r3, n3, i2, o2) {
          if (e3 > r3 || e3 < t3) {
            const n4 = "bigint" == typeof t3 ? "n" : "";
            let i3;
            throw i3 = o2 > 3 ? 0 === t3 || t3 === BigInt(0) ? `>= 0${n4} and < 2${n4} ** ${8 * (o2 + 1)}${n4}` : `>= -(2${n4} ** ${8 * (o2 + 1) - 1}${n4}) and < 2 ** ${8 * (o2 + 1) - 1}${n4}` : `>= ${t3}${n4} and <= ${r3}${n4}`, new F.ERR_OUT_OF_RANGE("value", i3, e3);
          }
          !function(e4, t4, r4) {
            G(t4, "offset"), void 0 !== e4[t4] && void 0 !== e4[t4 + r4] || H(t4, e4.length - (r4 + 1));
          }(n3, i2, o2);
        }
        function G(e3, t3) {
          if ("number" != typeof e3)
            throw new F.ERR_INVALID_ARG_TYPE(t3, "number", e3);
        }
        function H(e3, t3, r3) {
          if (Math.floor(e3) !== e3)
            throw G(e3, r3), new F.ERR_OUT_OF_RANGE(r3 || "offset", "an integer", e3);
          if (t3 < 0)
            throw new F.ERR_BUFFER_OUT_OF_BOUNDS();
          throw new F.ERR_OUT_OF_RANGE(r3 || "offset", `>= ${r3 ? 1 : 0} and <= ${t3}`, e3);
        }
        C("ERR_BUFFER_OUT_OF_BOUNDS", function(e3) {
          return e3 ? `${e3} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
        }, RangeError), C("ERR_INVALID_ARG_TYPE", function(e3, t3) {
          return `The "${e3}" argument must be of type number. Received type ${typeof t3}`;
        }, TypeError), C("ERR_OUT_OF_RANGE", function(e3, t3, r3) {
          let n3 = `The value of "${e3}" is out of range.`, i2 = r3;
          return Number.isInteger(r3) && Math.abs(r3) > 2 ** 32 ? i2 = $(String(r3)) : "bigint" == typeof r3 && (i2 = String(r3), (r3 > BigInt(2) ** BigInt(32) || r3 < -(BigInt(2) ** BigInt(32))) && (i2 = $(i2)), i2 += "n"), n3 += ` It must be ${t3}. Received ${i2}`, n3;
        }, RangeError);
        const Y = /[^+/0-9A-Za-z-_]/g;
        function V(e3, t3) {
          let r3;
          t3 = t3 || 1 / 0;
          const n3 = e3.length;
          let i2 = null;
          const o2 = [];
          for (let s2 = 0; s2 < n3; ++s2) {
            if (r3 = e3.charCodeAt(s2), r3 > 55295 && r3 < 57344) {
              if (!i2) {
                if (r3 > 56319) {
                  (t3 -= 3) > -1 && o2.push(239, 191, 189);
                  continue;
                }
                if (s2 + 1 === n3) {
                  (t3 -= 3) > -1 && o2.push(239, 191, 189);
                  continue;
                }
                i2 = r3;
                continue;
              }
              if (r3 < 56320) {
                (t3 -= 3) > -1 && o2.push(239, 191, 189), i2 = r3;
                continue;
              }
              r3 = 65536 + (i2 - 55296 << 10 | r3 - 56320);
            } else
              i2 && (t3 -= 3) > -1 && o2.push(239, 191, 189);
            if (i2 = null, r3 < 128) {
              if ((t3 -= 1) < 0)
                break;
              o2.push(r3);
            } else if (r3 < 2048) {
              if ((t3 -= 2) < 0)
                break;
              o2.push(r3 >> 6 | 192, 63 & r3 | 128);
            } else if (r3 < 65536) {
              if ((t3 -= 3) < 0)
                break;
              o2.push(r3 >> 12 | 224, r3 >> 6 & 63 | 128, 63 & r3 | 128);
            } else {
              if (!(r3 < 1114112))
                throw new Error("Invalid code point");
              if ((t3 -= 4) < 0)
                break;
              o2.push(r3 >> 18 | 240, r3 >> 12 & 63 | 128, r3 >> 6 & 63 | 128, 63 & r3 | 128);
            }
          }
          return o2;
        }
        function K(e3) {
          return n2.toByteArray(function(e4) {
            if ((e4 = (e4 = e4.split("=")[0]).trim().replace(Y, "")).length < 2)
              return "";
            for (; e4.length % 4 != 0; )
              e4 += "=";
            return e4;
          }(e3));
        }
        function q(e3, t3, r3, n3) {
          let i2;
          for (i2 = 0; i2 < n3 && !(i2 + r3 >= t3.length || i2 >= e3.length); ++i2)
            t3[i2 + r3] = e3[i2];
          return i2;
        }
        function z(e3, t3) {
          return e3 instanceof t3 || null != e3 && null != e3.constructor && null != e3.constructor.name && e3.constructor.name === t3.name;
        }
        function X(e3) {
          return e3 != e3;
        }
        const J = function() {
          const e3 = "0123456789abcdef", t3 = new Array(256);
          for (let r3 = 0; r3 < 16; ++r3) {
            const n3 = 16 * r3;
            for (let i2 = 0; i2 < 16; ++i2)
              t3[n3 + i2] = e3[r3] + e3[i2];
          }
          return t3;
        }();
        function Z(e3) {
          return "undefined" == typeof BigInt ? Q : e3;
        }
        function Q() {
          throw new Error("BigInt not supported");
        }
      }, 8310: (e2, t2, r2) => {
        e2.exports = i;
        var n2 = r2(7007).EventEmitter;
        function i() {
          n2.call(this);
        }
        r2(6698)(i, n2), i.Readable = r2(5412), i.Writable = r2(6708), i.Duplex = r2(5382), i.Transform = r2(4610), i.PassThrough = r2(3600), i.finished = r2(6238), i.pipeline = r2(7758), i.Stream = i, i.prototype.pipe = function(e3, t3) {
          var r3 = this;
          function i2(t4) {
            e3.writable && false === e3.write(t4) && r3.pause && r3.pause();
          }
          function o() {
            r3.readable && r3.resume && r3.resume();
          }
          r3.on("data", i2), e3.on("drain", o), e3._isStdio || t3 && false === t3.end || (r3.on("end", a), r3.on("close", l));
          var s = false;
          function a() {
            s || (s = true, e3.end());
          }
          function l() {
            s || (s = true, "function" == typeof e3.destroy && e3.destroy());
          }
          function u(e4) {
            if (c(), 0 === n2.listenerCount(this, "error"))
              throw e4;
          }
          function c() {
            r3.removeListener("data", i2), e3.removeListener("drain", o), r3.removeListener("end", a), r3.removeListener("close", l), r3.removeListener("error", u), e3.removeListener("error", u), r3.removeListener("end", c), r3.removeListener("close", c), e3.removeListener("close", c);
          }
          return r3.on("error", u), e3.on("error", u), r3.on("end", c), r3.on("close", c), e3.on("close", c), e3.emit("pipe", r3), e3;
        };
      }, 8584: (e2, t2, r2) => {
        "use strict";
        const n2 = r2(5606), { ArrayPrototypeSlice: i, Error: o, FunctionPrototypeSymbolHasInstance: s, ObjectDefineProperty: a, ObjectDefineProperties: l, ObjectSetPrototypeOf: u, StringPrototypeToLowerCase: c, Symbol: f, SymbolHasInstance: h } = r2(4134);
        e2.exports = x, x.WritableState = M;
        const { EventEmitter: d } = r2(7007), p = r2(4259).Stream, { Buffer: b } = r2(8287), y = r2(5896), { addAbortSignal: g } = r2(4147), { getHighWaterMark: w, getDefaultHighWaterMark: _ } = r2(5291), { ERR_INVALID_ARG_TYPE: m, ERR_METHOD_NOT_IMPLEMENTED: E, ERR_MULTIPLE_CALLBACK: S, ERR_STREAM_CANNOT_PIPE: v, ERR_STREAM_DESTROYED: A, ERR_STREAM_ALREADY_FINISHED: I, ERR_STREAM_NULL_VALUES: T, ERR_STREAM_WRITE_AFTER_END: R, ERR_UNKNOWN_ENCODING: B } = r2(6371).codes, { errorOrDestroy: N } = y;
        function L() {
        }
        u(x.prototype, p.prototype), u(x, p);
        const U = f("kOnFinished");
        function M(e3, t3, n3) {
          "boolean" != typeof n3 && (n3 = t3 instanceof r2(3370)), this.objectMode = !(!e3 || !e3.objectMode), n3 && (this.objectMode = this.objectMode || !(!e3 || !e3.writableObjectMode)), this.highWaterMark = e3 ? w(this, e3, "writableHighWaterMark", n3) : _(false), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
          const i2 = !(!e3 || false !== e3.decodeStrings);
          this.decodeStrings = !i2, this.defaultEncoding = e3 && e3.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = D.bind(void 0, t3), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, O(this), this.pendingcb = 0, this.constructed = true, this.prefinished = false, this.errorEmitted = false, this.emitClose = !e3 || false !== e3.emitClose, this.autoDestroy = !e3 || false !== e3.autoDestroy, this.errored = null, this.closed = false, this.closeEmitted = false, this[U] = [];
        }
        function O(e3) {
          e3.buffered = [], e3.bufferedIndex = 0, e3.allBuffers = true, e3.allNoop = true;
        }
        function x(e3) {
          const t3 = this instanceof r2(3370);
          if (!t3 && !s(x, this))
            return new x(e3);
          this._writableState = new M(e3, this, t3), e3 && ("function" == typeof e3.write && (this._write = e3.write), "function" == typeof e3.writev && (this._writev = e3.writev), "function" == typeof e3.destroy && (this._destroy = e3.destroy), "function" == typeof e3.final && (this._final = e3.final), "function" == typeof e3.construct && (this._construct = e3.construct), e3.signal && g(e3.signal, this)), p.call(this, e3), y.construct(this, () => {
            const e4 = this._writableState;
            e4.writing || W(this, e4), H(this, e4);
          });
        }
        function k(e3, t3, r3, i2) {
          const o2 = e3._writableState;
          if ("function" == typeof r3)
            i2 = r3, r3 = o2.defaultEncoding;
          else {
            if (r3) {
              if ("buffer" !== r3 && !b.isEncoding(r3))
                throw new B(r3);
            } else
              r3 = o2.defaultEncoding;
            "function" != typeof i2 && (i2 = L);
          }
          if (null === t3)
            throw new T();
          if (!o2.objectMode)
            if ("string" == typeof t3)
              false !== o2.decodeStrings && (t3 = b.from(t3, r3), r3 = "buffer");
            else if (t3 instanceof b)
              r3 = "buffer";
            else {
              if (!p._isUint8Array(t3))
                throw new m("chunk", ["string", "Buffer", "Uint8Array"], t3);
              t3 = p._uint8ArrayToBuffer(t3), r3 = "buffer";
            }
          let s2;
          return o2.ending ? s2 = new R() : o2.destroyed && (s2 = new A("write")), s2 ? (n2.nextTick(i2, s2), N(e3, s2, true), s2) : (o2.pendingcb++, function(e4, t4, r4, n3, i3) {
            const o3 = t4.objectMode ? 1 : r4.length;
            t4.length += o3;
            const s3 = t4.length < t4.highWaterMark;
            return s3 || (t4.needDrain = true), t4.writing || t4.corked || t4.errored || !t4.constructed ? (t4.buffered.push({ chunk: r4, encoding: n3, callback: i3 }), t4.allBuffers && "buffer" !== n3 && (t4.allBuffers = false), t4.allNoop && i3 !== L && (t4.allNoop = false)) : (t4.writelen = o3, t4.writecb = i3, t4.writing = true, t4.sync = true, e4._write(r4, n3, t4.onwrite), t4.sync = false), s3 && !t4.errored && !t4.destroyed;
          }(e3, o2, t3, r3, i2));
        }
        function P(e3, t3, r3, n3, i2, o2, s2) {
          t3.writelen = n3, t3.writecb = s2, t3.writing = true, t3.sync = true, t3.destroyed ? t3.onwrite(new A("write")) : r3 ? e3._writev(i2, t3.onwrite) : e3._write(i2, o2, t3.onwrite), t3.sync = false;
        }
        function j(e3, t3, r3, n3) {
          --t3.pendingcb, n3(r3), $(t3), N(e3, r3);
        }
        function D(e3, t3) {
          const r3 = e3._writableState, i2 = r3.sync, o2 = r3.writecb;
          "function" == typeof o2 ? (r3.writing = false, r3.writecb = null, r3.length -= r3.writelen, r3.writelen = 0, t3 ? (t3.stack, r3.errored || (r3.errored = t3), e3._readableState && !e3._readableState.errored && (e3._readableState.errored = t3), i2 ? n2.nextTick(j, e3, r3, t3, o2) : j(e3, r3, t3, o2)) : (r3.buffered.length > r3.bufferedIndex && W(e3, r3), i2 ? null !== r3.afterWriteTickInfo && r3.afterWriteTickInfo.cb === o2 ? r3.afterWriteTickInfo.count++ : (r3.afterWriteTickInfo = { count: 1, cb: o2, stream: e3, state: r3 }, n2.nextTick(F, r3.afterWriteTickInfo)) : C(e3, r3, 1, o2))) : N(e3, new S());
        }
        function F({ stream: e3, state: t3, count: r3, cb: n3 }) {
          return t3.afterWriteTickInfo = null, C(e3, t3, r3, n3);
        }
        function C(e3, t3, r3, n3) {
          for (!t3.ending && !e3.destroyed && 0 === t3.length && t3.needDrain && (t3.needDrain = false, e3.emit("drain")); r3-- > 0; )
            t3.pendingcb--, n3();
          t3.destroyed && $(t3), H(e3, t3);
        }
        function $(e3) {
          if (e3.writing)
            return;
          for (let r4 = e3.bufferedIndex; r4 < e3.buffered.length; ++r4) {
            var t3;
            const { chunk: n4, callback: i2 } = e3.buffered[r4], o2 = e3.objectMode ? 1 : n4.length;
            e3.length -= o2, i2(null !== (t3 = e3.errored) && void 0 !== t3 ? t3 : new A("write"));
          }
          const r3 = e3[U].splice(0);
          for (let t4 = 0; t4 < r3.length; t4++) {
            var n3;
            r3[t4](null !== (n3 = e3.errored) && void 0 !== n3 ? n3 : new A("end"));
          }
          O(e3);
        }
        function W(e3, t3) {
          if (t3.corked || t3.bufferProcessing || t3.destroyed || !t3.constructed)
            return;
          const { buffered: r3, bufferedIndex: n3, objectMode: o2 } = t3, s2 = r3.length - n3;
          if (!s2)
            return;
          let a2 = n3;
          if (t3.bufferProcessing = true, s2 > 1 && e3._writev) {
            t3.pendingcb -= s2 - 1;
            const n4 = t3.allNoop ? L : (e4) => {
              for (let t4 = a2; t4 < r3.length; ++t4)
                r3[t4].callback(e4);
            }, o3 = t3.allNoop && 0 === a2 ? r3 : i(r3, a2);
            o3.allBuffers = t3.allBuffers, P(e3, t3, true, t3.length, o3, "", n4), O(t3);
          } else {
            do {
              const { chunk: n4, encoding: i2, callback: s3 } = r3[a2];
              r3[a2++] = null, P(e3, t3, false, o2 ? 1 : n4.length, n4, i2, s3);
            } while (a2 < r3.length && !t3.writing);
            a2 === r3.length ? O(t3) : a2 > 256 ? (r3.splice(0, a2), t3.bufferedIndex = 0) : t3.bufferedIndex = a2;
          }
          t3.bufferProcessing = false;
        }
        function G(e3) {
          return e3.ending && !e3.destroyed && e3.constructed && 0 === e3.length && !e3.errored && 0 === e3.buffered.length && !e3.finished && !e3.writing && !e3.errorEmitted && !e3.closeEmitted;
        }
        function H(e3, t3, r3) {
          G(t3) && (function(e4, t4) {
            t4.prefinished || t4.finalCalled || ("function" != typeof e4._final || t4.destroyed ? (t4.prefinished = true, e4.emit("prefinish")) : (t4.finalCalled = true, function(e5, t5) {
              let r4 = false;
              function i2(i3) {
                if (r4)
                  N(e5, null != i3 ? i3 : S());
                else if (r4 = true, t5.pendingcb--, i3) {
                  const r5 = t5[U].splice(0);
                  for (let e6 = 0; e6 < r5.length; e6++)
                    r5[e6](i3);
                  N(e5, i3, t5.sync);
                } else
                  G(t5) && (t5.prefinished = true, e5.emit("prefinish"), t5.pendingcb++, n2.nextTick(Y, e5, t5));
              }
              t5.sync = true, t5.pendingcb++;
              try {
                e5._final(i2);
              } catch (e6) {
                i2(e6);
              }
              t5.sync = false;
            }(e4, t4)));
          }(e3, t3), 0 === t3.pendingcb && (r3 ? (t3.pendingcb++, n2.nextTick((e4, t4) => {
            G(t4) ? Y(e4, t4) : t4.pendingcb--;
          }, e3, t3)) : G(t3) && (t3.pendingcb++, Y(e3, t3))));
        }
        function Y(e3, t3) {
          t3.pendingcb--, t3.finished = true;
          const r3 = t3[U].splice(0);
          for (let e4 = 0; e4 < r3.length; e4++)
            r3[e4]();
          if (e3.emit("finish"), t3.autoDestroy) {
            const t4 = e3._readableState;
            (!t4 || t4.autoDestroy && (t4.endEmitted || false === t4.readable)) && e3.destroy();
          }
        }
        M.prototype.getBuffer = function() {
          return i(this.buffered, this.bufferedIndex);
        }, a(M.prototype, "bufferedRequestCount", { __proto__: null, get() {
          return this.buffered.length - this.bufferedIndex;
        } }), a(x, h, { __proto__: null, value: function(e3) {
          return !!s(this, e3) || this === x && e3 && e3._writableState instanceof M;
        } }), x.prototype.pipe = function() {
          N(this, new v());
        }, x.prototype.write = function(e3, t3, r3) {
          return true === k(this, e3, t3, r3);
        }, x.prototype.cork = function() {
          this._writableState.corked++;
        }, x.prototype.uncork = function() {
          const e3 = this._writableState;
          e3.corked && (e3.corked--, e3.writing || W(this, e3));
        }, x.prototype.setDefaultEncoding = function(e3) {
          if ("string" == typeof e3 && (e3 = c(e3)), !b.isEncoding(e3))
            throw new B(e3);
          return this._writableState.defaultEncoding = e3, this;
        }, x.prototype._write = function(e3, t3, r3) {
          if (!this._writev)
            throw new E("_write()");
          this._writev([{ chunk: e3, encoding: t3 }], r3);
        }, x.prototype._writev = null, x.prototype.end = function(e3, t3, r3) {
          const i2 = this._writableState;
          let s2;
          if ("function" == typeof e3 ? (r3 = e3, e3 = null, t3 = null) : "function" == typeof t3 && (r3 = t3, t3 = null), null != e3) {
            const r4 = k(this, e3, t3);
            r4 instanceof o && (s2 = r4);
          }
          return i2.corked && (i2.corked = 1, this.uncork()), s2 || (i2.errored || i2.ending ? i2.finished ? s2 = new I("end") : i2.destroyed && (s2 = new A("end")) : (i2.ending = true, H(this, i2, true), i2.ended = true)), "function" == typeof r3 && (s2 || i2.finished ? n2.nextTick(r3, s2) : i2[U].push(r3)), this;
        }, l(x.prototype, { closed: { __proto__: null, get() {
          return !!this._writableState && this._writableState.closed;
        } }, destroyed: { __proto__: null, get() {
          return !!this._writableState && this._writableState.destroyed;
        }, set(e3) {
          this._writableState && (this._writableState.destroyed = e3);
        } }, writable: { __proto__: null, get() {
          const e3 = this._writableState;
          return !(!e3 || false === e3.writable || e3.destroyed || e3.errored || e3.ending || e3.ended);
        }, set(e3) {
          this._writableState && (this._writableState.writable = !!e3);
        } }, writableFinished: { __proto__: null, get() {
          return !!this._writableState && this._writableState.finished;
        } }, writableObjectMode: { __proto__: null, get() {
          return !!this._writableState && this._writableState.objectMode;
        } }, writableBuffer: { __proto__: null, get() {
          return this._writableState && this._writableState.getBuffer();
        } }, writableEnded: { __proto__: null, get() {
          return !!this._writableState && this._writableState.ending;
        } }, writableNeedDrain: { __proto__: null, get() {
          const e3 = this._writableState;
          return !!e3 && !e3.destroyed && !e3.ending && e3.needDrain;
        } }, writableHighWaterMark: { __proto__: null, get() {
          return this._writableState && this._writableState.highWaterMark;
        } }, writableCorked: { __proto__: null, get() {
          return this._writableState ? this._writableState.corked : 0;
        } }, writableLength: { __proto__: null, get() {
          return this._writableState && this._writableState.length;
        } }, errored: { __proto__: null, enumerable: false, get() {
          return this._writableState ? this._writableState.errored : null;
        } }, writableAborted: { __proto__: null, enumerable: false, get: function() {
          return !(false === this._writableState.writable || !this._writableState.destroyed && !this._writableState.errored || this._writableState.finished);
        } } });
        const V = y.destroy;
        let K;
        function q() {
          return void 0 === K && (K = {}), K;
        }
        x.prototype.destroy = function(e3, t3) {
          const r3 = this._writableState;
          return !r3.destroyed && (r3.bufferedIndex < r3.buffered.length || r3[U].length) && n2.nextTick($, r3), V.call(this, e3, t3), this;
        }, x.prototype._undestroy = y.undestroy, x.prototype._destroy = function(e3, t3) {
          t3(e3);
        }, x.prototype[d.captureRejectionSymbol] = function(e3) {
          this.destroy(e3);
        }, x.fromWeb = function(e3, t3) {
          return q().newStreamWritableFromWritableStream(e3, t3);
        }, x.toWeb = function(e3) {
          return q().newWritableStreamFromStreamWritable(e3);
        };
      }, 9231: (e2) => {
        "use strict";
        e2.exports = { format: (e3, ...t2) => e3.replace(/%([sdifj])/g, function(...[e4, r2]) {
          const n2 = t2.shift();
          return "f" === r2 ? n2.toFixed(6) : "j" === r2 ? JSON.stringify(n2) : "s" === r2 && "object" == typeof n2 ? `${n2.constructor !== Object ? n2.constructor.name : ""} {}`.trim() : n2.toString();
        }), inspect(e3) {
          switch (typeof e3) {
            case "string":
              if (e3.includes("'")) {
                if (!e3.includes('"'))
                  return `"${e3}"`;
                if (!e3.includes("`") && !e3.includes("${"))
                  return `\`${e3}\``;
              }
              return `'${e3}'`;
            case "number":
              return isNaN(e3) ? "NaN" : Object.is(e3, -0) ? String(e3) : e3;
            case "bigint":
              return `${String(e3)}n`;
            case "boolean":
            case "undefined":
              return String(e3);
            case "object":
              return "{}";
          }
        } };
      }, 9452: (e2, t2) => {
        "use strict";
        t2.MT = { POS_INT: 0, NEG_INT: 1, BYTE_STRING: 2, UTF8_STRING: 3, ARRAY: 4, MAP: 5, TAG: 6, SIMPLE_FLOAT: 7 }, t2.TAG = { DATE_STRING: 0, DATE_EPOCH: 1, POS_BIGINT: 2, NEG_BIGINT: 3, DECIMAL_FRAC: 4, BIGFLOAT: 5, BASE64URL_EXPECTED: 21, BASE64_EXPECTED: 22, BASE16_EXPECTED: 23, CBOR: 24, URI: 32, BASE64URL: 33, BASE64: 34, REGEXP: 35, MIME: 36, SET: 258 }, t2.NUMBYTES = { ZERO: 0, ONE: 24, TWO: 25, FOUR: 26, EIGHT: 27, INDEFINITE: 31 }, t2.SIMPLE = { FALSE: 20, TRUE: 21, NULL: 22, UNDEFINED: 23 }, t2.SYMS = { NULL: Symbol.for("github.com/hildjj/node-cbor/null"), UNDEFINED: Symbol.for("github.com/hildjj/node-cbor/undef"), PARENT: Symbol.for("github.com/hildjj/node-cbor/parent"), BREAK: Symbol.for("github.com/hildjj/node-cbor/break"), STREAM: Symbol.for("github.com/hildjj/node-cbor/stream") }, t2.SHIFT32 = 4294967296, t2.BI = { MINUS_ONE: BigInt(-1), NEG_MAX: BigInt(-1) - BigInt(Number.MAX_SAFE_INTEGER), MAXINT32: BigInt("0xffffffff"), MAXINT64: BigInt("0xffffffffffffffff"), SHIFT32: BigInt(t2.SHIFT32) };
      }, 9744: (e2) => {
        "use strict";
        class t2 {
          constructor() {
            this.clear();
          }
          clear() {
            this.map = /* @__PURE__ */ new WeakMap(), this.count = 0, this.recording = true;
          }
          stop() {
            this.recording = false;
          }
          check(e3) {
            const r2 = this.map.get(e3);
            if (r2)
              return r2.length > 1 ? r2[0] || this.recording ? r2[1] : (r2[0] = true, t2.FIRST) : this.recording ? (r2.push(this.count++), r2[1]) : t2.NEVER;
            if (!this.recording)
              throw new Error("New object detected when not recording");
            return this.map.set(e3, [false]), t2.NEVER;
          }
        }
        t2.NEVER = -1, t2.FIRST = -2, e2.exports = t2;
      }, 9777: (e2, t2, r2) => {
        "use strict";
        const n2 = r2(8310), i = r2(3737), o = r2(7328), s = r2(672), { MT: a, SYMS: l } = r2(9452);
        class u extends n2.Transform {
          constructor(e3 = {}) {
            const { separator: t3 = "\n", stream_errors: r3 = false, tags: n3, max_depth: o2, preferWeb: s2, encoding: a2, ...l2 } = e3;
            super({ ...l2, readableObjectMode: false, writableObjectMode: false }), this.float_bytes = -1, this.separator = t3, this.stream_errors = r3, this.parser = new i({ tags: n3, max_depth: o2, preferWeb: s2, encoding: a2 }), this.parser.on("more-bytes", this._on_more.bind(this)), this.parser.on("value", this._on_value.bind(this)), this.parser.on("start", this._on_start.bind(this)), this.parser.on("stop", this._on_stop.bind(this)), this.parser.on("data", this._on_data.bind(this)), this.parser.on("error", this._on_error.bind(this));
          }
          _transform(e3, t3, r3) {
            this.parser.write(e3, t3, r3);
          }
          _flush(e3) {
            this.parser._flush((t3) => this.stream_errors ? (t3 && this._on_error(t3), e3()) : e3(t3));
          }
          static diagnose(e3, t3 = {}, r3 = null) {
            if (null == e3)
              throw new TypeError("input required");
            ({ options: t3, cb: r3 } = function(e4, t4) {
              switch (typeof e4) {
                case "function":
                  return { options: {}, cb: e4 };
                case "string":
                  return { options: { encoding: e4 }, cb: t4 };
                case "object":
                  return { options: e4 || {}, cb: t4 };
                default:
                  throw new TypeError("Unknown option type");
              }
            }(t3, r3));
            const { encoding: n3 = "hex", ...i2 } = t3, a2 = new s(), l2 = new u(i2);
            let c = null;
            return "function" == typeof r3 ? (l2.on("end", () => r3(null, a2.toString("utf8"))), l2.on("error", r3)) : c = new Promise((e4, t4) => {
              l2.on("end", () => e4(a2.toString("utf8"))), l2.on("error", t4);
            }), l2.pipe(a2), o.guessEncoding(e3, n3).pipe(l2), c;
          }
          _on_error(e3) {
            this.stream_errors ? this.push(e3.toString()) : this.emit("error", e3);
          }
          _on_more(e3, t3, r3, n3) {
            e3 === a.SIMPLE_FLOAT && (this.float_bytes = { 2: 1, 4: 2, 8: 3 }[t3]);
          }
          _fore(e3, t3) {
            switch (e3) {
              case a.BYTE_STRING:
              case a.UTF8_STRING:
              case a.ARRAY:
                t3 > 0 && this.push(", ");
                break;
              case a.MAP:
                t3 > 0 && (t3 % 2 ? this.push(": ") : this.push(", "));
            }
          }
          _on_value(e3, t3, r3) {
            if (e3 === l.BREAK)
              return;
            this._fore(t3, r3);
            const n3 = this.float_bytes;
            this.float_bytes = -1, this.push(o.cborValueToString(e3, n3));
          }
          _on_start(e3, t3, r3, n3) {
            switch (this._fore(r3, n3), e3) {
              case a.TAG:
                this.push(`${t3}(`);
                break;
              case a.ARRAY:
                this.push("[");
                break;
              case a.MAP:
                this.push("{");
                break;
              case a.BYTE_STRING:
              case a.UTF8_STRING:
                this.push("(");
            }
            t3 === l.STREAM && this.push("_ ");
          }
          _on_stop(e3) {
            switch (e3) {
              case a.TAG:
                this.push(")");
                break;
              case a.ARRAY:
                this.push("]");
                break;
              case a.MAP:
                this.push("}");
                break;
              case a.BYTE_STRING:
              case a.UTF8_STRING:
                this.push(")");
            }
          }
          _on_data() {
            this.push(this.separator);
          }
        }
        e2.exports = u;
      }, 9881: (e2, t2, r2) => {
        "use strict";
        const n2 = r2(893), i = r2(9777), o = r2(3737), s = r2(2893), a = r2(5059), l = r2(3557), u = r2(2903), c = r2(207);
        e2.exports = { Commented: n2, Diagnose: i, Decoder: o, Encoder: s, Simple: a, Tagged: l, Map: u, SharedValueEncoder: c, comment: n2.comment, decodeAll: o.decodeAll, decodeFirst: o.decodeFirst, decodeAllSync: o.decodeAllSync, decodeFirstSync: o.decodeFirstSync, diagnose: i.diagnose, encode: s.encode, encodeCanonical: s.encodeCanonical, encodeOne: s.encodeOne, encodeAsync: s.encodeAsync, decode: o.decodeFirstSync, leveldb: { decode: o.decodeFirstSync, encode: s.encode, buffer: true, name: "cbor" }, reset() {
          s.reset(), l.reset();
        } };
      } }, t = {};
      function r(n2) {
        var i = t[n2];
        if (void 0 !== i)
          return i.exports;
        var o = t[n2] = { exports: {} };
        return e[n2](o, o.exports, r), o.exports;
      }
      r.n = (e2) => {
        var t2 = e2 && e2.__esModule ? () => e2.default : () => e2;
        return r.d(t2, { a: t2 }), t2;
      }, r.d = (e2, t2) => {
        for (var n2 in t2)
          r.o(t2, n2) && !r.o(e2, n2) && Object.defineProperty(e2, n2, { enumerable: true, get: t2[n2] });
      }, r.o = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), r.r = (e2) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
      };
      var n = {};
      return (() => {
        "use strict";
        r.r(n);
        var e2 = r(9881), t2 = {};
        for (const r2 in e2)
          "default" !== r2 && (t2[r2] = () => e2[r2]);
        r.d(n, t2);
      })(), n;
    })());
  }
});
export default require_cbor();
/*! Bundled license information:

cbor-web/dist/cbor.js:
  (*! For license information please see cbor.js.LICENSE.txt *)
*/
//# sourceMappingURL=cbor-web.js.map
